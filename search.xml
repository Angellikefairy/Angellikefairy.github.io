<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[scrollTop与无限上滑的简单实现]]></title>
    <url>AngelLikeFairy%2F2020%2F01%2F13%2FscrollTop%E4%B8%8E%E6%97%A0%E9%99%90%E4%B8%8A%E6%BB%91%E7%9A%84%E7%AE%80%E5%8D%95%E5%AE%9E%E7%8E%B0%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[TypeScript元数据的理解与使用]]></title>
    <url>AngelLikeFairy%2F2019%2F12%2F16%2FTypeScript%E5%85%83%E6%95%B0%E6%8D%AE%E7%9A%84%E7%90%86%E8%A7%A3%E4%B8%8E%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[元数据我们知道,TS仅在代码设计时使用类型，但一些特性，注入依赖注入，运行时类型断言、反射和测试，需要运行时的类型信息才可以实现。 因此，TS使用了反射元信息API来获取元数据。 什么是元数据元数据是用来定义数据的数据。例如，对于一个数据A，它会具有值，数据类型等等描述这个数据的数据。这样的数据，我们称之为元数据。 通过元数据反射API，我们可以为数据添加和获取元数据 Reflect Metadata 的 API 可以用于类或者类的属性上 当我们为类或类的属性添加了元数据之后，构造函数或者构造函数的原型将会具有一个新的[[Metadata]]内部属性,该属性将包含一个Map，其键是属性键（或undefined），其值是元数据键值 元数据的定义具有以下特征： 当在类C声明上或者类C的静态成员上定义元数据时，元数据会存储在C.[[Metadata]]中 当在类C的实例成员上定义元数据时，元数据会存储在C.prototype.[[Metadata]]中 TS定义了三种保留元数据键 类型元数据使用元数据键”design:type”（用来获取属性类型） 参数类型元数据使用元数据键”design:paramtypes”（用来获取参数类型） 返回值类型元数据使用元数据键”design:returntype”（用来获取返回值类型） 元数据的定义和添加我们有以下三种方式进行元数据的定义： 通过为类或类中的成员定义一个装饰器 通过Reflect.metadata声明式定义 通过Reflect.defineMetadata命令式定义 注意： 如果没有进行这三种方式的定义，我们无法通过反射元数据API来获得元数据 通过为类或类中的成员定义一个装饰器事实上，这是我在元编程实战的时候发现的。当我将TS代码翻译成ES5代码的时候，我发现了这个特性。 当我们为类或类中的成员使用装饰器时，ES会默认为其添加上元数据的信息。但是，这会有以下几种不同的情况 当我们为类使用装饰器是，只会为类添加上”design:paramtypes”的元数据信息，含义为其构造函数的传入参数的类型数组 当我们为类中的属性使用装饰器时，只会为该属性添加上”design:type”的元数据，含义为该属性的类型 当我们为类中的方法使用装饰器时，会为该属性添加上所有三种保留元数据键，含义分别为方法的类型，传入该方法的形参类型数组，该方法的返回值的类型 1234567891011121314151617181920212223242526272829303132333435363738394041424344import "Reflect-metadata";type constructor&lt;T = any&gt; = new(...args: Array&lt;any&gt;) =&gt; T;@logclass A &#123; @log static n: string = 'hello'; constructor(private m: string) &#123; &#125; @log getMes(mes:number): number &#123; return mes; &#125;&#125;function log&lt;T&gt;(constructor: constructor&lt;T&gt;|&#123;&#125;,propertyName?: string,descriptor?: PropertyDescriptor) &#123; let type: Function,paramtypes: Array&lt;Function&gt;,returntype: Function; type = Reflect.getMetadata("design:type",constructor,propertyName); if(descriptor) &#123; paramtypes = Reflect.getMetadata("design:paramtypes",constructor,propertyName); returntype = Reflect.getMetadata("design:returntype",constructor,propertyName); console.log(propertyName,type,paramtypes,returntype); &#125; else &#123; if(propertyName) &#123; console.log(propertyName,type); &#125; else &#123; paramtypes = Reflect.getMetadata("design:paramtypes",constructor); console.log(constructor,paramtypes); &#125; &#125;&#125;export &#123;&#125;;/* 输出结果getMes [Function: Function] [ [Function: Number] ] [Function: Number]n [Function: String][Function: A] &#123; n: 'hello' &#125; [ [Function: String] ]*/ 当我们查看其编译成ES5的代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455"use strict";var __decorate = (this &amp;&amp; this.__decorate) || function (decorators, target, key, desc) &#123; var c = arguments.length, r = c &lt; 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d; if (typeof Reflect === "object" &amp;&amp; typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc); else for (var i = decorators.length - 1; i &gt;= 0; i--) if (d = decorators[i]) r = (c &lt; 3 ? d(r) : c &gt; 3 ? d(target, key, r) : d(target, key)) || r; return c &gt; 3 &amp;&amp; r &amp;&amp; Object.defineProperty(target, key, r), r;&#125;;var __metadata = (this &amp;&amp; this.__metadata) || function (k, v) &#123; if (typeof Reflect === "object" &amp;&amp; typeof Reflect.metadata === "function") return Reflect.metadata(k, v);&#125;;Object.defineProperty(exports, "__esModule", &#123; value: true &#125;);require("Reflect-metadata");var A = /** @class */ (function () &#123; function A(m) &#123; this.m = m; &#125; A.prototype.getMes = function (mes) &#123; return mes; &#125;; A.n = 'hello'; __decorate([ log, __metadata("design:type", Function), __metadata("design:paramtypes", [Number]), __metadata("design:returntype", Number) ], A.prototype, "getMes", null); __decorate([ log, __metadata("design:type", String) ], A, "n", void 0); A = __decorate([ log, __metadata("design:paramtypes", [String]) ], A); return A;&#125;());function log(constructor, propertyName, descriptor) &#123; var type, paramtypes, returntype; type = Reflect.getMetadata("design:type", constructor, propertyName); if (descriptor) &#123; paramtypes = Reflect.getMetadata("design:paramtypes", constructor, propertyName); returntype = Reflect.getMetadata("design:returntype", constructor, propertyName); console.log(propertyName, type, paramtypes, returntype); &#125; else &#123; if (propertyName) &#123; console.log(propertyName, type); &#125; else &#123; paramtypes = Reflect.getMetadata("design:paramtypes", constructor); console.log(constructor, paramtypes); &#125; &#125;&#125;//# sourceMappingURL=hello.js.map 我们就很容易明白，为类及类中的成员使用装饰器会为它们定义元数据。 将Reflect.metadata当做装饰器使用进行声明式定义我们可以将Reflect.metadata当做装饰器来使用，直接装饰类或类的属性。 @Reflect.metadata(metadataKey, metadataValue) 使用这样的装饰器语法，就相当于在类或类的属性上添加了元数据的键名和键值。 例如： 123456789101112131415161718192021222324252627import "reflect-metadata"@Reflect.metadata("name","classA")class A &#123; @Reflect.metadata("name","propertyN") n: string = 'nice'; @Reflect.metadata("name","propertyK") private static k: string = "hello"; constructor(public m: string) &#123;&#125; @Reflect.metadata("name","funcGet") get() &#123; return this.m; &#125;&#125;console.log(Reflect.getMetadata("name",A));console.log(Reflect.getMetadata("name",A,"k"));console.log(Reflect.getMetadata("name",A.prototype,"get"));console.log(Reflect.getMetadata("name",A.prototype,"n"));/* 输出结果classApropertyKfuncGetpropertyN*/ 使用Reflect.defineMetadata进行命令式定义“Reflect-metadata”提供了Reflect.defineMetadata来对元数据进行命令式的定义。与之前定义元数据的目标一致，我们可以用命令式定义API来定义类或类的成员（属性和方法），其有以下两种语法： 为类定义元数据 Reflect.defineMetadata(metadataKey, metadataValue, target) 为类的成员（属性和方法）定义元数据 Reflect.defineMetadata(metadataKey, metadataValue, target, propertyKey) 例如： 1234567891011121314151617181920212223import "Reflect-metadata";class A &#123; static m: string = "hello"; constructor(public n: string) &#123;&#125; getMes(): string &#123; return this.n; &#125;&#125;Reflect.defineMetadata("name","classA",A);Reflect.defineMetadata("name","propertyM",A,"m");Reflect.defineMetadata("name","propertyGetMes",A.prototype,"getMes");console.log(Reflect.getMetadata("name",A));console.log(Reflect.getMetadata("name",A,"m"));console.log(Reflect.getMetadata("name",A.prototype,"getMes"));/* 输出结果classApropertyMpropertyGetMes*/ Reflect.getMetadata获取元数据信息我们可以通过以下的反射元数据API来获取元数据的信息 获取类（构造函数）上的元数据 Reflect.getMetadata(metadataKey, target); 获取静态成员或实例成员的元数据 Reflect.hasOwnMetadata(metadataKey, target, propertyKey); 其中,metadataKey表示元数据键,target表示构造函数或者是构造函数的原型，peropertyKey表示属性或者是方法 除了自定义的元数据键(metadataKey)，还有三种常用的保留元数据键 类型元数据使用元数据键”design:type”（用来获取属性类型） 参数类型元数据使用元数据键”design:paramtypes”（用来获取参数类型） 返回值类型元数据使用元数据键”design:returntype”（用来获取返回值类型） 例如： 1234567891011121314151617181920212223242526272829303132333435import "Reflect-metadata";// 使用类型别名，将构造函数类型别名为使用泛型的Construct&lt;T = any&gt;type Construct&lt;T = any&gt; = new (...args: Array&lt;any&gt;) =&gt; T// 为类添加装饰器使得类具有保留元数据（只具有"design:paramtyps"元数据键，表示该构造函数的所有形参类型数组）@Injectableclass A &#123; // 对类中的属性使用Reflect.metadata装饰器进行声明式定义，同样，该属性也会具有保留元数据（只具有"design:type"元数据键，表示该属性的类型）。另外，该属性还具有声明式定义的元数据键值对“name:propertyM” @Reflect.metadata("name","propertyM") static m: string = "hello"; constructor(public n: string) &#123;&#125; getMes(): string &#123; return this.n; &#125;&#125;function Injectable&lt;T&gt;(constructor: Construct&lt;T&gt;) &#123; let paramtypes = Reflect.getMetadata("design:paramtypes",constructor); console.log("传递给类A的构造函数的参数类型数组",paramtypes);&#125;console.log(Reflect.getMetadata("design:type",A,"m"));// 使用Reflect.defineMetadata进行命令式定义时，则不会为其添加保留元数据键，而只是添加命令式定义的元数据键值对“name:propertyGetMes”Reflect.defineMetadata("name","propertyGetMes",A.prototype,"getMes");console.log(Reflect.getMetadata("name",A.prototype,"getMes"));console.log(Reflect.getMetadata("design:returntype",A.prototype,"getMes"));/* 输出结果传递给类A的构造函数的参数类型数组 [ [Function: String] ][Function: String]propertyGetMesundefined*/ 元数据相关总结通过以上的所有例子，可以得到以下的元数据相关总结： 我们只能为类或者是类中的成员（属性和方法）来进行元数据定义 我们可以通过三种方式来进行元数据的定义： 为类或类的成员使用自定义装饰器 为类或类的成员使用@Reflect.metadata装饰器进行声明式定义 使用Reflect.defineMetadata进行命令式定义 只有使用以上三种方式进行元数据定义后，目标对象才会拥有[[Metadata]]属性（默认为不可枚举属性），也就是说才能获取和定义元数据 为类或类的静态成员定义元数据时，元数据会存储在C.[[Metadata]]中 为类的实例成员定义元数据时，元数据会存储在C.prototype[[Metadata]]中 TS为我们定义了三种保留元数据键 “design:type” 类型元数据使用元数据键，用来获取元素的属性（只有类中的成员会具有，类本身不具有） “design:paramtypes” 参数类型元数据使用元数据键，用来获取参数的类型数组（只有类（构造函数的形参数组），类中的方法（该方法的形参数组）会具有，类的属性不具有） “desing:returntype” 返回值元数据使用元数据键，用来获取方法返回值的类型（只有类中的方法会具有，类声明和类中的属性都不具有） 使用Reflect.defineMetadata为类和类中的成员进行命令式定义时，并不会为指定的类或类的成员默认添加保留元数据键，而其他两种定义方法会默认添加 使用反射元数据和装饰器进行应用控制翻转和依赖注入的简单实现依赖注入可以通过类构造函数进行注入，也可以通过书信进行注入。在这里，我们只进行类构造函数注入的简单实现。 我们来模拟Nest.js的依赖注入的简单实现： 首先，我们需要定义一些基础的装饰器以及IOC容器 1234567891011121314151617181920// 在common.ts中import "Reflect-metadata"type Construct&lt;T = any&gt; = new (...args: Array&lt;any&gt;) =&gt; T;// 声明Injectable装饰器，当为类声明装饰该装饰器时则表示该类是可注入的类function Injectable&lt;T&gt;(constructor: Construct&lt;T&gt;) &#123;&#125;// 声明Controller装饰齐齐，当为类声明装饰器装饰器时则表示该类是控制器模块function Controller&lt;T&gt;(constructor: Construct&lt;T&gt;) &#123;&#125;// 声明简单的IOC容器，用来将对象创建的控制器反转function Factory&lt;T&gt;(constructor: Construct&lt;T&gt;): T &#123; let paramtypes = Reflect.getMetadata("design:paramtypes",constructor); let providers = paramtypes.map((provider: Construct&lt;T&gt;) =&gt; new provider()); return new constructor(...providers);&#125;export &#123;Injectable,Controller,Factory&#125; 可以看到，我们只是声明了一些装饰器函数，但我们并没有为装饰器函数添加任何函数体。那么这是为什么呢？我们之前提到过，为类或类的成员使用装饰器会默认为它们添加它们所允许拥有的保留元数据键。这些元数据键我们在之后的Factory函数中需要使用到。 接下来，我们来定义Service模块和Controller模块 1234567891011// 在cats.service.ts中，该模块为cats的service模块，用来编写业务代码import &#123;Injectable&#125; from "./common"@Injectableexport class CatsService &#123; catName: string = "jack"; getCatName(): string &#123; return this.catName; &#125;&#125; 123456789101112// 在cats.controller.ts中，该模块为控制器模块import &#123;Controller&#125; from "./common"import &#123;CatsService&#125; from "./cats.service"@Controllerexport class CatsController &#123; constructor(public readonly catsService: CatsService) &#123;&#125; getCatsServiceMes(): string &#123; return this.catsService.getCatName(); &#125;&#125; 可以看到，在catsController类的构造函数中没有任何函数体，而构造函数的参数前添加了访问限定符public和readonly。这是一种叫做参数属性的特性： 参数属性通过给构造函数参数前面添加一个访问限定符来声明。 使用 private限定一个参数属性会声明并初始化一个私有成员；对于 public，protected和readonly来说也是一样。 使用参数属性，允许我们将声明和赋值合并至一处。 最后是模拟依赖注入的过程： 1234567891011// 在main.ts中import &#123;Factory&#125; from "./common"import &#123;CatsController&#125; from "./cats.controller"console.log(Factory(CatsController));console.log(Factory(CatsController).getCatsServiceMes());/* 输出结果catsController &#123; catsService: CatsService &#123; catName: 'jack' &#125; &#125;jack*/ 到这里，我们完成了依赖注入的最简单的实现。总之，实现依赖注入就得需要依靠装饰器和反射元数据API的使用，因为，我们需要在运行中获得参数的类型信息。 @Controller和@Get的简单实现在Nest.js中，我们经常会使用到这些装饰器。@Controller负责路由控制，@Get表示请求的方法须为get请求 首先，我们建立Controller和请求方法的装饰器函数 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465// 在common.ts中import "Reflect-metadata"type Construct&lt;T = any&gt; = new (...args: Array&lt;any&gt;) =&gt; Tinterface Route &#123; route: string; method: string; fn: Function; methodName: string;&#125;// 建立@Controller装饰器函数function Controller(path: string): Function &#123; return function&lt;T&gt;(constructor: Construct&lt;T&gt;) &#123; Reflect.defineMetadata('path','/'+path,constructor); &#125;&#125; // 一个工厂函数，根据传入的请求方法类型来返回一个该类型的装饰器工厂函数function createMethodsDecorator(method: string): Function &#123; return function(routeName: string): Function &#123; return function(target: any,propertyName: string,descriptor: PropertyDescriptor) &#123; // @Get之类的装饰器会装饰实例方法。因此，为该实例方法设定元数据route路由路径和method请求方法 Reflect.defineMetadata("route",'/'+routeName,target,propertyName); Reflect.defineMetadata("method",method,target,propertyName); &#125; &#125;&#125;// 路径信息解析函数，传入的参数为控制器类，返回该控制器的所有路由信息function mapRoute&lt;T&gt;(constructor: Construct&lt;T&gt;) &#123; // 得到控制器路径，即@Controller()中的参数值 let pathName = Reflect.getMetadata("path",constructor); let routes: Array&lt;Object&gt; = []; let proto = constructor.prototype; // 过滤掉类的原型中不是函数的属性 let funcs = Object.keys(proto).filter(item =&gt; (typeof proto[item] === 'function')); funcs.forEach(funcName=&gt;&#123; // 得到@Get()中的参数值 let route = Reflect.getMetadata("route",proto,funcName); route = pathName + route; // 得到为该方法设定的允许请求方法 let method = Reflect.getMetadata("method",proto,funcName); let fn = proto[funcName]; let routeMes: Route = &#123; route, method, fn, methodName: funcName &#125;; routes.push(routeMes) &#125;) return &#123; pathName, routes &#125;&#125;// 通过上述工厂函数得到装饰器工厂函数const Get = createMethodsDecorator('GET');const Post = createMethodsDecorator('POST');export &#123;Controller,Get,Post,mapRoute&#125; 接着，我们编写控制器模块 123456789101112131415161718192021// 在cats.controller.ts中import &#123;Controller,Get,Post&#125; from "./common"@Controller("cats")export class CatsController &#123; @Get('findAll') findAll(): string &#123; return "Find all"; &#125; @Get('findOne') findOne(): string &#123; return "Find one"; &#125; @Post('create') create(): string &#123; return "Create succeed"; &#125;&#125; 接着，我们需要解析这个控制器得到相应的路径信息，并且创建http服务器进行请求监听 123456789101112131415161718192021// 在main.ts中import http from "http"import &#123;mapRoute&#125; from "./common"import &#123;CatsController&#125; from "./cats.controller"let controller = mapRoute(CatsController);http.createServer((req,res) =&gt; &#123; for(let route of controller.routes) &#123; let routeName = (route as any).route; if(req.url === routeName) &#123; res.setHeader("Content-Type","text/palin"); res.end((route as any).fn()); &#125; &#125;&#125;).listen(3000,()=&gt;&#123; console.log("Port 3000 is listening");&#125;) 这样我们就完成了从控制器模块到服务器监听程序建立的全部过程了。]]></content>
      <categories>
        <category>TypeScript</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[在TS中使用混合]]></title>
    <url>AngelLikeFairy%2F2019%2F12%2F14%2F%E5%9C%A8TS%E4%B8%AD%E4%BD%BF%E7%94%A8%E6%B7%B7%E5%90%88%2F</url>
    <content type="text"><![CDATA[为什么需要混合在TS中，类语法遵循严格的单继承，我们无法通过extends语法来实现多继承 123class Bat extends Mammal , WingedAnimal &#123; // Error: 类只能扩展一个类 // ... &#125; 但是有时候我们又会遇到一种需求：从可重用组件中创建一个新类。也就是说，我们希望新创建的类可以同时拥有可重用组件中的方法。然而，多继承已经在语法上就予以否决了。因此，我们需要混合的方式来解决这个问题 什么是混合首先，我们需要明确的是：我们无法使用extends语法，因此，我们使用了implements语法来做替代。在这里，我们把基类当做了接口而不是类，因此，在继承的时候，我们只使用了它们的类型定义而非实现。那么，我们需要考虑的就是如何在想要被扩展的类中实现那些接口。 混合可以帮助我们解决这个问题。 混合是一个函数。它需要两个参数： 构造函数（需要扩展的类） 可重用组件（想要被继承的类） 之后，混合函数会遍历基类（类实质上是一个构造函数）的原型对象中的所有属性，并复制到我们所需要扩展的类上 混合的实例我们现在来使用混合的方式来实现多继承的替代（事实上这并不是多继承） 实例1（初级版本：类直接继承多个接口）12345678910111213141516171819202122232425262728293031323334353637383940// 声明并定义基类A,Bclass A &#123; basicA() &#123; console.log('基类A'); &#125; &#125;class B &#123; basicB() &#123; console.log('基类B'); &#125;&#125;// 声明想要被扩展的类C implements A,Bclass C implements A,B &#123; // 我们需要预先为继承过来的属性做好类型定义，否则如果后续有调用这些属性的话编译阶段则无法通过 basicA: () =&gt; void; basicB: () =&gt; void;&#125;// 实现混合函数applyMixinsfunction applyMixins(derivedCtor: any, baseCtors: Array&lt;any&gt;): void &#123; baseCtors.forEach(baseCtor =&gt; &#123; Object.getOwnPropertyNames(baseCtor.prototype).forEach(name =&gt; &#123; derivedCtor.prototype[name] = baseCtor.prototype[name]; &#125;) &#125;)&#125;// 应用混合函数applyMixins(C,[A,B]);let c = new C();c.basicA();c.basicB();/* 输出结果基类A基类B*/ 需要注意的是： 我们需要为将要mixin进来的属性方法创建出占位属性。这告诉编译器这些成员在运行时是可用的。否则如果后续有调用这些属性的话编译阶段则无法通过 实例2（改进版本：接口继承多个接口，然后类继承该接口）在实例1中，我们需要在想要被扩展的类中预先创立一些站位属性。那么，我们可以避免这个行为吗？ 当然可以。我们可以让这个类继承某个接口，而这个接口会继承那些基类。我们知道，当接口继承某个类的时候，它会继承类的成员但不包括其实现。这就好像接口声明了所有类中存在的成员，但并没有提供具体实现一样。 123456789class A &#123; // ...&#125;class B &#123; // ...&#125;interface C implements A,B &#123;&#125; 最后，这个接口就会具有所有基类的成员但不包括它们的实现。接着，我们只需要定义与接口相同名的类，利用声明合并的特性，那么我们就不需要预先创建占位属性。 完整实现如下： 1234567891011121314151617181920212223242526272829303132333435class A &#123; staticA() &#123; console.log('基类A'); &#125;&#125;class B &#123; staticB() &#123; console.log('基类B') &#125;&#125;// 接口C多继承类A，B（只继承成员而不继承实现）interface C extends A,B &#123;&#125;// 类C与接口C同名，由于声明合并的特性，因此，该类C会与接口C合并，从而我们不需要显式继承该接口class C &#123;&#125;function applyMixins(derivedCtor: any, baseCtors: Array&lt;any&gt;): void &#123; baseCtors.forEach(baseCtor =&gt; &#123; Object.getOwnPropertyNames(baseCtor.prototype).forEach(name =&gt; &#123; derivedCtor.prototype[name] = baseCtor.prototype[name]; &#125;) &#125;)&#125;applyMixins(C,[A,B]);let c = new C();c.staticA();c.staticB();/* 输出结果基类A基类B*/ 应用装饰器进行混合因为混合函数就是用来修改类的成员，因此，我们很容易可以想到是否可以将以上混合函数applyMixins的调用改为类装饰器 事实上当然是可行的： 定义一个装饰器工厂函数用来返回一个装饰器 123456789function mixins(baseCtors: Array&lt;any&gt;): Function &#123; return function applyMixins(constructor: Function): void &#123; baseCtors.forEach(baseCtor =&gt; &#123; Object.getOwnPropertyNames(baseCtor.prototype).forEach(name =&gt; &#123; constructor.prototype[name] = baseCtor.prototype[name]; &#125;) &#125;) &#125;&#125; 应用装饰器 12345678910111213interface C extends A,B &#123;&#125;@mixins([A,B])class C &#123;&#125;let c = new C();c.staticA();c.staticB();/* 输出结果基类A基类B*/ 混合的限制我们之前说混合是一种可以替代多继承的一种可行的方式。但我们知道多继承只能是一个类继承多个接口，因此，我们在继承多个类的时候使用的是implements关键字，从而将类视作是接口，然后，我们使用混合函数的方式来将这些接口实现。 但如果我们去看混合函数就会发现，我们通过遍历基类上的成员来进行复制。那么如果两个类中有成员是重名的，那么被扩展的类只能继承在给定数组中较后位置的成员值 例如： 12345678910111213141516171819202122232425262728293031323334class A &#123; staticA() &#123;&#125; get() &#123; console.log('基类A中的get方法'); &#125;&#125;class B &#123; static B() &#123;&#125; get() &#123; console.log('基类B中的get方法'); &#125;&#125;// 需要利用声明合并的特性，因此，我们需要定义两个与类型相同的接口interface C extends A,B &#123;&#125;interface D extends A,B &#123;&#125;@mixins([A,B])class C &#123;&#125;@mixins([B,A])class D &#123;&#125;let c = new C();let d = new D();c.get();d.get();/* 输出结果基类B中的get方法基类A中的get方法*/ 注意： 如果不使用声明合并的特性，那么一个类继承某个接口则必须要实现这个接口]]></content>
      <categories>
        <category>TypeScript</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[代理proxy和反射Reflection的基本使用]]></title>
    <url>AngelLikeFairy%2F2019%2F12%2F09%2F%E4%BB%A3%E7%90%86proxy%E5%92%8C%E5%8F%8D%E5%B0%84Reflection%E7%9A%84%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[ES5的Object.defineProperty()在ES5的时候，我们可以使用Object.defineProperty来对属性的特性做出定义或者修改。例如，我们经常使用到的访问器属性： 12345678910111213141516171819let obj = &#123; _item: 1&#125;Object.defineProperty(obj,'item',&#123; get() &#123; console.log('这是访问器方法get'); return this._item; &#125;, set(item) &#123; console.log('这是访问器方法set'); this._item = item; &#125;&#125;)console.log(obj); // &#123;_item: 1&#125;console.log(obj.item); // 这是访问器方法get 1obj.item = 2; // 这是访问器方法setconsole.log(obj.item); // 这是访问器方法get 2 因此，我们可以使用Object.defineProperty来为属性的赋值与访问操作进行拦截从而加入一些自定义的操作。 到了ES6，语言为我们添加了一些内建对象来允许我们更多地访问JavaScript引擎的能力。 其中，代理（Proxy）是一种可以拦截并改变底层JavaScript引擎操作的包装器。 代理和反射什么是代理那么什么是代理呢？MDN是这样定义的 Proxy 对象用于定义基本操作的自定义行为（如属性查找，赋值，枚举，函数调用等）。 这么看起来，好像Proxy这个内建对象允许我们可以自定义一些JavaScript引擎已有的一些基本操作。但是，代理这个词体现在哪里呢？ 事实上，我们需要调用new Proxy(target,handler)来创建一个target对象的代理。我们将一些自定义的行为会放在handler对象内作为其属性 之后，我们在代理上做的所有操作都会通过handler中定义的陷阱来执行 现在，我们来创建一个代理并且进行简单的应用： 123456789101112131415161718let obj = &#123; _item: 1&#125;let handler = &#123; get(trapTarget,key,receiver) &#123; console.log('这是get代理陷阱'); return trapTarget[key]; &#125;&#125;let objProxy = new Proxy(obj,handler);console.log(objProxy._item); /* 输出结果这是get代理陷阱1*/ 乍一看，是不是特别像之前提到过的ES5中的Object.defineProperty()为对象属性设置了访问器特性从而进行了拦截。 的确，我们确实为属性读取操作进行了一层拦截，但是使用的方法却有大的不同。 什么是反射代理用来拦截内建特性的基本操作，而反射则是在代理中提供这些基本操作。 也就是说，如果我们在代理中仍旧需要内建特性，那么我们就必须得使用反射API 常用的代理陷阱与相应的反射API我们将代理要执行的一些操作称为代理陷阱。同时，每个代理陷阱都会对应一个命名和参数都相同的反射(Reflect)方法 以下，是一些常用的代理陷阱及其相应的反射API 代理陷阱 覆写的特性 默认特性（反射API） get 读取一个属性值 Reflect.get() set 写入一个属性 Reflect.set() has 判断对象中是否有某属性，相当于in操作符 Reflect.has() deleteProperty 删除某属性，相当于delete操作符 Reflect.deleteProperty() getPrototypeOf 返回给定对象的原型，Object.getPrototypeOf() Reflect.getPrototypeOf() setPrototypeOf 设置某对象为目标对象的原型 Reflect.setPrototypeOf() getOwnPropertyDescriptor 获取属性描述符，Object.getOwnPropertyDescriptor() Reflect.getOwnPropertyDescriptor() defineProperty 定义或修改属性的特性，Object.defineProperty() Reflect.defineProperty() apply 调用一个函数 Reflect.apply() construct 用new调用一个函数 Reflect.construct() 一些常用陷阱及其反射的使用get陷阱我们使用get陷阱来定义对象属性读取的自定义操作。 get陷阱接受三个参数： trapTarget 代理的目标（被代理的对象），也就是源对象 key 要读取的属性值 receiver 代理对象 需要记住的是，所有与陷阱相对应的反射API都接受对应陷阱接受的参数。在这里也就是说，get陷阱对应的反射API Reflect.get()也同样接受trapTarget,key,receiver这三个参数 现在，我们来使用get陷阱来写个例子。我们知道，get陷阱覆写的特性是属性的读取，那么我们可以利用get陷阱来对读取操作进行重新的定义 一般来说，如果某个对象中没有指定要读取的属性则会返回undefined 12345const obj = &#123; _item: 1&#125;console.log(obj.item); // undefined 现在，我希望当我读取某个不存在的属性时可以通知我这个属性不存在而不是返回undefined。因为，有些存在的属性但是赋予了undefined值访问后也是返回undefined。 12345const obj = &#123; _item: undefined&#125;console.log(obj._item); // undefined 因此，我们无法通过undefined来确定某个属性是否存在。但我们可以使用in操作符 因此，我们可以这样来使用get陷阱来达到我们想要的目的： 123456789101112131415161718192021const obj = &#123; _item: 1, item: undefined&#125;const handler = &#123; get(trapTarget,key,receiver) &#123; // 使用in操作符来判断属性是否存在 if(!(key in trapTarget)) &#123; throw new Error('该属性不存在'); &#125; // 如果属性存在则使用默认行为 else return Reflect.get(trapTarget,key,receiver); &#125;&#125;const proxy = new Proxy(obj,handler);console.log(proxy._item); // 1console.log(proxy.item); // undefinedconsole.log(proxy.itemA); // Error: '该属性不存在' set陷阱set陷阱接受以下四个参数： trapTarget 被代理的对象 key 要设置的属性名 value 属性名对应的属性值 receiver 代理 通常，我们会在设置对象的属性时使用到set陷阱。那么，我们可以在写入的时候为写入的属性值做出限制，比如写入的属性值必须为number类型；当然，对于那些已经存在的属性，当我们要对那些属性值做出修改的时候，属性值也必须为number类型 那么，我们可以这样写： 123456789101112131415161718192021const obj = &#123; item: 1&#125;let handler = &#123; set(trapTarget,key,value,receiver) &#123; // 判断要修改或要写入的值是否为非数值 if(isNaN(value)) &#123; throw new Error('写入的属性值必须为number类型') &#125; else return Reflect.set(trapTarget,key,value,receiver); &#125;&#125;const objProxy = new Proxy(obj,handler);// 写入一个新属性objProxy._item = 2;console.log(obj); // &#123; item: 1, _item: 2 &#125;// 修改已有属性objProxy.item = 'nice'; // Error: 写入的属性值必须为number类型 为什么Proxy远比Object.defineProperty强大Proxy可以监听对象属性的增加和删除我们知道在Vue2.x的版本中，数据绑定的实现中是无法监听到属性的增加和删除的。因为，在2.x版本中，通过深层次（递归）遍历每个属性（包括属性值为对象中的属性）然后使用Object.defineProperty来进行数据劫持的，因此，它只能监听属性值的变化。 但是Proxy通过set陷阱就可以很方便地做到这一点 Proxy可以监听数组变化（使用push,pop,shift,slice等操作）同样的，这些事情也是Object,defineProperty无法做到的，而是用proxy则可以很方便地实现。]]></content>
      <categories>
        <category>ES6</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[防抖与节流]]></title>
    <url>AngelLikeFairy%2F2019%2F11%2F28%2F%E9%98%B2%E6%8A%96%E4%B8%8E%E8%8A%82%E6%B5%81%2F</url>
    <content type="text"><![CDATA[为什么需要防抖与节流试着去想象一个场景，当我们在输入框输入内容的时候。如果有一个函数是根据输入框当前输入的内容来进行接口调用。那么，当你在不断输入的时候这个函数就会一直被调用，那么就很容易加重浏览器的负担导致性能降低。 除此之外，包括当我们点击一个按钮时，如果我们没有立即得到反馈，我们可能就会一直去频繁点击它，导致时间绑定程序不断地被调用；另外，还有scroll事件,resize事件等等 因此，采用防抖与节流的方式可以让我们降低调用函数的频率，又可以保证功能的正常执行 防抖什么是函数防抖一般来说，我们会为需要进行防抖操作的函数设置一个超时时间，这个函数在这段时间内仅仅只会被触发一次。 更加通俗的来说，防抖对于要被执行的方法 当然，我们可以选择让这个仅仅只会被触发一次的函数是立即执行还是延迟执行。其中： 立即执行指第一次触发后函数会立刻执行，之后只有再经过超时时间间隔后才可以被执行 延迟执行指的是在时间间隔内连续触发的函数只有最后一次会被延时执行 延迟执行的函数防抖延迟执行的函数防抖主要适用于那些需要最后才响应频繁操作的函数。例如，在往输入框不断输入内容的时候希望当内容全部输入完毕后才进行接口的调用 基本思路延迟执行的基本思路是： 创建一个定时器timer用来保存每一次定时操作返回的定时器ID 如果我们在超时时间内又一次触发了该函数，那么清空之前设定的定时器，并且将timer绑定新的定时器ID 这样，只要你在超时时间间隔内无论多少次频繁的触发函数，之前触发的函数都不会响应 coding实现123456789101112131415161718192021function debounce(fn,wait) &#123; // 利用闭包的特性，返回函数中访问到的timer都会访问到这个timer let timer = null; return function(...args) &#123; // 若没有到超时时间，函数被触发的话，如果已经有timer，则说明之前已经触发过，那么取消之前的定时器 if(timer) clearTimeout(timer); // 这个fn函数永远会在最后一次触发后延时wait秒被执行 timer = setTimeout(()=&gt;&#123; fn.apply(this,args); &#125;,wait); &#125;&#125;let button = document.getElementById('button');let wait = 1000;button.addEventListener('click',debounce(alert,wait));function alert() &#123; console.log('alert');&#125; 立即执行的函数防抖立即执行的函数防抖要求当函数第一次被触发后就会被执行，但是下一次函数执行与前一次函数执行的时间间隔必须大于超时时间。 也就是说，当你第一次触发该函数后，该函数会立即被执行。之后，如果你每次触发该函数的时间间隔小于超时时间，那么函数都不会被触发。只有，在你最后一次触发该函数（无论是有效触发（调用成功）还是无效触发（不允许调用））经过超时时间后才可以被再次成功调用 例如用户给interviewMap点star的时候，我们希望用户点第一下的时候就去调用接口，并且成功之后改变star按钮的样子，用户就可以立马得到反馈是否star成功了，这个情况适用立即执行的防抖函数，它总是在第一次调用，并且下一次调用必须与前一次调用的时间间隔大于wait才会触发。 12345678910111213141516function debounce(fn,wait) &#123; // 还是利用闭包的特性来创建定时器 let timer = null; return function(...args) &#123; // 如果定时器为空，那么说明该函数是第一次被触发，那么立即执行它 if(!timer) &#123; fn.apply(this,args); &#125; // 否则清空前一个定时器 else clearTimeout(timer); // 设定定时器，当时间间隔超过wait后才将timer重新赋予null timer = setTimeout(()=&gt;&#123; timer = null; &#125;,wait); &#125;&#125; 两种方式结合的版本我们总希望封装的可以更加彻底一点，因此，我们可以利用传入的immediate参数来决定是立即执行防抖还是延迟防抖 以下是实现： 123456789101112131415161718function debounce(func,wait,immediate) &#123; let timer = null; return function(...args) &#123; if(immediate) &#123; if(timer) clearTimeout(timer); else func.apply(this,args); timer = setTimeout(()=&gt;&#123; timer = null; &#125;,wait); &#125; else &#123; if(timer) clearTimeout(timer); timer = setTimeout(()=&gt;&#123; func.apply(this,args); &#125;,wait) &#125; &#125;&#125; 节流什么是函数节流与防抖不同，防抖是用来将一个多次在超时时间内执行的函数只让其执行一次，无论是立即执行还是延迟执行。 而节流是将多次执行变成每隔一段时间进行执行。比如，你在10s中按了n次按钮（每次按钮的时间间隔小于给定的超时时间），那么对于节流来说，这n次按钮绑定的事件处理程序不是都执行也不是像防抖一样只执行一次，而是每隔一段给定时间就执行其中一次事件 简而言之： 当持续触发事件时，保证一定时间段内只调用一次事件处理函数 实现函数节流的方式也有两种： 时间戳实现函数节流 定时器实现函数节流 时间戳实现函数节流12345678910function throttle(func,wait) &#123; let start = Date.now(); return function(...args) &#123; let now = Date.now(); if(now-start&gt;=wait) &#123; func.apply(this,args); start = now; &#125; &#125; &#125; 定时器实现函数节流1234567891011function throttle(func,wait) &#123; let timer = null; return function(...args) &#123; if(!timer) &#123; timer = setTimeout(()=&gt;&#123; func.apply(this,args); timer = null; &#125;,wait) &#125; &#125;&#125;]]></content>
      <categories>
        <category>javaScript基础</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[二叉树的递归与非递归遍历]]></title>
    <url>AngelLikeFairy%2F2019%2F11%2F25%2F%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%80%92%E5%BD%92%E4%B8%8E%E9%9D%9E%E9%80%92%E5%BD%92%E9%81%8D%E5%8E%86%2F</url>
    <content type="text"><![CDATA[二叉树的遍历首先，我们做好树建立的准备工作 12345678910111213141516171819202122232425262728293031interface Node&lt;T&gt; &#123; val: T; left: Node&lt;T&gt;; right: Node&lt;T&gt;;&#125;class TreeNode&lt;T&gt; implements Node&lt;T&gt; &#123; val: T; left = null; right = null; constructor(val: T) &#123; this.val = val; &#125;&#125;let a = new TreeNode('a');let b = new TreeNode('b');let c = new TreeNode('c');let d = new TreeNode('d');let e = new TreeNode('e');let f = new TreeNode('f');let g = new TreeNode('g');let h = new TreeNode('h');a.left = b;a.right = c;b.left = d;b.right = e;d.right = f;e.left = g;f.right = h; 先序遍历递归实现1234function preOrder&lt;T&gt;(root: TreeNode&lt;T&gt;): Array&lt;T&gt; &#123; if(root === null) return []; return Array.of(root.val).concat(preOrder&lt;T&gt;(root.left)).concat(preOrder&lt;T&gt;(root.right));&#125; 非递归实现12345678910111213141516function preOrder&lt;T&gt;(root: TreeNode&lt;T&gt;): Array&lt;T&gt; &#123; let result: Array&lt;T&gt; = []; let stack: Array&lt;TreeNode&lt;T&gt;&gt; = []; while(root||stack.length&gt;0) &#123; if(root) &#123; stack.push(root); result.push(root.val); root = root.left; &#125; else &#123; let node = stack.pop(); root = node.right; &#125; &#125; return result;&#125; 中序遍历递归实现1234function inOrder&lt;T&gt;(root: TreeNode&lt;T&gt;): Array&lt;T&gt; &#123; if(root === null) return []; return inOrder&lt;T&gt;(root.left).concat(Array.of(root.val)).concat(inOrder&lt;T&gt;(root.right));&#125; 非递归实现12345678910111213141516function inOrder&lt;T&gt;(root: TreeNode&lt;T&gt;): Array&lt;T&gt; &#123; let result: Array&lt;T&gt; = []; let stack: Array&lt;TreeNode&lt;T&gt;&gt; = []; while(root||stack.length&gt;0) &#123; if(root) &#123; stack.push(root); root = root.left; &#125; else &#123; let node = stack.pop(); result.push(node.val); root = node.right; &#125; &#125; return result;&#125; 后序遍历递归实现1234function postOrder&lt;T&gt;(root: TreeNode&lt;T&gt;): Array&lt;T&gt; &#123; if(root === null) return []; return postOrder&lt;T&gt;(root.left).concat(postOrder&lt;T&gt;(root.right)).concat(Array.of(root.val));&#125; 非递归遍历使用两个栈的方式来进行后序遍历。 12345678910111213141516function postOrder&lt;T&gt;(root: TreeNode&lt;T&gt;): Array&lt;T&gt; &#123; if(root === null) return []; let stack1: Array&lt;TreeNode&lt;T&gt;&gt; = [root]; let stack2: Array&lt;T&gt; = []; while(stack1.length&gt;0) &#123; let node = stack1.pop(); stack2.push(node.val); if(node.left) &#123; stack1.push(node.left); &#125; if(node.right) &#123; stack1.push(node.right); &#125; &#125; return stack2.reverse();&#125; 层次遍历非递归实现使用队列 12345678910111213141516function levelOrder&lt;T&gt;(root: TreeNode&lt;T&gt;) &#123; if(root === null) return []; let queue: Array&lt;TreeNode&lt;T&gt;&gt; = [root]; let node: TreeNode&lt;T&gt;; let result: Array&lt;T&gt; = []; while(node = queue.shift()) &#123; result.push(node.val); if(node.left) &#123; queue.push(node.left); &#125; if(node.right) &#123; queue.push(node.right); &#125; &#125; return result;&#125;]]></content>
      <categories>
        <category>算法笔记</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[TypeScript装饰器理解]]></title>
    <url>AngelLikeFairy%2F2019%2F11%2F23%2FTypeScript%E8%A3%85%E9%A5%B0%E5%99%A8%E7%90%86%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[什么是装饰器 装饰器（Decorators）为我们在类的声明及成员上通过元编程语法添加标注提供了一种方式。 事实上，它是一种特殊类型的声明，它能够被附加到类声明，方法，访问符，属性或参数上。 装饰器使用@expression的形式，expression求值后必须为一个函数(也就是说expression本身就是一个装饰器函数或者是装饰器工厂函数)，其中可以包括装饰声明信息（该信息会被作为参数传入） 为什么需要装饰器那么，为什么需要装饰器呢？我们可以思考一个场景，现在我们有一个类，该类中有一个用setTimout来模拟向后端请求数据的方法，例如： 123456789class Model &#123; async getData() &#123; return await new Promise((resolve,reject)=&gt;&#123; setTimeout(()=&gt;&#123; resolve(&#123;data: 123&#125;) &#125;,2000) &#125;) &#125;&#125; 那么，如果我们想要统计这次请求花了多少时间呢？我们的确可以在该getData方法中添加统计时间的逻辑，但事实上，我们需要明白的是：如果有更多的方法需要添加统计时间的功能，那么我们需要为每一个方法都添加上相应的逻辑。 很容易明白这样是有很大缺陷的。而装饰器这个概念就是用来解决这一问题的。如果哪个方法需要统计时间，那么我们只要为其加上时间统计的装饰器，就可以做到时间的统计又不需要修改原来方法内部的逻辑。 在使用语法糖@expression之前，我们先使用函数来解决这个问题 1234567891011121314151617181920212223242526272829// 这个函数要做的就是获取到类中的方法，然后修改方法中的逻辑添加统计时间的逻辑function timeCount(Model: Function,key: string) &#123; let target = Model.prototype; let func = target[key]; async function newFunc() &#123; let start = Date.now(); console.log(start); let v = await func.call(this); console.log('得到的值为',v); let duration = Date.now()-start; console.log(`请求花费了$&#123;duration&#125;秒`) &#125; Object.defineProperty(target,key,&#123; value: newFunc &#125;)&#125;// 将类Model和方法名getData传递给这个统计时间函数timeCount(Model,'getData');let m = new Model();m.getData();/* 输出结果1574512136828得到的值为 &#123; data: 123 &#125;请求花费了2006秒*/ 那么，以后只要哪个方法需要添加统计时间功能，那么我们只要将该方法名传递给该统计时间函数。这种思想也就是装饰器思想。 装饰器的思想在于： 我们不用修改原来方法中的逻辑以及破坏原方法中的代码结构便可以添加上一些自定义的功能 可以复用 装饰器的用法装饰器工厂函数装饰器@expression中的expression在求值后必须是一个函数，也就是说，如果expression本身就是装饰器函数，那么我们不需要在方法名后面加上()来执行；如果，expression需要求值后才能得到装饰器函数，那么我们就需要在函数后添加()来执行该函数 需要进行求值后才能得到函数，一般都是利用了工厂函数的思想。 例如： 12345function time(...args: any[]) &#123; return function(target,key,descriptor) &#123; // ... &#125;&#125; 类装饰器类装饰器需要在类声明之前被声明。类装饰器应用于类构造函数，可以用来监视，修改或替换类定义。 类装饰器表达式会在运行时当作函数被调用，类的构造函数会作为其唯一的参数。 注意：如果类装饰器返回一个值，它会使用提供的构造函数来替换类的声明 例如，我们可以通过修改原有构造函数的方式来为类添加一些新的实例属性 12345678910111213141516171819202122232425262728293031323334353637383940@property('I am a person')class Person &#123; name: string; sex: string; constructor(name: string,sex: string) &#123; this.name = name; this.sex = sex; &#125; getMes() &#123; return this.name+' '+this.sex; &#125;&#125;// 为类Person添加property属性和getProperty方法function property(propertyDescription: string) &#123; // 确保传入的泛型是一个构造函数使得TS编译阶段可以通过，因此需要&lt;T extends &#123;new(...args:Array&lt;any&gt;): &#123;&#125;&#125;&gt; return &lt;T extends &#123;new(...args: Array&lt;any&gt;):&#123;&#125;&#125;&gt;(Constructor: T) =&gt; &#123; // 返回一个继承自给定构造函数的继承匿名类 return class extends Constructor &#123; property: string; constructor(...args) &#123; // 调用super方法来实现原有类的构造方法 super(...args); this.property = propertyDescription; &#125; getProperty(): string &#123; return this.property; &#125; &#125; &#125;&#125;let ming = new Person('ming','男');console.log(ming); // Person &#123; name: 'ming', sex: '男', property: 'I am a person' &#125;// 因为装饰器实在运行阶段运行的，因此，一开始在编译阶段无法判断ming实例具有property属性和getProperty方法，因此，我们需要通过断言的方式来进行正确的输出console.log((ming as any).property); // I am a personconsole.log((ming as any).getProperty()); // I am a personconsole.log(ming.property); // Error: 类型“Person”上不存在属性“property”console.log(ming.getProperty); // Error: 类型“Person”上不存在属性“getProperty” 当然，如果我们只是想为类添加一些新的方法，那我们大可不必去返回一个新的构造函数，而是通过修改构造函数的原型的方式来进行 12345678910111213141516171819202122232425@get('name')class Person &#123; private name: string; private sex: string; constructor(name: string,sex: string) &#123; this.name = name; this.sex = sex; &#125;&#125;function get(key: string) &#123; return function(target: Function) &#123; let func = function() &#123; return this[key]; &#125; Object.defineProperty(target.prototype,'get_'+key,&#123; value: func &#125;) &#125;&#125;let ming = new Person('ming','男');console.log(ming); // Person &#123; name: 'ming', sex: '男' &#125;console.log((ming as any).get_name()); // 'ming'console.log(ming.name); // Error: 属性“name”为私有属性，只能在类“Person”中访问 如果我们不想使用ES5的Object.defineProperty()。我们还可以使用更为强大的ES6的Proxy和Reflection 以下只改写上述例子中的get装饰器函数 1234567891011121314151617181920function get(key: string) &#123; return function(target: Function) &#123; let handler = &#123; defineProperty(trapTarget: Object,key: string,receiver: Object) &#123; // 如果属性名已存在，则抛出错误 if(key in trapTarget) &#123; throw new Error('属性已存在'); &#125; return Reflect.defineProperty(trapTarget,key,receiver); &#125; &#125; let proxy = new Proxy(target.prototype,handler); let func = function() &#123; return this[key]; &#125; Object.defineProperty(proxy,'get_'+key,&#123; value: func &#125;) &#125;&#125; 使用Proxy的好处就是，我们在可以拦截底层的一些操作，从而定义一些自定义操作。以上Proxy就定义了如果Object.defineProperty要定义的属性名已存在则抛出错误，否则就使用Reflect.defineProperty执行常规操作 方法装饰器方法装饰器声明在一个方法的声明之前（紧靠着方法声明）。 它会被应用到方法的 属性描述符上，可以用来监视，修改或者替换方法定义。 方法装饰器表达式会在运行时当作函数被调用，传入下列3个参数： 对于静态成员来说是类的构造函数，对于实例成员是类的原型对象。 成员的名字。 成员的属性描述符（通过Object.getOwnPropertyDescriptor()来得到）。 例如：我们为类中的某一个方法增加一行输出’这是方法装饰器’ 12345678910111213141516171819202122232425262728class Person &#123; name: string; constructor(name: string) &#123; this.name = name; &#125; @sayHelloMore sayHello() &#123; console.log('hello'); &#125;&#125;function sayHelloMore(target: any,key: string,descriptor: PropertyDescriptor) &#123; let func = target[key]; function newFunc() &#123; func.call(this); console.log('这是方法装饰器'); &#125; descriptor.value = newFunc;&#125;let ming = new Person('ming');ming.sayHello();/* 输出结果hello这是方法装饰器*/ 访问器装饰器访问器装饰器声明在一个访问器的声明之前（紧靠着访问器声明）。 访问器装饰器应用于访问器的 属性描述符并且可以用来监视，修改或替换一个访问器的定义。 访问器装饰器的使用与方法装饰器的使用一致，因为访问器属性就是getter和setter函数 例如： 1234567891011121314151617181920212223242526272829303132333435363738394041class Person &#123; _name: string; constructor(_name: string) &#123; this._name = _name; &#125; @nameMore get name() &#123; console.log('在getter函数中'); return this._name; &#125; set name(_name: string) &#123; console.log('在setter函数中'); this._name = _name; &#125;&#125;function nameMore(target: any,key: string,descriptor: PropertyDescriptor) &#123; descriptor.get = function() &#123; console.log('访问器装饰器--读取name值'); return this._name; &#125; descriptor.set = function(_name) &#123; console.log('访问器属性--修改name值'); this._name = _name; &#125;&#125;let ming = new Person('ming');console.log(ming.name);ming.name = 'zheng';console.log(ming.name);/* 输出结果访问器装饰器--读取name值ming访问器属性--修改name值访问器装饰器--读取name值zheng*/ 属性装饰器与其他装饰器不同，属性装饰器只会传入两个参数，而不会传入第三个参数descriptor。因为，实例属性是要在实例化之后才可以被描述。 因为目前没有办法在定义一个原型对象的成员时描述一个实例属性，并且没办法监视或修改一个属性的初始化方法。返回值也会被忽略。因此，属性描述符只能用来监视类中是否声明了某个名字的属性。 但是，我们可以去修改静态属性的值 例如： 12345678910111213class Person &#123; @mesChange('hello') static mes: string = 'person mes';&#125;function mesChange(value: string) &#123; return function(target,key) &#123; console.log(target.prototype); target[key] = value; &#125;&#125;console.log(Person.mes); // 'hello' 函数参数装饰器参数装饰器声明在一个参数声明之前（紧靠着参数声明）。 参数装饰器应用于类构造函数或方法声明。 参数装饰器表达式会在运行时当作函数被调用，传入下列3个参数： 对于静态成员来说是类的构造函数，对于实例成员是类的原型对象。 成员的名字（参数所在函数名）。 参数在函数参数列表中的索引。 这个装饰器也是像实例属性一样的，没有办法单独使用，毕竟函数是在运行时调用的，而无论是何种装饰器，都是在声明类时（可以认为是伪编译期）调用的。 注意 参数装饰器只能用来监视一个方法的参数是否被传入。 例如： 1234567891011121314151617181920212223242526272829class Person &#123; name: string; constructor(name: string) &#123; this.name = name; &#125; sayHello(@param('123') data: string) &#123; console.log('hello '+data); &#125;&#125;function param(value: string) &#123; return function(target: any,name: string,index: number) &#123; console.log(value); console.log(target); console.log(name); console.log(index); &#125;&#125;let ming = new Person('ming');ming.sayHello('world');/* 输出结果123Person &#123; sayHello: [Function] &#125;sayHello0hello world*/]]></content>
      <categories>
        <category>TypeScript</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[TypeScript中的泛型理解]]></title>
    <url>AngelLikeFairy%2F2019%2F11%2F19%2FTypeScript%E4%B8%AD%E7%9A%84%E6%B3%9B%E5%9E%8B%E7%90%86%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[什么是泛型我们在写JS的时候可以不用去管输入输出的类型，但是当我们在使用TS的时候就要注意类型的约束 例如： 我们有一个方法要返回传入的number类型的值： 123function getValue(arg: number): number &#123; return arg;&#125; 而另一个方法要返回传入的string类型的值： 123function getValue(arg: string): string &#123; return arg;&#125; 为了类型的约束与安全，我们经常会这么写。但是，仔细一看除了类型约束的差别外，这两个方法并没有本质的区别 因此，我们肯定想要减少重复代码的书写。这时候，肯定有人会想到用any数据类型来解决通用性问题，事实上这的确可以： 123function getValue(arg: any): any &#123; return arg;&#125; 这样一来，我们输入各种类型参数就都没有任何问题了： 12getValue(123);getValue('123'); 但是，沉下心来仔细思考，这样子做会有什么问题呢？ 我们的确可以传入任何类型，但是有一点是需要注意的，当参数类型和函数输出值类型为any时，TS无法判断输入的是什么类型，输出的是什么类型。那么，这样子就会破坏了类型安全（这样子就与js无异了，没有输入输出的类型检测） 因此，ts引入了泛型的概念，用来保证类型的安全同时又能使代码具有可复用性 泛型（Generics）是指在定义函数、接口或类的时候，不预先指定具体的类型，而在使用的时候再指定类型的一种特性。 了解泛型的初步概念那么，我们现在尝试使用泛型来解决上述的问题。 在泛型中，我们使用Type参数来表示传递给类，接口和函数的参数的数据类型。Type参数通常被定义为T 123function getValue&lt;T&gt;(arg: T): T &#123; return arg;&#125; 其中，函数名getValue后跟的中的T就用来指代输入的类型。当该T类型被确认后，在后面的参数arg和函数返回值都会被当做该指定类型 例如，当你将T指代为string类型后，上述函数的效果就相当于我们之前写过的传入为字符串类型的函数： 123function getValue(arg: string): string &#123; return arg;&#125; 那么，我们该如何为T来指定输入的类型呢？ 第一种方法：显式传入类型参数（也就是显式为T赋值），例如： 1getValue&lt;string&gt;('123'); 这样，我们就明确为T指定为string类型，那么，传递给函数的参数和输出值的类型现在就只能为string类型 第二种方法： （这种方法更为普遍）利用ts的类型推论 – 即编译器会根据传入的参数自动地帮助我们确定T的类型，那么，我们只要像正常一样调用即可 1getValue('123'); 多个类型参数如果我们要传入多个参数呢？没关系，在定义泛型的时候，我们也可以定义多个类型参数 事实上我们可以用任何可用标识符来表示这个类型参数，例如a,A,mmm,$等等等 但一般情况下，我们常用T,U,V来表示类型参数 例如： 1234567function getValue&lt;T,U,V&gt;(arg1: T,arg2: U,arg3: V): [T,U,V] &#123; return [arg1,arg2,arg3]&#125;getValue&lt;string,number,boolean&gt;('hello',123,true); // [ 'hello', 123, true ]getValue(undefined,null,&#123;a:1&#125;); // [ undefined, null, &#123; a: 1 &#125; ] 泛型的约束 我们需要一直记住一点，ts不同于js，它是具有静态类型系统的。 js是运行时检查类型js的类型检查会是在运行期间进行的（也就是说运行到某个地方需要检查类型才会去检查）。例如，定义一个函数输出传入参数的length属性值： 123function getLength(arg) &#123; return arg.length;&#125; 当我们传入一个数组或者是具有length属性的对象，这完全没有任何问题。但是，当我们传入undefined的时候，当代码运行到arg.length的时候，就会去检查arg的类型，然后发现其是undefined类型，它不会有length属性，因此报出错误 这便是在运行时检查类型 ts是编译时检查类型相比于js，ts使用了静态类型系统，这也意味着ts是在编译时（运行前）就检查类型的 那么，在函数内部使用泛型变量的时候，由于我们事先并不知道它是那种类型，因此，我们不能再函数内随意操作它的属性或方法 例如： 1234function getValue&lt;T&gt;(arg: T): T &#123; return arg.length; // 报错：类型“T”上不存在属性“length”&#125; 这样子就会产生报错。 那么，在函数内使用类型断言可以吗？我们之前学到过可以将较为不具体的类型推断为更加具体的类型，比如将any断言为string。 事实上，这是不允许的。因为类型变量T在函数声明的时候是不确定，因此，我们不能为它进行断言为更具体的类型（除了any类型）。 那么，为什么any类型可以呢？因为，我们知道any类型可以访问任何属性和方法（即使不存在），这在编译的时候是不会有任何错误的，只是可能在运行阶段报错 12345function getValue&lt;T&gt;(arg: T): T &#123; return (arg as any).length;&#125;console.log(getValue(&#123;length:2&#125;)); // 2 通用性约束既然我们想要在泛型中操作某个属性与方法，那么为了类型安全，我们可以对泛型进行更加通用性的约束，只允许这个函数传入具有某个属性与方法的变量 我们之前使用接口来描述一个对象或函数的形状，那么在泛型约束中我们就可以使用接口和extends来实现约束 例如： 12345678910interface Value &#123; length: any;&#125;function getValue&lt;T extends Value&gt;(arg: T): T &#123; console.log(arg.length); // 1 return arg;&#125;console.log(getValue(&#123;length: 1,m: 2&#125;)); // &#123; length: 1, m: 2 &#125; 我们定义了一个接口，这个接口内有一个length属性，然后类型变量T继承了该接口，使得传入函数的参数必须包含该length属性 我们知道，我们可以使用接口来对对象或者函数来做形状上的约束。 事实上，上述代码在调用函数的时候传递给泛型的类型参数是通过类型推断进行传递，那么如果我们显示传递类型给类型变量T呢？ 以上代码相当于： 1234567891011121314151617interface Value &#123; length: any;&#125;function getValue&lt;T&gt;(arg: T): T &#123; console.log(arg.length); // 1 return arg;&#125;// 定义一个需要显示传递给泛型的类型参数T的接口Minterface M &#123; length: any; m: number;&#125;console.log(getValue&lt;M&gt;(&#123;length: 1,m: 2&#125;)); // &#123;length: 1,m:2&#125; 泛型接口在上述中，我们将泛型运用在了函数中，事实上，我们还可以将泛型运用在接口中 例如： 123456789// 我们将泛型的类型变量T当做整个接口的参数interface Person&lt;T&gt; &#123; name: T;&#125;// 显示传递string类型给接口中的参数类型变量Tlet ming: Person&lt;string&gt; = &#123; name: 'ming'&#125; 接口除了可以约束对象之外，还可以去约束函数的形状： 例如： 1234567interface Func &#123; (m: string,n: number): void;&#125;let test: Func = function(m: string,n: number): void &#123; console.log(m,n);&#125; 但如果我们想约束一个使用了泛型的函数呢？ 123456789interface Func &#123; &lt;T&gt;(m: T,n: number): void;&#125;let test: Func = function&lt;T&gt;(m: T,n: number): void &#123; console.log(m,n); // 'hello' 123&#125;test&lt;string&gt;('hello',123); 另外，我们也可以将类型变量T作为接口的参数： 12345678910interface Func&lt;T&gt; &#123; (m: T,n: number): void;&#125;// 需要注意的是，此时我们需要定义好泛型的类型，因为此时我们必须将某个类型传递给类型参数T，而不能T传递给Tlet test: Func&lt;string&gt; = function&lt;T&gt;(m: T,n: number): void &#123; console.log(m,n);&#125;test('hello',123); 泛型类泛型也能作用于类上。 例如： 123456789101112class Item&lt;T&gt; &#123; property: T;&#125;let a = new Item&lt;string&gt;();let b = new Item&lt;number&gt;();a.property = 'hello';b.property = 123;console.log(a,b);// Item &#123; property: 'hello' &#125; Item &#123; property: 123 &#125; 类型参数作为类型的一部分在之前，我们一直将泛型的类型参数T作为整个类型来使用。但事实上，泛型的类型参数T还可以作为整个类型的一部分来使用 例如，我们考虑传入的参数是一个数组，然后利用泛型来限定该数组元素的类型 12345function getLength&lt;T&gt;(arg: T[]): number &#123; return arg.length;&#125;console.log(getLength&lt;number&gt;([1,2,3,4,5,4,3,2,1])); // 9 TS定义好的常用泛型TS为我们定义好了一些极其常用的泛型，包括： Array&lt;T&gt; Promise&lt;T&gt; Set&lt;T&gt; Map&lt;K,V&gt; 我们分别为以上四个泛型举一些例子： Array&lt;T&gt;12345function getArr&lt;T&gt;(arg: Array&lt;T&gt;): Array&lt;T&gt; &#123; return arg;&#125;console.log(getArr&lt;string&gt;(['hello','world'])); // [ 'hello', 'world' ] Promise&lt;T&gt;123456789101112131415function getPromise&lt;T&gt;(arg: T): Promise&lt;T&gt; &#123; return new Promise&lt;T&gt;((resolve,reject)=&gt;&#123; setTimeout(()=&gt;&#123; resolve(arg); &#125;,1000) &#125;)&#125;getPromise&lt;string&gt;('hello').then(v=&gt;&#123; console.log(v); // 'hello'&#125;)getPromise&lt;number&gt;(123).then(v=&gt;&#123; console.log(v); // 123&#125;) Promise&lt;T&gt;表示传递给Promise对象的参数的类型必须为T Set&lt;T&gt;12345function getSet&lt;T&gt;(args: Array&lt;T&gt;): Set&lt;T&gt; &#123; return new Set(args);&#125;console.log(getSet&lt;number&gt;([1,2,1,3,3,2,5])); // Set &#123; 1, 2, 3, 5 &#125; Map&lt;K,V&gt;12345function getMap&lt;K,V&gt;(args: Array&lt;[K,V]&gt;): Map&lt;K,V&gt; &#123; return new Map(args);&#125;console.log(getMap&lt;string,string&gt;([['key1','value1'],['key2','value2'],['key3','value3']])); // Map &#123; 'key1' =&gt; 'value1', 'key2' =&gt; 'value2', 'key3' =&gt; 'value3' &#125; 泛型接口实现TS自带的一些泛型下面，我们将使用泛型接口来自定义实现TS自带的一些泛型 首先，我们需要知道，我们可以使用接口来表示可索引的类型比如数组、类数组等： 12345interface numArray &#123; [index: number]: any;&#125;let numArray = [1,'hello',true]; 现在我们开始来自定义一下数组泛型，我们需要为该接口设置可索引，具有length属性，并且由一些常用的数组方法： 123456789interface numArray&lt;T&gt; &#123; length: number; [index: number]: any; reverse(): Array&lt;T&gt;; shift(): T; push(...items: Array&lt;T&gt;): number; // ...&#125; 之后我们创建数组类来实现这些接口中定义的方法和属性即可。 在泛型中使用new操作（类类型）如果我们想要构造一个工厂函数，该工厂函数可以返回传入该函数的类的实例。因为，我们不知道这个类的具体类型，因此，我们使用泛型来进行。 值得注意的是，如果我们直接这样写，编译是会出错的： 123function createObjec&lt;T&gt;(ctor: T): T &#123; return new ctor(); // Error: 该类型不具有构造函数&#125; 我们知道只有一个函数具有[[constructor]]时，该构造函数才可以被实例化（进行new操作）。 因此，我们做出如下修改： 123456789101112131415// 声明传入的参数ctor具有构造函数function createObject&lt;T&gt;(ctor: &#123;new(): T;&#125;): T &#123; return new ctor();&#125;class Test &#123; data: string = 'hello world';&#125;let test: Test = createObject&lt;Test&gt;(Test);console.log(test);/* 输出结果Test &#123; data: 'hello world' &#125;*/]]></content>
      <categories>
        <category>TypeScript</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[TypeScript的类与接口]]></title>
    <url>AngelLikeFairy%2F2019%2F11%2F17%2FTypeScript%E7%9A%84%E7%B1%BB%E4%B8%8E%E6%8E%A5%E5%8F%A3%2F</url>
    <content type="text"><![CDATA[TypeScript中对类的加强我们知道TypeScript能够提前用上最新ES版本的一些特性。例如，类的一些用法在ES7和Ts中就得到了更新 实例属性在ES6中，我们只能在constructor中来定义实例属性 例如： 123456class Person &#123; constructor(name,age) &#123; this.name = name; this.age = age; &#125;&#125; 然而，ts中允许我们直接在类中定义实例属性 1234567891011class Person &#123; name: string = 'lee'; age: number = 18; constructor() &#123; &#125;&#125;let lee = new Person();console.log(lee);// Person &#123; name: 'lee', age: 18 &#125; 静态成员我们也可以在类上定义静态成员，这些静态成员只存在于类本身而不会被实例所得到的 我们使用static关键字来定义静态成员 123456789101112131415161718192021222324class Person &#123; name: string; age: number; static id: string = '12345'; constructor(name: string,age: number) &#123; this.name = name; this.age = age; &#125;, static getId() &#123; return this.id; &#125;&#125;let ming = new Person('ming',18);console.log(ming);// Person &#123; name: 'ming', age: 18 &#125;// 我们可以看到在实例上并不能访问到静态成员console.log(Person.id); // '12345'console.log(Person.getId());// '12345' 类的继承类的继承在面向对象的特性中是一个重要的特点 看个例子： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162class Person &#123; name: string; age: number; static mes: string = 'short mes'; constructor(name: string,age: number) &#123; this.name = name; this.age = age; &#125; static getMes(): any &#123; return this.mes; &#125; sayHello(): void &#123; console.log('Person say hello'); &#125;&#125;class Man extends Person &#123; sex: string = 'man'; friends: Array&lt;string&gt;; constructor(name: string,age: number,friends: Array&lt;string&gt;) &#123; super(name,age); this.friends = friends; &#125; sayHello(): void &#123; console.log('Man say hello'); &#125;&#125;class Woman extends Person &#123; sex: string = 'woman'; friends: Array&lt;string&gt;; constructor(name: string,age: number,friends: Array&lt;string&gt;) &#123; super(name,age); this.friends = friends; &#125; sayHello(): void &#123; console.log('woman say hello'); &#125;&#125;let ming = new Man('ming',18,['lee','alice']);let alice = new Woman('alice',17,['lee,ming']);console.log(ming,alice);/*Man &#123; name: 'ming', age: 18, sex: 'man', friends: [ 'lee', 'alice' ] &#125;Woman &#123; name: 'alice', age: 17, sex: 'woman', friends: [ 'lee,ming' ] &#125;*/ming.sayHello();// 'Man say hello'alice.sayHello();// 'woman say hello'console.log(Man.getMes());// 'short mes'console.log(Woman.getMes());// 'short mes' 通过以上的例子，我们基本可以总结出关于类的继承方面的几点： 使用extends关键字进行类的继承 在子类的构造函数中调用super来调用父类的构造函数 在子类的构造函数中this的使用必须在super调用后 子类可以重写父类的方法 静态成员可以被继承，同样也可以被重写 访问修饰符TypeScript可以提供三种访问修饰符，分别是public,private,protected 其中： public修饰的属性或方法是公有的，可以在任何地方被访问到，所有类中的成员默认为public private修饰的属性或方法是私有的，不能在声明它的类外部进行访问 protected修饰的属性或方法是受保护的，它允许在基类和基类的子类中进行访问 public类中默认所有的属性和方法都是public修饰符，因此，所有属性和方法都可以在任何地方被访问到（静态成员和实例属性均可） 例如： 1234567class Person &#123; public name: string; public static mes: string = 'short mes'; public constructor(name: string) &#123; this.name = name; &#125;&#125; 这个看起来与我们之前的例子相比只是在每个属性和方法之前添加了public修饰符而已，实际上它们的效果也是一样的。因为，类中所有属性和方法都是默认使用public修饰符的，之前只是简写罢了。 private当成员被标记为private后，它就不能在声明它的类的外部使用了 我们将上述代码的public改为private来看下会有什么影响： 123456789101112class Person &#123; private name: string; private static mes: string = 'short mes'; private constructor(name: string) &#123; this.name = name; &#125;&#125;let ming = new Person('ming');// 类“Person”的构造函数是私有的，仅可在类声明中访问console.log(Person.mes);// 属性“mes”为私有属性，只能在类“Person”中访问。 我们就可以看到会报出如上的错误。因此，如果类中的某个成员前添加了private修饰符，那么该成员就变为了这个类的私有成员，在类的外部是无法访问该成员的 protected使用protected修饰符的类中成员可以在该类以及该类的派生类中进行使用 例如： 12345678910111213141516171819202122232425262728293031323334353637class Person &#123; name: string; age: number; private static mes: string = '这是Person的私有成员mes'; constructor(name: string,age: number) &#123; this.name = name; this.age = age; &#125; protected static getMes() &#123; console.log(this,this.mes); &#125;&#125;class Man extends Person &#123; constructor(name,age) &#123; super(name,age); &#125; public static getPersonMes() &#123; // 调用Person的子类Man继承得到的protected方法getMes Man.getMes(); &#125;&#125;// 创建Man实例let ming = new Man('ming',18);console.log(ming);// Man &#123; name: 'ming', age: 18 &#125;// 访问Person类私有静态成员mes，则会报错// console.log(Person.mes);Man.getPersonMes();// [Function: Man] 这是Person的私有成员mes/*在看到这段输出的时候，我产生了疑问，为什么this指向的是子类Man，而this.mes却可以得到基类中的私有属性，后来当我将这段代码编译成es6的时候就想明白了*/ 为了说明上述的问题，我将代码做了精简 1234567891011121314151617class Person &#123; private static mes = '这是Person基类的私有属性mes'; protected static getMes() &#123; console.log(this,this.mes); &#125; constructor() &#123;&#125;&#125;class Man extends Person &#123; constructor() &#123; super(); Man.getMes(); // [Function: Man] 这是Person基类的私有属性mes &#125;&#125;let man = new Man(); 当我们将该段代码编译为es6时，得到以下的文件： 12345678910111213141516171819202122232425262728293031323334var __extends = (this &amp;&amp; this.__extends) || (function () &#123; var extendStatics = function (d, b) &#123; extendStatics = Object.setPrototypeOf || (&#123; __proto__: [] &#125; instanceof Array &amp;&amp; function (d, b) &#123; d.__proto__ = b; &#125;) || function (d, b) &#123; for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; &#125;; return extendStatics(d, b); &#125;; return function (d, b) &#123; extendStatics(d, b); function __() &#123; this.constructor = d; &#125; d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __()); &#125;;&#125;)();var Person = /** @class */ (function () &#123; function Person() &#123; &#125; Person.getMes = function () &#123; console.log(this, this.mes); &#125;; Person.mes = '这是Person基类的私有属性mes'; return Person;&#125;());var Man = /** @class */ (function (_super) &#123; __extends(Man, _super); function Man() &#123; var _this = _super.call(this) || this; Man.getMes(); return _this; // [Function: Man] 这是Person基类的私有属性mes &#125; return Man;&#125;(Person));var man = new Man();//# sourceMappingURL=a.js.map 当看到这段代码的时候，我就突然明白了。因为，Js的继承是通过原型链来实现的。 因此，父类Person是子类Man的原型对象。所以，当在Man中找不到属性mes的时候，它就会顺着原型链向上查找，因此在原型对象Person中找到了属性mes readonly关键字我们之前在接口部分接触到了readonly关键字的概念。该关键字用来表示属性是只读的，不允许被修改 例如： 123456class Person &#123; static readonly mes: string = 'short mes';&#125;Person.mes = 'long mes';// 报错： Cannot assign to 'mes' because it is a read-only property. 我们可以看到，当我们试图要修改一个readonly成员时是不被允许的 另外，值得注意的是： 如果 readonly 和其他修饰符（例如：public private protected static）同时存在的话，需要写在其后面。 存储器（getter和setter）TypeScript支持通过getters/setters来截取对对象成员的访问。 它能帮助你有效的控制对对象成员的访问。 例如： 123456789101112131415161718192021class Person &#123; private static _mes: string = 'short mes'; constructor() &#123;&#125; static get mes() &#123; return this._mes; &#125; static set mes(_mes: string) &#123; console.log('现在开始修改Person类的私有属性_mes') this._mes = _mes; &#125;&#125;console.log(Person.mes);// 'short mes'Person.mes = 'long mes';// '现在开始修改Person类的私有属性_mes'console.log(Person.mes);// 'long mes' 因此，使用getter和setter方法我们就可以在值访问和值操作之前进行拦截，从而进行一些自定义操作 抽象类有些时候，我们经常会在子类重写父类的某个方法，而且我们不会去实例化这个父类。那么，抽象类就变得很有用处了。 抽象类不允许被实例化，并且抽象类需要定义抽象方法。该抽象方法不用完整地定义方法体。 记住，抽象类不能被实例化 另外，我们需要在派生类中实现该抽象方法 我们使用abstract关键字是定义抽象类和在抽象类内部定义抽象方法。 例如： 1234567891011121314151617181920212223242526272829303132abstract class Person &#123; abstract sayHello(): void; sayBye() &#123; console.log('bye'); &#125;&#125;class Man extends Person &#123; sayHello():void &#123; console.log('Man say hello'); &#125; constructor() &#123; super(); &#125;&#125;class Woman extends Person &#123; sayHello() &#123; console.log('Woman say hello'); &#125; constructor() &#123; super(); &#125;&#125;let man = new Man();let woman = new Woman();man.sayHello(); // 'Man say hello'woman.sayHello(); // 'Woman say hello'man.sayBye(); // 'bye'woman.sayBye(); // 'bye' 给类的实例化对象加上类型类似于给对象加上接口类型，我们也可以给类的实例化对象加上类的类型，表明该对象是由此类实例化得到的 例如： 123456789class Person &#123; constructor() &#123;&#125; sayHello() &#123; console.log('hello'); &#125;&#125;let ming: Person = new Person();ming.sayHello(); // 'hello' 类与接口我们知道接口可以用于描述一个对象的形状以及对象内部的结构，除此之外，接口还可以对类的一部分行为进行抽象 在Java之类的面向对象的语言中，接口常用于实现多继承，在ts中也可以让一个类去强制去实现某种契约 类实现接口比如说，有Man类和Woman类，他们都可以有一个方法sayHello()。我们可以让这个方法从基类Person中继承得到，例如： 123456789101112131415class Person &#123; sayHello() &#123;&#125;&#125;class Man extends Person&#123; sayHello() &#123; console.log('Man say hello'); &#125;&#125;class Woman extends Person&#123; sayHello() &#123; console.log('Woman say hello'); &#125;&#125; 除此之外，我们也可以使用抽象类： 123456789101112131415abstract class Person &#123; abstract sayHello(): void;&#125;class Man extends Person&#123; sayHello() &#123; console.log('Man say hello'); &#125;&#125;class Woman extends Person&#123; sayHello() &#123; console.log('Woman say hello'); &#125;&#125; 但是我们知道，类是不允许被多继承的，那么抽象类也是如此。因此，我们就可以使用接口来定义： 123456789101112131415interface Say &#123; sayHello(): void;&#125;class Man implements Say &#123; sayHello(): void&#123; console.log('Man say hello'); &#125;&#125;class Woman implements Say &#123; sayHello(): void&#123; console.log('Man say hello'); &#125;&#125; 类实现多个接口接口的很重要的一个功能就是用来实现多继承的。 因此，我们可以用一个类来继承多个接口： 1234567891011121314151617181920interface Say &#123; sayHello(): void;&#125;interface Travel&#123; travelByBus(): void;&#125;class Man implements Say,Travel &#123; sayHello(): void &#123; console.log('Man say hello'); &#125; travelByBus(): void &#123; console.log('Man travel by bus'); &#125; &#125;let man = new Man();man.sayHello(); // 'Man say hello'man.travelByBus(); // 'Man travel by bus' 接口继承接口继承接口事实上，和类一样，接口也可以实现继承。我们可以将一个接口继承另一个接口，来实现更为灵活的可重用 例如： 1234567891011121314151617181920212223interface Person &#123; sayHello(): void;&#125;interface Man extends Person&#123; gender: string;&#125;class MaleStudents implements Man &#123; gender: string = 'male'; sayHello(): void &#123; console.log('Students say hello'); &#125; constuctor() &#123;&#125; sayNice() &#123; console.log('nice'); &#125;&#125;let maleStudent = new MaleStudents();console.log(maleStudent.gender); // 'male'maleStudent.sayHello(); // 'Students say hello'maleStudent.sayNice(); // 'nice' 当然，既然类可以多继承多个接口，那么接口也可以多继承多个接口 123456789101112131415161718192021interface Say &#123; say(): void;&#125;interface Walk &#123; walk(): void;&#125;interface Person extends Say,Walk&#123; property: string;&#125;class Man implements Person &#123; property = 'person'; say() &#123; console.log('say'); &#125; walk() &#123; console.log('walk'); &#125;&#125; 接口继承类接口也可以继承类。 当接口继承了一个类类型时，它会继承类的成员但不包括其实现。 就好像接口声明了所有类中存在的成员，但并没有提供具体实现一样。 接口同样会继承到类的private和protected成员。 这意味着当你创建了一个接口继承了一个拥有私有或受保护的成员的类时，这个接口类型只能被这个类或其子类所实现（implement）。 12345678910111213141516171819class Person &#123; property: string = 'person'; sayHello(): void &#123; console.log('Person say hello'); &#125;&#125;interface InterfacePerson extends Person &#123;&#125;class Man implements InterfacePerson &#123; property = 'man'; sayHello(): void &#123; console.log('Man say hello'); &#125;&#125;let man = new Man();console.log(man.property); // 'man'man.sayHello(); // 'Man say hello']]></content>
      <categories>
        <category>TypeScript</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[flex布局一把梭]]></title>
    <url>AngelLikeFairy%2F2019%2F11%2F16%2Fflex%E5%B8%83%E5%B1%80%E4%B8%80%E6%8A%8A%E6%A2%AD%2F</url>
    <content type="text"><![CDATA[flex布局的基本语法知识如何设置flex布局我们可以通过 将块级元素设置为display: flex 将内联元素设置为display: inline-flex 来为元素创建flex布局 基本概念引用阮老师的一张图： 我们将设置为flex布局的那个元素称之为flex容器，而在该容器内部的其他元素称之为flex子项 我们可以看到，如果不设置flex-direction的属性，那么容器的主轴默认为横向，与主轴垂直的轴称之为交叉轴 当然，如果我们将flex-direction属性值设置为 1234#app &#123;display: flex;flex-direction: column;&#125; 那么，项目的主轴就会变成竖向，而项目的交叉轴就会变为横向 flex容器可以设置的属性flex容器内包含了多个子项，因此，flex容器的属性就是为了控制多个子项的分布 其主要具有以下几个属性（只提及常用属性和对应属性值）： 属性名 属性值 作用 flex-direction row,column 设置flex容器主轴为横向或者为竖向 flex-wrap wrap,nowrap 是否换行 justify-content flex-start,flex-end,center,space-between,space-around,space-evenly 稍后详解 align-items stretch, flex-start,flex-end, center,baseline 稍后详解 align-content stretch, flex-start,flex-end, center,space-between,space-around,space-evenly 稍后详解 justify-contentjustify-content属性用来设置子项在主轴上的排列方式 语法如下： 1justify-content: flex-start | flex-end | center | space-between | space-around | space-evenly; 其中： flex-start 默认值，主轴的起点对齐 flex-end 主轴的终点对齐 center 主轴方向上居中 space-between 两端对齐，中间各项目之间的间隔相同 space-around 每个flex子项两侧都环绕互不干扰的等宽的空白间距，最终视觉上边缘两侧的空白只有中间空白宽度一半。 space-evenly 每个子项之间的间隔与子项与容器边界的间隔完全相同（视觉上看起来所有子项平分了空白区域） align-itemsalign-items用来设置容器交叉轴上的子项排列方式 其语法如下： 1align-items: align-items: stretch | flex-start | flex-end | center | baseline; 其中： stretch （默认值）如果子项没有设置高度或者设置为auto，那么子项高度就为容器高度 flex-start 交叉轴的起点对齐 flex-end 交叉轴的终点对齐 center 交叉轴方向上居中 baseline 所有flex子项都相对于flex容器的基线对齐 align-contentalign-content则是指明垂直方向每一行flex元素的对齐和分布方式。如果所有flex子项只有一行，则align-content属性是没有任何效果的。 也就是说，使用align-content属性是将flex容器中的所有主轴上的所有项目合起来看做是一个flex子项，然后各个主轴上的整体子项可以使用justify-content上的属性值进行排列 其语法如下： 1align-content: stretch | flex-start | flex-end | center | space-between | space-around | space-evenly; 具体含义不再赘述，与justify-content属性值并无二异。只是前者作用于交叉轴上，而后者作用在主轴上 举个align-content:space-between属性值的例子即可 1234567891011121314151617181920&lt;div id="app"&gt; &lt;div class="item"&gt; &lt;p&gt;A&lt;/p&gt; &lt;/div&gt; &lt;div class="item"&gt; &lt;p&gt;B&lt;/p&gt; &lt;/div&gt; &lt;div class="item"&gt; &lt;p&gt;C&lt;/p&gt; &lt;/div&gt; &lt;div class="item"&gt; &lt;p&gt;D&lt;/p&gt; &lt;/div&gt; &lt;div class="item"&gt; &lt;p&gt;E&lt;/p&gt; &lt;/div&gt; &lt;div class="item"&gt; &lt;p&gt;F&lt;/p&gt; &lt;/div&gt;&lt;/div&gt; 1234567891011121314151617181920212223#app &#123; width: 500px; height: 200px; border: 1px solid black; display: flex; flex-direction: row; flex-wrap: wrap; justify-content: space-evenly; align-content: space-between;&#125;.item &#123; width: 200px; height: 30px; background-color: pink; display: flex; justify-content: center; align-items: center;&#125;p &#123; font-size: 20px;&#125; 最后得到的效果如下： flex子项可以设置的属性在flex子项上设置的属性用于作用在子项自身身上，并不会对整个容器的所有子项产生影响。 其主要有以下几个属性： order flex-grow flex-shrink flex-basis flex align-self orderorder属性可以设置子项的排列顺序，数值越小，排列越靠前。所有子项的默认order属性值为0 例如： 123456789#A &#123; order: -1&#125;#B &#123;&#125;#C &#123; order: -4&#125; 我们可以看到各个子项的order由小到大排序应该是C，A，B（默认order为0） 渲染结果为： flex-growflex-grow中的grow就是扩展的意思。这个属性的目的就是在自身子项已有的宽度上来根据属性值来决定利用剩余的空白部分来扩展自身的宽度 语法为： 1flex-grow: &lt;number&gt; /* 数值，可以是小数，但不支持负数，默认值是 0 */ 首先，我们需要明确的是，所有剩余空白空间在数值上表示为1 那么具体的分配规则如下： 如果只有一个子项设置了flex-grow属性，那么就只对该子项进行空间扩展。其中可以分为两种情况： 如果flex-grow的属性值小于1，那么扩展的空间就相当于总剩余空间和这个比例的乘积值。 如果属性值大于等于1，那么扩展的空间就是剩余所有空间 如果有多个子项设置了flex-grow属性，那么具体可以分为以下情况： 如果所有已设置flex-grow属性的属性值的和小于1，那么每个已设置该属性的子项的扩展空间相当于总剩余空间和各个子项设置的属性值的乘积值 如果flex-grow值总和大于或等于1，则所有剩余空间被利用，分配比例就是flex-grow属性值的比例。例如所有的flex子项都设置flex-grow:1，则表示剩余空白间隙大家等分，如果设置的flex-grow比例是1:2:1，则中间的flex子项占据一半的空白间隙，剩下的前后两个元素等分。 来看下具体例子： 只有一个子项设置flex-grow属性12345678910111213141516171819202122232425#app &#123; width: 500px; height: 200px; border: 1px solid black; display: flex; flex-direction: row; flex-wrap: wrap; justify-content: space-evenly;&#125;#A &#123; flex-grow: 0.5; background-color: blue; width: 100px;&#125;#B &#123; background-color: pink; width: 100px;&#125;#C &#123; background-color: pink; width: 100px;&#125; 渲染结果为： 我们可以看到容器的总宽度为500px。每个子项最初本来只占100px，也就是说本来会剩余200px宽度的空白空间。 然后，我们在A子项设置了flex-grow:0.5。因此，A子项所获得的扩展空间也就为200px*0.5=100px宽度的空白空间 多个子项设置flex-grow属性123456789101112131415161718192021222324252627#app &#123; width: 500px; height: 200px; border: 1px solid black; display: flex; flex-direction: row; flex-wrap: wrap; justify-content: space-evenly;&#125;#A &#123; flex-grow: 0.5; background-color: blue; width: 100px;&#125;#B &#123; flex-grow: 0.5; background-color: pink; width: 100px;&#125;#C &#123; flex-grow: 1; background-color: pink; width: 100px;&#125; 渲染结果为： 我们可以看到，因为A子项设置flex-grow为0.5，B子项为0.5，C子项为1.因此，这三者的和超过了1。那么，这三个子项的扩展空间将占领全部的剩余空白空间，并且每个子项在扩展空间的分配比例相当于它们属性值的比例。因此： A子项获得200px*(0.5/(0.5+0.5+1))=50px的宽度的扩展空间 B子项获得200px*(0.5/(0.5+0.5+1))=50px的宽度的扩展空间 C子项获得200px*(0.5/(0.5+0.5+1))=100px的宽度的扩展空间 flex-shrinkshrink是收缩的意思。因此，该属性用来处理当剩余空间不足的情况下，各个子项该如何收缩。 什么叫剩余空间不够呢？假如说，当flex容器的宽度为500px，每个子项的宽度为200px，并且我们设置不允许换行（flex-wrap:nowrap）。那么，如果每个子项不收缩的话，那么就会有一个子项溢出，如下所示： 因此，该flex-shrink属性就是用来当剩余空间不足的情况下来处理各个子项的收缩情况 语法如下： 1flex-shrink: &lt;number&gt;; /* 数值，不支持负值，所有子项默认值是 1，也就是都进行同等比例的收缩，以保证元素不会溢出 */ 默认渲染情况如下： 具体收缩规则如下： 如果只有一个子项设置了flex-shrink，那么只有该子项会进行收缩 如果flex-shrink属性值小于1，那么收缩尺寸不完全，仍然会有一部分内容会溢出 如果flex-shrink属性值大于或等于1，那么收缩尺寸完全，不会有任何溢出 如果有多个子项设置了flex-shrink，那么设置该属性的子项会进行收缩 如果所有设置该属性的属性值的和小于1，那么收缩会不完全，每个元素收缩尺寸为“完全收缩的尺寸”与每个子项上的该属性值的乘积 flex-shrink值的总和大于1，则收缩完全，每个元素收缩尺寸的比例和flex-shrink值的比例一样 align-selfalign-self用于单独设置该子项在交叉轴上的对齐方式。 其语法如下： 1align-self: auto | flex-start | flex-end | center | baseline | stretch; 属性值都已介绍过，这里不再赘述 我们以align-self:center为示例： 123456789101112131415161718192021222324252627#app &#123; width: 500px; height: 200px; border: 1px solid black; display: flex; flex-direction: row; justify-content: space-evenly;&#125;#A &#123; background-color: blue; width: 50px; height: 100px;&#125;#B &#123; background-color: pink; width: 100px; height: 100px; align-self: center;&#125;#C &#123; background-color: gainsboro; height: 100px; width: 150px;&#125; 渲染结果为： flex布局的应用场景三栏布局三栏布局就是整体高度已知，左栏和右栏宽度确定然后中间栏宽度自适应 我们假设整体高度为200px。左右两栏的宽度为20px，高度为100% 那么，我们可以利用flex布局来实现，同时使用flex-grow来是实现中间栏自适应宽度 首先设置三个flex子项 1234567891011&lt;div id="app"&gt; &lt;div id="A" class="flex"&gt; &lt;p&gt;A&lt;/p&gt; &lt;/div&gt; &lt;div id="B" class="flex"&gt; &lt;p&gt;B&lt;/p&gt; &lt;/div&gt; &lt;div id="C" class="flex"&gt; &lt;p&gt;C&lt;/p&gt; &lt;/div&gt;&lt;/div&gt; 然后设置css属性 这里假设整体宽度为500px 12345678910111213141516171819202122232425262728293031#app &#123; width: 500px; height: 200px; border: 1px solid black; display: flex; flex-direction: row;&#125;#A &#123; background-color: blue; width: 20px;&#125;#B &#123; background-color: pink; flex-grow: 1;&#125;#C &#123; background-color: gainsboro; width: 20px;&#125;p &#123; font-size: 20px;&#125;.flex &#123; display: flex; justify-content: center; align-items: center;&#125; 那么，渲染结果为： 当我们将整体宽度设置为200px， 1234567#app &#123; width: 200px; height: 200px; border: 1px solid black; display: flex; flex-direction: row;&#125; 那么渲染结果为：]]></content>
      <categories>
        <category>css</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[相等==与全等===的区别]]></title>
    <url>AngelLikeFairy%2F2019%2F11%2F15%2F%E7%9B%B8%E7%AD%89-%E4%B8%8E%E5%85%A8%E7%AD%89-%E7%9A%84%E5%8C%BA%E5%88%AB%2F</url>
    <content type="text"><![CDATA[概要JavaScript 有两种比较方式：严格比较运算符和转换类型比较运算符。对于严格比较运算符（===）来说，仅当两个操作数的类型相同且值相等为 true，而对于被广泛使用的比较运算符（==）来说，会在进行比较之前，将两个操作数转换成相同的类型。 全等运算符（===）全等运算符（===）的规则相对简单，我们先来看全等运算符的运算规则 如果两个操作数有不同的类型，它们不是严格相等的 如果两个操作数都为 null，则它们是严格相等的 如果两个操作数都为 undefined，它们是严格相等的 如果一个或两个操作数都是 NaN，它们就不是严格相等的 如果两个操作数都为 true 或都为 false，它们是严格相等的 如果两个操作数都是 number 类型并且具有相同的值，则它们是严格相等的 如果两个操作数都是 string 类型并且具有相同的值，则它们是严格相等的 如果两个操作数都引用相同的对象或函数，则它们是严格相等的 以上所有其他情况下操作数都不是严格相等的。 简单概括来说，对于全等运算符来说，操作数双方必须是同一类型并且具有相同的值（引用的指向必须指向同一个引用）（除了NaN）以外。因为，NaN与任何值都不相等包括其本身。 例如： 1234console.log(undefined===undefined); // trueconsole.log(1==='1'); // falseconsole.log(null===null); // trueconsole.log(&#123;a:1&#125;===&#123;a:1&#125;); // false 数值转换我们使用Number()转型函数来将其他类型转化为数值型 具体规则如下： 如果是布尔值，那么true转化为1，false转化为02，如果是null值，那么转化为0 如果是undefined，返回NaN 如果是字符串，又会分以下几种情况 如果字符串只包含数字（包括带正负号，整数或者是浮点数），那么就会返回该数值 如果字符串是空的，那么返回数字0 其余情况返回NaN 如果是对象，那么调用对象的valueOf()方法，然后再依照前面的规则转换返回的值 对象转化为基本类型值在将相等运算符的规则之前，我们需要弄清楚对象转化为基本类型值会变成怎么样？因为，这会出现在相等运算符的比较规则中 对象在转换基本类型时，首先会调用 valueOf 然后调用 toString valueOf valueOf() 方法返回指定对象的原始值。 具体规则如下：对象|返回值–|–Array|返回数组本身对象Boolean|布尔值Date|存储的时间是从 1970 年 1 月 1 日午夜开始计的毫秒数 UTCFunction|函数本身Number|数字值Object|对象本身String|字符串值 例如： 1234567console.log([1,2,3].valueOf()); // [1,2,3]console.log(new Boolean(false).valueOf()); //falseconsole.log(new Date().valueOf()); // 1573803246103console.log(function a()&#123;&#125;.valueOf()); // function a()&#123;&#125;console.log(new Number(1).valueOf()); // 1console.log(&#123;a:1&#125;.valueOf()); // &#123;a:1&#125;console.log(new String('nice').valueOf()); // 'nice' toString toString() 方法返回一个表示该对象的字符串。 例如： 1234567console.log([1,2,3].toString()); // '1,2,3'console.log(new Boolean(false).toString()); //'false'console.log(new Date().toString()); // 'Fri Nov 15 2019 15:41:22 GMT+0800 (GMT+08:00)'console.log(function a()&#123;&#125;.toString()); // 'function a()&#123;&#125;'console.log(new Number(1).toString()); // '1'console.log(&#123;a:1&#125;.toString()); // [object Object]console.log(new String('nice').toString()); // 'nice' 相等运算符（==）使用相等运算符时，都会先转换操作数（通常称为强制转型）为相同的类型，然后再比较他们的相等性 相等运算符遵循以下规则： 如果操作数具有相同的类型，请使用上面的 IEA 测试它们是否严格相等。 如果它们不严格相等，则它们不相等，否则相等。 如果操作数有不同的类型： 如果一个操作数为 null 而另一个 undefined，则它们相等 如果一个值是数字，另一个是字符串，先将字符串转换为数字，然后使用转换后的值比较 如果一个操作数是布尔值，则将 true 转换为 1，将 false 转换为 0，然后使用转换后的值比较 如果一个操作数是一个对象，而另一个操作数是一个数字或字符串，则调用valueOf()将该对象转换为基本类型值，再使用转换后的值进行比较 在以上的其他情况下，操作数都不相等 注意： 在进行相等比较操作中,undefined和null是不能进行类型转化的。因此,undefined和null只能互相相等或者它们自身相等 例如： 其中一个操作数为布尔值 如果一个操作数为布尔值，那么将true转化为1，将false转化为0。然后，再利用其余规则进行比较 布尔值与数值比较12console.log(1==true); // trueconsole.log(3==false); // false 布尔值与字符串比较12console.log('1'==true); // trueconsole.log('123'==false); // false 布尔值与其余基本类型值比较12console.log(undefined==true); // falseconsole.log(null==false); // false 因为，在进行相等比较操作中，undefined和null是不能进行转化的，而布尔值需要转化为数值型，因此，两者不可能相等 布尔值与数组比较123console.log([]==false); // trueconsole.log([1,2,3]==false); // falseconsole.log([1]==true); // true 是不是感觉很奇怪？ 我们在前面提过，如果其中一个操作数为对象，那么就要该对象先通过valueOf()再通过toString()转化为基本类型值（确切来说是字符串型）然后再利用其余规则进行比较 又因为另一个操作数为布尔值，那么，布尔值就会被转化为数值型，true转化为1，false转化为0 因此，已经转化为字符串的对象还需要将字符串转化为数值型 具体过程如下： 1234567891011/*比较[]与false1. [].valueOf() --&gt; &apos;&apos;2. &apos;&apos;.toString() --&gt; &apos;&apos;3. Number(&apos;&apos;) --&gt; 04. Number(false) --&gt; 05. 0===0 --&gt;true*/ 其余几个过程类似，因此不再赘述 布尔值与其余对象123console.log(&#123;a:1&#125; == false); // falseconsole.log(new Date()=== true); // falseconsole.log(function ()&#123;&#125; == false); // false 其中一个操作数为字符串在进行操作数比较前，我们需要明确，只有另一个操作数为数值型的情况下（可能发生了转换变为了数值型），我们才需要将该字符串转化为数值；否则，该字符串不会进行转化 例如： 另一个操作数为数值1console.log('123'==123); // true 另一个操作数为布尔值12console.log('1'==true); // trueconsole.log('0'==false); // true 因为布尔值在进行相等比较的前一定会转换为数值型，因此，字符串也会被通过Number转型函数变为数值型。 另一个操作数为其他基本类型值12console.log('0'==null); // falseconsole.log('0'==undefined); // false 在相等比较前，null和undefined不能被转换为其他类型值 另一个操作数为数组1234console.log('0'==[]); // falseconsole.log('1'==[1]); // trueconsole.log('123'==[1,2,3]); // falseconsole.log('1,2,3'==[1,2,3]); // true 首先，必须明确地是，如果其中一个操作数为字符串类型，那么我们先去看另一个操作数为什么类型。 在这里，另一个操作数为引用类型值，那么引用类型值会通过valueOf和toString转换为字符串型。那么，另一个字符型操作数就不需要进行转换，两个字符串类型进行比较即可。（因为，相等操作符在比较比较之前的目的就是将两个操作数的类型转换为一致，然后再进行比较） 另一个操作数为对象12console.log(&#123;a:1&#125;=='a:1'); // falseconsole.log(&#123;&#125;==''); // false 在这里，我们千万不要忘记自定义对象通过toString()方法转换得到的都是： 1console.log(&#123;a:1&#125;.valueOf().toString()); // '[object Object]' 其中一个操作数为数组大致的比较方法差不多在前面都提及了，这里看一个奇葩的题目： 1console.log([]=![]); // true 是不是很奇怪，但是，如果仔细进行分析就不会觉得奇怪了。 具体过程： 第一个操作数为[]，那么将其通过valueOf和toString转换为字符串得到空字符串’’ 第二个操作数![]，因为有逻辑非布尔操作符，因此第二个操作数实际上是布尔值false 布尔值需要转换为数值型,false转换为0 因为第二个操作数转换为数值型了，因此，第一个操作数也要将得到的字符串转换为数值型，空字符串’’通过Number转型函数得到的是0 0===0 返回true]]></content>
      <categories>
        <category>javaScript基础</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[TypeScript零散知识点总结]]></title>
    <url>AngelLikeFairy%2F2019%2F11%2F15%2FTypeScript%E9%9B%B6%E6%95%A3%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[如何注解二维数组我们一般会使用一下两种方式来注解一维数组： 类型+方括号 1let arr: number[]; 数组泛型 1let arr: Array&lt;number&gt;; 那么，以此类推，我们也可以用以上两种方式来注解二维数组： 类型+两个方括号 1let arr: number[][]; 泛型中类型为泛型数组 1let arr: Array&lt;Array&lt;number&gt;&gt;]]></content>
      <categories>
        <category>TypeScript</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Vue的一些零散知识点总结]]></title>
    <url>AngelLikeFairy%2F2019%2F11%2F11%2FVue%E7%9A%84%E4%B8%80%E4%BA%9B%E9%9B%B6%E6%95%A3%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[v-if与v-show的区别官方文档对于这两个指令的定义： v-show：根据表达式之真假值，切换元素的 display CSS属性。 v-if: 根据表达式的值的真假条件渲染元素。在切换时元素及它的数据绑定 / 组件被销毁并重建。如果元素是 &lt;template&gt; ，将提出它的内容作为条件块。 我们通过实际的例子来区分这两个指令的区别： v-show的渲染情况123&lt;div id="app"&gt; &lt;p v-show="bool"&gt;&#123;&#123;value&#125;&#125;&lt;/p&gt;&lt;/div&gt; 当bool值为真时，渲染情况如下： 1&lt;p&gt;123&lt;/p&gt; 当bool值为假时，渲染情况发生了如下变化： 1&lt;p styel="display:none;"&gt;123&lt;/p&gt; 我们可以看到，当使用v-show时，该节点会被添加到DOM树中，始终会被渲染。切换v-show的值只是简单的切换元素的display元素而已 display与opacity与visibility的区别当v-show为false时，vue会将该元素的style属性的display属性设置为none。 那么，对于其他两种也可以将元素隐藏的css方式，这三种有什么区别呢？ 属性 属性值 是否可见 是否占用布局 是否可以被点击 display none 不可见 不占用 不能 opacity 0 不可见 占用 能 visibility hidden 不可见 占用 不能 v-if的渲染情况123&lt;div id="app"&gt; &lt;p v-if="bool"&gt;&#123;&#123;value&#125;&#125;&lt;/p&gt;&lt;/div&gt; 当bool值为真时，渲染情况如下： 1&lt;p&gt;123&lt;/p&gt; 当bool值为假时，渲染情况发生了如下变化： 123&lt;div id="app"&gt;&lt;!----&gt;&lt;/div&gt; 我们可以看到，当使用v-if时，如果v-if的值为false，那么该节点就不会被添加到DOM树中，当然也不会被渲染。只有，当v-if的值为true时，该节点才会被正常渲染 另外，我们也可以使用v-else与v-if进行配合 例如： 12&lt;p v-if="bool"&gt;&#123;&#123;value&#125;&#125;&lt;/p&gt;&lt;p v-else&gt;&#123;&#123;anotherValue&#125;&#125;&lt;/p&gt; 多元素条件渲染（v-if支持,v-show不支持）以上我们使用v-if和v-show都是对单个元素进行条件渲染，那么如果想对多个元素一起进行条件渲染呢？ vue允许我们在&lt;template&gt;元素上使用v-if来对多个元素进行一起条件渲染。 此时vue会把 &lt;template&gt; 元素当做不可见的包裹元素，并在上面使用 v-if。最终的渲染结果将不包含 &lt;template&gt; 元素。 例如： 123456789101112&lt;div id="app"&gt; &lt;template v-if="bool"&gt; &lt;p&gt;&#123;&#123;value1&#125;&#125;&lt;/p&gt; &lt;p&gt;&#123;&#123;value2&#125;&#125;&lt;/p&gt; &lt;p&gt;&#123;&#123;value3&#125;&#125;&lt;/p&gt; &lt;/template&gt; &lt;template v-else&gt; &lt;p&gt;&#123;&#123;anotherValue&#125;&#125;&lt;/p&gt; &lt;/template&gt; &lt;button @click="changeIf"&gt;change&lt;/button&gt;&lt;/div&gt; 那么v-show呢？它支持多元素条件渲染吗？遗憾的是，它并不支持。 注意，v-show 不支持 &lt;template&gt; 元素，也不支持 v-else v-if与v-show区别总结由以上的示例我们可以看到： v-if是真正的条件渲染，它会根据条件的真值来决定是否将该DOM元素加入或移除DOM树 v-show会一直渲染该DOM元素，也就是该DOM元素一直在DOM树上。只是，简单地切换该元素的style属性中的display而已 因此，v-if有更高的切换开销，而v-show有更高的初始渲染开销。如果，元素需要频繁的切换的话，那么使用v-show更好，反之，使用v-if较好 除了数组，我们还可以给v-for传递什么参数通常来说，我们一般会传递v-for一个数组来让vue进行列表渲染 但事实上，除了数组，我们还可以传递给v-for更多类型的参数。官方文档并没有太多的提及传递的参数类型限制。但是，我们可以从源码中找到答案： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253import &#123; isObject, isDef, hasSymbol &#125; from 'core/util/index'/** * Runtime helper for rendering v-for lists. */export function renderList ( val: any, render: ( val: any, keyOrIndex: string | number, index?: number ) =&gt; VNode): ?Array&lt;VNode&gt; &#123; let ret: ?Array&lt;VNode&gt;, i, l, keys, key // 如果传递的参数是数组或者是字符串，那么生成的新数组的元素为数组元素或是字符串中的每个字符 if (Array.isArray(val) || typeof val === 'string') &#123; ret = new Array(val.length) for (i = 0, l = val.length; i &lt; l; i++) &#123; ret[i] = render(val[i], i) &#125; &#125; else if (typeof val === 'number') &#123; // 如果传递的参数是number，那么生成一个数组，数组元素为1到该number的值 ret = new Array(val) for (i = 0; i &lt; val; i++) &#123; ret[i] = render(i + 1, i) &#125; &#125; else if (isObject(val)) &#123; // 传递的参数为对象类型，需要进行进一步的判断 // 如果传递的对象可迭代，即具有Symbol.iterator生成器方法 if (hasSymbol &amp;&amp; val[Symbol.iterator]) &#123; ret = [] const iterator: Iterator&lt;any&gt; = val[Symbol.iterator]() let result = iterator.next() while (!result.done) &#123; ret.push(render(result.value, ret.length)) result = iterator.next() &#125; &#125; else &#123; // 该对象为不可迭代对象，一般为用户自定义对象，那么使用object.keys遍历它（因此，如果对象中有不可枚举属性，则该属性值无法得到） keys = Object.keys(val) ret = new Array(keys.length) for (i = 0, l = keys.length; i &lt; l; i++) &#123; key = keys[i] ret[i] = render(val[key], key, i) &#125; &#125; &#125; if (!isDef(ret)) &#123; ret = [] &#125; (ret: any)._isVList = true return ret&#125; 读完上面这段源码后，可以做个总结：无论我们传递什么类型的数据给v-if，vue层面会将该数据进行转化得到一个数组再进行列表渲染。 分类来说： 如果为string，那么会得到一个字符数组 如果为number，那么数组将会是[1,2,3…,number]; 如果为数组，那么以该数组建立新数组 如果为对象，又要分两类 如果为可迭代对象（集合对象：数组，Map，Set，字符等其他有Symbol.iterator生成器方法的对象）那么将迭代的值存入新数组 如果为不可迭代对象，那么使用Object.keys()方法将得到的属性值存入新数组；因此，不会包括不可枚举属性的属性值 数组和对象更新时需要注意的地方我们知道，在进行数据双向绑定的时候。vue会将data中的每个属性和子属性使用Object.defineProperty变为访问器属性。当我们修改这些属性的属性值时，就会触发setter函数，从而引起视图变化。 但是，这个Object.defineProperty方法只能对具有属性的对象使用，那么vue是怎么做到对数组的监听呢？ 这里只给出总体代码： 12345678/** * Observe a list of Array items. */observeArray (items: Array&lt;any&gt;) &#123; for (let i = 0, l = items.length; i &lt; l; i++) &#123; observe(items[i]) // observe 功能为监测数据的变化 &#125;&#125; 具体的，之后再深入的过程中会做出更加详细的解释s 然而，我们要注意，这个数据双向绑定的过程是发生在vue生命周期的挂载节点之后的。也就是说，当vue实例完全初始化完毕进入运行状态后，我们进行以下的操作将不会使数据进行响应： 对于数组： 当你利用索引直接设置一个数组项时，例如：vm.items[indexOfItem] = newValue 当你修改数组的长度时，例如：vm.items.length = newLength 对于对象： 添加对象属性 删除对象属性 对于以上的情况，我们都可以使用vm.$set来解决 Vue为DOM元素设置和获取自定义属性在html5中，我们使用 data-* 属性来嵌入自定义数据： data-* 属性赋予我们在所有 HTML 元素上嵌入自定义 data 属性的能力。 需要注意的是： 属性名不应该包含任何大写字母，并且在前缀 “data-“ 之后必须有至少一个字符 例如： 1&lt;a data-v='1'&gt;hello&lt;/a&gt; 因此，为了遵循这一规范，我们在Vue中为一个DOM元素添加自定义属性时，也应当这样写： 1&lt;a :data-v="value"&gt;&#123;&#123;value&#125;&#125;&lt;/a&gt; 然后，我们可以通过element.getAttribute()来获取元素 12let a = document.getElementsByTagName('a')[0];console.log(a.getAttribute('data-v')); 但是，Vue并不推荐我们直接来操纵DOM，因此，我们可以使用Vue的ref属性来进行DOM元素的引用，引用的信息将会被注册在$refs对象上 因此，我们可以做出如下的修改： 1&lt;a :data-v="value" ref="aLink"&gt;&#123;&#123;value&#125;&#125;&lt;/a&gt; 此时，该a标签DOM元素将会作为aLink的键值在$refs对象中被注册 12345678910// 数据对象data: &#123; value: 123&#125;// 在Vue组件的某个方法中getDataV() &#123; console.log(this.$refs); // &#123;aLink: a&#125; console.log(this.$refs.aLink.getAttribute('data-v')); // 123&#125; 为指令设置动态参数我们知道，Vue允许在指令后添加参数。例如，在v-bind指令后添加参数就可以将该参数作为DOM元素的属性 例如： 1&lt;a :value="value" ref="aLink"&gt;&lt;/a&gt; 我们通过控制台查看该DOM元素就可以得到如下结果： 1&lt;a value="123346"&gt;value&lt;/a&gt; 初次之外，Vue可以支持使用类似方括号的语法（但是方括号中只能填写Vue实例中data声明的变量）来为指令设置动态参数 例如： 123&lt;div id="app"&gt; &lt;a :[attributeName]="url"&gt;&#123;&#123;value&#125;&#125;&lt;/a&gt;&lt;/div&gt; 然后，我们在Vue实例中这样设置： 12345678new Vue(&#123; el: '#app', data: &#123; attributeName: 'href', url: 'https://www.baidu.com', value: 'baidu' &#125;&#125;) 然后，我们在控制台进行查看，就可以得到如下的结果： 1&lt;a&gt;baidu&lt;/a&gt; 令人意外的是，得到的结果并不是预料中的如下的结果： 1&lt;a href="https://www.baidu.com"&gt;baidu&lt;/a&gt; 然后我查看官方文档才发现了原因所在： 其实，Vue对于动态参数表达式是有限制的： 空格和引号在表达式中是无效的 避免使用大写字符来命名键名，因为浏览器会把 attribute（属性） 名全部强制转为小写 因此，我们需要将之前的模板和Vue实例进行修改： 123&lt;div id="app"&gt; &lt;a :[attribute]="url"&gt;&#123;&#123;value&#125;&#125;&lt;/a&gt;&lt;/div&gt; 12345678new Vue(&#123; el: '#app', data: &#123; attribute: 'href', url: 'https://www.baidu.com', value: 'baidu' &#125;&#125;) 此时，我们就可以查看到正确的DOM元素了 1&lt;a href="https://www.baidu.com"&gt;baidu&lt;/a&gt; Vue的常用修饰符修饰符 (modifier) 是以半角句号 . 指明的特殊后缀，用于指出一个指令应该以特殊方式绑定。 在进行详细的事件处理修饰符的说明前，我们先来了解target.addEventListener方法的详细说明，因为，下面的修饰符大多数针对该方法进行简写而已 addEventListener的详细说明完整的addEventListener的方法定义如下： target .addEventListener（type，listener [，options ]）; 参数说明： type: 区分大小写的字符串，表示要侦听的事件类型。 listener: Event当指定类型的事件发生时，接收通知的对象（实现接口的对象）。这必须是实现EventListener接口的对象或JavaScript 函数 options: 可选，一个选项对象，可以包括以下几个选项： capture true表示在捕获阶段执行事件处理程序，false表示在冒泡阶段 once Boolean，listener应在添加后最多调用一次。如果为true，则listener在调用时会自动将其删除。 passive: Boolean 如果true表示表示所指定的函数listener将永远不会调用preventDefault()。如果被动侦听器确实进行了调用preventDefault()，则用户代理将不执行任何操作，只生成控制台警告。 v-on事件处理的修饰符Vue的官方文档是这样叙述为什么要使用数件处理修饰符的： 在事件处理程序中调用 event.preventDefault() 或 event.stopPropagation() 是非常常见的需求。尽管我们可以在方法中轻松实现这点，但更好的方式是：方法只有纯粹的数据逻辑，而不是去处理 DOM 事件细节。 因此，Vue为v-on提供了事件处理修饰符 .stop修饰符 相当于调用event.stopPropagation()该.stop修饰符可以阻止事件流进一步的传递（捕获或者冒泡） 以下以阻止事件进一步冒泡为例进行说明： 没有使用.stop修饰符123&lt;div id="app" style="border: 1px solid black;width: 100px;height: 100px;"&gt; &lt;p :[attribute]="url" @click="clickP"&gt;&#123;&#123;value&#125;&#125;&lt;/p&gt;&lt;/div&gt; 我们分别为div元素和p元素设置一个方法用来监听click事件: 1234567891011121314151617181920let vm = new Vue(&#123; el: '#app', data: &#123; attribute: 'href', url: 'https://www.baidu.com', value: 'baidu' &#125;, methods: &#123; // p元素的事件监听程序 clickP() &#123; console.log('p is clicked'); &#125; &#125;, // 在挂载节点完毕后的生命周期阶段添加div元素的事件监听程序 mounted() &#123; this.$el.addEventListener('click',()=&gt;&#123; console.log('app is clicked'); &#125;) &#125;&#125;) 当我们单击p元素的时候可以得到以下的输出结果： 1234/* 输出结果p is clickedapp is clicked*/ 我们知道DOM事件流会经过以下三个阶段： 捕获阶段 处于事件目标阶段 冒泡阶段 在这里提一句，如果在v-on后没有添加.capture修饰符，那么该事件会在冒泡阶段发生（相当于addEventListener方法的第二个参数为false） 因此，当我们单击p元素时，会经过以下步骤： 在捕获阶段，没有绑定若任何处理程序，因此没有任何响应 处于目标阶段，因为我们单击的是p元素，因此，响应p元素绑定的事件监听程序，输出’p is clicked’ 处于冒泡阶段，此时div元素绑定的click事件监听程序被响应，因此，输出’app is clicked’ 那么，如果使用.stop修饰符呢？ 使用.stop修饰符我们将html代码修改，js代码保持不变： 123&lt;div id="app" style="border: 1px solid black;width: 100px;height: 100px;"&gt; &lt;p :[attribute]="url" @click.stop="clickP"&gt;&#123;&#123;value&#125;&#125;&lt;/p&gt;&lt;/div&gt; 此时，当我们单击p元素的时候，就会得到以下的输出结果： 123/* 输出结果p is clicked*/ 我们看到’app is clicked’并没有输出，这是因为修饰符.stop起到了stopPropagation的作用，阻止了事件流的进一步传递 .prevent修饰符 相当于调用 event.preventDefault()我们知道preventDefault方法可以取消事件的默认行为。因此，.prevent修饰符也是起到同样的作用 例如： 1&lt;a href ="https://www.baidu.com" @click.prevent="clickA"&gt;clickA&lt;/a&gt; 本来，当我们点击a标签的时候，默认将会跳转到href给定的地址。但是，当我们使用.prevent修饰符后就可以取消跳转这一默认行为 .capture修饰符 添加事件监听器时使用捕获模式之前就提到过这一修饰符的作用，.capture修饰符可以让事件在捕获阶段被调用，而不是默认在冒泡阶段被调用 例如： 注意，此时我将带修饰符的事件处理程序绑定在了div元素，而p元素的事件处理程序没有带修饰符 123&lt;div id="app" @click.capture="clickDiv" style="border: 1px solid black;width: 100px;height: 100px;"&gt; &lt;p @click="clickP"&gt;&#123;&#123;value&#125;&#125;&lt;/p&gt;&lt;/div&gt; 1234567891011121314let vm = new Vue(&#123; el: '#app', data: &#123; value: 'click it' &#125;, methods: &#123; clickP() &#123; console.log('p is clicked'); &#125;, clickDiv() &#123; console.log('div is clicked'); &#125; &#125;&#125;) 现在，当我们点击p元素时可以得到如下输出结果： 1234/* 输出结果div is clickedp is clicked*/ 的确，div元素绑定的事件处理程序在事件流的捕获阶段被触发了。 那么，如果我们不添加.capture修饰符，那么点击p元素得到的输出结果就会是： 1234/* 输出结果p is clickeddiv is clicked*/ 这样，div事件处理程序就会默认在事件流的冒泡阶段被执行 .self修饰符 相当于事件自身触发的而不是从内部元素触发的.self修饰符的作用是：只有当事件是自身元素触发的而不是该元素内部元素触发的才会被执行相应的事件处理程序 示例： 123&lt;div id="app" @click.self="clickDiv" style="border: 1px solid black;width: 100px;height: 100px;"&gt; &lt;p @click="clickP"&gt;&#123;&#123;value&#125;&#125;&lt;/p&gt;&lt;/div&gt; 1234567891011121314let vm = new Vue(&#123; el: '#app', data: &#123; value: 'click it' &#125;, methods: &#123; clickP() &#123; console.log('p is clicked'); &#125;, clickDiv() &#123; console.log('div is clicked'); &#125; &#125;&#125;) 现在，当我们点击p元素时的输出结果会得到以下的输出结果： 123/* 输出结果p is cliked*/ 我们看到div元素的事件处理程序没有被触发。因为,.self修饰符让该元素的事件处理程序只有在该元素自身触发事件才可以被执行 但是，如果我们将div元素的.self修饰符去掉 123&lt;div id="app" @click="clickDiv" style="border: 1px solid black;width: 100px;height: 100px;"&gt; &lt;p @click="clickP"&gt;&#123;&#123;value&#125;&#125;&lt;/p&gt;&lt;/div&gt; 那么，当我们点击p元素的输出结果就会是这样的: 1234/* 输出结果p is clickeddiv is clicked*/ 此时，div的事件处理程序就会在事件流的冒泡阶段而被触发 .once修饰符 点击事件将只会被触发一次.once修饰符只允许事件监听程序只会被执行一次，无论你多少次触发该事件 例如： 123&lt;div id="app" @click="clickDiv" style="border: 1px solid black;width: 100px;height: 100px;"&gt; &lt;p @click.once="clickP"&gt;&#123;&#123;value&#125;&#125;&lt;/p&gt;&lt;/div&gt; 事件处理程序的定义还是如下，不做任何改变 那么，当我们第一次点击p元素的时候会得到如下的输出结果： 1234/* 输出结果p is clickeddiv is clicked*/ 那么，当我们第二次再点击该p元素，此时输出结果就变成这样了： 123/* 输出结果div is clicked*/ 我们可以看到，p元素的事件处理程序没有再执行。这可以用来实现防抖的效果。 .passive修饰符该.passive修饰符对应addEventListener中的passive选项，当我们使用该.passive修饰符时，也就是默认将addEventListener的passive选项设置为true。 那么，这也意味着： 所指定的函数listener将永远不会调用preventDefault()。 简而言之，该.passive修饰符的作用是不要阻止事件的默认行为。那么，如果我们将.passive 和 .prevent 一起使用，那么.prevent 将会被忽略。 .passcive修饰符对于移动端性能的提升在移动端，我们经常要使用触摸滚动的事件，那么使用passive修饰符将会大幅提升移动端的性能 1&lt;div v-on:scroll.passive="onScroll"&gt;...&lt;/div&gt; 那么，这是为什么呢？ MDN文档是这样做出解释的： 根据规范，passive 选项的默认值始终为false。但是，这引入了处理某些触摸事件（以及其他）的事件监听器在尝试处理滚动时阻止浏览器的主线程的可能性，从而导致滚动处理期间性能可能大大降低。 v-model表单输入绑定的修饰符.lazy修饰符我们知道在默认情况下，v-model使用监听oninput事件来使得数据保持同步。此时，只要我们在输入数据时该事件就会被触发 但是，当我们使用.lazy修饰符，v-model就会转而去监听onchange事件，而不是oninput事件。这意味着，只有当表单的value值发生了改变，并且该表单失去焦点时才会触发 例如： 12&lt;input v-model.lazy="value" /&gt;&lt;p&gt;&#123;&#123;value&#125;&#125;&lt;/p&gt; 此时，当我们输入数据时，p元素中的value值不会立即更新。只有当input输入框失去焦点后，value值才会更新 .trim修饰符如果要自动过滤用户输入的首尾空白字符，可以给 v-model 添加 trim 修饰符 1&lt;input v-model.trim="msg"&gt; 计算属性和侦听器计算属性什么是计算属性我们知道，可以在模板语法中写入表达式： 1&lt;a&gt;&#123;&#123;value.split('').reverse().join('')&#125;&#125;&lt;/a&gt; 但是，为了模板的可读性，Vue提供了可计算属性来代替这种在模板中插入复杂的表达式计算 12345computed: &#123; reverseValue: function() &#123; return this.value.split('').reverse().join(''); &#125;&#125; 如果，我们试着在某个阶段输出一下Vue实例，我们可以看到computed对象中的计算属性的值是直接被添加到vue实例的属性中的 因此，它可以直接被作为模板语法直接进行插入 计算属性的getter和setter其实，计算属性就是一个访问器属性。虽然，在computed对象中，我们声明的计算属性目前只是一个函数（此时计算属性默认只有getter），但其实，我们也可以为计算属性添加setter函数 例如： 12345678910computed: &#123; reverseValue: &#123; get: function () &#123; return this.value.split('').reverse().join(''); &#125;, set: function (value) &#123; this.value = value; &#125; &#125;&#125; 当我学习到这部分的时候，我就产生了疑问。明明这个计算属性应该是访问器属性才对，但是为什么计算属性使用了包含get和set属性的对象写法？还有，之前的默认是getter函数的为什么只需要采用函数写法？ 这一切疑问我们可以从源码中找到答案 这是初始化计算属性的函数 12345678910111213141516171819202122232425262728293031323334353637383940414243function initComputed (vm: Component, computed: Object) &#123; // $flow-disable-line const watchers = vm._computedWatchers = Object.create(null) // computed properties are just getters during SSR const isSSR = isServerRendering() // 遍历所有computed对象中声明的计算属性 for (const key in computed) &#123; const userDef = computed[key] // 如果属性值为函数，那么将该函数赋值给getter；如果属性值为对象，那么将对象的get属性值赋值给getter const getter = typeof userDef === 'function' ? userDef : userDef.get if (process.env.NODE_ENV !== 'production' &amp;&amp; getter == null) &#123; warn( `Getter is missing for computed property "$&#123;key&#125;".`, vm ) &#125; if (!isSSR) &#123; // create internal watcher for the computed property. watchers[key] = new Watcher( vm, getter || noop, noop, computedWatcherOptions ) &#125; // component-defined computed properties are already defined on the // component prototype. We only need to define computed properties defined // at instantiation here. if (!(key in vm)) &#123; // 将该计算属性添加到vm实例上 defineComputed(vm, key, userDef) &#125; else if (process.env.NODE_ENV !== 'production') &#123; if (key in vm.$data) &#123; warn(`The computed property "$&#123;key&#125;" is already defined in data.`, vm) &#125; else if (vm.$options.props &amp;&amp; key in vm.$options.props) &#123; warn(`The computed property "$&#123;key&#125;" is already defined as a prop.`, vm) &#125; &#125; &#125;&#125; 我们找到对应的defineComputed方法 12345678910111213141516171819202122232425262728293031function defineComputed ( target: any, key: string, userDef: Object | Function) &#123; const shouldCache = !isServerRendering() if (typeof userDef === 'function') &#123; sharedPropertyDefinition.get = shouldCache ? createComputedGetter(key) : createGetterInvoker(userDef) sharedPropertyDefinition.set = noop &#125; else &#123; sharedPropertyDefinition.get = userDef.get ? shouldCache &amp;&amp; userDef.cache !== false ? createComputedGetter(key) : createGetterInvoker(userDef.get) : noop sharedPropertyDefinition.set = userDef.set || noop &#125; if (process.env.NODE_ENV !== 'production' &amp;&amp; sharedPropertyDefinition.set === noop) &#123; sharedPropertyDefinition.set = function () &#123; warn( `Computed property "$&#123;key&#125;" was assigned to but it has no setter.`, this ) &#125; &#125; // 在这里将计算属性添加到vm实例上，并且该属性正式成为了访问器属性 Object.defineProperty(target, key, sharedPropertyDefinition)&#125; 看完了这两段源码，之前的困惑就应该消除了。 如果，我们将计算属性写成函数的形式，那么就将该函数作为该属性的getter方法； 如果，我们将计算属性写成对象的形式，那么就将对象中的get属性值和set属性值作为计算属性的getter方法和setter方法 计算属性缓存和方法以下是源码中的初始化方法的函数 123456789101112131415161718192021222324252627function initMethods (vm: Component, methods: Object) &#123; const props = vm.$options.props for (const key in methods) &#123; if (process.env.NODE_ENV !== 'production') &#123; if (typeof methods[key] !== 'function') &#123; warn( `Method "$&#123;key&#125;" has type "$&#123;typeof methods[key]&#125;" in the component definition. ` + `Did you reference the function correctly?`, vm ) &#125; if (props &amp;&amp; hasOwn(props, key)) &#123; warn( `Method "$&#123;key&#125;" has already been defined as a prop.`, vm ) &#125; if ((key in vm) &amp;&amp; isReserved(key)) &#123; warn( `Method "$&#123;key&#125;" conflicts with an existing Vue instance method. ` + `Avoid defining component methods that start with _ or $.` ) &#125; &#125; vm[key] = typeof methods[key] !== 'function' ? noop : bind(methods[key], vm) &#125;&#125; 粗略看一眼我们就可以看到，vm实例中的methods对象中的属性都是直接添加到vm实例的属性上的。 这也就意味着，我们在模板语法中也可以直接使用methods中的方法 例如： 1&lt;button @click="change"&gt;&#123;&#123;getValue()&#125;&#125;&lt;/button&gt; 那么，对于之前的计算属性的写法，我们又可以直接将逻辑写在methods的方法中了 原来的复杂逻辑直接作为表达式插入模板中 1&lt;a&gt;&#123;&#123;value.split('').reverse().join('')&#125;&#125;&lt;/a&gt; 使用计算属性 1&lt;a&gt;&#123;&#123;reverseValue&#125;&#125;&lt;/a&gt; 现在，我们使用方法： 1&lt;a&gt;&#123;&#123;reverseValue()&#125;&#125;&lt;/a&gt; 12345methods: &#123; reverseValue() &#123; return this.value.split('').reverse().join(''); &#125;&#125; 对了，计算属性的属性名不能与方法中的方法名同名，不然，计算属性就会无效。原因在于，计算属性和方法都会作为属性被添加到vm实例中去，那么总不能同名吧。具体，看上面的两个初始化函数。 来看个总体的例子： 12345&lt;div id="app"&gt; &lt;p&gt;&#123;&#123;value&#125;&#125;&lt;/p&gt; &lt;p&gt;&#123;&#123;reverseValue&#125;&#125;&lt;/p&gt; &lt;p&gt;&#123;&#123;reverse()&#125;&#125;&lt;/p&gt;&lt;/div&gt; 12345678910111213141516new Vue(&#123; el: '#app', data: &#123; value: 'abc' &#125;, methods: &#123; reverse() &#123; return this.value.split('').reverse().join(''); &#125; &#125;, computed: &#123; reverseValue() &#123; return this.value.split('').reverse().join(''); &#125; &#125;&#125;) 渲染结果： 计算属性与方法的区别那么，这两种写法有什么区别呢？ 官方文档是这样解释的： 计算属性是基于它们的响应式依赖进行缓存的。只在相关响应式依赖发生改变时它们才会重新求值 也就是说，如果计算属性的getter函数中所依赖的值是响应式数据（上文中的value），那么只有当value值更新时，该计算属性才会更新。 但是，对于方法呢？只要DOM树重新渲染，这个方法就会被重新执行。我们知道，在vue的生命周期中，只要响应式数据发生了update，那么虚拟DOM就会被重建，挂载的那一部分就会被重新渲染 我们可以用一个例子来说明以上的结论 123456&lt;div id="app"&gt; &lt;p&gt;&#123;&#123;value&#125;&#125;&lt;/p&gt; &lt;p&gt;&#123;&#123;dateNow&#125;&#125;&lt;/p&gt; &lt;p&gt;&#123;&#123;getDateNow()&#125;&#125;&lt;/p&gt; &lt;button @click="changeValue"&gt;change value&lt;/button&gt;&lt;/div&gt; 12345678910111213141516171819new Vue(&#123; el: '#app', data: &#123; value: 123 &#125;, methods: &#123; getDateNow() &#123; return Date.now(); &#125;, changeValue() &#123; this.value = 321; &#125; &#125;, computed: &#123; dateNow() &#123; return Date.now(); &#125; &#125;&#125;) 此时，渲染结果会如下gif 我们可以看到，当我们改变value值的时候，计算属性的值并没有改变，而方法所得到的的值发生了改变。 因为，计算属性的值依赖于响应式数据的变化，但是，上述代码中的计算属性的getter函数中并没有响应式数据，因此，就算该组件因为数据变化而重新渲染，计算属性的值也没有发生变化 但是，模板中的方法只要组件被重新渲染，就会被重新执行，因此，得到的值也就发生了变化 侦听器Vue提供了侦听器用来响应数据的变化。 在vm实例中，我们可以用watch选项来侦听数据的变化，并作出响应 例如： 1234567891011new Vue(&#123; el: '#app', data: &#123; value: 123 &#125;, watch: &#123; value: function(newVal,oldVal) &#123; console.log(newVal,oldVal); &#125; &#125;&#125;) class与style绑定class绑定因为，class属性属于元素上的一个特性，那么，我们可以使用v-bind语法进行绑定 表达式结果为字符串的绑定因为，v-bind中需要的是一个表达式，因此，我们只需要计算出表达式的字符串结果即可 单变量绑定假如v-bind表达式中只有一个变量，那么，我们可以这样写： 123456789&lt;style&gt;.red &#123; color: red&#125;&lt;/style&gt;&lt;div id="app"&gt; &lt;p :class="className"&gt;&#123;&#123;value&#125;&#125;&lt;/p&gt;&lt;/div&gt; 123456789new Vue(&#123; el: "#app", data: &#123; value: &#123; value: 123, className: 'red' &#125; &#125;&#125;) 变量与字符串进行拼接因为表达式的值必须为字符串，那么当拼接的时候就要求必须至少有一方为字符串类型 例如： 123456789&lt;style&gt;.red-item &#123; color: red&#125;&lt;/style&gt;&lt;div id="app"&gt; &lt;p :class="className+'-item'"&gt;&#123;&#123;value&#125;&#125;&lt;/p&gt;&lt;/div&gt; 123456789new Vue(&#123; el: "#app", data: &#123; value: &#123; value: 123, className: 'red' &#125; &#125;&#125;) 表达式结果为对象的绑定我们可以为v-bind传入一个对象来作为表达式的结果以动态切换class的值 例如： 1&lt;p :class="&#123;['red-item']:true&#125;"&gt;&#123;&#123;value&#125;&#125;&lt;/p&gt; 另外，为了更加清晰的模板效果，我们可以将对象放在实例的data中 1&lt;p :class="classObj"&gt;&#123;&#123;value&#125;&#125;&lt;/p&gt; 123456789new Vue(&#123; el: '#app', data: &#123; value: 123, classObj: &#123; ['red-item']: true &#125; &#125;&#125;) 当然，作为计算属性也可： 12345678910111213new Vue(&#123; el: '#app', data: &#123; value: 123 &#125;, computed: &#123; classObj() &#123; return &#123; ['red-item']: true &#125; &#125; &#125;&#125;) 表达式结果为数组的绑定Vue还允许我们使用数组来对class进行绑定，数组的结果就是class列表 例如： 1&lt;p :class="['red-item']"&gt;&lt;/p&gt; 当然，我们可以在数组项中加入对象 例如： 1&lt;p :class="[classObj]"&gt;&lt;/p&gt; 此时classObj对象作为vm实例的data属性和计算属性都可以 style绑定当然，对于style我们也可以进行如上以数组和对象的表达式结果的绑定 对象绑定对于对象绑定，我们可以这样写 12&lt;style&gt;&lt;p :style="&#123;color: 'red',['font-size']: 15+'px'&#125;"&gt;&#123;&#123;value&#125;&#125;&lt;/p&gt; 因为，在Js中变量不能包含’-‘连字符，因此，我们需要使用方括号语法进行转换[‘font-size’] 数组绑定v-bind:style 的数组语法可以将多个样式对象应用到同一个元素上 如果对:style进行数组语法的绑定，那么数组元素必须为对象 例如： 1:style="[&#123;color: 'red'&#125;,&#123;['font-size']: 20+'px',['font-weight']: 'bolder'&#125;]"]]></content>
      <categories>
        <category>Vue</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Vue的生命周期理解]]></title>
    <url>AngelLikeFairy%2F2019%2F11%2F10%2FVue%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E7%90%86%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[Vue的生命周期概述每个Vue实例的生命周期大致如下：创建实例，初始化数据，模板编译，挂载DOM，，更新数据然后视图重新渲染，实例销毁等一系列过程 各个生命周期的具体作用在Vue实例的生命周期中，Vue提供了一系列相关的生命周期钩子的函数用来帮助开发者在Vue的不同生命周期阶段来添加适当的代码 以下是一张Vue官方文档中的生命周期示意图 我们来详细理解以下这张生命周期示意图 new Vue()阶段 创建Vue实例，这一步也就是调用Vue构造函数 1var vm = new Vue(&#123;&#125;); 初始化了一个空的Vue实例，此时该Vue实例对象上只有默认的一些生命周期函数和默认事件。 在这里有一个beforeCreate()生命周期钩子，但是在该钩子函数里我们还无法访问到data以及methods里的方法，当然更无法访问el 123beforeCreate() &#123; console.log(this.$data,this.$el); // undefined undefined&#125; 数据初始化完毕，此时data和methods可以被访问了 在该阶段有一个created()的钩子可以供我们调用，此时在该钩子函数中我们可以访问到data和methods内的属性了，但是此时仍然无法访问到el。因此，我们也可以看到该钩子函数是我们在所有钩子函数中最早能够访问到data和methods的阶段 Vue开始进行模板编译 当模板编译完毕后，Vue在这里提供了一个beforeMount()的生命周期钩子函数，此时render函数将开始被调用，在这个钩子里，我们已经可以访问到el属性了 123beforeMount() &#123; console.log(this.$el);&#125; // &lt;div id="app"&gt;...&lt;/div&gt; 但是，在此阶段模板仅仅只是被编译好，而没有真正地替换到页面中去，我们点击上面的this.$el的输出结果可以发现： 1234&lt;div id="app"&gt; &lt;input v-model="value" /&gt; &lt;p&gt;&#123;&#123;value&#125;&#125;&lt;/p&gt;&lt;/div&gt; 我们可以看到此时的输出的要挂载的节点内容并没有被真实地替换掉，模板语法仍旧存在 将编译好的模板真实地替换到页面中去，此时我们在mounted()钩子中就可以看到真实被渲染完毕的el 12345678910mounted() &#123; console.log(this.$el);&#125;/* 输出结果&lt;div&gt; &lt;input /&gt; &lt;p&gt;123&lt;/p&gt;&lt;/div&gt;*/ 此时，Vue实例已经被初始化完毕了，之后就是实例的运行阶段。 此时，在Vue组件运行阶段我们可能会要更新数据，当更新数据的时候，beforeUpdate钩子就会被调用，此时，data中的数据是最新的，但是还没有更新到视图中 虚拟DOM树重新渲染，然后更新到视图中 更行完毕后,updated钩子会被调用，此时数据与视图已经是同步的了 当vm.$destroy()实例销毁函数显式被调用时，便会触发触发 beforeDestroy 和 destroyed 的钩子。 在实例销毁之前我们可以调用beforeDestroy钩子，此时实例并没有被销毁，该组件所有的功能都还是可用的 destroyed()调用时，此时实例已经被销毁完毕了，该组件的所有功能都不再可用 各个生命周期适合开发者适合做的操作异步操作应该在哪个生命周期阶段进行首先我们需要确认异步操作会不会阻塞Vue的整个生命周期的进行 我们可以使用宏任务setTimeout并且不设置过时时间来模拟异步操作的进行并修改data中的数据，具体实现如下： 1234567891011121314151617181920212223242526272829303132// 确定脚本开始运行的时间let start = Date.now();let vm = new Vue(&#123; el: '#app', data: &#123; value: 123 &#125;, created() &#123; console.log(`created time $&#123;Date.now()-start&#125;s`); // 没有设置宏任务setTimeout的过时时间 setTimeout(()=&gt;&#123; console.log(`$&#123;Date.now()-start&#125;s change the value to 321`); this.value = 321; &#125;) &#125;, mounted() &#123; console.log(`mounted time $&#123;Date.now()-start&#125;s`); &#125;, updated() &#123; console.log(`$&#123;Date.now()-start&#125;s updated the value to $&#123;this.value&#125;`); &#125;&#125;)/* 输出结果created time 2smounted time 29s140s change the value to 321141s start updating the value to 321143s updated the value to 321*/ 我们可以看到宏任务setTimeout在Vue实例完全初始化后，也就是mounted阶段后才会开始运行。因此，对于异步请求数据操作也只会在Vue实例初始化完毕后（mounted阶段后）才会进行，之后的数据修改或赋值就会直接触发beforeUpdate以及后续进行的updated钩子 通过以上的输出结果，我们可以得出一个结论： 异步操作并不会阻塞Vue初始化生命周期的进行。 因此，我们将异步操作放在created，beforeMount，mounted这三个钩子里都是OK的。因为这三个阶段data数据都已经被初始化好了，我们可以在异步操作的回调中对data中的数据进行修改或赋值了 但是，为了减少用户的等待时间，我们最好在created阶段进行异步操作。因为异步任务都会被放入event table中进行，越早声明也就代表着被运行的时间越早，因此也就越有可能会在异步回调中的任务队列优先被执行回调 DOM访问操作应该在哪个生命周期阶段进行只有在Vue实例挂在到DOM节点时，我们才可以去访问和操作DOM，因此，DOM访问操作应该在mounted阶段进行]]></content>
      <categories>
        <category>Vue</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[MVVM模式的理解以及双向数据绑定]]></title>
    <url>AngelLikeFairy%2F2019%2F11%2F09%2FMVVM%E6%A8%A1%E5%BC%8F%E7%9A%84%E7%90%86%E8%A7%A3%E4%BB%A5%E5%8F%8A%E5%8F%8C%E5%90%91%E6%95%B0%E6%8D%AE%E7%BB%91%E5%AE%9A%2F</url>
    <content type="text"><![CDATA[MVVM什么是MVVMMVVM是一种软件架构设计模式，其由以下三个方面组成： Model: 对应MVVM中的第一个M，表示数据模型层，包括自定义数据以及后端给定的api接口数据 View: 对应MVVM中的第一个V，表示视图层，也就是我们常说的用户界面，这一层使用html+css来进行构建 ViewModel: 对应MVVM中的VM，表示视图数据层。这一层也是MVVM设计模式的核心。该层作为桥梁用来沟通View视图层和Model数据模型层。我们在该层对Model层给的数据进行数据上和业务上的处理，然后通过双向数据绑定，使得View视图层实时更新视图 双向数据绑定什么数据双向绑定对于MVVM设计模式来说，数据绑定是指当数据变化时试图会进行更新，当视图变化时数据会进行相应更新 双向数据绑定的原理对于View视图层变化更新数据，一般可以通过事件监听的方式 例如：vue中的指令v-model就可以监听表单的输入事件来更新相应的数据 先看下vue中实现的例子： 1234&lt;div id="app"&gt; &lt;input v-model="value" /&gt; &lt;p&gt;&#123;&#123;value&#125;&#125;&lt;/p&gt;&lt;/div&gt; 123456var app = new Vue(&#123; el: &apos;#app&apos;, data: &#123; value: &apos;&apos; &#125;&#125;) 当我们在input表单中输入数据的时候，value值也会进行相应的更新 实现效果如下： 利用事件监听机制来实现视图变动来更新数据对于v-model指令在表单中输入数据可以进行相应数据的更新，我们可以利用事件监听机制来进行实现 12345&lt;div id="app"&gt; /*绑定一个changeData事件，用于当进行表单输入操作时进行数据的更新*/ &lt;input type="text" value="" id="input" @click="changeData" /&gt; &lt;p&gt;&#123;&#123;value&#125;&#125;&lt;/p&gt;&lt;/div&gt; input输入框有一个oninput方法可以用来监听输入框中的value值是否有变化 12345678910111213141516var app = new Vue(&#123; el: '#app', data: &#123; value: '' &#125;, methods: &#123; changeData() &#123; let input = document.getElementById('input'); // 如果value值发生了变化，那么就将该value赋值给vue实例data中的value属性 input.addEventListener('input',(e)=&gt;&#123; // e.target指向事件绑定的元素，也就是input元素，然后再获取到该元素的value值 this.value = e.target.value; &#125;) &#125; &#125;&#125;) 发布订阅模式来解决数据的更新引起视图的更新以下是一张来自vue官方的数据双向绑定的原理图 对于Vue中的数据双向绑定的实现，主要通过以下四个步骤来实现 实现一个监听器 Observer：对数据对象进行遍历，包括子属性对象的属性，利用 Object.defineProperty() 对属性都加上访问器属性 setter 和 getter。这样的话，监听器就可以对数据进行劫持，当我们给这个对象的某个值赋值，就会触发 setter，从而监听到数据的变化。 实现一个解析器 Compile：解析 Vue 模板指令，将模板中的变量都替换成数据，然后初始化渲染页面视图，并将每个指令对应的节点绑定更新函数，添加监听数据的订阅者，一旦数据有变动，收到通知，调用更新函数进行数据更新。 实现一个订阅者 Watcher：Watcher 订阅者是 Observer 和 Compile 之间通信的桥梁 ，主要的任务是订阅 Observer 中的属性值变化的消息，当收到属性值变化的消息时，触发解析器 Compile 中对应的更新函数。 实现一个订阅器 Dep：订阅器采用 发布-订阅 设计模式，用来收集订阅者 Watcher，对监听器 Observer 和 订阅者 Watcher 进行统一管理。 大致流程图如下： 接下来我们会一一实现这些步骤 Observer监听器进行事件劫持此过程主要是通过Object.defineProperty将data对象中的所有属性（包括属性是对象类型所有的子属性）具有访问器属性getter和setter 具体实现如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445// 要劫持的数据let data = &#123; item: 1, k: &#123; m: &#123; g: 2 &#125; &#125;&#125;observe(data)console.log(data.item,data.k,data.k.m);data.item = &#123;i:1&#125;;data.k = 2;console.log(data.item,data.k,data.k.m);// observer监听器函数，遍历data对象中的所有属性包括子属性然后调用自定义数据劫持函数setProperty进行数据劫持function observe(obj) &#123; let keys = Object.keys(obj); keys.forEach(v=&gt;&#123; // 如果该属性值是对象，那么进行递归 if(typeof obj[v] === 'object' &amp;&amp; v!==null) &#123; observe(obj[v]); &#125; setProperty(data,v,obj[v]); &#125;)&#125;// 数据劫持函数，使用Object.defineProperty进行劫持// 传入对象，键名，以及键值，并将它们作为对象的私有变量，之后对属性值修改与访问都是在操作该私有变量valfunction setProperty(obj, key, val) &#123; Object.defineProperty(obj, key, &#123; enumerable: true, configurable: true, // 访问器属性get，访问属性时将会调用该函数 get: function() &#123; console.log('get value') return val &#125;, // 访问器属性set，设置属性值时将会调用该函数 set: function(newVal) &#123; console.log('change value') val = newVal &#125; &#125;)&#125; 现在我们已经实现了，当数据变化后我们可以获得通知。接下来我们要去实现订阅器，来更加方便地管理这些变动 Dep订阅器的实现订阅器的主要功能就是收集订阅者的订阅，然后当发布者发布事件后将订阅者的回调进行执行 12345678910111213141516class Dep &#123; constructor() &#123; this.subs = [] &#125; addSub(sub) &#123; // sub 是 Watcher 实例 this.subs.push(sub) &#125; notify() &#123; this.subs.forEach(sub =&gt; &#123; sub.update() &#125;) &#125;&#125;// 全局属性，通过该属性配置 WatcherDep.target = null Watcher订阅者的实现Watcher订阅者的功能就是等待发布者发布之后，订阅器就会统一执行所有订阅者的回调 事实上，data对象中并不是所有的数据都与视图层有关系，因此，当在模板解析的时候，解析到该值时模板语法，那么就会将该属性作为订阅者添加到订阅器中 具体实现如下： 1234567891011121314151617181920212223class Watcher &#123; constructor(obj, key, cb) &#123; // 将 Dep.target 指向自己 // 然后触发属性的 getter 添加监听 // 最后将 Dep.target 置空 Dep.target = this this.cb = cb this.obj = obj this.key = key this.value = obj[key] Dep.target = null &#125; update() &#123; // 获得新值 this.value = this.obj[this.key] // 调用 update 方法更新 Dom this.cb(this.value) &#125;&#125;function update(value) &#123; document.querySelector('div').innerText = value&#125; 最后，我们还需要修改之前的setProperty函数，在属性访问的时候将其作为订阅者添加到订阅器中，将属性值被修改时，将该事件发布，并执行订阅者相应的回调函数 具体实现如下： 123456789101112131415161718192021function setProperty(obj, key, val) &#123; let dp = new Dep() Object.defineProperty(obj, key, &#123; enumerable: true, configurable: true, get: function reactiveGetter() &#123; console.log('get value') // 将 Watcher 添加到订阅 if (Dep.target) &#123; dp.addSub(Dep.target) &#125; return val &#125;, set: function reactiveSetter(newVal) &#123; console.log('change value') val = newVal // 执行 watcher 的 update 方法 dp.notify() &#125; &#125;)&#125;]]></content>
      <categories>
        <category>Vue</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Buffer的理解以及文件上传的应用]]></title>
    <url>AngelLikeFairy%2F2019%2F11%2F05%2FBuffer%E7%9A%84%E7%90%86%E8%A7%A3%E4%BB%A5%E5%8F%8A%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E7%9A%84%E5%BA%94%E7%94%A8%2F</url>
    <content type="text"><![CDATA[Buffer（缓冲区）在Node中，应用需要处理网络协议、操作数据库、处理图片、接收上传的文件等，在网络流和文件的操作中，还要处理大量的二进制数据，而Js自有的字符串远远无法满足这些需求，于是Buffer对象应运而生 Buffer类在全局作用域中，因此，我们无需使用require(‘buffer’).Buffer来进行使用 什么是Buffer（缓冲区）我们知道数据的移动是以流的方式进行的。当我们从文件或网络读取数据的时候，就需要一个输入流来进行数据的读取；而当我们要写入一些数据的时候，就需要开启一个输出流来进行数据的移动。 但是，Node并无法控制数据流的速度以及数据到达目的地的时间。因此，如果数据到达的速度比进程消耗的速度快，那么少数早到达的数据会处于等待区等候被处理。反之，如果数据到达的速度比进程消耗的数据慢，那么早先到达的数据需要在等待区中等待一定量的数据到达之后才能被处理。 这个等待区也就是我们要提的Buffer（缓冲区） Buffer对象Buffer对象类似与一个数组，它的元素为16进制的两位数，即0到255的数值。 我们可以这样来创建Buffer对象 12const buf = Buffer.from('理解Buffer')console.log(buf); // &lt;Buffer e7 90 86 e8 a7 a3 42 75 66 66 65 72&gt; 我们输出一下这个buf对象长度 1console.log(buf.length); // 12 我们可以看到buf对象的长度与给定的字符串长度不一样。因此，我们可以得出不同编码的字符串占用的元素个数各不相同。上面的代码中的中文字在UTF-8的编码下占用3个元素，而字母和半角标点符号占用1个元素。 另外，以下是创建Buffer对象时常用的API： Buffer.from(array) 返回一个新的 Buffer，其中包含提供的八位字节数组的副本。 Buffer.from(arrayBuffer[, byteOffset [, length]]) 返回一个新的 Buffer，它与给定的 ArrayBuffer 共享相同的已分配内存。 Buffer.from(buffer) 返回一个新的 Buffer，其中包含给定 Buffer 的内容的副本。 Buffer.from(string[, encoding]) 返回一个新的 Buffer，其中包含提供的字符串的副本,encoding为给定的string的编码格式。 Buffer.alloc(size[, fill[, encoding]]) 返回一个指定大小的新建的的已初始化的 Buffer。 此方法比 Buffer.allocUnsafe(size) 慢，但能确保新创建的 Buffer 实例永远不会包含可能敏感的旧数据。 如果 size 不是数字，则将会抛出 TypeError。 Buffer.allocUnsafe(size) 和 Buffer.allocUnsafeSlow(size) 分别返回一个指定大小的新建的未初始化的 Buffer。 由于 Buffer 是未初始化的，因此分配的内存片段可能包含敏感的旧数据。 如果 size 小于或等于 Buffer.poolSize 的一半，则 Buffer.allocUnsafe() 返回的 Buffer 实例可能是从共享的内部内存池中分配。 Buffer.allocUnsafeSlow() 返回的实例则从不使用共享的内部内存池。 示例： 1234567// 创建一个给定Array的Buffer，其中Array的元素为10进制整数，它会被转化为16进制的二进制数let buffer = Buffer.from([53,198,255]);console.log(buffer); // &lt;Buffer 35 c6 ff&gt;// 分配一个指定大小的新建的的已初始化的 Buffer，该Buffer永远不会包含旧数据buffer = Buffer.alloc(10);console.log(buffer); // &lt;Buffer 00 00 00 00 00 00 00 00 00 00&gt; Buffer的内存分配我们在V8的垃圾回收机制中了解到，一般的基本类型变量会存储在栈中，而复杂引用类型会存储在v8的堆内存中。 然而，Buffer对象的内存分配不是在v8的堆内存中进行的，而是在Node的C++层面进行内存分配的。 因为处理大量的字节数据不能采用需要一点内存就向系统申请内存的方式（v8的内存管理就采用这种方式，如果堆内存不够就继续申请堆内存直到超过系统限制），这样的话会造成操作系统层面的压力 Node采用slab分配机制来进行Buffer对象的内存分配。 slab是一块申请号的固定大小的内存区域，它的大小为8kb。Node通常也以8Kb为分界来区分小Buffe对象和大Buffer对象 1Buffer.poolSize = 8*1024; 之前提过，我们可以使用Buffer.alloc(size)来分配指定大小的Buffer对象 当size&lt;8*1024时，该Buffer对象为小对象，否则，则是大对象 当在进行slab内存分配的时候，其符合以下的规则： 如果要分配的Buffer内存大小小于slab内存大小，那么在slab中分配内存给Buffer 如果slab剩余空闲内存小于需要分配的Buffer内存大小，那么重新会新建一个slab来分配该Buffer对象的内存 如果Buffer对象为大对象，即需要分配的内存大于8kb，那么，系统将会直接分配一个SlowBuffer对象作为slab单元，这个slab单元将会被该Buffer对象独占 Buffer与字符串的相互转换当字符串存储入一个Buffer实例或者从Buffer实例中提取时，我们可以指定一个字符编码 例如： 123456789// 以utf-8编码将字符串存储入Buffer中let buf = Buffer.from('理解Buffer','utf-8');console.log(buf); // &lt;Buffer e7 90 86 e8 a7 a3 42 75 66 66 65 72&gt;// 以base64编码取出该字符串console.log(buf.toString('base64')); // 55CG6KejQnVmZmVy// 以ascii编码将字符串存入Buffer中buf = Buffer.from('理解Buffer','ascii');console.log(buf); Buffer的拼接直接拼接Buffer时遇到的问题我们知道数据的移动是以流的方式进行的。那么，使用了Buffer作为缓冲区后，我们得到一个流数据就是一段一段的进行获取 现在我们来试着使用读取流来读取一个文件内容： 例如： 12345678910111213141516const fs = require('fs');// 该fs.createReadStream()方法会返回一个新的fs.ReadStream对象，该对象也就是读取流let rs = fs.createReadStream('./a.ja');let data = '';// 当流将数据块传送给消费者后触发data事件rs.on('data',(chunk)=&gt;&#123; data+=chunk;&#125;)// 'end' 事件只有在数据被完全消费掉后才会触发rs.on('end',()=&gt;&#123; console.log(data);&#125;) 此时a.js文件内容如下： 1console.log('hello'); 那么，输出结果如下： 1console.log(&apos;hello&apos;); 我们发现读取似乎没有什么问题。但其实，这是有问题的。上述程序中有一行语句是 1data+=chunk; 我们知道流的读取时，传递的应该是Buffer对象，我们试着输出一下这个chunk 1234rs.on('data',(chunk)=&gt;&#123; console.log(chunk); // &lt;Buffer 63 6f 6e 73 6f 6c 65 2e 6c 6f 67 28 27 68 65 6c 6c 6f 27 29 3b&gt; data+=chunk;&#125;) 的确，这个chunk确实是Buffer对象，那么为什么最后输出的是正确的字符串呢？ 我们知道在字符串拼接的时候，如果有一方不是字符串，那么就会将其转化为字符串之后再进行拼接。因此，那行代码又可以等价为 1data+=chunk.toString(); 这样似乎都可以说的通了，但是如果我们读取的内容不全是英文，而是包括有宽字节的中文呢? 我们将a.js文件内容改为如下 1console.log('你好呀，我很好'); 同时，我们利用highWaterMark属性将缓冲区的大小限制为5。 此时，完整的程序如下： 12345678910111213141516171819202122232425262728const fs = require('fs');// 将每次读取的Buffer长度限制为5let rs = fs.createReadStream('./a.js',&#123;highWaterMark:5&#125;);let data = '';rs.on('data',(chunk)=&gt;&#123; console.log(chunk); data+=chunk;&#125;)rs.on('end',()=&gt;&#123; console.log(data);&#125;)/* 输出结果&lt;Buffer 63 6f 6e 73 6f&gt;&lt;Buffer 6c 65 2e 6c 6f&gt;&lt;Buffer 67 28 27 e4 bd&gt;&lt;Buffer a0 e5 a5 bd e5&gt;&lt;Buffer 91 80 ef bc 8c&gt;&lt;Buffer e6 88 91 e5 be&gt;&lt;Buffer 88 e5 a5 bd 27&gt;&lt;Buffer 29 3b&gt;console.log('��好���，我��好');*/ 我们可以看到，每次的读取Buffer长度的确为5。此时，我们惊奇的发现，文件内容出现了乱码。 这是为什么呢？我们知道，中文字符为宽字节字符，在utf-8模式下，其占3个字节。因此，我们用每次5个字节进行读取时，就会遇到，有些中文字符会被拆分到两次读取中，因此，就会显示出乱码 利用setEncoding来解决readable.setEncoding() 方法为从可读流读取的数据设置字符编码。 默认情况下没有设置字符编码，流数据返回的是 Buffer 对象。 如果设置了字符编码，则流数据返回指定编码的字符串。 例如，调用 readable.setEncoding(‘utf-8’) 会将数据解析为 UTF-8 数据，并返回字符串，调用 readable.setEncoding(‘hex’) 则会将数据编码成十六进制字符串。 因此，我们可以这样修改上述的程序： 1234567891011121314151617181920212223242526272829const fs = require('fs');const rs = fs.createReadStream('./a.js',&#123;highWaterMark:5&#125;);// 设置字符编码，将流Buffer对象转化为字符串rs.setEncoding('utf-8');let data = '';rs.on('data',(chunk)=&gt;&#123; // 此时chunk为字符串形式 console.log(chunk); data+=chunk;&#125;)rs.on('end',()=&gt;&#123; console.log(data);&#125;)/* 输出结果console.log('你好呀，我很好');console.log('你好呀，我很好');*/ 虽然使用setEncoding可以解决目前的问题，但是它目前只能处理utf-8、Base64等部分编码，因此，它并不是完美的。 使用Buffer.concat()来解决相较setEncoding方法在接收时并将buffer对象进行编码转换的不同，Buffer.concat()方法的思想是先接收到所有的小Buffer对象，然后将所有的小Buffer对象进行合并成一个大对象然后再进行字符串输出 Buffer.concat(list[,totalLength])方法接受一个要合并的Buffer数组和合并后list中的Buffer实例的总长度，然后返回一个合并了list中所有Buffer实例的新Buffer 如果没有提供 totalLength，则计算 list 中的 Buffer 实例的总长度。 但是这会导致执行额外的循环用于计算 totalLength，因此如果已知长度，则明确提供长度会更快 因此，最完美的解决方案应该如下： 123456789101112131415161718192021const fs = require('fs');const rs = fs.createReadStream('./a.js',&#123;highWaterMark:5&#125;);let list = [];let length = 0;rs.on('data',(chunk)=&gt;&#123; list.push(chunk); length+=chunk.length;&#125;)rs.on('end',()=&gt;&#123; let newBuf = Buffer.concat(list,length); console.log(newBuf); console.log(newBuf.toString('utf-8'));&#125;)/* 输出结果&lt;Buffer 63 6f 6e 73 6f 6c 65 2e 6c 6f 67 28 27 e4 bd a0 e5 a5 bd e5 91 80 ef bc 8c e6 88 91 e5 be 88 e5 a5 bd 27 29 3b&gt;console.log('你好呀，我很好');*/ 我们可以看到，结果是可以正确输出的。 BUffer与网络传输网络传输一般使用字节流来进行传输，因此，无论我们在传输之前什么类型的值，在传输的过程中都会转化为Buffer对象来进行网络传输 例如：当客户端想要通过post方式传递一些数据的时候，这些数据就会被转化为Buffer对象，一点一点地传递到服务器端 注意： 网络传输中，请求与响应都是流对象，req为可读流，res为可写流 因此，我们可以利用以下的方式来获取post请求的携带的数据 1234567891011121314151617181920const http = require('http');let list = [];let length = 0;http.createServer((req,res)=&gt;&#123; req.on('data',(chunk)=&gt;&#123; // console.log(chunk); list.push(chunk); length+=chunk.length; &#125;) req.on('end',()=&gt;&#123; let buf = Buffer.concat(list,length); // console.log(buf); console.log(buf.toString('utf-8')); res.setHeader('Content-Type','application/JSON'); res.end(buf.toString('utf-8')) &#125;)&#125;) 因此，如果我们直接返回Buffer类型，cpu就不需要进行类型转换工作，可以有效地减少cpu的重复使用，节省服务器资源 文件上传首先我们要在前端选取文件，并得到文件的base64编码 前端部分代码，通过FileReader对象来将获取的文件进行base64编码，通过axios来进行文件上传 前端部分 12345678910111213141516171819202122232425const axios = require('axios');let fileSelect = document.getElementsByTagName('input')[0];let submit = document.getElementsByTagName('input')[1];submit.addEventListener('click',()=&gt;&#123; let file = fileSelect.files[0]; let fr = new FileReader(file); // 处理load事件。该事件在读取操作完成时触发。 fr.addEventListener('load',()=&gt;&#123; console.log(fr.result); axios.post('/api/hello',&#123; params: &#123; value: fr.result &#125; &#125;).then(v=&gt;&#123; console.log(v); &#125;).catch(err=&gt;&#123; console.log(err); &#125;) &#125;) // 开始读取指定的Blob中的内容。一旦完成，result属性中将包含一个data: URL格式的Base64字符串以表示所读取文件的内容。 fr.readAsDataURL(file);&#125;) Node端处理文件上传123456789101112131415161718192021222324252627282930313233const http = require('http');const fs = require('fs');const queryString = require('queryString');let list = [];let length = 0;http.createServer((req,res)=&gt;&#123; req.on('data',(chunk)=&gt;&#123; list.push(chunk); length+=chunk.length; &#125;) req.on('end',()=&gt;&#123; // 获取得到的是utf-8编码的Buffer对象 let buf = Buffer.concat(list,length); // 将该Buffer对象转化为utf-8编码的字符串，并且取出包含在该字符串中的base64编码的文件内容 let data = JSON.parse(buf.toString('utf-8')).params.value.replace(/^data:text\/javascript;base64,/,''); // 接下来就需要将base64编码转化为utf-8编码，我们可以间接地通过Buffer对象来转换 // 创建以base64编码的Buffer对象 let newBuf = Buffer.from(data,'base64'); // 将该Buffer对象转化为base64编码的字符串 let fileContent = newBuf.toString('utf-8'); // 将文件内容写进get.js文件 fs.writeFile('get.js',fileContent,()=&gt;&#123; console.log('文件已保存'); &#125;) res.setHeader('Content-Type','application/JSON'); res.end(JSON.stringify(&#123;value:'收到'&#125;)); &#125;)&#125;).listen(3000,()=&gt;&#123; console.log('Port 3000 is listenging');&#125;) 此时，我们就可以实现一个js文件的上传。 当然，为了能够上传更多格式的文件，我们修改以上的正则表达式就OK了 Node端处理图片上传因为图片的编码貌似都是base64编码，因此，我们在获得图片的base64编码后不需要像文件一样转化为utf-8编码，只需直接存储即可 12345678910111213141516171819202122232425262728293031323334const http = require('http');const fs = require('fs');const queryString = require('queryString');let list = [];let length = 0;http.createServer((req,res)=&gt;&#123; req.on('data',(chunk)=&gt;&#123; list.push(chunk); length+=chunk.length; &#125;) req.on('end',()=&gt;&#123; // 获取得到的是utf-8编码的Buffer对象 let buf = Buffer.concat(list,length); // 将该Buffer对象转化为utf-8编码的字符串，并且取出包含在该字符串中的base64编码的文件内容 let data = JSON.parse(buf.toString('utf-8')).params.value.replace(/^data:((text\/(javascript|plain))|(image\/(png|jpg|jpeg|gif)));base64,/,''); // 接下来就需要将base64编码转化为utf-8编码，我们可以间接地通过Buffer对象来转换 console.log(data); // 创建以base64编码的Buffer对象 let newBuf = Buffer.from(data,'base64'); // 不需要将该Buffer对象转化为base64编码的字符串 //let fileContent = newBuf.toString('utf-8'); // 生成a.jpeg fs.writeFile('a.jpeg',newBuf,()=&gt;&#123; console.log('文件已保存'); &#125;) res.setHeader('Content-Type','application/JSON'); res.end(JSON.stringify(&#123;value:'收到'&#125;)); &#125;)&#125;).listen(3000,()=&gt;&#123; console.log('Port 3000 is listenging');&#125;)]]></content>
      <categories>
        <category>Node</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[V8的垃圾回收机制与内存管理]]></title>
    <url>AngelLikeFairy%2F2019%2F11%2F04%2FV8%E7%9A%84%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6%2F</url>
    <content type="text"><![CDATA[内存管理简介来自于MDN的简介： 像C语言这样的底层语言一般都有底层的内存管理接口，比如 malloc()和free()。相反，JavaScript是在创建变量（对象，字符串等）时自动进行了分配内存，并且在不使用它们时“自动”释放。 释放的过程称为垃圾回收。这个“自动”是混乱的根源，并让JavaScript（和其他高级语言）开发者错误的感觉他们可以不关心内存管理。 内存的生命周期内存的生命周期基本如下： 分配需要的内存 时候用分配到的内存进行读写操作 不需要是将该内存归还或释放 v8的内存模型一个运行中的程序总是与内存中的一部分空间相对应，这部分空间被称为Resident Set（驻留集）。 其内存模型如下： 图中各名词的解释： Resident Segment 驻留集（当前程序所占用的全部空间） Code Segment 存放正在执行的代码 Stack 栈 存放基本类型变量以及对象的指针（因为栈中的内存较小，栈中的每一块内存大小固定） Heap 堆 存放复杂引用类型 Used Heap 堆中已经使用的内存量 Node中的内存查看方式Node中可以使用process.memoryUsage()方法来查看当前进程的内存使用情况 因为该方法输出的内存单位为字节，我们在下面的方法中将其封装从而输出以M为单位 12345678910111213141516171819function format(bytes) &#123; return (bytes/1024/1024).toFixed(2)+'MB';&#125;(function() &#123; let memoryUsage = process.memoryUsage(); console.log('rss',format(memoryUsage.rss)); console.log('heapTotal',format(memoryUsage.heapTotal)); console.log('heapUsed',format(memoryUsage.heapUsed)); console.log('external',format(memoryUsage.external));&#125;)()/* 输出结果rss 17.60MBheapTotal 4.05MBheapUsed 2.01MBexternal 0.61MB*/ 其中，process.memoryUsage方法返回的对象中的所有属性说明如下： rss(resident set size): 当前进程占用的内存部分，包括之前提到过的代码本身、存储基本类型变量和对象指针的栈、存储复杂引用类型的堆 heapTotal: 堆中总共申请到的内存量 heapUsed: 堆中目前已经使用的内存量 external: v8引擎内部的C++对象占用的内存 我们知道，Js中的所有复杂引用类型都是存储在堆中的。因此，当我们创建一个对象时，该对象所占用的内存就会被存放在堆中。如果，当前堆的空闲内存大小已经不够再分配一个新的对象，那么将会继续申请堆内存，直到堆的大小超过V8的限制为止。 在这里提一句，在默认情况下，v8堆内存的最大值在64位系统下大约为1.4G，在32位系统下大约为0.7G v8的垃圾回收机制 垃圾回收是指回收那些在应用程序中不再被引用的对象 例如，我们将一个对象指向null后该对象就会垃圾回收机制自动回收掉 v8的垃圾回收机制主要基于分代式垃圾回收机制 新生代与老生代在V8中，主要将内存分为新生代和老生代两代。新生代中的对象为存活时间较短的对象，老生代中的对象为存活时间较长或常驻内存中的对象 由此，我们可以看到v8申请到堆的大小就是新生代所用内存空间加上老生代所用内存空间 新生代内存空间所使用的的垃圾回收算法（Scavenge算法）在新生代内存空间中，v8主要使用Scavenge算法来进行垃圾回收。 该算法是一种采用复制的方式来实现的垃圾回收算法。 它会将新生代内存一份为二，其中一个空间称为From空间，该空间是当前正在使用的空间；另一个空间成为To空间，该空间是当前正在被闲置的空间（该空间中的内存没有被任何对象使用） 当开始进行垃圾回收时，v8会检查From空间是否还有存活的对象，如果有，那么将这些对象复制到当前空闲的To空间；而，其余非存活的对象则会被回收，它们所占用的空间也会被释放。完成复制后，From空间和To空间的角色将会被互换，也就是刚刚的From空间在复制后就会变为空闲的To空间；而刚刚空闲的To空间在复制后则变成From空间 该算法的缺点是，将新生代内存空间一分为二后，新生代中的内存使用变为原来的一半。 但是，其有一个显著的优点。该算法只复制存活的对象，并且存活时间短的存活对象只占所有新生代中对象的极少一部分，因此，复制效率就会极其高 这便是典型的以空间换时间策略的算法。 另外，如果一个新生代中的对象经过多次SC垃圾回收算法的复制仍然存在，那么v8将会认为该对象已经是存活时间较长的对象了，它已经不适合再呆在新生代内存空间中了，更加确切的说，该对象已经不再适合用SC算法来进行管理了。那么,v8就会将该对象移动到老生代内存空间中，采用新的垃圾回收算法进行管理 老生代内存空间所使用的垃圾回收算法由于老生代内存空间中的对象生存事件较长。因此，如果仍旧采用SC算法就会有明显的两个缺点： 因为对象存活时间长，因此当该算法运行时，存活对象所占的比例极高，那么复制对象的效率就会明显很低 另外，就是要有一半的内存空间是空闲出来的，这样就会造成浪费 因此，v8中采用Mark-Sweep（标记清除）&amp;Mark-Compact（标记整理） 标记清除标记清除算法分为标记和清除两个阶段。 标记阶段 遍历堆中的所有对象，将存活的对象进行标记 清除阶段 清除没有进行标记的对象 可以看出，该算法只清理已经不再存活的对象。由于，在老生代内存空间中，死对象所占的比例较少，因此，清除死对象的方式会极其高效 我们可以看到，该算法将死对象清除后会造成内存空间的不连续，这也将会对后续的内存分配造成问题，因为，很可能后续会有一个需要较大的内存空间的对象要被分配，但是所有的碎片空间都无法满足此次分配，因此，就会提前触发垃圾回收机制并将该大内存空间的对象回收 为了解决这个问题，标记整理的算法就被提了出来 标记整理标记整理算法是标记清除算法的改进版。 标记的过程还是一样的，区别在于清除过程，标记清除算法只是直接回收死对象的内存空间； 而标记整理算法是在整理过程中，将活着的对象往一端移动，那么当移动完成后，另一端就都是死的对象，因此，此时只要直接清除掉那一整块死掉的对象内存空间即可 v8对于标记清除和标记整理算法的考虑由于在标记整理中，v8需要将对象移动，因此它的执行速度就会相对比标记清除算法要慢。 因此，v8对于这两个算法是结合使用的。v8主要使用标记清除算法，只有当老生代内存空间不足以应对即将要分配的占用大内存空间对象的时候才会使用标记整理算法]]></content>
      <categories>
        <category>浏览器</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[node.js的事件循环机制]]></title>
    <url>AngelLikeFairy%2F2019%2F11%2F03%2Fnode-js%E7%9A%84%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF%E6%9C%BA%E5%88%B6%2F</url>
    <content type="text"><![CDATA[什么是事件循环之前，我们了解了浏览器中的事件循环机制。现在，我们来看一下Node中的事件循环机制。 来自于Node官网的解释： The event loop is what allows Node.js to perform non-blocking I/O operations — despite the fact that JavaScript is single-threaded — by offloading operations to the system kernel whenever possible. 大致意思是，事件循环可以使Node.js通过将操作转移到系统内核中来执行非阻塞I / O操作（尽管JavaScript是单线程的）。 另外，我们需要知道，Node事件循环的概念与浏览器事件循环的概念类似，都是用来处理异步任务的。虽然异步任务必须要等到主线程执行堆栈中的任务执行完毕后才能被执行，但是，事件循环在进程启动的时候就会被创建。 事件循环的流程在进程启动时，Node便会创建一个类似于While(true)的循环，每执行一次循环体的过程我们称之为Tick。在每个Tick中，我们查看是否还有事件待处理，如果有，那么就取出该事件及其相关回调函数。如果存在关联的回调函数就执行它们。然后再进入下一个循环，如果不再有事件处理，那么就退出该循环。 流程图如下： 事件循环的详细步骤每一个事件循环都会包含以下6个阶段 每个阶段都有一个当前阶段要执行的回调FIFO（先进先出）队列。虽然每个阶段都有其自己的特殊方式，但是通常，当事件循环进入给定阶段时，它将执行该阶段特定的任何操作，然后在该阶段的队列中执行回调，直到队列用尽或回调的最大数量为止。当队列已用完或达到回调限制时，事件循环将移至下一个阶段，依此类推。 阶段概述 timers阶段：该阶段执行setTimeout和setInterval设定的回调函数 pending callbacks阶段： 此阶段执行某些系统操作的回调，例如TCP错误的类型。例如，如果ECONNREFUSED尝试连接时收到TCP套接字，则某些* nix系统希望等待报告错误。这将排队等待在挂起的回调阶段执行。 idle,prepare阶段：该阶段仅在内部使用，我们不用关心 poll阶段： 检索新的I / O事件； 执行与I / O相关的回调（除了close回调，计时器安排的回调和setImmediate()的回调）； 适当时，Node将在此处阻塞。 check阶段：执行setImmediate()设置的回调 close callbacks阶段： 一些监听事件结束的回调，例如socket.destroy()和socket.on(‘close’, callback)等等 需要详细说明的几个阶段timers阶段我们在阶段概述的时候就提到过，该阶段用来执行setTimeout和setInterval设定的回调函数。 我们也知道，Node无法保证在定时器设定的时间正好响应该回调函数。那个时间更准确地说来，应该是当Node监听到当前时间已经过了预期设定的事件，那么就将该回调函数放到主线程执行队列去等待执行。 另外，我们需要知道的是，从技术上来说，计时器的执行时间是由poll阶段来控制的（具体内容我们在poll阶段来详细说明）。 poll阶段poll阶段主要有2个功能： 处理poll队列的事件的回调 当有已超时的timer（定时器），那么就转去timers阶段执行定时器设定的回调函数（这一个功能是有条件的，条件是此时的poll阶段必须为空闲状态，事件循环才会去查看当前是否有已超时的定时器。否则，事件循环会同步执行poll队列里的回调函数） 以下为详细说明： 如果事件循环进入了poll阶段，并且当前代码中没有设定定时器，那么就会发生以下两种情况： 如果poll队列不为空，那么事件循环将会同步执行poll队列里的回调函数直到清空队列或者执行的回调数量到达规定的上限 如果poll队列为空，那么事件循环就会去检查是否有设定setImmediate() 如果设定了setImmediate()，那么事件循环将立刻结束当前的poll阶段，并转入下一个check阶段执行check阶段的队列中的回调（check阶段中的队列包含的是setImmediate()的回调） 如果没有设定setImmediate()，那么事件循环则会阻塞在该阶段等待回调加入队列中（其中阻塞是有超时时间的，当阻塞的时间超过超时时间，那么还未执行的回调只能在下一轮或更后面的事件循环中被执行） 一旦poll任务队列为空，那么事件循环将会检查timers，如果有一个或多个定时器准备就绪，那么事件循环将会离开当前阶段并进入下一轮事件循环，在timers阶段去执行timers任务队列中的回调 check阶段setImmediate()的回调会被加入check队列中，然后当事件循环进入check阶段时同步执行队列中的回调 总结事件循环的每个阶段都有对应的任务队列。当异步任务完成后，它们所对应的回调函数将会根据异步任务的类型进入相应的任务队列。例如： 定时器任务的回调进入timers阶段的任务队列 异步I/O的回调进入poll阶段的任务队列 setImmediate的回调进入chck阶段的任务队列 另外，对于上述复杂的poll阶段的规则。 我们可以总结得到： 如果事件循环进入poll阶段时有任务，那么同步执行完所有的回调； 如果没有，那么查看是否有setImmediate， 如果有，那么离开poll阶段进入下一个check阶段； 如果没有，那么Node进入阻塞状态，同时不断检查Timers阶段任务队列是否有任务， 如果有那么离开当前阶段去到Timers阶段执行回调； 如果没有，那么一直保持阻塞状态直到有异步I/O的回调加入任务队列或者设置的限制阻塞的超时时间已到 简单来说: 能够退出poll阶段阻塞态的只有以下几种方式 阻塞时间超过了设定的超时时间 在阻塞状态时检查到timers队列中有任务 设定了setImmediate 说了那么多，我们来看一下一个例子，就应该较好地理解Node中的事件循环机制 123456789101112131415161718192021const fs = require('fs');// 程序开始时间let startTime = Date.now();// Node中读取文件的异步APIfs.readFile('./a.js','utf-8',(err,data)=&gt;&#123; console.log('readFileTime',Date.now()-startTime); if(err) throw new Error('error'); return data;&#125;)// 定时器setTimeout(()=&gt;&#123; console.log('timeout',Date.now()-startTime);&#125;,50);// setImmediate()setImmediate(()=&gt;&#123; console.log('immediate',Date.now()-startTime);&#125;) 来看下输出结果： 123immediate 2readFileTime 10timeout 54 setTimeout与setImmediate在上面我们已经知道了setTimeout设定的回调会在timers阶段被执行，而setImmediate设定的回调会在check阶段被执行。 那么，接下来我们来看一段程序： 1234567setTimeout(()=&gt;&#123; console.log('timeout');&#125;,0)setImmediate(()=&gt;&#123; console.log('immediate');&#125;) 事实上，这段代码的运行结果不是唯一的。主要是两个输出语句的输出顺序是不一定的。 有可能是： 12timeoutimmediate 但也有可能是 12immediatetimeout 但是，如果我们在一次I/O中在运行调用setTimeout和setImmediate，我们会发现setImmediate的回调永远比setTimeout的回调先执行 例如： 12345678910111213141516const fs = require('fs');fs.readFile('./a.js','utf-8',()=&gt;&#123; setTimeout(()=&gt;&#123; console.log('timeout'); &#125;,0) setImmediate(()=&gt;&#123; console.log('immediate'); &#125;)&#125;)/* 输出结果immediatetimeout*/ 那么，这是为什么呢? 搬用cnode社区里的一个大神的回答 在node中，setTimeout(cb, 0) === setTimeout(cb, 1); 而setImmediately属于uv_run_check的部分 确实每次loop进来，都是先检查uv_run_timer的，但是由于cpu工作耗费时间，比如第一次获取的hrtime为0 那么setTimeout(cb, 1)，超时时间就是loop-&gt;time = 1(ms，node定时器精确到1ms，但是hrtime是精确到纳秒级别的) 所以第一次loop进来的时候就有两种情况： 1.由于第一次loop前的准备耗时超过1ms，当前的loop-&gt;time &gt;=1 ，则uv_run_timer生效，timeout先执行 2.由于第一次loop前的准备耗时小于1ms，当前的loop-&gt;time = 0，则本次loop中的第一次uv_run_timer不生效，那么io_poll后先执行uv_run_check，即immediate先执行，然后等close cb执行完后，继续执行uv_run_timer 那么你说的为什么在回调中，一定是先immediate执行呢，其实也很容易理解 你可以思考一下你写的场景 由于你的timeout和immediate的事件注册是在readFile的回调执行时，触发是必然的，在readFile的回调执行前的每一次event loop进来的uv_run_timer都不会有超时事件触发 那么当readFile执行完毕，kevent收到监听的fd事件完成后，执行了该回调，此时 1.timeout事件注册 2.immediate事件注册 3.由于readFile的回调执行完毕，那么就会从uv_io_poll中出来，此时立即执行uv_run_check，所以immediate事件被执行掉 4.最后的uv_run_timer检查timeout事件，执行timeout事件 所以你会发现，在I/O回调中注册的两者，永远都是immediately先执行这里是大神文章的链接： process.nextTick()Node官方文档是这样解释process.nextTick()的： process.nextTick() 方法将 callback 添加到下一个时间点的队列。 在 JavaScript 堆栈上的当前操作运行完成之后以及允许事件循环继续之前，此队列会被完全耗尽。 如果要递归地调用 process.nextTick()，则可以创建无限的循环。 这就意味着： 如果，process.nextTick定义在事件循环机制开始前，而非事件循环机制中，那么，process.nextTick定义的回调函数将在主线程执行队列中的所有任务执行完毕后被调用 例如： 123456789101112131415161718192021222324console.log(1);setTimeout(()=&gt;&#123; console.log('timeout');&#125;)process.nextTick(()=&gt;&#123; console.log('tick');&#125;)setImmediate(()=&gt;&#123; console.log('immediate');&#125;)console.log(2);/* 输出结果12tick// 注意：timeout和Immediate的输出顺序是不一定的，原因在前文已经提过timeoutimmediate*/ 如果process.nextTick()在事件循环中被定义，那么process.nextTick定义的回调函数将会在下一个事件循环的阶段开始前被执行，也就是两个阶段切换时的中间过程 来看一个例子： 12345678910111213141516171819202122232425const fs = require('fs');fs.readFile('./a.js','utf-8',()=&gt;&#123; console.log(1); setTimeout(()=&gt;&#123; console.log('timeout'); &#125;,0) setImmediate(()=&gt;&#123; console.log('immediate'); &#125;) process.nextTick(()=&gt;&#123; console.log('tick1'); &#125;) process.nextTick(()=&gt;&#123; console.log('tick2'); &#125;)&#125;)/* 输出结果1tick1tick2immediatetimeout*/ 当异步读取完文件后，此时位于poll阶段，执行回调函数，该回调函数设定了一个setTimeout，一个setImmediate，两个process.nextTick。加下来事件循环开始离开poll阶段，在从poll阶段切换到check阶段的中间，两个process.nextTick设定的回调函数将会被执行。接着，转换到check阶段执行setImmediate设定的回调函数。最后，在下一轮事件循环中执行setTimeout设定的回调函数。 如果process.nextTick()定义在某个阶段中要同步的执行当前队列的所有回调函数内部时，根据，官方文档的说明，在 JavaScript 执行堆栈上的当前操作运行完成之后以及允许事件循环继续之前，process.nextTick将会被执行 例如： 12345678910111213141516setImmediate(()=&gt;&#123; console.log('immediate1'); process.nextTick(()=&gt;&#123; console.log('tick强势插入'); &#125;)&#125;)setImmediate(()=&gt;&#123; console.log('immediate2');&#125;)/* 输出结果immediate1tick强势插入immediate2*/ 在事件循环机制中，此时位于check阶段，事件循环机制将按照同步的方式依次将setImmediate的回调函数放入主线程的执行堆栈中进行运行。但是第一个setImmediate的回调函数执行时又注册了process.nextTick()。因此，在事件循环机制继续运行（将下一个setImmediate回调放入主线程执行堆栈中进行执行）前，process.nextTick就优先被执行 另外，需要尤其注意的是，process.nextTick的回调一旦执行，必须要直到nextTick队列被清空，才会进入到下一个事件阶段，所以如果递归调用 process.nextTick()，会导致出现I/O starving（饥饿）的问题 例如： 1234567891011121314151617181920212223242526272829const fs = require('fs');let index = 0;let startTime = Date.now();fs.readFile('./a.js','utf-8',()=&gt;&#123; console.log('File is readed'); console.log(`Time wasted $&#123;Date.now()-startTime&#125;`);&#125;)function handle() &#123; if(index &gt; 1000) return; console.log(`tick $&#123;index&#125;`); index++; process.nextTick(handle);&#125;handle();/* 输出结果tick 0tick 1tick 2......tick 1000File is readedTime wasted 495*/ 我们发现，在上述程序中，只有当process.nextTick()全部执行完毕后，fs。readFile()注册的回调函数才会被执行 process.nextTick()与setImmediate()我们在前面已经分别介绍过了process.nextTick()与setImmediate()注册的回调函数的执行时机。 因此，如果，process.nextTick()与setImmediate()同时被注册，那么process.nextTick的优先级要高于setImmediate 例如： 123456789101112setImmediate(()=&gt;&#123; console.log('immediate');&#125;)process.nextTick(()=&gt;&#123; console.log('tick');&#125;)/* 输出结果tickimmediate*/ 其实，这段代码在上面的叙述中已经提过。那么，为什么还要将它们俩放在一起比较呢？ 其实，是因为我们提到，process.nextTick()一旦执行就会将当前所有的nextTick()注册的回调执行完后才会进入下一个事件阶段，因此，很容易造成I/O饥饿现象 而setImmediate则会改变这种现象。因为，在事件循环中，每次在check阶段每个setImmedaite任务只会执行一次setImmediate的回调，如果回调里还有setImmediate任务，那么它将会在下一轮事件循环中执行 例如： 12345678910111213141516171819const fs = require('fs');fs.readFile('./a.js','utf-8',()=&gt;&#123; setImmediate(()=&gt;&#123; console.log('immediate1'); setImmediate(()=&gt;&#123; console.log('immediate2'); &#125;) &#125;) setTimeout(()=&gt;&#123; console.log('timeout2'); &#125;)&#125;)/* 输出结果immediate1timeout2immediate2*/ 我们可以看到,setImmediate第一个回调执行完毕后并没有立刻执行第二个setImmediate回调，而是进入了下一轮事件循环，先在timers阶段执行了setTimeout的回调，然后再在check阶段执行第二个setImmediate的回调。 因此，在解决多次调用process.nextTick所具有的的I/O饥饿问题，我们可以使用setImmediate来解决 下面的程序只是将上面的程序中的process.nextTick替换成setImmediate 1234567891011121314151617181920212223242526272829303132const fs = require('fs');let index = 0;let startTime = Date.now();fs.readFile('./a.js','utf-8',()=&gt;&#123; console.log('File is readed'); console.log(`Time wasted $&#123;Date.now()-startTime&#125;`);&#125;)function handle() &#123; if(index &gt; 100) return; console.log(`tick $&#123;index&#125;`); index++; setImmediate(handle);&#125;handle();/* 输出结果tick 0tick 1...tick 7File is readedTime wasted 12tick 8tick 9......tick 100*/ 我们可以看到,fs.readFile()的回调再setImmediate的递归中进行了输出，而不是等所有递归结束后再被执行。 我们来解释一下其中的原因： 执行fs.readFile异步任务和handle()函数，同时输出tick 0 第一次事件循环，此时在poll阶段并没有得等到readFile的回调加入任务队列，而此时setImmediate函数被注册，那么立即离开poll阶段 进入check阶段，执行setImmediate注册的回调函数，在该程序中也就是再执行一遍，此时输出tick 1，但是，在该回调函数中又注册了一个setTimeout，但是该setTimeout并不会立即执行，而是等到下一轮事件循环中执行 …中途经过了几轮的事件循环，在这几轮中，pool阶段始终没有等到readFile的回调，因此，在check阶段一直输出到了tick 7 在这轮事件循环中，在poll阶段的任务队列中终于有了readFile()的回调，那么立即执行该回调，输出 File is readed Time wasted 12 继续多轮事件循环，一直到退出handle()递归]]></content>
  </entry>
  <entry>
    <title><![CDATA[深入了解Node的异步I/O]]></title>
    <url>AngelLikeFairy%2F2019%2F11%2F01%2F%E6%B7%B1%E5%85%A5%E4%BA%86%E8%A7%A3Node%E7%9A%84%E5%BC%82%E6%AD%A5I-O%2F</url>
    <content type="text"><![CDATA[I/O什么是I/O I/O（英语：Input/Output），即输入/输出，通常指数据在内部存储器和外部存储器或其他周边设备之间的输入和输出。 另外，I/O又可以具体分为磁盘I/O和网络I/O。 它们一般具有以下两个步骤： 等待数据准备 将数据从内核拷贝到进程中 对于一般的I/O读操作，我们可以进行以下的抽象： 应用发起read系统调用 操作系统层面接受应用的请求，如果内核缓冲区中有该数据，那么将该数据拷贝到用户缓存区 如果内核缓存区中没有数据，那么内核会向io模块发送请求，让其从磁盘中读取数据。读取完毕后，将其存入内核缓存区，并拷贝到用户缓存区 总结： 当应用程序调用read接口时，操作系统检查在内核的高速缓存有没有需要的数据，如果已经缓存了，那么就直接从缓存中返回，如果没有，则从磁盘中读取，然后缓存在操作系统的缓存中。 应用程序调用write接口时，将数据从用户地址空间复制到内核地址空间的缓存中，这时对用户程序来说，写操作已经完成，至于什么时候再写到磁盘中，由操作系统决定，除非显示调用了sync同步命令 PIO与DMA有必要提一下PIO与DMA两种I/O方式 PIO我们拿磁盘来说，很早以前，磁盘和内存之间的数据传输是需要CPU控制的，也就是说如果我们读取磁盘文件到内存中，数据要经过CPU存储转发，这种方式称为PIO。显然这种方式非常不合理，需要占用大量的CPU时间来读取文件，造成文件访问时系统几乎停止响应。 DMA后来，DMA（直接内存访问，Direct Memory Access）取代了PIO，它可以不经过CPU而直接进行磁盘和内存的数据交换。在DMA模式下，CPU只需要向DMA控制器下达指令，让DMA控制器来处理数据的传送即可，DMA控制器通过系统总线来传输数据，传送完毕再通知CPU，这样就在很大程度上降低了CPU占有率，大大节省了系统资源，而它的传输速度与PIO的差异其实并不十分明显，因为这主要取决于慢速设备的速度。 因此，在这里我们树立一个概念，现在的I/O操作在读写的过程中是不需要经过CPU进行处理的。 异步与非阻塞，同步与阻塞是同一个概念吗在Node的文章中，我们经常可以看到异步，非阻塞；同步，阻塞这些概念。听起来，异步与非阻塞像是同一个概念，而且他们实现的效果好像是一样的。但是，实际上它们是两回事。 对于阻塞与非阻塞我们可以这样理解： 阻塞和非阻塞关注的是程序在等待调用结果（消息，返回值）时的状态.阻塞调用是指调用结果返回之前，当前线程会被挂起。调用线程只有在得到结果之后才会返回。非阻塞调用指在不能立刻得到结果之前，该调用不会阻塞当前线程。 而对于异步与同步： 同步和异步关注的是消息通信机制。所谓同步，就是在发出一个调用时，在没有得到结果之前，该调用就不返回。但是一旦调用返回，就得到返回值了。换句话说，就是由调用者*动等待这个调用的结果。而异步则是相反，调用在发出之后，这个调用就直接返回了，当然不会有返回结果。换句话说，当一个异步过程调用发出后，调用者不会立刻得到结果。而是在调用发出后，被调用者通过状态、通知来通知调用者，或通过回调函数处理这个调用。 总结来说： 阻塞与非阻塞更多的考虑是对于自身的线程。阻塞即线程挂起等待结果返回；而非阻塞就是该线程继续往下执行，但是不会立即得到等待结果。我们只有通过轮询机制才能得到结果 同步与异步更多的是考虑双方的状态。例如，应用层向服务端发起一个请求，如果是同步请求，那么只有服务端得到结果之后才可以返回；而如果是异步请求，那么调用就直接返回，经过一定时间后，服务端的数据已经处理完毕，然后通过回调机制来通知应用层结果已经返回 Node的异步I/O事件循环在这里可以去查看另一篇文章 观察者在每次事件循环中，Node如何判断是否有新的事件需要处理呢？ Node引入观察者来实现是否有事件需要处理的判断。每个事件循环中都会有1个或多个观察者，而判断是否有事件需要处理的过程就是向这些观察者询问是否有要处理的事件。 在Node中，事件主要来源于网络请求、文件I/O等，这些事件的对应观察者即网络I/O观察者，文件I/O观察者。 另外，事件循环是典型的生产者/消费者模型。异步I/O、网络请求等则是生产者，源源不断为Node提供不同类型的事件，这些事件会被传递到对应的观察者那里，然后事件循环则会从观察者那里取出事件并进行处理 异步I/O的整体流程我们以fs.open()方法为例来探究以下异步I/O的整体流程。 123const fs = require('fs');fs.open(path,flags,mode,callback); fs.open()的作用是根据指定的路径和参数去打开一个文件，从而得到一个文件描述符。 异步调用的第一个阶段当Node调用fs.open()核心模块后，该核心模块将会去调用C++内建模块。然后通过libuv这一层为不同的平台（windows和*nix）调用分别系统级底层函数。 在系统级底层函数uv_fs_open()的调用过程中，会创建一个FSReqWrap的请求对象，所有传递给js核心模块fs.open()的参数和回调方法都被作为该对象的属性被其封装。例如，回调函数会被设置在这个对象的oncomplete_sym上： 1req_wrap-&gt;object_-&gt;Set(oncomplete_sym,callback); 请求对象包装完毕后，则会将该请求对象推入线程池中去等待执行。 至此，Js调用立即返回，有Js层面发起的异步调用的第一阶段到这里就结束了。Js主线程可以继续去执行其余任务，当前的I/O操作则会在线程池中等待执行，不管线程池中的该I/O线程是否阻塞，都不会影响Js主线程的后续执行，因此，异步就这样实现了。 异步调用的第二个阶段 回调通知则是异步调用的第二个阶段。 当线程池中的I/O线程完成工作后，会将获取的结果储存在第一阶段定义的请求对象的req-&gt;result属性上，然后会通知IOCP（windows实现的异步I/O方案），告知当前对象操作已经完成，然后将线程归还线程池。 到这里，整个异步I/O的流程并没有结束。 事件循环中的I/O观察者将会在每次事件循环中去检查请求是否执行完成，如果执行完毕，那么就会取出请求对象的rq-&gt;result属性作为参数，取出oncomplete_sym属性作为方法，然后进行调用执行，以此来达到调用Js中传入的回调函数的目的。 总结至此，整个异步I/O的流程完全结束，流程图如下： 简单来说，Node的异步I/O流程可以分为以下几步： 异步调用 应用层发起异步调用，Node会从调用核心模块到内建模块一直到调用到底层系统级函数 将应用层传入的参数和回调封装给一个请求对象 将请求对象放入线程池等待执行 应用层发起的异步调用结束，立即返回 线程池 分配空闲线程来执行请求对象中的I/O操作 I/O线程执行完毕，将执行完毕的结果储存在请求对象中 在windows下通知IOCP已经执行完毕，然后归还该I/O线程 事件循环 事件循环中的I/O观察者观察到事件已完成，将该事件的回调推入任务队列中 取出回调函数和请求对象中的结果进行调用执行 事件驱动Node中的事件驱动就是通过不断地进行事件循环然后当事件来临时进行触发的机制。]]></content>
      <categories>
        <category>Node</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[浏览器渲染机制]]></title>
    <url>AngelLikeFairy%2F2019%2F10%2F29%2F%E6%B5%8F%E8%A7%88%E5%99%A8%E6%B8%B2%E6%9F%93%E6%9C%BA%E5%88%B6%2F</url>
    <content type="text"><![CDATA[浏览器渲染步骤浏览器的渲染机制一般分为以下几步： 处理HTML并构建DOM树 处理CSS构建CSSOM树 将DOM和CSSOM合并生成Render Tree（渲染树） 根据渲染树计算节点的位置进行布局 通过显卡将画面绘制到屏幕上 一个整体的流程图 DOM树与CSSOM树的生成过程DOM树的生成过程（CSSOM树与之类似）： 转换：浏览器从磁盘或网络上读取HTML的原始字节，并根据文件的指定编码（例如UTF-8）将它们转换为单个字符。 标记化：浏览器将字符串转换为W3C HTML5标准指定的不同标记；例如“ ”，“ ”以及尖括号内的其他字符串。每个令牌都有特殊的含义和自己的规则集。 节点生成：发出的令牌被转换为“对象”，以定义其属性和规则。 DOM构造：最后，由于HTML标记定义了不同标记之间的关系（某些标记包含在其他标记中），因此创建的对象以树形数据结构链接，该树数据结构还捕获了原始标记中定义的父子关系：HTML 对象是body对象的父对象，body是段落对象的父 对象，依此类推。 DOM树示例 CSSOM树示例 Render Tree（渲染树）在上面，我们得到了描述页面内容的DOM树和描述页面样式的CSSOM。接下来，我们就得需要将两者进行结合生成Render Tree 渲染树的生成和渲染步骤 将DOM和CSSOM树合并以形成渲染树 渲染树的生成步骤： 1. 从DOM树的根节点开始，采取深度优先遍历的方式（也就是说当前节点的所有子节点都构建好后才会去构建当前节点的下一个兄弟节点）来遍历每一个可见节点 &gt; 什么是不可见节点： 1. 一些节点不可见（例如，脚本标记，元标记等），由于它们未反映在渲染的输出中，因此将其省略。 2. 一些节点通过CSS隐藏，并且在渲染树中也被省略；例如，将一个节点设置了“ display：none”属性。（但是设置visibility: hidden就会将该CSSOM节点和属性添加到渲染树中） 2. 对于每个可见节点，找到匹配CSSOM规则并应用它们。 3. 生成具有内容及其计算样式的可见节点。 布局：在生成的渲染树中，我们已经可以得知了那些节点是可见的，并且该节点的样式也是已知的。接下来我们需要计算它们在设备视口中的确切位置和大小，这就是“布局”阶段，也称为“重排”。 将各个节点绘制到屏幕上 需要注意的是： Render Tree与DOM树不一定是相同的。虽然，Renter Tree是按照DOM树的节点进行遍历生成的。但是，我们要记住，Render Tree中的所有节点都是可见节点（我们在前面已经提到过什么是不可见节点）。 阻塞渲染我们知道HTML会阻塞渲染树的渲染，因为要是没有DOM，渲染树就无法渲染任何内容。那么对于css和JS呢？它们阻塞渲染吗？ 掘金站点的html文档耗时情况 我们可以看到阻塞了150ms css阻塞渲染在默认的情况下，css是阻塞渲染的。 我们在html文档里引入一个css文件，然后查看一下渲染过程，我们可以看到该css文件是阻塞的 在构建 CSSOM 树时，会阻塞渲染，直至 CSSOM 树构建完成。并且构建 CSSOM 树是一个十分消耗性能的过程，所以应该尽量保证层级扁平，减少过度层叠，越是具体的 CSS 选择器，执行速度越慢。 js文件阻塞渲染 除非明确声明为异步，否则JavaScript会阻止DOM构建 非异步脚本无论我们使用的是&lt;script&gt;内联形式的代码块还是引入外部文件，浏览器都会暂停并执行js脚本，然后才能处理文档的其余部分。 另外，在使用外部JavaScript文件的情况下，浏览器必须暂停以等待从磁盘，缓存或远程服务器中获取脚本，这可能会增加关键渲染路径的数十到数千毫秒的延迟。 我们来试验一下： 123456&lt;html&gt; &lt;head&gt;&lt;/head&gt; &lt;body&gt; &lt;script type="text/javascript" src="./a.js"&gt; &lt;/body&gt;&lt;/html&gt; 结果 异步脚本HTML5为script元素定义了async属性。该属性可以让js文件异步加载。 async只适用于外部脚本文件 指定async属性的目的是不让页面等待脚本下载和执行，从而异步加载页面其他内容。因此，异步脚本不要在加载期间修改DOM 另外，异步脚本一定会在页面的load事件前执行。 来看一下加上async属性，该js脚本是否回阻塞后面的执行： 123456&lt;html&gt; &lt;head&gt;&lt;/head&gt; &lt;body&gt; &lt;script async type="text/javascript" src="./a.js"&gt; &lt;/body&gt;&lt;/html&gt; 结果 重绘与回流重绘与回流的基本概念 当Render Tree中部分或全部元素的尺寸、结构、或某些属性发生改变时，浏览器重新渲染部分或全部文档的过程称为回流。 当页面中元素样式的改变并不影响它在文档流中的位置时（例如：color、background-color、visibility等），浏览器会将新样式赋予给元素并重新绘制它，这个过程称为重绘。 由此我们可以得出一个结论： 回流必定会发生重绘，重绘不一定会引发回流。 我们来看一下回流具体发生的场景： 添加或者删除可见的DOM元素； 元素位置改变； 元素尺寸改变——边距、填充、边框、宽度和高度 内容改变——比如文本改变或者图片大小改变而引起的计算值宽度和高度改变； 页面渲染初始化； 浏览器窗口尺寸改变——resize事件发生时； 查询或调用一些会引起回流的属性 clientWidth、clientHeight、clientTop、clientLeft offsetWidth、offsetHeight、offsetTop、offsetLeft scrollWidth、scrollHeight、scrollTop、scrollLeft scrollIntoView()、scrollIntoViewIfNeeded() getComputedStyle() getBoundingClientRect() scrollTo() 重绘与回流的开销 回流比重绘的开销要更大。 另外，回流的开销也会因为操作的不同而有可能相差很大 假如，我们直接操纵body，并且在body前插入一个元素，那么整个Render Tree都会被重新构建 而如果只是在Render Tree的叶子节点后插入一个节点，那么前面的所有节点都不会影响。因此，开销会比上一个回流的开销小得多。 减少重绘与回流（性能提高）对于css 避免使用table布局。 由于浏览器使用流式布局，对Render Tree的计算通常只需要遍历一次就可以完成，但table及其内部元素除外，他们可能需要多次计算，通常要花3倍于同等元素的时间。 使用 visibility：0 替换 display: none ，因为前者只会引起重绘，后者会引发回流（改变了布局–渲染树不会生成该节点） CSS 选择符从右往左匹配查找，避免 DOM 深度过深 避免使用CSS表达式（例如：calc()） 对于js 避免频繁操作样式，最好一次性重写style属性，或者将样式列表定义为class并一次性更改class属性。 避免频繁操作DOM，创建一个documentFragment，在它上面应用所有DOM操作，最后再把它添加到文档中。 避免频繁读取会引发回流/重绘的属性，如果确实需要多次使用，就用一个变量缓存起来。 1234for (let i = 0; i &lt; 1000; i++) &#123; // 获取 offsetTop 会导致回流，因为需要去获取正确的值 console.log(document.querySelector('.test').style.offsetTop)&#125; 也可以先为元素设置display: none，操作结束后再把它显示出来。因为在display属性为none的元素上进行的DOM操作不会引发回流和重绘（因为将display属性设置为none的节点为不可见节点，不可见节点不会被添加到渲染树中）。]]></content>
      <categories>
        <category>浏览器</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[循环中的async与await处理]]></title>
    <url>AngelLikeFairy%2F2019%2F10%2F28%2F%E5%BE%AA%E7%8E%AF%E4%B8%AD%E7%9A%84async%E4%B8%8Eawait%E5%A4%84%E7%90%86%2F</url>
    <content type="text"><![CDATA[引言之前在做项目的时候，遇到一个场景： 给定了一个数组类似于这样： 123456789[ &#123; hallId: 1 &#125;, &#123; hallId: 2 &#125;, ...] 需求是这样的，我们需要遍历整个数组，获得每个对象中的hallId值，再通过该ID值请求某接口得到hallName，再将该hallName存入对象 结果类似于这样 12345678910[ &#123; hallId: 1, hallName: '1号' &#125;, &#123; hallId: 2, hallName: '2号' &#125;] 然后就遇到了循环中使用async和await遇到的一些问题，以下就是探究的过程 前期准备我们首先准备要获取的数据 123456789101112131415161718192021222324252627const ha = [ &#123; hallId: 1 &#125;, &#123; hallId: 2 &#125;, &#123; hallId: 3 &#125;]const hall = [ &#123; hallId: 1, hallName: '1号' &#125;, &#123; hallId: 2, hallName: '2号' &#125;, &#123; hallId: 3, hallName: '3号' &#125;] 以及使用setTimeout来模拟异步请求 1234567891011function getHallName(id) &#123; return new Promise((resolve,reject)=&gt;&#123; setTimeout(()=&gt;&#123; for(let v of hall) &#123; if(v.hallId===id) &#123; resolve(v.hallName); &#125; &#125; &#125;,1000) &#125;)&#125; for循环中使用await我们首先来看下在for循环中使用await 我们可以很自然地写出以下异步函数： 1234567891011121314151617async function test() &#123; for(let v of ha) &#123; let value = await getHallName(v.hallId); console.log(value); &#125;&#125;test();/* 执行结果// 等待1000ms1号// 等待1000ms2号// 等待1000ms3号*/ 在forEach中使用await一开始的写的异步函数如下 12345678async function test() &#123; ha.forEach(v=&gt;&#123; let value = await getHallName(v.hallId); console.log(value); &#125;)&#125;test(); 但是当我们兴致冲冲去查看运行结果的时候却傻了眼，得到的输出结果却是如下 1SyntaxError: await is only valid in async function 这时候，我们一拍脑袋，回想起来forEach() 方法是对数组的每个元素执行一次提供的函数。 现在，我又将函数修改为以下的形式 12345678async function test() &#123; ha.forEach(async v =&gt; &#123; let value = await getHallName(v.hallId); console.log(value); &#125;)&#125;test(); 现在结果总该是正确的吧，但是，令人失望的是，结果还是错的 输出结果如下： 123456/* 输出结果// 等待1000ms,然后直接输出下面的三项，而不是每一项之间间隔1000ms1号2号3号*/ 查阅资料后，才得到了一个结论 JavaScript 中的 forEach不支持 promise 感知，也不支持 async 和await，所以不能在 forEach 使用 await 。 在map中使用await既然在forEach中无法使用await，那么map()方法呢？ 这次我们有了forEach()的教训， map() 方法创建一个新数组，其结果是该数组中的每个元素都调用一个提供的函数后返回的结果。 我们就记住了要让提供给map()方法的函数为异步函数 我们写出来以下的方法来进行试验： 12345678async function test() &#123; ha.map(async v=&gt; &#123; let value = await getHallName(v.hallId); console.log(value); &#125;)&#125;test(); 输出结果如下： 123456/* 输出结果// 等待1000ms，然后直接一次性输出下列三个值1号2号3号*/ 我们查看一下mdn文档对于map()方法的说明： map 方法会给原数组中的每个元素都按顺序调用一次 callback 函数。callback 每次执行后的返回值（包括 undefined）组合起来形成一个新数组。 也就是说，在不考虑返回数组的情况下，map()方法就可以表示为以下的形式 123456789101112131415161718async function map1(v) &#123; let value = await getHallName(v.hallId); console.log(value);&#125;async function map2(v) &#123; let value = await getHallName(v.hallId); console.log(value);&#125;async function map3(v) &#123; let value = await getHallName(v.hallId); console.log(value);&#125;map1(ha[0]);map2(ha[1]);map3(ha[2]); 我们首先注册了三个异步函数，然后并行调用了它们。因此，输出结果也就是如上述所述，等待一段时间后，然后按照任务队列中的顺序依次输出 那么，如果再考虑map()方法的特性，其可以将每次函数执行后的返回值组合起来形成一个新的数组。另外，我们又知道 异步函数返回一个promise对象 因此，使用map()方法就可以返回一个包含promise对象的数组 1[ Promise &#123; &lt;pending&gt; &#125;, Promise &#123; &lt;pending&gt; &#125;, Promise &#123; &lt;pending&gt; &#125; ] 因此，我们可以利用Promise.all()方法来进行后续的处理 现在，我们来重写之前的方法 123456789101112131415161718async function test() &#123; let promiseArr = ha.map(async v =&gt; &#123; let value = await getHallName(v.hallId); return value; &#125;) Promise.all(promiseArr).then( v=&gt; &#123; console.log(v); &#125;)&#125;test();/* 输出结果// 等待1000ms[ '1号', '2号', '3号' ]*/ 小结根据以上的分析，我们可以看到：对于async和await来控制异步流程 如果想要在循环中让异步任务串行（继发运行），那么使用for循环(包括for的一些列循环: for…of , for…in) 如果想要在循环中让异步任务并行，那么我们除了Promise.all()方法外，还可以使用map()方法来使异步任务并行]]></content>
      <categories>
        <category>ES6</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[TypeScript与koa搭建web项目的总结]]></title>
    <url>AngelLikeFairy%2F2019%2F10%2F28%2FTypeScript%E4%B8%8Ekoa%E6%90%AD%E5%BB%BAweb%E9%A1%B9%E7%9B%AE%E7%9A%84%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[项目准备项目的创建以及必需的包的安装 创建npm项目 npm init 默认即可，如果考虑后期npm包的发布，那么可以自定义 安装koa项目必要的npm包模块 安装TypeScript cnpm i -g typescript 安装koa,koa-router cnpm i koa koa-router -D 安装@types/koa,@types/koa-router 这两个模块可以允许我们使用TypeScript语法来编写koa应用 cnpm i @types/koa @types/koa-router -D 安装ts-node,nodemon ts-node可以直接编译.ts文件，而不需要等待tsc将ts文件编译成js文件再进行编译的方式 nodemon可以监听文件的变动并进行重新编译（热加载） cnpm i ts-node nodemon -D 安装数据库相关的npm包模块 安装node.js ORM框架 sequelize cnpm i sequelize -D 为所选数据库安装驱动程序 One of the following: $ npm install –save pg pg-hstore # Postgres $ npm install –save mysql2 $ npm install –save mariadb $ npm install –save sqlite3 $ npm install –save tedious # Microsoft SQL Server 项目结构的确定采用面向对象（OOP）的思想，我们可以确定如下的项目结构 1234567891011121314151617181920212223242526|-- program |-- package.json |-- tsconfig.json |-- .vscode |-- dist |-- src |-- app.ts |-- Config | |-- config.ts |-- Controllers | |-- movieController.ts | |-- swiperController.ts | |-- timeController.ts |-- Entity | |-- entities.ts |-- Models | |-- movieHall.ts | |-- movieModel.ts | |-- swiperModel.ts | |-- timeModel.ts |-- Sequelize | |-- Sequelize.ts |-- Services |-- movieService.ts |-- swiperService.ts |-- timeServiece.ts package.json接下来我们会提一下package.josn该配置文件的关键配置 12345"scripts": &#123; "build": "tsc", "start": "tsc &amp;&amp; nodemon dist/app.js", "watch-server": "nodemon --watch src -e ts,tsx --exec ts-node ./src/app.ts"&#125; npm 允许在package.json文件里面，使用scripts字段定义脚本命令。 我们需要在scripts脚本命令中进行配置，以简化启动命令的编写 脚本配置命令的说明 start 命令 我们执行npm run start就相当于创建了一个新的shell来执行tsc &amp;&amp; node dist/app.js。 对于tsc命令，是typescript命令行自带的，在不带任何输入文件下调用tsc命令，编译器就会从当前目录向上查找tsconfig.json配置文件。按照tsconfig.json配置文件的说明来进行ts的文件编译 对于nodemon dist/app.js,监听使用tsc命令编译成的app.js文件的变化，并进行热加载编译 watch-server 命令 nodemon –watch src用来监视src目录下所有文件的变动 nodemon -e ts/tsx 默认情况下，nodemon查找与文件.js，.mjs，.coffee，.litcoffee，和.json扩展。使用该命令可以扩展其监视的文件类型（当前是ts/tsx） nodemon –exec ts-node ./src/app.ts nodemon还可以用于执行和监视其他外部非nodemon程序。此处用来执行ts-node ./src/app.ts。用来执行该ts文件 tsconfig.jsontsconfig.json文件中指定了用来编译这个项目的根文件和编译选项。 我们通过tsc命令来进行ts文件的编译。 以下是tsconfig.json的配置 1234567891011121314&#123; "compilerOptions": &#123; "target": "ES2017", /* 指定 ECMAScript 目标版本: 'ES3' (default), 'ES5', 'ES2015', 'ES2016', 'ES2017', or 'ESNEXT' */ "module": "es2015", /* 指定使用模块: 'commonjs', 'amd', 'system', 'umd' or 'es2015' */ "sourceMap": true, /* 生成相应的 '.map' 文件 */ "strict": true, /* 启用所有严格类型检查选项 */ "outDir": "./dist", /* 指定输出目录 */ "rootDir": "./src", /* 用来控制输出目录结构 --outDir. (输出目录的解构会与给定的rootDir目录解构一致) */ "strictNullChecks": false, /* 是否启用严格的 null 检查 （这里为否） */ "noImplicitAny": false, /* 在表达式和声明上有隐含的 any类型时是否报错 （这里为否）*/ "alwaysStrict": false, /* 是否以严格模式检查每个模块，并在每个文件里加入 'use strict' （这里为否）*/ "esModuleInterop": true &#125;&#125; dist指定编译生成的输出目录，目录结构与src源代码目录一致 src源代码目录 app.ts项目入口文件，引入控制器模块并指定端口生成应用 例如： 123456789101112131415import Koa from 'koa';import swiperController from './Controllers/swiperController';import movieController from './Controllers/movieController';import timeController from './Controllers/timeController';let app = new Koa();app.use(swiperController.routes()).use(swiperController.allowedMethods());app.use(movieController.routes()).use(movieController.allowedMethods());app.use(timeController.routes()).use(timeController.allowedMethods());app.listen(3000,(): void =&gt; &#123; console.log('Port 3000 is listening');&#125;) Controllers 控制层控制层用来分发路由，处理传入的HTTP请求。 例如： 1234567891011import Router from 'koa-router';import &#123;MovieService&#125; from '../Services/movieService';let movieController = new Router();let movieService = new MovieService();movieController.get('/movies',(ctx) =&gt; movieService.getMovieById(ctx));movieController.get('/movies/showing',(ctx) =&gt; movieService.getShowingMovies(ctx));movieController.get('/movies/coming',(ctx) =&gt; movieService.getComingMovies(ctx))export default movieController; services 业务层业务层用来编写业务代码，对控制层得到的http请求作出响应 例如： 123456789101112131415161718192021222324252627282930313233import Movie from '../Models/movieModel';class MovieService &#123; // 通过电影ID获取电影信息 async getMovieById(ctx) &#123; let movieId = ctx.request.query['movieId']; try &#123; let value = await Movie.findOne(&#123; where: &#123; movieId: movieId &#125; &#125;); let movieMes = value.dataValues; ctx.body = &#123; error_code: 0, data: &#123; movie: movieMes &#125; &#125;; &#125;catch(e) &#123; console.log(e); ctx.body = &#123; error_code: -100, data: &#123; mes: '指定参数movieId不存在' &#125; &#125;; &#125; &#125;&#125;export &#123;MovieService&#125; Models 模型模型代表一个存取数据的对象。用来对应数据库中的一个表实体。通过sequelize ORM框架来进行模型对象与数据库表之间的映射。之后，我们在业务层就可以直接通过操作该模型对象来操作数据库。 例如： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465import &#123;sequelize&#125; from '../Sequelize/Sequelize';import &#123;Sequelize,Movie&#125; from '../Entity/entities';Movie.init(&#123; MovieId: &#123; type: Sequelize.STRING, allowNull: false, primaryKey: true &#125;, MovieName: &#123; type: Sequelize.STRING, allowNull: false &#125;, MovieImgUrl: &#123; type: Sequelize.STRING, allowNull: false &#125;, MovieType: &#123; type: Sequelize.STRING, allowNull: false &#125;, Duration: &#123; type: Sequelize.INTEGER, allowNull: false &#125;, PlayType: &#123; type: Sequelize.STRING, allowNull: false &#125;, stage: &#123; type: Sequelize.STRING, allowNull: false &#125;, Score: &#123; type: Sequelize.FLOAT, allowNull: true &#125;, SourceArea: &#123; type: Sequelize.STRING, allowNull: false &#125;, ReleaseArea: &#123; type: Sequelize.STRING, allowNull: false &#125;, ReleaseDate: &#123; type: Sequelize.DATE, allowNull: false &#125;, Stars: &#123; type: Sequelize.STRING, allowNull: false &#125;, Details: &#123; type: Sequelize.STRING, allowNull: false &#125;,&#125;,&#123; sequelize, tableName: 'movie', createdAt: false, updatedAt: false&#125;)export default Movie; Entity 实体存放所有model对应的实体 12345678910const Sequelize = require('sequelize');const Model = Sequelize.Model;class Swiper extends Model &#123;&#125;;class Movie extends Model &#123;&#125;;class Time extends Model &#123;&#125;;class MovieHall extends Model &#123;&#125;;export &#123;Sequelize,Swiper,Movie,Time,MovieHall&#125;; Sequelize 数据库连接sequelize.ts 来进行数据库连接 123456import &#123;Sequelize&#125; from 'sequelize';import config from '../Config/config'const sequelize = new Sequelize(config.dataBase,config.userName,config.password,(config.options as object));export &#123;sequelize,config&#125;; config存放一些配置文件，例如数据库配置 123456789101112131415161718192021222324252627282930313233343536373839// 这是sequelize用来进行数据库连接的一些配置信息interface Options&#123; host: string; port?: number; dialect: string; pool?: &#123; max?: number; min?: number; idle?: number; acquire: number; &#125;&#125;interface Config &#123; dataBase: string; userName: string; password: string; options: Options;&#125;let config: Config = &#123; dataBase: 'moviedb', userName: 'root', password: 'zjb13777838499', options: &#123; host: 'localhost', port: undefined, dialect: 'mysql', pool: &#123; max: 5, min: 0, idle: 10000, acquire: 30000 &#125; &#125;&#125;export default config;]]></content>
      <categories>
        <category>TypeScript</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[TypeScript的常用类型探秘]]></title>
    <url>AngelLikeFairy%2F2019%2F10%2F23%2FTypeScript%E7%9A%84%E5%B8%B8%E7%94%A8%E7%B1%BB%E5%9E%8B%E6%8E%A2%E7%A7%98%2F</url>
    <content type="text"><![CDATA[基本注解类型注解使用 :TypeAnnotation 语法。类型声明空间中可用的任何内容都可以用作类型注解。 例如，在下面这个例子中，使用了变量、函数参数以及函数返回值的类型注解： 1234const num: number = 123;function identity(num: number): number &#123; return num;&#125; 类型系统JS原有的基本数据类型TypeScript支持JS具有的六种基本数据类型 null undefined boolean number string symbol 我们在声明变量的时候可以预先定义该变量的类型，使得之后定义的变量类型必须符合该类型 例如： 12345let num: number = 1;let str: string = '123';let bool: boolean = true;let u: undefined = undefined;let n: null = null; 值得注意的是： 默认情况下null和undefined（后面还会介绍到Never类型，它也是所有类型的子类型）是所有类型的子类型。也就是说我们可以把null和undefined赋值给任意类型的变量 例如： 12let num: number = undefined;let str: string = null; JS原有的复杂引用类型数组TypeScript像JavaScript一样可以操作数组元素。 有两种方式可以定义数组。 可以在元素类型后面接上 []，表示由此类型元素组成的一个数组： 1let arr: number[] = [1,2,3]; 那么，该数组不允许出现其他类型的项 12// Errorlet arr: number[] = [1,'nice',3] 当然，如果我们想要像js一样可以包含各种类型的数组，我们可以使用Any类型再在后面接上 []： 1let arr: any[] = [1,'nice',true]; 使用数组泛型 1let list: Array&lt;number&gt; = [1,2,3]; Objectobject表示非原始类型，也就是复杂引用类型。 1234567let obj: object = &#123; m: 1&#125;console.log(obj); // &#123;m:1&#125;let date: object = new Date();console.log(typeof date); // object 函数与JS一直，ts也可以使用函数声明和函数表达式来声明函数 例如： 123456789101112131415// 函数声明function test(v: string): void &#123; console.log(v);&#125;// 函数表达式（注意：这种写法其实经过了类型推断；因为，我们只是给匿名函数添加类型）let test = function(v: string): void &#123; console.log(v);&#125;// 函数表达式完整写法（手动给返回的函数添加类型）let test: (v: string) =&gt; void = function(v: string): void &#123; console.log(v);&#125; 注意：在 TypeScript 的类型定义中，=&gt; 用来表示函数的定义，左边是输入类型，需要用括号括起来，右边是输出类型。 值得注意的是,与js不同，js可以不用去管形参的个数和类型而向函数传递任意实参。但是 ts规定输入多余的（或者少于要求的）参数，是不被允许的 123456789function test(v: string|number): void &#123; console.log(v);&#125;// OKtest('nice');// Error (应有 1 个参数，但获得 2 个。)test('nice',1); 可选参数我们在接口中可以使用可选属性，那么，类似的，在函数中，我们也可以使用可选参数 12345function test(k: string,v?: number): void&#123; console.log(k,v); // 'hello' 'undefined'&#125;test('hello'); 值得注意的是，可选参数必须在确定参数的后面 这点很容易想清楚，如果可选参数在确定参数的前面，因此，我们无法知道可选参数是不是一定传入了实参，因此，会造成实参与形参匹配的混乱 123456// Errorfunction test(v?: number,k: string): void&#123; console.log(k,v); // 'hello' 'undefined'&#125;test('hello'); 参数默认值在ES6中，我们允许为参数添加默认值，就像这样 1234function test(k,v=1) &#123; console.log(k,v); // 'k' 1&#125;test('k'); 如果我们没有为相应的形参传入实参，那么形参就会默认使用默认值 类似的，ts也具有默认参数值。另外，我们在之前提到的可选参数必须放在确定参数后面的限制在默认参数这里也就没有了（但是我们依旧需要传入undefined来匹配这个可选参数）。 例如： 123456789function test(k: string = 'k',v: number): void &#123; console.log(k,v);&#125;// OKtest(undefined,1); // 'k' 1// Errortest(1); 不定参数类似ES6不定参数的概念，在ts中，我们也可以使用不定参数 记住，不定参数必须在函数所有命名参数的末尾 12345function test(k: string, ...arr: any[]) &#123; console.log(k,arr); // 'k' [ 1, 2, 3, 4 ]&#125;test('k',1,2,3,4); 其他复杂引用类型包括基本包装类型、Error、Date、RegExp等 12345let s: String = new String(1); // [String: '1']let b: Boolean = new Boolean(1); // [Boolean: true]let e: Error = new Error('Error occurred'); // Error: Error occurredlet d: Date = new Date(); // 2019-10-24T14:24:24.745Z let r: RegExp = /[a-z]/; // /[a-z]/ TypeScript提供的一些类型任意值 Any有时候我们在定义的时候可能不知道该变量会在之后是什么类型。又或者，我们想要在定义变量之后可以修改该变量的类型。那么，我们就可以使用Any类型。 任意值（Any）用来表示允许赋值为任意类型。 例如： 123let a: any;a = 1;a = 'hello'; 可能会有点匪夷所思，但是事实上： 在任意值上访问和操作任何属性和方法都是允许的，哪怕该属性和方法从未定义过。 例如： 12let a: any = 1;console.log(a.num); // undefined 如果照着js的思维，那么引擎在执行a.num时，会执行如下操作： 创建a的基本包装类型对象，也就是new Number(1); 访问a.num（a的基本包装类型对象中的num属性，当然没有该属性，那么返回undefined） 销毁该实例（生命周期只会存在一行） 这样来看，似乎说的通，但是对于undefined和null呢？ 12let a: any = undefined;console.log(a.num); 我们利用ts-node来运行该段代码，我们会得到如下输出结果 Cannot read property ‘num’ of undefined 因此，我们可以看到虽然在任意值上访问未被定义的属性是允许的，但并不代表可以得到正确的输出。 我们将该ts文件编译成js文件得到如下： 123var a = undefined;console.log(a.number);// TypeError: Cannot read property 'number' of undefined 我们编译一下该js文件就会得到如上的错误。 因此，对于那些使用任意值访问未定义的属性不会产生错误的值一般是对象或者是可以转化为基本包装类型的基本类型值 我个人认为（因为网上找寻资料未果），我们尽量避免在任意值上操作其本来就不具有的属性和方法。因为，尽管其在TypeScript语法中不会报错，但是当其编译成js代码后可能就会出现错误。 另外，我们知道TypeScript是JS语法的超集。在ts文件里写js语法是没有任何问题的。 在js中，我们定义的变量可以是任何类型。因此，在ts中，如果我们在变量定义时没有指定其类型，那么它就会被视为Any（任意值）类型 123let str;str = 1;str = 'str'; 等同于 123let str: any;str = 1;str = 'str'; 空值 Void我们可以用void来表示空值。在某种程度上,Void类型就像是与Any类型相反，它表示没有任何类型 在c和java中，我们就经常使用void来表示一个函数没有返回值。同样，TypeScript也是如此： 123456function test(v: number): void&#123; console.log(v); // 没有任何返回值&#125;test(1); // 1 声明一个类型为void类型的变量并没有什么实际的意义。因为，我们只能为其赋予undefined和null（undefined和null是所有类型的子类型），仅此而已。 1let v: void = undefined; 因此，我们只需要在函数没有任何返回值的时候使用void的类型即可 Never类型Never类型表示那些永远不会存在的值。与void类型表示空值不同（void表示一个函数没有返回值），never类型用来表示一个函数根本不可能会有返回值 例如： 函数一直无限运行下去，不会有返回值 12345function test(): never&#123; while(true) &#123; &#125;&#125; 函数抛出错误，不会有返回值 123function test(): never&#123; throw new Error('error');&#125; 另外,never类型与null和undefined类型是任何类型的子类型，因此也能赋值给任何类型。但是，没有类型是它的子类型，也就是说只有never类型只能被另一个never类型所赋予。 元组 Tuple元组类型用来表示给定已知元素类型和数量的数组，各元素类型不必相同。 使用 :[typeofmember1, typeofmember2] 能够为元组添加类型注解 例如: 1234567let t: [string,number];t = ['123',123];console.log(t); // ['123',123]console.log(typeof t[0],typeof t[1]); // string number// Errort = [123,'123']; 我们可以使用解构来配合元组进行使用 12345let t: [string,number];t = ['123',123];let [m,n] = t;console.log(m,n); // '123' 123console.log(typeof m,typeof n); // string number 值得注意的是： 当在一个元组中访问一个越界的元素时，该元素的类型会被限制为元组中每个类型的联合类型 也就是说，在上述t这个元组中，当我们访问一个越界元素时，该元素的类型只能是string或者是number 12345678let t: [string,number];t = ['123',123];t.push('nice');t.push(5);console.log(t); // ['123',123,'nice',5]// Error（类型“true”的参数不能赋给类型“string | number”的参数）t.push(true); 枚举 Enum枚举（Enum）类型用于取值被限定在一定范围内的场景，比如一周只能有七天，颜色限定为红绿蓝等。 12enum Week &#123;Sun,Mon,Tue,Wed,Thu,Fri,Sat&#125;enum Colors &#123;red,green,blue&#125; 现在，让我们试着输出一下这些枚举变量 1console.log(Colors); // &#123; '0': 'red', '1': 'green', '2': 'blue', red: 0, green: 1, blue: 2 &#125; 我们可以发现，枚举类型变量实际上是一个对象。 枚举成员会被赋值为从 0 开始递增的数字，同时也会对枚举值到枚举名进行反向映射 我们查看一下被编译的js文件，我们可以看到枚举类型被编译为： 123456var Colors;(function (Colors) &#123; Colors[Colors["red"] = 0] = "red"; Colors[Colors["green"] = 1] = "green"; Colors[Colors["blue"] = 2] = "blue";&#125;)(Colors || (Colors = &#123;&#125;)); 我们来看下这段代码 Colors[Colors[“red”] = 0] = “red”; 很巧妙的写法，在[Colors[“red”] = 0]这里，首先将Colors对象的”red”属性赋值0。又因为赋值表达式的值为等式右边的值，因此，后面的赋值又会变为Colors[0]=”red”。这样，一个赋值表达式就可以达到两个表达式的效果。 当然，除了默认从0开始为元素编号，我们也可以手动为成员指定自己的编号 1234567891011121314// 部分指定枚举成员(未手动赋值的枚举项会接着上一个枚举项递增。)enum Colors &#123;red = 1, green, blue&#125;;console.log(Colors); // &#123; '1': 'red', '2': 'green', '3': 'blue', red: 1, green: 2, blue: 3 &#125;enum Colors &#123;red, green = 2, blue&#125;;console.log(Colors); // &#123; '0': 'red', '2': 'green', '3': 'blue', red: 0, green: 2, blue: 3 &#125;enum Colors &#123;red , green = 2 , blue , black = 7&#125;console.log(Colors); // &#123; '0': 'red', '2': 'green', '3': 'blue', '7': 'black', red: 0, green: 2, blue: 3 , black: 7&#125;// 全部指定enum Colors &#123;red = 1, green = 3, blue = 5&#125;console.log(Colors); // &#123; '1': 'red', '3': 'green', '5': 'blue', red: 1, green: 3, blue: 5 &#125; 接口 interface什么是接口在面向对象的语言中，例如java。在java中，接口中的所有方法都是抽象的，这些方法都需要使用接口的类来实现 在ts中，接口是一个非常灵活的概念，除了可用于对类的一部分行为进行抽象，也常用于对对象的形状进行描述 接口的最基础使用我们使用interface来声明一个接口，被声明的接口一般首字母大写。 注意: 接口中的每一个属性的类型声明语句最好以分号（;）结尾 例如，我们声明一个Person接口 12345678910111213interface Person&#123; name: string; age: number; area: string;&#125;let ming: Person = &#123; name: 'ming', age: 18, area: 'zh'&#125;console.log(ming); // &#123; name: 'ming', age: 18, area: 'zh' &#125; 另外，类型检查器不会去检查属性的顺序，只要相应的属性存在并且类型也是对的就可以。 因此，以下使用Person接口来描述的对象也是允许的。 12345let lee: Person = &#123; age: 19; name: 'lee'; area: 'zh';&#125; 但是，我们需要记住，使用接口作为类型定义的变量形状与接口的形状必须保持一致（属性顺序可以调换，但是属性不能多也不能少） 例如：以下使用Person接口定义的变量是不被允许的 123456789101112// Errorlet ming: Person = &#123; name: 'ming'&#125;// Errorlet lee: Person = &#123; name: 'lee', age: 19, area: 'zh', city: 'hz'&#125; 可选属性有时候，接口里的属性不全是必需的，例如Person接口中的area属性 那么，我们可以在接口中的属性名后面加上?来表示这是一个可选属性 例如： 1234567891011121314151617181920interface Person&#123; name: string; age: number; area?: string;&#125;// area属性现在是可选属性了// OKlet ming: Person = &#123; name: 'ming', age: 18, area: 'zh'&#125;// OKlet lee: Person = &#123; name: 'lee', age: 18&#125; 只读属性我们希望有些属性在创建的时候被赋值之后就无法再被修改，那么我们就可以使用readonly将该属性定义为只读属性 我们可以在属性名前用 readonly来指定只读属性 例如： 12345678910111213141516171819interface Person &#123; readonly name: string; age: number; area: string;&#125;let ming: Person = &#123; name: 'ming', age: 18, area: 'zh'&#125;// name属性现在无法被修改了// OKming.age = 19;// Errorming.name = 'wang'; 任意属性利用接口的属性可索引的特性，我们可以创建一个拥有任意属性的接口 例如： 123456789101112interface Person &#123; readonly name: string; age: number; area?: string; [propName: string]: any;&#125;let ming: Person = &#123; name: 'ming', age: 18, city: 'hz' // 接口中预先未定义的属性&#125; 需要注意的是： 虽然定义了任意属性，但是接口中已有的确定的属性必须在声明的对象中表示 比如这样声明的变量是不被允许的 12345// Errorlet lee: Person = &#123; age: 19, city: 'hz'&#125; 另外，一旦定义了任意属性，那么该接口中的其他确定属性和可选属性的类型必须是该任意属性定义的属性类型的子集 也就是说，像下面这样的情况是不被允许的 12345678// Errorinterface Person &#123; readonly name: string; age: number; area?: string; // 因为定义的任意属性的类型为string，但是age属性的number类型并不在string类型的子集中（string类型的子集包括string,undefined,number,never类型） [propName: string]: string;&#125; 因此，如果要定义任意属性，那么任意属性的类型最好为任意值（Any）类型 联合类型联合类型的简单介绍有时候，我们希望一个变量可以在字符串类型和number类型之间相互转换；又或者，我们不确定某个变量的具体类型，只能知道其是string类型或者是number类型。那么，我们就可以使用联合类型来声明一个变量 我们使用’|’来联合两个类型 例如： 1234let v: string|number;v = '123';v = parseInt(v);console.log(v,typeof v); // 123 number 联合类型的属性和方法访问我们要始终记住一点： 当 TypeScript 不确定一个联合类型的变量到底是哪个类型的时候，我们只能访问此联合类型的所有类型里共有的属性或方法 这段话是什么意思呢？ 如果，ts可以确定一个联合类型的变量是什么类型，那么也就无关上述的限制了。这个被推断得到的类型只能访问和操作其所具有的属性和方法 例如： 12345678let v: string|number;v = '123';// OK (变量v被推断为string类型，它具有length属性) console.log(v.length); // 3v = 123;// Error （这时候变量v被推断为number类型，它不具有length属性）console.log(v.length); 上述的规则，其实是适用于下述的场景（也就是ts无法确定这个联合类型的变量究竟是什么类型） 123456789function test(v: string|number): void&#123; // 在函数声明的时候，ts无法推断出v究竟是联合类型中的哪一个类型。因此，v只能访问和操作其所有具有的属性和方法 // OK console.log(v.toString()); // Error console.log(v.length);&#125; 最基础的类型推论TypeScript里，在有些没有明确指出类型的地方，类型推论会帮助提供类型。 来看一些例子 1234567let u = undefined; // undefined类型let n = null; // null类型let str = '123'; // string类型let num = 123; // number类型let bool = true; // boolean类型let obj = &#123;v:1&#125;; // object类型let func = function k() &#123;&#125;; // object类型 我们可以看到，如果在ts中没有为变量指定类型，那么ts的类型推断将会按照js中的类型进行类型指定。 注意是指定，这也意味着，在后续，ts不允许我们将变量修改为其他类型 123456let str = '123';// 类型推论变量str为字符串类型，那么之后该变量的类型不允许被修改// Errorstr = 123; 另外，如果一个变量只是被声明（没有指定类型），而没有被定义。那么，该变量则会被推断为任意值（Any）类型 12345// OKlet str;str = '123';str = 123; 相当于 123let str: any;str = '123';str = 123; 类型断言类型断言有如下两种语法： 尖括号语法 123let a: any = 123;(&lt;string&gt;a) = '123';console.log(typeof a); // string as语法 123let a: any = 123;(a as string) = '123';console.log(typeof a); // string ts允许我们为类型进行断言从而覆盖编译器的类型推断结果。 也就是说， 通过类型断言，我们可以为一个变量指定一个类型。 是不是很奇怪？我们不是在定义的时候就可以指定它的类型了吗？没错，是的。那是一开始就知道了它的具体类型，但是，如果一开始设定的不是基本类型和一些object,数组之类的类型，而是any类型。 那么，我们可能不知道他会在后面变化为了什么类型，但是ts的类型推论可以推论出这是什么类型。 而类型断言，则是允许我们来断定这个类型是什么类型。某种程度上，在这一刻我们超越了编译器。 类型断言通常会发生在你清楚地知道一个实体具有比它现有类型更确切的类型。 例如： 1234let m: any;m = 123; // 类型推论会推论该类型为number类型(&lt;string&gt;m) = '123'; // 现在我们断言m是string类型console.log(typeof m); // string 是不是觉得好像没什么用，那么再来一个更为实际的应用（我们之前在联合类型写过的一个函数）, 123456789function test(v: string|number): void&#123; // 在函数声明的时候，ts无法推断出v究竟是联合类型中的哪一个类型。因此，v只能访问和操作其所有具有的属性和方法 // OK console.log(v.toString()); // Error console.log(v.length);&#125; 我们无法在被声明联合类型的变量访问联合类型不公有的属性和方法。但是，利用类型断言就可以将一个联合类型的变量指定更为具体的类型 123456789101112function test(v: string|number): void &#123; if(typeof v === 'string') &#123; // 如果我们传入的实参为string类型，那么我们断言该类型为string类型，那么此时v就是string类型，因此也就可以调用length属性了 console.log((&lt;string&gt;v).length); &#125; else &#123; console.log(v); &#125;&#125;test('str'); // 3test(1); // 1]]></content>
      <categories>
        <category>TypeScript</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[ts新手的vscode环境配置]]></title>
    <url>AngelLikeFairy%2F2019%2F10%2F22%2Fts%E6%96%B0%E6%89%8B%E7%9A%84vscode%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE%2F</url>
    <content type="text"><![CDATA[安装TypeScript通过npm/cnpm来安装TypeScript的命令行工具 cnpm i -g typescript 创建TypeSscript项目配置文件tsconfig.json概述如果一个目录下存在一个tsconfig.json文件，那么它意味着这个目录是TypeScript项目的根目录。 tsconfig.json文件中指定了用来编译这个项目的根文件和编译选项。 一个项目可以通过以下方式之一来编译： 使用tsconfig.json不带任何输入文件的情况下调用tsc，编译器会从当前目录开始去查找tsconfig.json文件，逐级向上搜索父目录。 不带任何输入文件的情况下调用tsc，且使用命令行参数–project（或-p）指定一个包含tsconfig.json文件的目录。当命令行上指定了输入文件时，tsconfig.json文件会被忽略。 创建与配置 创建tsconfig.json文件 tsc –init 修改配置项 因为ts文件会被编译生成一个js文件。因此，为了文件结构的清晰。我们可以创建ts源文件夹和js输出文件夹。并在tsconfig.json文件修改配置项 以下为我的配置项 1234567891011121314&#123; "compilerOptions": &#123; "target": "es5", "module": "commonjs", "sourceMap": true, "strict": true, "outDir": "./js", "rootDir": "./ts", "noImplicitAny": false, "strictNullChecks": false, "alwaysStrict": false, "esModuleInterop": true &#125;&#125; 更多配置项信息请查看TypeScript官方文档 创建ts文件，并编写ts程序我们在ts文件夹中新建一个hello.ts，并键入如下ts程序 12let str: string = '123';console.log(str); 自动编译我们可以采取两种方式来进行自动编译 命令行 tsc –watch / tsc -w 在监视模式下运行编译器。会监视输出文件，在它们改变时重新编译。 菜单栏 我们可以在vscode菜单栏中点击 终端 -&gt; 运行任务 可以看到两个可选项 tsc:build （进行一次编译） tsc:watch （监测ts文件的改动进行实时编译） 这样，我们既可以在js文件夹中找到同名的编译好的js文件 执行ts文件我们可以利用ts-node这个npm包来帮助我们执行ts文件，而不用预先编译ts文件为js文件 我们可以这样来执行 npx ts-node ./ts/hello.ts 热加载ts文件执行nodemon监听生成的Js文件我们不希望每次在修改ts文件之后都要重新进行ts-node来执行。因此，我想到了利用tsc -w来监视ts文件的变动，然后用nodemon来监视ts生成的js文件的变动。 因此，我们可以借助concurrently这个npm包来帮助我们同时运行多个命令 安装nodemon cnpm i nodemon -D 在package.json添加启动命令 “start”: “concurrently &quot; tsc -w&quot; &quot;nodemon js/hello.js&quot; “ 因为我们要在双引号中还要使用双引号，所以要使用转义符 之后我们在执行npm start的时候，修改ts文件的时候就可以看到执行结果的热更新了 监听ts源文件1&#123;"watch-server":"nodemon --watch ./ts/app.ts -e ts,tsx --exec ts-node ./ts/app.ts"&#125; 编写node程序Node.js 不是内置对象的一部分，如果想用 TypeScript 写 Node.js，则需要引入第三方声明文件： cnpm i @types/node -D]]></content>
      <categories>
        <category>TypeScript</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[浏览器的几种存储方式]]></title>
    <url>AngelLikeFairy%2F2019%2F10%2F21%2F%E6%B5%8F%E8%A7%88%E5%99%A8%E7%9A%84%E5%87%A0%E7%A7%8D%E5%AD%98%E5%82%A8%E6%96%B9%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[cookiecookie的介绍移步另一篇blog cookie与session webStorage由于cookie的存储的存储数据不能超过4k，并且每次请求都会携带在请求头中，对于请求性能会产生影响。因此，为了更大数据的存储，降低对请求性能的影响以及安全方面的考虑，html5引入了webStorage来进行客户端的存储 与cookie不同，webStorage的存储限制更大（至少5M） Web存储按来源进行。所有页面，如果是同源的话，都可以存储和访问相同的数据。（因此,webStorage也存在跨域问题） localStoragelocalStorage保存的数据会长期存在，只要你不删除，那么他就会一直存在。 localStorage的使用localStorage保存的数据，以“键值对”的形式存在。也就是说，每一项数据都有一个键名和对应的值。所有的数据都是以文本格式保存。 localStorage对象提供4个API来进行存储的相关操作 localStorage.setItem(key,value) 存储数据 localStorage.getItem(key) 读取某一项 localStorage.removeItem(key) 删除某一项 localStorage.clear() 清空所有数据 localStorage存储对象需要注意的是，在webStorage中，名称/值对始终存储为字符串。 因此，我们会发现，当你存储其他类型的值时，键值对都会被强制转型为字符串 例如： 123localStorage.setItem('a',1);localStorage.setItem('b',undefined);localStorage.setItem('c',&#123;c:1&#125;); 当我们使用存储api进行存储后，打开浏览器的webStorage选项，我们可以看到如下： 我们可以来查看一下这三个键值的类型 123console.log(typeof localStorage.getItem('a')); // stringconsole.log(typeof localStorage.getItem('b')); // stringconsole.log(typeof localStorage.getItem('c')); // string 我们会发现，无论哪种类型的值确实是都被存为了String类型，而且是通过String()转型函数的。因为,toString()方法不能转型undefiend和null（这里插一句，因为toString()方法只有对象才能够具有和使用，而Number,Boolean在读取的时候会作为基本包装类型（只存在一行中）所以具有toString()方法）。 我们可以看到，基本类型值转换为字符串我们还可以通过转型函数来将他们转换回来。那么对于对象呢？其实，我们可以通过JSON序列化来存入JSON字符串，之后再通过JSON解析的方式来进行存储和读取 12345678let obj = &#123;m:1&#125;;let arr = [1,2,3];localStorage.setItem('obj',JSON.stringify(obj));localStorage.setItem('arr',JSON.stringify([1,2,3]));console.log(JSON.parse(localStorage.getItem('obj'))); // &#123;m:1&#125;console.log(JSON.parse(localStorage.getItem('arr'))); // [1,2,3] 这时我们可以看到浏览器的webStorage存储的键值是JSON字符串，因此，我们也可以通过JSON解析成功得到对象 但是，这种方法无法处理函数对象。因为JSON不支持函数。 localStorage的使用场景我们可以使用localStorage来作为本地缓存。比如说在网页在首屏渲染的时候，我们可以将一些更新不频繁的文件或静态资源储存在localStorage来加快首屏渲染速度 sessionStoragesessionStorage 与 localStorage 相似，不同之处在于 localStorage 里面存储的数据没有过期时间设置，而存储在 sessionStorage 里面的数据在页面会话结束时会被清除。 页面会话在浏览器打开期间一直保持，并且重新加载或恢复页面仍会保持原来的页面会话。而在新标签或窗口打开一个页面时会在顶级浏览上下文中初始化一个新的会话，这点和 session cookies 的运行方式不同。 sesseionStorage的api与localStorage一致 1234567891011// 保存数据到 sessionStoragesessionStorage.setItem('key', 'value');// 从 sessionStorage 获取数据let data = sessionStorage.getItem('key');// 从 sessionStorage 删除保存的数据sessionStorage.removeItem('key');// 从 sessionStorage 删除所有保存的数据sessionStorage.clear(); IndexedDB简单介绍由于webStorage仍然具有一些缺点： 随着web应用程序的不断发展,5M的存储大小对于一些大型的web应用程序来说有些不够 web Storage只能存储string类型的数据.对于Object类型的数据只能先用JSON.stringify()转换一下在存储. 因此，就又有了浏览器数据库存储这个概念，也就是IndexedDB IndexedDB 是一种在用户浏览器中持久存储数据的方法。它允许您不考虑网络可用性，创建具有丰富查询能力的可离线 Web 应用程序。IndexedDB 对于存储大量数据的应用程序（例如借阅库中的 DVD 目录）和不需要持久 Internet 连接的应用程序（例如邮件客户端、待办事项列表或记事本）很有用。 基本概念 IndexedDB 数据库使用 key-value 键值对储存数据. values 数据可以是结构非常复杂的对象，key可以是对象自身的属性。你可以对对象的任何属性创建索引（index）以实现快速查询和列举排序。key可以是二进制对象。 IndexedDB 是事务模式的数据库. 任何操作都发生在事务(transaction)中。 IndexedDB API提供了索引(indexes)、表(tables)、指针(cursors)等等，但是所有这些必须是依赖于某种事务的。因此，你不能在事务外执行命令或者打开指针。事务(transaction)有生存周期，在生存周期以后使用它会报错。并且，事务(transaction)是自动提交的，不可以手动提交。 当用户在不同的标签页同时打开Web应用的两个实例时，这个事务模型就会非常有用。如果没有事务操作的支持，这两个实例就会互相影响对方的修改。 The IndexedDB API 基本上是异步的。 IndexedDB的API不通过return语句返回数据，而是需要你提供一个回调函数来接受数据。执行API时，你不以同步（synchronous）方式对数据库进行“存储”和“读取”操作，而是向数据库发送一个操作“请求”。当操作完成时，数据库会以DOM事件的方式通知你，同时事件的类型会告诉你这个操作是否成功完成。这个过程听起来会有些复杂，但是里面是有明智的原因的。这个和XMLHttpRequest请求是类似的 IndexedDB在结果准备好之后通过DOM事件通知用户。 DOM事件总是有一个类型（type）属性（在IndexedDB中，该属性通常设置为success或error）。DOM事件还有一个目标（target）属性，用来告诉事件是被谁触发的。通常情况下，目标（target）属性是数据库操作生成的IDBRequest。成功（success）事件不弹出提示并且不能撤销，错误（error）事件会弹出提示且可以撤销。这一点是非常重要的，因为除非错误事件被撤销，否则他们会终止所在的任何事务。 IndexedDB是面向对象的。 传统的关系型数据库，你需要用到二维表来存储数据集合（每一行代表一个数据，每一列代表一个属性），indexedDB有所不同，它要求你为一种数据创建一个对象仓库(object Store)，只要这种数据是一个JavaScript对象即可。每个对象仓库都有一个索引(index)集合以方便查询和迭代遍历。 IndexedDB遵循同源（same-origin）策略 “源”指脚本所在文档URL的域名、应用层协议和端口。每一个“源”都有与其相关联的数据库。在同一个“源”内的所有数据库都有唯一、可区别的名称。 基本使用打开数据库123456789const req = indexedDB.open('firstDB');req.addEventListener('success',()=&gt;&#123; console.log('数据库连接成功');&#125;)req.addEventListener('error',()=&gt;&#123; console.log('数据库连接失败');&#125;) open 请求不会立即打开数据库或者开始一个事务。 对 open() 函数的调用会返回一个我们可以作为事件来处理的包含 result（成功的话）或者错误值的 IDBOpenDBRequest 对象。在 IndexedDB 中的大部分异步方法做的都是同样的事情 - 返回一个包含 result 或错误的 IDBRequest 对象。open 函数的结果是一个 IDBDatabase 对象的实例。 在通过对indexedDB.open()方法拿到一个数据库对象IDBOpenDBRequest我们可以通过监听这个对象的success事件和error事件来执行相应的操作. 该 open 方法接受第二个参数，就是数据库的版本号。数据库的版本决定了数据库架构，即数据库的对象仓库（object store）和他的结构。如果数据库不存在，open 操作会创建该数据库，然后 onupgradeneeded 事件被触发，你需要在该事件的处理函数中创建数据库模式。如果数据库已经存在，但你指定了一个更高的数据库版本，会直接触发 onupgradeneeded 事件，允许你在处理函数中更新数据库模式。 创建对象仓库连接到数据库之后，我们就可以创建对象仓库来存储数据。对象仓库的概念类似于Mysql中的表的概念 要创建一个对象仓库必须在upgradeneeded事件中,而upgradeneeded事件只会在版本号更新的时候触发.这是因为indexedDB API中不允许数据库中的数据仓库在同一版本中发生变化 另外，我们使用createObjectStore()方法来创建对象仓库。 createObjectStore()方法接受两个参数,第一个是对象仓库的名字,在同一数据库中,仓库名不能重复.第二个是可选参数.用于指定数据的主键,以及是否自增主键. 1234567891011const req = indexedDB.open('firstDB',2);req.addEventListener('error',()=&gt;&#123; throw new Error('数据库连接失败');&#125;)req.addEventListener('upgradeneeded',function(e) &#123; let db = e.target.result; db.createObjectStore('Users',&#123;keyPath:'userId',autoIncrement:false&#125;); console.log('创建对象仓库成功');&#125;) 创建事务我们需要创建事务来确保一个数据库操作要么全部成功要么全部失败。比如，我们在一个操作中，要修改多条数据。如果前面几条成功了，最后一条失败了。那么事务的存在就会使得前面所有的成功修改的操作失效，放弃数据修改 1const tx = db.transaction('Users','readwrite'); 我们使用transaction()来创建一个事务.transaction()接受两个参数,第一个是你要操作的对象仓库名称,第二个是你创建的事务模式.传入 readonly时只能对对象仓库进行读操作,无法写操作.可以传入readwrite进行读写操作. 操作数据我们可以使用以下四种api来进行数据的操作 add() : 增加数据。接收一个参数，为需要保存到对象仓库中的对象。 put() : 增加或修改数据。接收一个参数，为需要保存到对象仓库中的对象。 get() : 获取数据。接收一个参数，为需要获取数据的主键值。 delete() : 删除数据。接收一个参数，为需要获取数据的主键值 总结到这里，我们就可以创建一个数据库以及对象仓库来进行数据的存储操作了。 以下是完整代码及解释 创建数据库和对象仓库 12345678910111213141516// 连接数据库，如果没有该数据库则创建const req = indexedDB.open('firstDB',1);// 监听数据库连接失败处理程序req.addEventListener('error',()=&gt;&#123; throw new Error('数据库连接失败');&#125;)// 在版本更新阶段阶段对象仓库（类似于mysql中的表）req.addEventListener('upgradeneeded',function(e) &#123; // 得到数据库对象 let db = e.target.result; // 创建对象仓库 db.createObjectStore('Users',&#123;keyPath:'userId',autoIncreament:false&#125;);&#125;) 添加数据 12345678910111213141516171819202122232425const req = indexedDB.open('firstDB');req.addEventListener('success',function(e) &#123; // 获得数据库对象 let db = e.target.result; // 创建事务，transaction() 方法接受两个参数（一个是可选的）并返回一个事务对象。第一个参数是事务希望跨越的对象存储空间的列表。如果你希望事务能够跨越所有的对象存储空间你可以传入一个空数组。如果你没有为第二个参数指定任何内容，你得到的是只读事务。如果你想写入数据，你需要传入 "readwrite" 标识。 const tx = db.transaction(['Users'],'readwrite'); // 取出对象仓库 const store = tx.objectStore('Users'); // 添加数据 let addReq = store.add(&#123; userId: 1, name: 'xiaoMing', age: 18, area: 'zhejiang' &#125;) // 监听数据是否添加成功 addReq.addEventListener('success',()=&gt;&#123; console.log('数据保存成功'); &#125;)&#125;)]]></content>
      <categories>
        <category>浏览器</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[cookie与session]]></title>
    <url>AngelLikeFairy%2F2019%2F10%2F20%2Fcookie%E4%B8%8Esession%2F</url>
    <content type="text"><![CDATA[cookie什么是cookiecookie 是服务器发送到用户浏览器并保存在本地的一小块数据，它会在浏览器下次向同一服务器再发起请求时被携带并发送到服务器上。通常，它用于告知服务端两个请求是否来自同一浏览器，如保持用户的登录状态。 我们知道http协议是无状态协议，也就是说服务器不知道是哪个浏览器在访问它。但是，利用cookie我们就可以使得http协议记录稳定的状态信息 cookie主要用于以下三个方面： 会话状态管理（如用户登录状态、购物车、游戏分数或其他需要记录的信息） 个性化设置（如用户自定义设置、主题等） 浏览器行为跟踪（如跟踪分析用户行为等） Cookie曾一度用于客户端数据的存储，因当时并没有其它合适的存储办法而作为唯一的存储手段，但现在随着现代浏览器开始支持各种各样的存储方式，Cookie渐渐被淘汰。由于服务器指定Cookie后，浏览器的每次请求都会携带Cookie数据，会带来额外的性能开销（尤其是在移动环境下）。新的浏览器API已经允许开发者直接将数据存储到本地，如使用 Web storage API （本地存储和会话存储）或 IndexedDB 。 cookie的创建当服务器收到HTTP请求时，服务器可以在响应头里面添加一个Set-Cookie选项。浏览器收到响应后通常会保存下Cookie，之后对该服务器每一次请求中都通过Cookie请求头部将Cookie信息发送给服务器。另外，Cookie的过期时间、域、路径、有效期、适用站点都可以根据需要来指定。 服务器使用Set-Cookie响应头部向用户代理（一般是浏览器）发送Cookie信息。 使用node.js来为请求创建cookie 123456789const http = require('http');http.createServer((req,res)=&gt;&#123; res.setHeader('Content-Type','text/html'); res.setHeader('Set-Cookie',['name=zhangsan', 'userId=123456']); res.end('set-cookie');&#125;).listen(3000,()=&gt;&#123; console.log('Port 3000 is listening');&#125;) 上述程序为http://localhost:3000请求设置了Set-Cookie响应头。所有的cookie键值对被存放在一个数组中。 响应头部分信息如下： 12345678Response HeadersConnection: keep-aliveContent-Length: 10Content-Type: text/htmlDate: Sun, 20 Oct 2019 06:11:45 GMTSet-Cookie: name=zhangsanSet-Cookie: userId=123456 设置完毕之后，该浏览器再对该服务器发送的每一次新请求都会携带保存的cookie信息通过Cookie请求头部发送给服务器 请求头部分信息如下： 1234Accept: text/html,application/xhtml+xml,Cache-Control: no-cacheConnection: keep-aliveCookie: _ga=GA1.1.608774072.1562924708; type=ninja; language=javascript; name=zhangsan; userId=123456 cookie的有效期会话期cookie会话期Cookie是最简单的Cookie：浏览器关闭之后它会被自动删除，也就是说它仅在会话期内有效。会话期Cookie不需要指定过期时间（Expires）或者有效期（Max-Age）。需要注意的是，有些浏览器提供了会话恢复功能，这种情况下即使关闭了浏览器，会话期Cookie也会被保留下来，就好像浏览器从来没有关闭一样。 我们可以注意到，当cookie是会话期cookie的时候（也就是只存在于一次会话期），其Expires字段就会被设置为session(会话存储)。 现在，我们来验证下会话期cookie是否在浏览器关闭后就会被自动删除，同时我们需要重新修改一下之前的程序，使得这次可以判断浏览器是否携带了cookie 12345678910111213141516const http = require('http');http.createServer((req,res)=&gt;&#123; if(req.headers.cookie)&#123; res.setHeader('Content-Type','text/html;charset=utf-8;'); res.end('浏览器携带了cookie'); &#125; else &#123; console.log('浏览器没有携带cookie信息，那么我们为其设置cookie信息'); res.setHeader('Set-Cookie',['name=zhangsan','userId=123456']); res.setHeader('Content-Type','text/html;charset=utf-8;'); res.end('服务器设置了cookie'); &#125;&#125;).listen(3000,()=&gt;&#123; console.log('Port 3000 is listening');&#125;) 现在，我们关闭浏览器之后重新打开并访问http:localhost:3000我们可以发现服务器端控制台输出： 12// 浏览器没有携带cookie信息，那么我们为其设置cookie信息// 浏览器携带了cookie 为什么会输出这样呢？而不是仅仅只输出第一句呢？其实是因为浏览器会默认请求两次，一次是请求该url也就是http://localhost:3000;而另一次，则是请求该网站的logo(favicon.ico) 我们可以查看chrome中的network，我们就可以发现请求http://localhost:3000时的请求头没有携带cookie，因此服务端为其设置了cookie；然后在请求favicon.ico的时候就携带上了刚刚设置的cookie Cookie: name=zhangsan; userId=123456 请求http://localhost:3000（没有Cookie请求头） 请求favion.ico（有Cookie请求头） 因此，我们验证了会话期cookie在浏览器被关闭后就会被自动删除 持久性cookie和关闭浏览器便失效的会话期Cookie不同，持久性Cookie可以指定一个特定的过期时间（Expires）或有效期（Max-Age）。 例如： Set-Cookie: id=a3fWa; Expires=Wed, 21 Oct 2015 07:28:00 GMT; 我们可以修改之前的设置cookie程序，来设置cookie的同时并设置有效期（单位为毫秒） 1234567891011121314151617const http = require('http');http.createServer((req,res)=&gt;&#123; if(req.headers.cookie)&#123; res.setHeader('Content-Type','text/html;charset=utf-8;'); console.log('浏览器携带了cookie'); res.end('浏览器携带了cookie'); &#125; else &#123; console.log('浏览器没有携带cookie信息，那么我们为其设置cookie信息'); res.setHeader('Set-Cookie',['name=zhangsan;max-age=100000;','userId=123456;max-age=200000;']); res.setHeader('Content-Type','text/html;charset=utf-8;'); res.end('服务器设置了cookie'); &#125;&#125;).listen(3000,()=&gt;&#123; console.log('Port 3000 is listening');&#125;) 这时候，我们可以看到响应头的Set-cookie字段会添加上每一个设置的cookie的有效期 12Set-Cookie: name=zhangsan;max-age=100000Set-Cookie: userId=123456;max-age=200000 这时候，我们关闭浏览器，再重新打开并访问http://localhost:3000，我们可以发现服务器端控制台会输出： 12// 浏览器携带了cookie// 浏览器携带了cookie 备注：输出两次的原因在上文提到过，之后的所有程序就当浏览器只请求了url一次 cookie的Secure和HttpOnly标记标记为 Secure 的Cookie只应通过被HTTPS协议加密过的请求发送给服务端。但即便设置了 Secure 标记，敏感信息也不应该通过Cookie传输，因为Cookie有其固有的不安全性，Secure 标记也无法提供确实的安全保障。 为避免跨域脚本 (XSS) 攻击，通过JavaScript的 Document.cookie API无法访问带有 HttpOnly 标记的Cookie，它们只应该发送给服务端。如果包含服务端 Session 信息的 Cookie 不想被客户端 JavaScript 脚本调用，那么就应该为其设置 HttpOnly 标记。 Set-Cookie: id=a3fWa; Expires=Wed, 21 Oct 2015 07:28:00 GMT; Secure; HttpOnly cookie的键值对cookie的键名（也就是name属性），我们需要注意的是一个域名下绑定的cookie的name不应该相同，如果相同的话，那么后面的键值对会覆盖之前同名的键值对 cookie的值（cookie的value属性）。 我们需要注意一点： 由于cookie规定是名称/值是不允许包含分号，逗号，空格的，所以为了不给用户带来麻烦，以及考虑服务器的兼容性，任何存储cookie的数据都应该被编码。 cookie的作用域Domain 和 Path 标识定义了Cookie的作用域：即Cookie应该发送给哪些URL。 Domain 标识指定了哪些主机可以接受Cookie。如果不指定，默认为当前文档的主机（不包含子域名）。如果指定了Domain，则一般包含子域名。 例如，如果设置 Domain=mozilla.org，则Cookie也包含在子域名中（如developer.mozilla.org）。 Path 标识指定了主机下的哪些路径可以接受Cookie（该URL路径必须存在于请求URL中）。以字符 %x2F (“/“) 作为路径分隔符，子路径也会被匹配。 例如，设置 Path=/docs，则以下地址都会匹配： /docs /docs/Web/ /docs/Web/HTTPJs操作cookie通过Document.cookie属性可创建新的Cookie，也可通过该属性访问非HttpOnly标记的Cookie。 例如： 123document.cookie = 'name=lisi';document.cookie = 'age=18';console.log(document.cookie); // "name=lisi; age=18" 通过js创建的cookie，在请求的时候同样也会被放在请求头中。但需要注意的是，js创建的cookie是会话期cookie，当浏览器被关闭后就会被自动删除。 session什么是sessionSession 对象存储特定用户会话所需的属性及配置信息。这样，当用户在应用程序的 Web 页之间跳转时，存储在 Session 对象中的变量将不会丢失，而是在整个用户会话中一直存在下去。当用户请求来自应用程序的 Web 页时，如果该用户还没有会话，则 Web 服务器将自动创建一个 Session 对象。当会话过期或被放弃后，服务器将终止该会话。Session 对象最常见的一个用法就是存储用户的首选项。例如，如果用户指明不喜欢查看图形，就可以将该信息存储在 Session 对象中。 session机制session机制是一种服务器端的机制，服务器使用一种类似于散列表的结构（也可能就是使用散列表）来保存信息。 当程序需要为某个客户端的请求创建一个session时，服务器首先检查这个客户端的请求里是否已包含了一个session标识（称为session id） 如果已包含则说明以前已经为此客户端创建过session，服务器就按照session id把这个session检索出来使用（检索不到，会新建一个） 如果客户端请求不包含session id，则为此客户端创建一个session并且生成一个与此session相关联的session id session id的值应该是一个既不会重复，又不容易被找到规律以仿造的字符串，这个session id将被在本次响应中返回给客户端保存。 创建session通过cookie来实现session我们已经知道session是保存于服务端的。有别于cookie可能将用户信息直接明文存储于浏览器端，session只是将sessionId通过cookie存储在浏览器端，然后同一个应用程序的所有页面访问服务端都会携带上该sessionId 通过url重写我们在每次请求中都携带一个 SessionID 的参数，也可以 Post 的方式提交，也可以在请求的地址后面拼接 xxx?SessionID=123456… 隐藏表单域当然我们也可以使用隐藏表单域来进行sessionId的提交 cookie与session的区别 作用范围不同，cookie保存在客户端（浏览器），而session保存在服务端 存取方式的不同，cookie只能保存ASCII，而session可以存储任何数据类型。因为，我们只是将sessionId存放到cookie返回给客户端。sessionde的信息需要服务端从数据库或文件或redis进行获取。 有效期不同，cookie可以设置为长时间保存，比如常用于自动登录；而session一般失效时间较短，客户端关闭或者session超市都会失效 隐私策略不同，Cookie 存储在客户端，比较容易遭到不法获取，早期有人将用户的登录名和密码存储在 Cookie 中导致信息被窃取；Session 存储在服务端，安全性相对 Cookie 要好一些。 存储大小不同， 单个 Cookie 保存的数据不能超过 4K，Session 可存储数据远高于 Cookie]]></content>
      <categories>
        <category>后端基础</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Generator与async+await]]></title>
    <url>AngelLikeFairy%2F2019%2F10%2F16%2F%E5%BC%82%E6%AD%A5%E7%9A%84%E7%BB%88%E6%9E%81%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88async-await%2F</url>
    <content type="text"><![CDATA[异步操作的发展有一个场景，要先读取a文件，当a文件成功读取完毕后再去读取b文件，我们看一下各种异步操作是如何进行的？ 回调函数12345678910111213141516const fs = require('fs');// 采用回调函数方式，很容易造成回调地狱function readFile(err,data) &#123; if(err) throw err; console.log(data);&#125;fs.readFile('./a.js','utf-8',(err,data)=&gt;&#123; if(err) throw err; console.log(data); fs.readFile('./b.js','utf-8',(err,data)=&gt;&#123; if(err) throw err; console.log(data); &#125;)&#125;); Promise12345678910111213141516171819202122const fs = require('fs');// 采用promise方式，但问题是容易造成代码冗余，并且一堆then导致代码不够清晰function getPromise(file) &#123; return new Promise((resolve,reject)=&gt;&#123; fs.readFile(file,'utf-8',(err,data)=&gt;&#123; if(err) reject(err); else &#123; resolve(data); &#125; &#125;) &#125;)&#125;getPromise('./a.js').then(v=&gt;&#123; console.log(v); return getPromise('./b.js');&#125;).then(v=&gt;&#123; console.log(v);&#125;).catch(err=&gt;&#123; console.log(err);&#125;) Generator1234567891011121314151617181920212223242526272829const fs = require('fs');// Generator生成器模式，利用每当执行完一条yield语句后函数会自动停止执行的特性，从而通过调用next()方法来使异步操作看起来同步化function read(file) &#123; return new Promise((resolve,reject)=&gt;&#123; fs.readFile(file,'utf-8',(err,data)=&gt;&#123; if(err) reject(err); else &#123; resolve(data); &#125; &#125;) &#125;)&#125;function *readFile() &#123; yield read('./a.js'); yield read('./b.js');&#125;let file = readFile();let value,done;while((&#123;value,done&#125; = file.next())&amp;&amp;!done) &#123; value.then(v=&gt;&#123; console.log(v); &#125;).catch(err=&gt;&#123; console.log(err); &#125;)&#125; async+await123456789101112131415161718192021222324const fs = require('fs');// async+awaitfunction read(fileName) &#123; return new Promise((resolve,reject)=&gt;&#123; fs.readFile(fileName,'utf-8',(err,data)=&gt;&#123; if(err) &#123; reject(err); &#125; else &#123; resolve(data); &#125; &#125;) &#125;)&#125;async function readFile() &#123; let fileA = await read('./a.js'); let fileB = await read('./b.js'); console.log(fileA); console.log(fileB); &#125;readFile(); Generator函数简单任务执行器由于执行yield语句会暂停当前函数的执行过程并等待下一次调用next()方法，那么我们能否做到设置一个简单任务执行器自动执行所有的任务呢？ 例如： 123456789101112131415161718192021222324252627282930// 设置三个简单任务function *tasks() &#123; yield 1; yield 2; yield 3;&#125;// 简单任务执行器函数function run() &#123; let task = tasks(); let result = task.next(); // 通过递归的方式，不断检测迭代器的done属性判断迭代器是否迭代完全 function step() &#123; if(!result.done) &#123; console.log(result.value); result = task.next(); step(); &#125; &#125; step();&#125;run();// 输出结果123 向任务执行器传递函数我们再深入一点：如果，那些任务之间是有关联的呢？比如说后执行的任务需要先执行的任务的返回值 12345function *tasks() &#123; let value = yield 1; value = yield value + 1; value = yield value + 2;&#125; 那么，我们就可以利用可以向next()方法传递参数的特性。因为这个参数的值就会代替生成器内部上一条yield语句的返回值。 对于上述生成器函数tasks，如果，没有向next()方法中传入参数，那么yield就不会有返回值（或者默认返回undefined） 123456789101112131415161718192021function run() &#123; let task = tasks(); let result = task.next(); function step() &#123; if(!result.done) &#123; console.log(result.value); result = task.next(result.value); step(); &#125; &#125; step();&#125;run();// 输出结果124 异步任务执行器Thunk函数任何函数，只要参数有回调函数，就能写成 Thunk 函数的形式 thunk函数的作用就是将一个函数的执行参数（除回调函数外，一般是回调函数之前定义的参数）和回调函数分成两个函数。 比如: 1fn(args,callback) = &gt; thunk(fn)(args)(callback) thunk函数转化器 1234567const Thunk = function(fn) &#123; return function (...args) &#123; return function (callback) &#123; return fn.call(this, ...args, callback); &#125; &#125;;&#125;; Thunk函数与Generator因为thunk函数可以将回调函数与执行函数分开，因此，我们就可以在一个地方执行执行函数，而在另一个地方来执行回调函数。 我们再去思考一些常用的异步操作，例如文件读取、例如Ajax。我们都是从回调函数中获取数据 因此，我们就可以得到下列的异步处理流程： 执行函数执行 –&gt;等待回调函数传回数据 –&gt; 操作获取的数据 这样，我们就可以将异步代码变得同步化。就像这样 1234let v = fs.readFile(&apos;./a.js&apos;); // 异步操作读取文件console.log(v); // 操作数据readFileThunk(callback); // 在另一个地方执行回调，得到数据并传回数据 那么，怎么传回数据呢？在前文提到过，我们可以在迭代器中的next()方法中传入参数，来使得该参数成为Generator函数中上一条yield语句的返回值 以fs.readFile()为例假如我们要读取a文件和b文件，那么结合Generator和Thunk函数，我们可以这样写： 12345678910111213141516171819202122232425262728293031323334353637383940const fs = require('fs');// Thunk函数转化器function thunkify(fn) &#123; return function(...args) &#123; return function(callback) &#123; fn.call(this,...args,callback); &#125; &#125;&#125;let readFile = thunkify(fs.readFile);function *read() &#123; // 执行函数以及操作数据 let value = yield readFile('./a.js','utf-8'); console.log(value); value = yield readFile('./b.js','utf-8'); console.log(value);&#125;function run(generator) &#123; let iterator = generator(); let file = iterator.next(); // 回调函数执行，以及将获取的数据回传 function step() &#123; if(!file.done) &#123; file.value((err,data)=&gt;&#123; if(err) return err; file = iterator.next(data); step(); &#125;) &#125; &#125; step();&#125;run(read); async函数async的引入可以说是异步操作的终极解决方案。 那么,async函数是什么呢？ async function 用来定义一个返回 AsyncFunction 对象的异步函数。异步函数是指通过事件循环异步执行的函数，它会通过一个隐式的 Promise 返回其结果。如果你在代码中使用了异步函数，就会发现它的语法和结构会更像是标准的同步函数。 事实上,async函数其实就是Generator函数的语法糖。使用async来表示这是一个异步函数，函数内部使用await来表示一个异步操作 例如，读取两个文件 123456789101112131415161718192021const fs = require('fs');function readFile(fileName,encode) &#123; return new Promise((resolve,reject)=&gt;&#123; fs.readFile(fileName,encode,(err,data)=&gt;&#123; if(err) &#123; reject(err); &#125; else resolve(data); &#125;) &#125;)&#125; async function read() &#123; let value = await readFile('./a.js','utf-8'); console.log(value); value = await readFile('./b.js','utf-8'); console.log(value);&#125;read(); 但是，相比于Generator函数，async函数主要有以下的改进 内置执行器 在前文提到过，Generator函数会返回一个迭代器。但若想要迭代器自动执行，我们就需要设置一个执行器函数来帮助操作。但是，async函数只需要直接调用就可以自动执行 更好的语义化 async和await，比起星号和yield，语义更清楚了。async表示函数里有异步操作，await表示紧跟在后面的表达式需要等待结果。 更广的实用性 co模块约定，yield命令后面只能是 Thunk 函数或 Promise 对象，而async函数的await命令后面，可以是 Promise 对象和原始类型的值（数值、字符串和布尔值，但这时会自动转成立即 resolved 的 Promise 对象）。 返回值是Promise async函数的返回值是 Promise 对象，这比 Generator 函数的返回值是 Iterator 对象方便多了。你可以用then方法指定下一步的操作。 基本用法因为async是用来定义一个异步函数的。因此，函数的所有写法都可以在前面加上async定义 例如： 12345678910111213141516171819202122// 函数声明async function test() &#123;&#125;// 函数表达式let test = async function () &#123;&#125;// 作为对象的方法let obj = &#123; async test() &#123; &#125;&#125;// 作为类的方法class T&#123; async test() &#123; &#125;&#125;// 箭头函数let test = async ()=&gt;&#123;&#125; async函数的返回值async会返回一个Promise对象，其会运行执行(resolve)异步函数的返回结果，或者运行拒绝(reject)——如果异步函数抛出异常的话。 async函数内部的返回值会成为返回的promise对象的回调函数的参数 例如： 123456789async function test() &#123; return 1;&#125;test().then(v=&gt;&#123; console.log(v); // 1&#125;).catch(err=&gt;&#123; console.log(err);&#125;) 当然，如果async函数内部抛出了错误，就会导致返回的Promsie对象变为reject状态。并且出错的原因会作为promise对象的拒绝处理程序的参数 例如： 123456789async function test() &#123; throw new Error('err');&#125;test().then(v=&gt;&#123; console.log(v);&#125;).catch(err=&gt;&#123; console.log(err); // Error: 'err'&#125;) async函数对于多个异步操作的简化async/await的目的是简化使用多个 promise 时的同步行为，并对一组 Promises执行某些操作。 async函数返回的Promise对象必须要等到内部所有的await命令后面的Promise全部执行完，才会将自身的状态从pending（运行态）转化为resolved（fulfilled已完成）或rejected（已拒绝） 例如： 12345678910111213async function test() &#123; let v1 = await Promise.resolve(1); console.log(v1); // 1 let v2 = await Promise.resolve(2); console.log(v2); // 2 return v1+v2;&#125;test().then(v=&gt;&#123; console.log(v); // 3&#125;).catch(err=&gt;&#123; console.log(err);&#125;) 值得注意的是，如果await命令后面的Promise对象如果变为reject状态，那么整个async函数就会中断运行，并且，async函数返回的promise就会变为拒绝态，并且出错的原因会作为promise对象的拒绝处理程序的参数 例如： 1234567891011121314async function test() &#123; let v1 = await Promise.resolve(1); console.log(v1); // 1 let v2 = await Promise.reject(2); // async在这里停止运行 console.log(v2);&#125;test().then(v=&gt;&#123; console.log(v);&#125;).catch(err=&gt;&#123; console.log(err); // 2&#125;) 错误处理我们在前面提到过，只要await命令后的一个promise是rejected态的，那么整个async函数就会停止运行。那么，为了防止某个promise错误影响后面的promise执行，我们需要有错误处理机制。 我们可以使用try…catch…来处理 例如： 1234567891011121314151617async function test() &#123; try &#123; let v1 = await Promise.reject('err'); &#125; catch(e)&#123; console.log(e); // 'err' &#125; let v2 = await Promise.resolve(1); console.log(v2); // 1 return v2;&#125;test().then(v=&gt;&#123; console.log(v); // 1&#125;).catch(err=&gt;&#123; console.log(err);&#125;) 如果有多个await命令，我们可以统一放在try…catch结构里 例如： 123456789101112131415161718async function test() &#123; try &#123; let v1 = await Promise.resolve(1); console.log(v1); // 1 let v2 = await Promise.reject('err'); // 抛出错误，try后续部分不再执行 console.log(v2); let v3 = Promise.resolve(3); console.log(3); &#125; catch(e) &#123; // 捕获错误 console.log(e); // 'err' &#125;&#125;test(); 继发与并发继发是执行完一个异步操作之后才会去执行下一个异步操作 例如： 123456async function test() &#123; await Promise.resolve(1); await Promise.reject('err');&#125;test(); 如果，函数内部的异步操作没有继发关系。也就是每个异步操作是相互独立的，那么让所有的异步操作同时触发会节省程序的执行时间 我们可以通过Promsie.all()来实现 例如： 12345678async function test() &#123; let [v1,v2] = await Promise.all([Promise.resolve(1),Promise.resolve(2)]); return [v1,v2];&#125;test().then(v=&gt;&#123; console.log(v); // [1,2]&#125;) 是的，我们很容易可以想到。如果并发的多个异步操作中有些抛出错误了怎么办？ 我们可以使用try…catch来处理。因此，在使用async函数时请尽量要确保有错误处理机制。 例如： 1234567891011async function test() &#123; try&#123; let [v1,v2] = await Promise.all([Promise.resolve(1),Promise.reject(2)]); // 停止运行 return [v1,v2]; &#125; catch(e) &#123; console.log('err',e); &#125;&#125; async函数可以保留运行堆栈123const a() &#123; b().then(()=&gt;c())&#125; 上述代码中，函数a内部运行了一个异步任务b()。当b运行的时候，函数a()不会中断，而是会继续执行，也就是说，当异步操作b()结束后，可能a()早已经结束了。那么，b()所在的上下文环境就会消失 但是，对于async异步函数 1234async function test() &#123; await b(); c();&#125; b()异步操作在运行的时候,a函数是暂停运行的。因此，对于b()函数，其上下文环境都仍旧保存着。 async/await与同步代码值得注意的是： 异步函数可以包含await指令，该指令会暂停异步函数的执行，并等待Promise执行，然后继续执行异步函数，并返回结果。 也就是说，当我们在异步函数中遇到await指令后，整个异步函数会暂停运行，执行栈会去执行下一个任务。 例如： 123456789101112131415161718let promise = new Promise((resolve,reject)=&gt;&#123; resolve(1);&#125;)async function get() &#123; console.log(1); await promise; console.log(2);&#125;get();console.log(3);/* 输出结果132*/ 执行get()后，会立即输出1，然后遇到了await命令，那么异步函数get会暂停运行，接着console.log(3)同步代码会进入执行栈并且并执行输出3，然后promise执行完毕后再重新启动异步函数get，输出2]]></content>
      <categories>
        <category>ES6</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[事件机制]]></title>
    <url>AngelLikeFairy%2F2019%2F10%2F11%2F%E4%BA%8B%E4%BB%B6%E6%9C%BA%E5%88%B6%2F</url>
    <content type="text"><![CDATA[事件流事件流描述的是从页面中接收事件的顺序。IE提出的事件流是事件冒泡流，而网景提出的事件流是事件捕获流 事件冒泡事件冒泡指代的是，事件开始时是由最具体的元素接收，然后逐级向上传播到较为不具体的节点 例如： 12345678&lt;html&gt; &lt;head&gt;&lt;/head&gt; &lt;body&gt; &lt;div&gt; &lt;p&gt;hello&lt;/p&gt; &lt;/div&gt; &lt;/body&gt;&lt;html&gt; 当你单击了P元素，那么这个事件就会按照如下顺序传播： &lt;p&gt; &lt;div&gt; &lt;body&gt; &lt;html&gt; document 事件捕获事件捕获的思想是不大具体的节点应该更早接收到事件，而最具体的节点应该最后接收到事件。事件捕获的用意在于在事件到达预定目标之前捕获它 那么上述例子如果采用事件捕获的话，那么传播顺序就会是这样的： document &lt;html&gt; &lt;body&gt; &lt;div&gt; &lt;p&gt; DOM事件流“DOM2级事件”规定的事件流包括三个阶段： 事件捕获阶段 处于目标阶段 事件冒泡阶段 首先发生的是事件捕获，为截获事件提供了机会。然后是实际的目标接收到事件。最后一个阶段是冒泡阶段，可以在这个阶段对事件做出响应 值得注意的是： 捕获阶段是不包括实际的目标元素的。这也意味着对于上述的例子，在捕获阶段，事件从document -&gt; &lt;div&gt;后就停止了。然后，处于目标阶段就会响应该目标注册的事件。并在事件处理中被看做事件冒泡阶段的一部分进入事件冒泡阶段 这有一个例子： 1234567891011121314151617181920&lt;html&gt; &lt;head&gt;&lt;/head&gt; &lt;body&gt; &lt;div style="width: 100px;height: 100px;border: 1px solid black;"&gt; &lt;p style="width: 50px;height: 20px;border: 1px solid red;margin: 10px 20px"&gt; hello &lt;/p&gt; &lt;/div&gt; &lt;script&gt; let div = document.getElementsByTagName('div')[0]; div.addEventListener("click",(e)=&gt;&#123; console.log('冒泡'); &#125;,false); div.addEventListener("click",(e)=&gt;&#123; console.log('捕获'); &#125;,true); &lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 我们为div元素注册了两个事件，一个要求在冒泡阶段被调用，一个是要求在捕获阶段被调用 根据DOM事件流的三个阶段，当我们点击&lt;p&gt;元素时，会看到先输”冒泡”再输出”捕获”。因为，我们点击的目标元素是&lt;p&gt;元素，会经历以下三个阶段。 在捕获阶段（document-&gt; &lt;html&gt; -&gt; &lt;body&gt; -&gt; &lt;div&gt;），我们捕获到了div注册的要在捕获阶段调用的事件，那么触发它。 处于目标阶段，没有目标注册的事件 冒泡阶段（&lt;div&gt; -&gt; &lt;body&gt; -&gt; &lt;html&gt; -&gt; document）响应了div注册的要在冒泡阶段调用的事件 但是，当我们点击的&lt;div&gt;元素的时候，会看到先输出”捕获”再输出”冒泡”，根据DOM事件流的三个阶段 在捕获阶段（document-&gt; &lt;html&gt; -&gt; &lt;body&gt;），我们没有捕获到div注册的任何事件。 处于目标阶段，那么触发目标注册的事件，因为目标注册了两个事件，那么按照顺序依次触发它们，依次输出”冒泡”、”捕获” 冒泡阶段（ 发生的事件 -&gt; &lt;body&gt; -&gt; &lt;html&gt; -&gt; document）没有捕获到div注册的任何事件 事件注册DOM0级事件处理程序每个元素都有自己的事件处理程序属性，这些属性通常全部小写，将这种属性的值设置为一个函数，就可以指定事件处理程序 因为，使用该方法指定的事件处理程序被认为是元素的方法。因此，这时候的事件处理程序是在当前元素的作用域内运行的。也就是说，处理函数中的this指向当前元素 例如： 1234let element = document.getElementById('ele');element.onclick = function() &#123; console.log(this.id); // 'ele'&#125; 我们可以将事件处理程序属性的值设为null来删除指定的事件处理程序 1element.onclick = null; 注意：DOM0级处理程序默认在冒泡阶段被调用 DOM2级事件处理程序DOM2级提供了两个方法来添加和删除事件处理程序 addEventListener() removeEventListener() 这两个方法都接受三个参数： 要处理的事件名 作为事件处理程序的函数 布尔值（true表示在捕获阶段调用函数；false表示在冒泡阶段调用函数） 例如： 12345678910111213let element = document.getElementById('ele');element.addEventListener('click',(e)=&gt;&#123; console.log('捕获')&#125;,true);element.addEventListener('click',(e)=&gt;&#123; console.log('冒泡')&#125;,false);element.removeEventListener('click',(e)=&gt;&#123; console.log('捕获')&#125;,true); 我们可以看到，使用DOM2级注册方式的主要好处是可以添加多个事件处理程序 值得注意的是： 通过addEventListener()方法注册的事件处理程序只能通过removeEventListener()方法来移除。并且，移除时传入的三个参数必须与添加时的三个参数一致。因此，通过addEventListener()添加的匿名函数无法被移除（参数必须完全一致，也就是说第二个参数函数也要是同一个函数） 例如： 12345678910111213let element = document.getElementById('ele');element.addEventListener('click',(e)=&gt;&#123; console.log('捕获')&#125;,true);element.addEventListener('click',(e)=&gt;&#123; console.log('冒泡')&#125;,false);element.removeEventListener('click',(e)=&gt;&#123; console.log('捕获')&#125;,true); 点击后的输出结果会是’捕获’与’冒泡’，也就是说事件移除方法没有生效。原因就在于事件移除方法中的第二个参数与添加时的那个函数不是同一个函数 我们可以将函数单独提出来赋予给一个变量，从而可以达到目标 12345678910111213let element = document.getElementById('ele');let handle = (e)=&gt;&#123; console.log('捕获')&#125;element.addEventListener('click',handle,true);element.addEventListener('click',(e)=&gt;&#123; console.log('冒泡')&#125;,false);element.removeEventListener('click',handle,true); 此时的输出结果就会是’冒泡’，也就是说事件移除程序生效了 另外，类似DOM0级方法，使用addEventListener()方法添加的事件处理程序内部的this值也指向当前绑定的元素，但要注意箭头函数的情况。因为箭头函数内部的this是由其外层代码作用域决定的 例如： 1&lt;div id="ele"&gt;hello&lt;div&gt; 1234567let div = document.getElementsByTagName('div')[0];div.addEventListener('click',function(e) &#123; console.log(this.id); // ele&#125;)div.addEventListener('click',(e)=&gt;&#123; console.log(this.id,this); // undefined,window &#123;&#125;&#125;) 可以看到，在非箭头函数中this指向当前事件绑定的对象；而在箭头函数中this指向了window全局对象（因为该箭头函数外层代码作用域为window全局作用域，因此this也指向了window全局对象） 事件对象在触发DOM上的某个事件时，会产生一个事件对象event。这个对象包含着所有与事件有关的信息。 事件对象的常用属性： 属性 类型 说明 target Element 事件的目标，也就是当前事件发生的目标。比如说点击的那个元素 currentTarget Element 当前事件绑定的那个元素 type String 被触发的事件类型 eventPhase Integer 调用时间处理程序的阶段：1表示捕获阶段，2表示处于目标阶段，3表示冒泡阶段 值得注意的是，在事件处理程序内部（非匿名函数），对象中this的值始终等于event.currentTarget的值，而不一定等于event.target 例如： 123&lt;div style="height:100px;width:100px;border:1px solid red;"&gt; &lt;p style="height:50px;width:50px;border:1px solid black;"&gt;hello&lt;/p&gt; &lt;/div&gt; 1234567let div = document.getElementsByTagName('div')[0];div.addEventListener('click',(event)=&gt;&#123; console.log(event.target); console.log(event.currentTarget); console.log(event.type); console.log(event.eventPhase);&#125;) 当我们点击div元素时，输出结果如下 1234&lt;div&gt;...&lt;/div&gt;&lt;div&gt;...&lt;/div&gt;click2 当我们点击p元素时，输出结果如下 1234&lt;p&gt;...&lt;/p&gt;&lt;div&gt;...&lt;/div&gt;click3 很明显可以发现，event.target指向你点击的那个元素；而event.currentTarget指向该事件绑定的那个元素 事件对象的常用方法 方法 类型 说明 preventDefault() Function 取消事件的默认行为。如果camcelable是true，则可以使用该方法 stopPropagation() Function 取消事件的进一步捕获或冒泡 stopImmediatePropagation() Function 取消事件的进一步捕获或冒泡，同时阻止相同事件的其他侦听器被调用 preventDefault()要阻止特定事件的默认行为，我们就可以使用preventDefault()方法。比如，链接的默认行为就是在被单击时会导航到其href特性指定的URL。如果想要阻止该默认行为，我们可以这样做 1234let a = document.getElementsByTagName('a');a.addEventListener('click',function(event) &#123; event.preventDefault();&#125;) 这样的话，我们点击链接后就不会进行跳转 stopPropagation()stopPropagation()方法可以立即停止事件在DOM层次中的传播，即取消进一步的事件捕获或冒泡 例如，我们在一个元素上的绑定两个事件处理程序，一个在捕获阶段执行，一个在冒泡阶段执行；并且我们在要在捕获阶段调用的函数添加event.stopPropagation()方法 1&lt;div&gt;hello&lt;/div&gt; 1234567891011let div = document.getElementsByTagName('div')[0];div.addEventListener('click',function(event) &#123; console.log('捕获',event.eventPhase); // 添加event.stopPropagation()方法来阻止事件的进一步传播 event.stopPropagation();&#125;,true)div.addEventListener('click',function(event) &#123; console.log('冒泡',event.eventPhase);&#125;,false) 此时我们会看到输出结果是： 12&apos;捕获&apos; 2&apos;冒泡&apos; 2 为什么event.stopPropagation()没有阻止事件的进一步传播？ 我们可以看到，两个事件处理程序输出的eventPhase值都是2，也就是这两个函数在处于目标阶段被调用。回忆，前文提到的，DOM事件流的三个阶段，捕获阶段和冒泡阶段是不会包括目标元素的。 因此，我们可以将事件绑定到document上 123456789document.addEventListener('click',function(event) &#123; console.log('捕获',event.eventPhase); // 添加event.stopPropagation()方法来阻止事件的进一步传播 event.stopPropagation();&#125;,true)document.addEventListener('click',function(event) &#123; console.log('冒泡',event.eventPhase);&#125;,false) 这样输出结果就符合预期，输出如下： 1&apos;捕获&apos; 1 事件委托（事件代理）事件委托是将一个或多个元素响应事件的函数委托给它们的外层元素来解决事件处理程序过多的问题。 例如，有一个列表 12345&lt;ul&gt; &lt;li id="li-1"&gt;1&lt;/li&gt; &lt;li id="li-2"&gt;2&lt;/li&gt; &lt;li id="li-3"&gt;3&lt;/li&gt;&lt;/ul&gt; 如果我们想要在点击每一个列表项时可以输出列表项的内容 传统做法会为每个li绑定事件处理程序： 123456789function handle(e) &#123; console.log(this.innerHTML);&#125;document.getElementById('li-1').addEventListener('click',handle);document.getElementById('li-2').addEventListener('click',handle);document.getElementById('li-3').addEventListener('click',handle); 使用事件委托（事件代理）,我们可以将事件处理程序绑定到li的外层元素ul上 12345let ul = document.getElementsByTagName('ul')[0];ul.addEventListener('click',function(event) &#123; console.log(event.target.innerHTML);&#125;) 此时，当我们点击列表项时，DOM事件流会在第三个阶段（冒泡阶段）触发事件处理程序。我们通过event.target来获得实际点击的元素来输出列表项内容。 因此，与传统方法相比，如果每一个列表项需要绑定的是不同的事件处理程序。那么，我们可以想象，如果，列表足够长，那么我们需要定义的函数对象就会非常多，因此，也会非常占用内存造成性能变差。而事件委托机制则可以很好的解决这个问题 事件委托（事件代理）的优点 减少内存消耗，提升效率 可以动态地绑定事件 例如：使用传统方法，当我们动态地添加一个节点时，我们就另外需要为该节点绑定一个事件。但是，如果采用事件委托，我们就可以避免这种情况。因为事件是绑定在父层的，和目标元素的增减是没有关系的，执行到目标元素是在真正响应执行事件函数的过程中去匹配的； 例如： 12345&lt;ul&gt; &lt;li id="li-1"&gt;1&lt;/li&gt; &lt;li id="li-2"&gt;2&lt;/li&gt; &lt;li id="li-3"&gt;3&lt;/li&gt;&lt;/ul&gt; 当我们需要动态添加一个节点比如说li-4，采用传统方式的话，创建完之后我们还需要额外绑定事件 12345let li_4 = document.createElment('li');li_4.addEventListener('click',function(event) &#123; console.log(this.innerHTML);&#125;) 如果，我们采用事件委托（事件代理）的话，就可以避免这个问题 123ul.addEventListener('click',function(event) &#123; console.log(event.target.innerHTML);&#125;) 这样的话，无论添加多少个节点或是删除多少个节点，只要在父节点内的节点都可以有相应的事件]]></content>
  </entry>
  <entry>
    <title><![CDATA[跨域与解决方案]]></title>
    <url>AngelLikeFairy%2F2019%2F10%2F07%2F%E8%B7%A8%E5%9F%9F%E4%B8%8E%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88%2F</url>
    <content type="text"><![CDATA[什么是跨域通过XHR对象来实现Ajax通信的一个主要限制，来源于跨域安全策略。在默认的情况下，XHR对象只能访问与包含它的页面位于同一个域中的资源。 那么，什么样的情况算是同一个域，什么样的情况算是不同的域呢？ 同源所谓同源（即指在同一个域）就是两个页面具有相同的协议（包括HTTP和HTTPS），主机（host）和端口号（port） 跨域当一个请求url的协议、域名、端口三者之间任意一个与当前页面url不同即为跨域 域名层次域名语法域名由一或多个部分组成，这些部分通常连接在一起，并由点分隔，例如zh.wikipedia.org。最右边的一个标签是顶级域名，例如zh.wikipedia.org的顶级域名是org。一个域名的层次结构，从右侧到左侧隔一个点依次下降一层。 顶级域名顶级域名是域名中最高的一级，每个域名都以顶级域名结尾。 子域名子域名将顶级域名进一步细分。域名层次结构中，顶级域名下面是二级域名，它位于顶级域名的左侧。例如，在zh.wikipedia.org中，wikipedia是二级域名。w3.org中，w3也是二级域名，与前例中的wikipedia属于一个层面。 二级域名下面是三级域名，它位于二级域名的左侧。例如，在zh.wikipedia.org中，zh是三级域名；zh-classical.wikipedia.org（文言文维基大典的域名）中，zh-classical也是三级域名，与前例中的zh属于一个层面。从右侧到左侧，隔一个点依次下降一层。 常见跨域场景 当前页面URL 请求页面URL 是否跨域 原因 http://www.example.com/a.js http://www.example.com/b.js 否 协议、域名、端口号均相同 http://www.example.com/a.js https://www.example.com/b.js 是 协议不同（http与https） http://www.example.com/a.js http://www.test.com/b.js 是 域名不同 http://www.example.com/a.js http://www.blog.example.com/b.js 是 主域名相同，但子域名不同 http://www.example.com/a.js http://192.168.56.1/b.js 是 域名与其对应ip地址之间的请求也算跨域 http://www.example.com http://www.example.com:8888/b.js 是 端口不同 跨域解决方案JSONP什么是JSONPJSONP是JSON with padding（填充式JSON或参数是JSON）的简写，是应用JSON的一种新方法。JSONP看起来与JSON差不多，只不过是被包含在函数调用中的JSON，例如 1callback(&#123;"name":"Ming"&#125;) JSONP由两部分组成：回调函数以及传递给回调函数的参数JSON字符串 JSONP的原理及具体实现过程 因为&lt;script&gt;元素可以不受限制地从其他域加载资源。因此我们可以在web端通过动态&lt;script&gt;来实现一个JSONP请求，例如 12let script = document.createElement('script');script.src = 'http://localhost:8888/getTestData?callback=handle' 通过上一步，我们就可以引入http://localhost:8888/getTestData?callback=handle该文件，同时将参数callback发送给服务器 因为script标签内需要可执行的javascript代码，因此我们可以知道使用JSONP是需要后端配合的，后端需要返回一个javascript类型数据才可以。我们通过express来模拟返回一下数据 1234567891011121314const express = require('express');let app = express();app.listen(8888);app.get('/getTestData',function(req,res,next) &#123;let _callback = req.query.callback;let _data = &#123; "code": 0, "msg": 'hello world'&#125;;res.type('text/javascript');res.send(_callback+'('+JSON.stringify(_data)+')');&#125;) 我们可以看到，服务器会接收到我们请求的参数，也就是回调函数名callback；接着，服务器生成_data数据，将其序列化后作为参数传入callback函数并返回给前端（注意的是，返回的内容类型是javascript代码） 收到服务器返回的javascript代码，也就是一个准备执行的已传入参数的函数。（需要注意的是，script标签内的代码会成为全局代码，也就是该函数会成为全局函数） 因此，如果我们在使用模块化开发的时候，模块内的代码都是局部代码，因此，我们需要注册一个全局的callback函数让服务器返回的Javascript代码可以执行。同时，我们的业务逻辑也就可以写在这个callback函数中。例如： 123window.handle = function(res) &#123; console.log(res);&#125; 捕获错误：我们可以使用onerror事件处理程序来确定JSONP请求是否成功 123script.onerror = function (err) &#123; console.log('error',err);&#125; JSONP的前后端代码示例前端代码123456789101112let script = document.createElement('script');window.handle = function (res) &#123; this.console.log(res.code);&#125;script.src = 'http://localhost:8888/getTestData?callback=handle';script.onerror = function (err) &#123; console.log('error',err);&#125;document.body.appendChild(script); Node.js代码1234567891011121314const express = require('express');let app = express();app.listen(8888);app.get('/getTestData',function(req,res,next) &#123; let _callback = req.query.callback; let _data = &#123; code: 0, msg: 'hello world' &#125;; res.type('text/javascript'); res.send(_callback+'('+JSON.stringify(_data)+')');&#125;) JSONP的一些个人思考 为什么后端返回的javascript代码中传给函数的参数是JSON而不是javascript对象？关于这个，我们要记住，JSON数据是我们的要获取的东西（json易于人阅读和编写，也易于机器解析和生成，相对网络传输速率较高，因此，进行数据交换我们一般使用JSON），而JSONP是我们获取JSON数据的手段。 JSONP能够直接访问响应文本，并且支持在浏览器与服务器之间双向通信 可以看到，JSONP只支持GET请求 CORSCORS （Cross-Origin Resource Sharing，跨域资源共享）是一个系统，它由一系列传输的HTTP头组成，这些HTTP头决定浏览器是否阻止前端 JavaScript 代码获取跨域请求的响应。 同源安全策略 默认阻止“跨域”获取资源。但是 CORS 给了web服务器这样的权限，即服务器可以选择，允许跨域请求访问到它们的资源。 简单请求某些请求不会触发CORS预检请求，这样的请求被视为简单请求。 满足以下条件之一就被视为简单请求 使用下列方法之一： GET HEAD POST Content-Type 的值仅限于下列三者之一： text/plain multipart/form-data application/x-www-form-urlencoded 目前浏览器基本都实现了XHR对象对CORS的原生支持。因此，对于简单请求，浏览器就会直接发出CORS请求，具体来说，就是会在请求的头信息中，增加一个Origin字段来表示请求源 我们查看一下请求报文就可以发现，在请求报文中会多出一个字段origin来说明请求的源；在响应报文中会多出一个字段Access-Control-Allow-Origin:*来允许所有的源进行跨域；当然也可以设置这个字段只允许一个或几个域才可以跨域 请求报文与响应报文 1234567891011121314151617181920212223242526GET /resources/public-data/ HTTP/1.1Host: bar.otherUser-Agent: Mozilla/5.0 (Macintosh; U; Intel Mac OS X 10.5; en-US; rv:1.9.1b3pre) Gecko/20081130 Minefield/3.1b3preAccept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8Accept-Language: en-us,en;q=0.5Accept-Encoding: gzip,deflateAccept-Charset: ISO-8859-1,utf-8;q=0.7,*;q=0.7Connection: keep-aliveReferer: http://foo.example/examples/access-control/simpleXSInvocation.html// originOrigin: http://foo.exampleHTTP/1.1 200 OKDate: Mon, 01 Dec 2008 00:23:53 GMTServer: Apache/2.0.61// Access-Control-Allow-OriginAccess-Control-Allow-Origin: *Keep-Alive: timeout=2, max=100Connection: Keep-AliveTransfer-Encoding: chunkedContent-Type: application/xml[XML Data] 非简单请求（预检请求）与简单请求不同，非简单请求（预检请求）会要求使用OPTIONS方法预先发送一个预检请求给服务器，以货值服务器是否允许该实际请求。预检请求的使用，可以一定程度上来避免跨域请求对服务器的用户数据产生未预期的影响 当请求满足以下任一条件时，就会发送预检请求 使用了下面任一HTTP方法 PUT DELETE CONNECT OPTIONS TRACE PATCH 人为设置了对 CORS 安全的首部字段集合之外的其他首部字段。该集合为： Accept Accept-Language Content-Language Content-Type (需要注意额外的限制) DPR Downlink Save-Data Viewport-Width Width Content-Type 的值不属于下列之一: application/ x-www-form-urlencoded multipart/form-data text/plain 非简单请求（预检请求）的示意图如下： node中间件代理node中间件实现跨域代理，是通过启一个代理服务器，实现数据的转发 前端所在的域与node代理服务器处在同一个域上，所有发送给代理服务器的请求都会被该服务器代理并转发给预先设定的服务器地址 前端请求12345678910111213let xhr = new XMLHttpRequest();xhr.onreadystatechange = function() &#123; if(xhr.readyState===4) &#123; if(xhr.status&gt;=200&amp;&amp;xhr.status&lt;300) &#123; console.log(xhr.responseText); &#125; else &#123; console.log('error'); &#125; &#125;&#125;xhr.open('get','http://localhost:3000',true);xhr.send(null); node代理服务器利用http-proxy-middleware该中间件实现代理服务器 123456789101112const express = require('express');const proxy = require('http-proxy-middleware')let app = express();app.use('/',proxy(&#123; target: 'http://localhost:3000', changeOrigin: true&#125;))app.listen(8080,function()&#123; console.log('8080端口已打开');&#125;) node.js后端1234567891011const express = require('express')let app = express();app.get('/',(req,res)=&gt;&#123; res.send('hello');&#125;)app.listen(3000,function() &#123; console.log('3000端口已打开');&#125;); 这样我们就可以通过代理服务器进行跨域请求 webpack配置跨域类似Vue这些框架都会用webpack进行打包。webpack中可以引入webpack-dev-server来进行服务器相关的配置。 与上述node中间件使用http-proxy-middleware 包一样，该dev-server也使用了该包，因此语法也是一样的 我们可以在webpack.config.js进行跨域相关的配置 webpack.config.js的跨域配置 12345678devServer : &#123; proxy: &#123; "/api": &#123; target: "http://localhost:3000", pathRewrite: &#123;"^/api": ""&#125; &#125; &#125;&#125; 前端请求 12345678910111213let xhr = new XMLHttpRequest();xhr.onreadystatechange = function() &#123; if(xhr.readyState===4) &#123; if(xhr.status&gt;=200&amp;&amp;xhr.status&lt;300) &#123; console.log(xhr.responseText); &#125; else &#123; console.log('error'); &#125; &#125;&#125;xhr.open('get','/api/hello',true);xhr.send(null); 后端node接口 123456789101112const express = require('express')let app = express();app.get('/hello',(req,res)=&gt;&#123; res.setHeader('Content-type','application/json'); res.send('hello');&#125;)app.listen(3000,function() &#123; console.log('3000端口已打开');&#125;); 此时，请求”/api/hello”就会被代理到”http://localhost:3000/hello&quot; 配置中的主要参数说明 ‘/api’ 如果请求中有该字符串’/api’，那么就会开始匹配代理。比如，api请求’/api/hello’，就会被代理到请求’http://localhost:3000/api/hello&#39; target 代理的API地址。地址可以是域名也可以是IP地址，如果是域名就需要额外添加一个参数changeOrigin: true pathRewrite 路径重写，也就是说会修改最终请求的API路径。设置pathRewrite:{‘^/api’:’’}后，最终代理访问的路径就会是’http://localhost:3000/hello&#39; changeOrigin 该参数可以让target参数是域名 secure secure: false，不检查安全问题；设置后，可以接受运行在https上，可以使用无效证书的后端服务器]]></content>
      <categories>
        <category>浏览器</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Ajax]]></title>
    <url>AngelLikeFairy%2F2019%2F09%2F30%2FAjax%2F</url>
    <content type="text"><![CDATA[什么是AjaxAJAX即“Asynchronous JavaScript and XML”（异步的JavaScript与XML技术）。使用Ajax可以无需刷新页面就可以从服务器取得数据 Ajax的核心–XMLHttpRequest对象如果不考虑IE7以前的版本，那么对于所有的标准浏览器我们都可以使用如下来创建一个XHR对象 1let xhr = new XMLHttpRequest(); XHR对象的一些属性 属性名 作用 status 响应的HTTP状态码 statusText HTTP状态码的说明 responseText 作为响应主体被返回的文本 responseXml 对请求的响应，解析为 XML 并作为 Document 对象返回 readyState 请求/响应过程的当前活动状态 onreadystatechange() readyState属性值改变触发的readystatechange事件的绑定函数 readyState属性的说明：属性可取值|名称|说明–|–|–0|未初始化|尚未调用open()方法1|启动|已经调用open()方法，但尚未调用send()方法2|发送|已经调用send()方法，但尚未接收到响应3|接收|已经接收到部分响应数据4|完成|已经接收到全部响应数据 status（HTTP常见状态码）状态码|名称|说明–|–|–200|OK|请求成功，信息在返回的响应报文中301|Moved Permanently|请求的对象已经被永久转移了，新的URL定义在响应报文的Location: 首部行中。客户软件将自动获取新的URL304|Not Modified|未修改。所请求的资源未修改，服务器返回此状态码时，不会返回任何资源。客户端通常会缓存访问过的资源，通过提供一个头信息指出客户端希望只返回在指定日期之后修改的资源400|Bad Request|一个通用差错代码，指示该请求不能被服务器理解404|Not Found|请求的资源不存在500|Internal Server Error|内部服务器错误505|HTTP Version Not Supported|服务器不支持请求报文使用的HTTP协议版本 HTTP状态码分类 状态码 名称 说明 1** 信息 服务器收到请求，需要请求者继续执行操作 2** 成功 操作被成功接收并处理 3** 重定向 需要进一步的操作以完成请求 4** 客户端错误 请求包含语法错误或无法完成请求 5** 服务器错误 服务器在处理请求的过程中发生了错误 XHR对象的一些方法open()参数： method 要使用的HTTP方法，比如「GET」、「POST」、「PUT」、「DELETE」、等。对于非HTTP(S) URL被忽略。 url 一个DOMString表示要向其发送请求的URL。 async 可选 一个可选的布尔参数，默认为true，表示要不要异步执行操作。如果值为false（表示同步执行），send()方法直到收到答复前不会返回。如果true（表示异步执行），已完成事务的通知可供事件监听器使用。 注意：主线程上的同步请求很容易破坏用户体验，应该避免；实际上，许多浏览器已完全弃用主线程上的同步XHR支持。在 Worker中允许同步请求user 可选 可选的用户名用于认证用途；默认为null。 password 可选 可选的密码用于认证用途，默认为null。 send()XMLHttpRequest.send() 方法接受一个可选的参数，其作为请求主体；如果请求方法是 GET 或者 HEAD，则应将请求主体设置为 null。（注：在HTTP请求报文中，使用GET方法时，请求实体为空，而是用POST方法时传输的内容保存在该请求实体中） setRequestHeaderXMLHttpRequest.setRequestHeader() 是设置HTTP请求头部的方法。此方法必须在 open() 方法和 send() 之间调用。如果多次对同一个请求头赋值，只会生成一个合并了多个值的请求头。 abort()如果该请求已被发出，XMLHttpRequest.abort() 方法将终止该请求。当一个请求被终止，它的 readyState 属性将被置为0（ UNSENT )。 使用XHR对象进行同步请求对于同步请求，也就是意味着该次请求是阻塞的。因此，之后的代码会等到服务器响应之后才会执行。 在收到响应后，响应的数据会自动填充到XHR对象的属性 例如： 1234567891011let xhr = new XMLHttpRequest();// 使用同步请求时，open()方法的第三个参数设置为falsexhr.open("get","https://www.baidu.com",false);xhr.send(null);if((xhr.status&gt;=200&amp;&amp;xhr.status&lt;300)||xhr.status===304) &#123; console.log(xhr.responseText);&#125;else &#123; console.log("Request was failed");&#125; 使用XHR对象进行异步请求123456789101112131415let xhr = new XMLHttpRequest();xhr.onreadystatechange=function() &#123; if(xhr.readyState===4) &#123; if((xhr.status&gt;=200&amp;&amp;xhr.status&lt;300)||xhr.status===304) &#123; console.log(xhr.responseText); &#125; else &#123; console.log("Request was failed"); &#125; &#125;&#125;// 使用异步请求时，open()方法的第三个参数设置为truexhr.open("get","https://www.baidu.com",true);xhr.send(null);console.log('异步请求'); 注意：我们必须在调用open()方法之前指定onreadystatechange事件处理程序才能确保跨浏览器兼容性 GET请求对于GET请求，我们经常将查询字符串参数追加到URL的末尾，以便将信息发送给服务器 但是，我们经常会遇到URL的编码问题（查询字符串的格式有问题，例如在传递中文字符的时候）。因此，我们需要将每个参数的名称和值使用encodeURIComponent()进行编码，然后才能放到URL的末尾 encodeURIComponent()是对统一资源标识符（URI）的组成部分进行编码的方法。它使用一到四个转义序列来表示字符串中的每个字符的UTF-8编码。它会转义除了字母、数字、(、)、.、!、~、*、’、-和_之外的所有字符。 decodeURIComponent() 方法用于解码由 encodeURIComponent 方法或者其它类似方法编码的部分统一资源标识符（URI）。 因此，我们利用一个函数，将每个参数的键与值进行编码后加入到URL的末尾 1234567891011121314151617function addURLParam(url,key,value) &#123; url+=url.indexOf('?')&lt;0?'?':'&amp;'; // 编码参数 url+=encodeURIComponent(key)+'='+encodeURIComponent(value); return url;&#125;let url = addURLParam('https://www.baidu.com','a','天');console.log(url);let url1 = addURLParam(url,'b','才');// 解码URLconsole.log(decodeURIComponent(url1));/*https://www.baidu.com?a=%E5%A4%A9https://www.baidu.com?a=天&amp;b=才*/ POST请求POST请求的内容不会明文出现在URL上，它会存放在请求的实体部分进行传递。值得注意的是，POST请求的主体可包含非常多的数据，而且格式不限 注意，在使用POST请求提交数据的时候，我们需要将请求头设置一下 1xhr.setRequestHeader("Content-Type","application/x-www-form-urlencoded"); POST完整请求示例 1234567891011121314let xhr = new XMLHttpRequest();xhr.onreadystatechange=function() &#123; if(xhr.readyState===4) &#123; if(xhr.status&gt;=200&amp;&amp;xhr.status&lt;300) &#123; console.log(xhr.responseText); &#125; else &#123; console.log('error'); &#125; &#125;&#125;xhr.open("post","https://www.baidu.com","true");xhr.setRequestHeader("Content-Type","x-www-from-urlencoded");xhr.send('123'); XMLHttpRequest 2级FormData在上面提到过，使用POST请求进行传输时，我们需要明确地设置请求头 1xhr.setRequestHeader("Content-Type","x-www-from-urlencoded"); 但是，如果使用FormData的话，我们就不要进行设置。因为，XHR对象能够识别传入的数据类型是FormData的实例，并配置适当的头部信息 例如： 12345678910111213141516171819// 创建FormData实例let data = new FormData();// 向对象添加数据，append()方法接受两个参数：键和值data.append("name","Ming");// 我们可以看到没有设置POST请求头let xhr = new XMLHttpRequest();xhr.onreadystatechange=function() &#123; if(xhr.readyState===4) &#123; if(xhr.status&gt;=200&amp;&amp;xhr.status&lt;300) &#123; console.log(xhr.responseText); &#125; else &#123; console.log('error'); &#125; &#125;&#125;xhr.open("post","https://www.baidu.com",true);xhr.send(data); 进度事件我们可以利用进度事件来实现一个进度指示器 progress事件会在浏览器接收新数据期间周期性地触发。而onprogress事件处理程序就会接收到一个events对象，其有三个关于进度的属性：lengthComputable(表示进度信息是否可用),position(表示已经接受的字节数),totalSize(表示总字节数) 例如： 12345678let xhr = new XMLHttpRequest();xhr.onprogress=function(events) &#123; if(events.lengthComputable)&#123; console.log(events.position+"/"+events.totalSize); &#125;&#125;xhr.open("get","https://www.baidu.com",true);xhr.send(null); Ajax的一些知识点总结原生Js Ajax请求有几个步骤我们以步骤最多的POST请求为例 12345678910111213141516171819// 1. 创建XHR对象let xhr = new XMLHttpRequest();// 响应服务器返回的数据xhr.onreadystatechange=function() &#123; if(xhr.readyState===4) &#123; if(xhr.status&gt;=200&amp;&amp;xhr.status&lt;300) &#123; console.log(xhr.responseText); &#125; else &#123; console.log('error'); &#125; &#125;&#125;// 2. 准备一个请求，规定请求的类型、URL 以及是否异步处理请求xhr.open("post","https://www.baidu.com","true");// 3. 设置请求头中的Content-typexhr.setRequestHeader("Content-Type","x-www-from-urlencoded");// 发送请求xhr.send('123'); Ajax有哪几种请求方式常用的有GET,POST,DELETE,PUT。 POST请求与GET请求的区别 POST请求更加安全，因为POST请求将参数存放在请求实体中，而GET请求参数在URL上 GET请求传输速度更快。因为post通过请求体传参，后台通过数据流接收。速度稍微慢一些。而get通过url传参可以直接获取 POST请求没有数据量的限制 POST请求的参数内容没有格式限制]]></content>
      <categories>
        <category>javaScript基础</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[JSON的解析与序列化]]></title>
    <url>AngelLikeFairy%2F2019%2F09%2F30%2FJSON%E7%9A%84%E8%A7%A3%E6%9E%90%E4%B8%8E%E5%BA%8F%E5%88%97%E5%8C%96%2F</url>
    <content type="text"><![CDATA[JSON简介JSON（JavaScript Object Notation，JavaScript对象表示法）是一种数据格式，而不是一种编程语言。 我们可以使用JSON来通过网络进行数据交互和处理。 语法JSON的语法可以表示一下三种类型的值： 简单值：可以在JSON中表示字符串、数值、布尔值和null。但JSON不支持undefined 对象： 对象作为一种复杂数据类型，表示的是一组无序的键值对儿 数组 值得注意的是：除了undefined，JSON也不支持变量、函数或对象实例 另外，JSON字符串必须使用双引号（单引号会导致语法错误） 例如： 1234&#123; "name": "Ming", "age": 18&#125; 解析与序列化JavaScript对象序列化为JSON字符串JSON.stringify() 方法是将一个JavaScript值(对象或者数组)转换为一个 JSON字符串，如果指定了replacer是一个函数，则可以选择性的替换值，或者如果指定了replacer是一个数组，可选择性的仅包含数组指定的属性。 语法 JSON.stringify(value[, replacer [, space]]) 参数 value 将要序列化成 一个JSON 字符串的值。 replacer 可选 如果该参数是一个函数（传入的函数接受连个参数，属性名和属性值），则在序列化过程中，被序列化的值的每个属性都会经过该函数的转换和处理（值得注意的是，如果过滤器函数没有返回值或者显示返回undefined，那么相应的属性就会被忽略；因为JSON语法默认不支持undefined）；如果该参数是一个数组，则只有包含在这个数组中的属性名才会被序列化到最终的 JSON 字符串中；如果该参数为null或者未提供，则对象所有的属性都会被序列化； space 可选 指定缩进用的空白字符串，用于美化输出（pretty-print）；如果参数是个数字，它代表有多少的空格；上限为10。该值若小于1，则意味着没有空格；如果该参数为字符串(字符串的前十个字母)，该字符串将被作为空格；如果该参数没有提供（或者为null）将没有空格。 返回值 一个表示给定值的JSON字符串。 例如： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748let test = &#123; name: 'Ming', age: 18&#125;// 未传入过滤数组或过滤函数console.log(JSON.stringify(test,null,4));/*&#123; "name": "Ming", "age": 18&#125;*/// 传入过滤数组console.log(JSON.stringify(test,["name"],4));/*&#123; "name": "Ming"&#125;*/// 传入过滤函数console.log(JSON.stringify(test,function (key,value)&#123; if(key==="name") &#123; return "My name is"+value; &#125; else return value;&#125;,4))/*&#123; "name": "My name isMing", "age": 18&#125;*/// 值得注意的是，如果过滤器函数没有返回值或者显示返回undefined，那么相应的属性就会被忽略console.log(JSON.stringify(test,function(key,value) &#123; if(key==="name") &#123; return; &#125; return value;&#125;,4))/*&#123; "age": 18&#125;*/ JSON字符串解析成原生JavaScript值JSON.parse() 方法用来解析JSON字符串，构造由字符串描述的JavaScript值或对象。提供可选的reviver函数用以在返回之前对所得到的对象执行变换(操作)。 语法 JSON.parse(text[, reviver]) 参数 text 要被解析成JavaScript值的字符串，关于JSON的语法格式。 reviver 可选 转换器, 如果传入该参数(函数)，可以用来修改解析生成的原始值。如果还原函数返回undefined，则表示要从结果中删除相应的键。（因为JSON语法默认不支持undefined） 返回值 Object类型, 对应给定JSON文本的对象/值。 异常 若传入的字符串不符合 JSON 规范，则会抛出 SyntaxError 异常。 不传入还原函数我们将JSON.parse()的第二个函数参数称之为还原参数 12345678910111213141516171819let text = &#123; name: 'Ming', age: 18, friends: [ &#123; name: 'Lin', age: 19 &#125; ]&#125;let jsonText = JSON.stringify(text,null,4);let textCopy = JSON.parse(jsonText);console.log(textCopy); // &#123; name: 'Ming', age: 18, friends: [ &#123; name: 'Lin', age: 19 &#125; ] &#125;console.log(textCopy instanceof Object); // trueconsole.log(textCopy===text); // falseconsole.log(textCopy.friends[0]===text.friends[0]); // false 因此，我们经常使用JSON.parse(JSON.stringify(example))来深拷贝一个对象（注意：JSON语法不支持undefined与函数…） 传入还原函数12345678910111213141516171819202122232425262728let text = &#123; name: 'Ming', age: 18, friends: [ &#123; name: 'Lin', age: 19 &#125; ]&#125;let jsonText = JSON.stringify(text,null,4);let textCopy = JSON.parse(jsonText,function(key,value)&#123; if(key==="name") &#123; return "My name is"+value; &#125; return value;&#125;);console.log(textCopy);/*&#123; name: 'My name isMing', age: 18, friends: [ &#123; name: 'My name isLin', age: 19 &#125; ]&#125;*/]]></content>
      <categories>
        <category>javaScript基础</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[super关键字]]></title>
    <url>AngelLikeFairy%2F2019%2F09%2F26%2Fsuper%E5%85%B3%E9%94%AE%E5%AD%97%2F</url>
    <content type="text"><![CDATA[super关键字简介super关键字用于访问和调用一个对象的父对象上的函数。 注意的是： super关键字只能访问和调用函数，而不能访问父对象上的变量 在构造函数中使用时，super关键字作为函数调用将单独出现，并且必须在使用this关键字之前使用。super关键字也可以用来调用父对象上的函数。 语法super([arguments]); // 调用 父对象/父类 的构造函数 super.functionOnParent([arguments]); // 调用 父对象/父类 上的方法super作为函数调用super作为函数调用时，其代表着基类的构造函数。 此时，它的内部的this指向为当前子类的实例对象。 需要注意的是： 我们只能在派生类的构造函数中使用super()。如果尝试在非派生类（不是用extends声明的类）或函数中使用则会导致程序错误 在构造函数中访问this前一定要调用super()，它负责初始化this。也就是说，虽然super()代表着基类的构造函数，但是内部的作用域指向还是当前类的作用域。 示例： 123456789101112131415class Father&#123; constructor(item) &#123; this.item= item; &#125;&#125;class Son extends Father&#123; constructor(item,name) &#123; super(item); this.name= name; &#125;&#125;let son = new Son(123,'ming');console.log(son); // Son &#123; item: 123, name: 'ming' &#125; 上述代码中的super(item)其实相当于super.constructor.call(this) super作为对象调用super 作为对象时，在普通方法和构造函数中，指向父类的原型对象，在静态方法中指向父类。 super作为对象在普通方法和构造函数中的this指向当前子类的实例对象 super作为对象在静态方法中的this指向当前子类，而不是当前子类的对象 接下来验证super作为对象在普通方法中被调用指向的是父类的原型对象 123456789101112131415161718192021class A&#123; constructor(item) &#123; this.item= item; &#125; test() &#123; return 123; &#125;&#125;class B extends A&#123; constructor(item) &#123; super(item); console.log(super.test()); &#125; test() &#123; console.log(super.test===A.prototype.test); &#125;&#125;let b = new B(123); // 123b.test(); // true 接下来验证super作为对象在静态方法中被调用指向的是父类，而不是父类的原型对象 123456789101112131415161718192021222324252627class A&#123; static item= 'A'; constructor(item) &#123; this.item= item; &#125; static getItem() &#123; console.log('static'); return this.item; &#125; getItem() &#123; console.log('not static'); return this.item; &#125;&#125;class B extends A&#123; static item= 'B'; constructor(item) &#123; super(item); &#125; static getItem() &#123; return super.getItem(); &#125;&#125;console.log(B.getItem()); // 'static' , 'B']]></content>
      <categories>
        <category>ES6</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Node的模块机制]]></title>
    <url>AngelLikeFairy%2F2019%2F09%2F25%2FNode%E7%9A%84%E6%A8%A1%E5%9D%97%E6%9C%BA%E5%88%B6%2F</url>
    <content type="text"><![CDATA[模块化的必要性在应用开发中，模块化的方式可以带来诸多好处： 避免变量的全部污染，每个模块的变量之间都是相互独立的 模块可以复用，提高代码复用率 每一个来实现一部分功能，代码维护性高 便于各个功能模块之间的代码依赖性管理 CommonJS的模块规范CommonJS规范对于模块的定义主要分为以下三个部分： 模块引用CommonJS通过require()方式来对模块进行引用 1const test = require('./test.js'); 模块导出CommonJS可以使用两种方式进行导出 123456789// 使用exportsexports.add = function(a,b) &#123; return a+b;&#125;// 使用module.exportsmodule.exports = function add(a,b) &#123; return a+b;&#125; exports与module.exports的区别与联系我们在一个模块中运行如下代码 123console.log(exports); // &#123;&#125;console.log(module.exports); // &#123;&#125;console.log(exports===module.exports); // true 我们可以知道exports与module.exports指向的是同一个对象，并且这个对象一开始是一个空对象 先说结论吧： 一个模块真正导出的内容是module.exports的值，exports只是对module.exports的引用 那么我们尝试着利用两种方式去导出对象来看下会发生什么 12345678910111213// 为exports对象添加属性exports.add = function(a,b) &#123; return a+b;&#125;console.log(module.exports); // &#123; add: [Function] &#125;// 将exports对象指向其他对象exports = &#123; item: 1&#125;// module.exports内容依旧没有改变console.log(module.exports); // &#123; add: [Function] &#125; 我们在另一个模块中引入该模块： 123const m = require('./a.js');console.log(m); // &#123;add: [Function]&#125; 我们可以看到引入的模块确实是module.exports的值而不是exports的值。 那么，如果我们将module.exports对象指向另一个对象，而不是模块一开始自定义的那个对象，又会怎么样呢 1234567module.exports = function add(a,b) &#123; return a+b;&#125;exports.a = 1;console.log(module.exports); // [Function: add] 意料之内，模块导出的永远是module.exports的值，而不会关心这个module.exports属性指向什么值 那么，如果我们将模块本身的module对象重新赋予另一个新对象呢？那么，该模块能否被导出呢？ 答案当然是不能。 我们将模块赋予一个当前模块对象的一个浅拷贝 12345678910module = &#123; id: '.', path: 'd:\\jsTest', exports: &#123;a:1&#125;, parent: null, filename: 'd:\\jsTest\\tempCodeRunnerFile.js', loaded: false, children: [], paths: [ 'd:\\jsTest\\node_modules', 'd:\\node_modules' ] &#125; 我们在另一个模块中引入，就会发现 123const m = require('./a.js');console.log(m); // &#123;&#125; 之前的那个模块没有导出任何东西 模块标识模块标识其实就是传递给require()方法的参数，它必须是符合小驼峰命名的字符串，或者是相对路径，或者是绝对路径。它可以没有文件名后缀。 node模块详解什么是模块在Node模块系统中，每一个文件都是一个模块。在每个模块中，用变量moudule来表示对当前模块对象的引用。 例如： 1234const a = 1;const b = 2;exports.c = a+b;console.log(module.exports); // &#123;c:3&#125; 该js文件就是一个模块，并且该模块导出了一个变量c。 模块对象在每个模块中,module变量引用着当前模块的模块对象 它的定义如下： 12345678910function Module(id = '', parent) &#123; this.id = id; this.path = path.dirname(id); // 返回该模块文件的目录名 this.exports = &#123;&#125;; this.parent = parent; updateChildren(parent, this, false); // 将该模块添加到parent模块的children模块数组中 this.filename = null; this.loaded = false; this.children = [];&#125; 我们在一个模块中试着输出一下module 123456// a.jsexports.a = 1;// b.jsconst a = require('./a.js');console.log(module); 我们运行一下b.js，可以得到如下的输出结果： 1234567891011121314151617181920212223/* 输出结果Module &#123; id: '.', // 模块标识符，对于自己是'.'，对于引入的依赖是其完全解析后的文件名 path: 'D:\\jsTest', exports: &#123;&#125;, parent: null, filename: 'D:\\jsTest\\b.js', loaded: false, children: [ Module &#123; id: 'D:\\jsTest\\a.js', path: 'D:\\jsTest', exports: [Object], parent: [Circular], filename: 'D:\\jsTest\\a.js', loaded: true, children: [], paths: [Array] &#125; ], paths: [ 'D:\\jsTest\\node_modules', 'D:\\node_modules' ]&#125;*/ module.parent与module.children我们修改一下上面的两个模块的代码 a模块 12console.log('module.parent',module.parent.filename); // 'D:\\jsTest\\a.js'console.log('module.children',module.children); // [] b模块 1234567891011121314151617181920212223242526const a = require('./a.js');console.log('module.parent',module.parent); // nullconsole.log(module.children);/*[ Module &#123; id: 'D:\\jsTest\\a.js', path: 'D:\\jsTest', exports: &#123;&#125;, parent: Module &#123; id: '.', path: 'D:\\jsTest', exports: &#123;&#125;, parent: null, filename: 'D:\\jsTest\\b.js', loaded: false, children: [Circular], paths: [Array] &#125;, filename: 'D:\\jsTest\\a.js', loaded: true, children: [], paths: [ 'D:\\jsTest\\node_modules', 'D:\\node_modules' ] &#125;]*/ 我们查看一下node的官方api文档： module.parent: &lt;module&gt;（单个模块对象） 最先引用该模块的模块。 module.children: &lt;module[]&gt; （模块对象数组） 被该模块引用的模块对象。 因此，我们可以得出结论：module.parent指向第一个引用该模块的模块，而module.children指被该模块引用的所有模块对象 那么，疑问又来了： 如果一个a模块同时被b模块和c模块引入，那么a模块的module.parent属性究竟指向谁呢？ 在同一个进程中，我们无法同时运行两个模块。因此，如果串行运行b模块和c模块，那么module.parent指向第一个引入该a模块的模块，而另一个模块则会从缓存中去读取该模块 模块的分类在node中，模块可以被分为两类：一类是node提供的模块，成为核心模块；另一类是用户编写的模块，成为文件模块。 对于，文件模块来说，我们又可以根据模块的标识符的路径再细分为以下三类： .或..开始的相对路径文件模块 以/开始的绝对路径文件模块 非路径形式的文件模块，又被称之为自定义模块（例如’koa’）。它是一种特殊的文件模块，可能是一个文件或者包的形式 模块封装器模块内部的所有变量都是私有的，因为模块内的代码都会被封装在一个称作模块封装器的函数内。 在执行模块代码之前，Node.js会使用一个如下的函数包装器将模块内的代码进行封装， 123(function(exports,require,module,__filename,__dirname)&#123; // 模块的实际代码实际上是被封装在这里&#125;) 使用这样的方式，每个模块内部的代码就会被函数作用域所相互隔离。因此，我们就保证了模块内部的所有(使用显示声明的（var,let,const）)变量都是私有的。 也就是说，隐式声明的变量会成为全局变量（其他模块可以访问到该变量）。这点很容易想到，在一个函数作用域内声明一个全局变量就需要隐式声明或者直接将该变量作为全局对象的属性。 例如： 12// a.jst = 11; 123// b.jsrequire('./a.js');console.log(t); // 11 我们可以看到，当a模块执行后，t就被声明为全局变量。因此，其他模块都可以访问到该变量t。 之后，在模块编译的时候，node会将当前模块对象(module)的exports属性，require()方法、module(模块自身)，以及在文件定位中得到的完整文件路劲和文件目录作为参数传递给该模块封装器函数进行执行。 因此，我们就知道了为什么，在模块内部我们可以直接使用exports,module等变量。 另外，我们也知道了模块内部的exports变量只是一个形参，而该形参值等于传递给该模块封装器的module.exports实参罢了。在这里，我们也对前面遇到的问题做出了一个底层性的解释。 模块缓存模块在第一次被加载后就会被缓存，以减少二次引入的开销。 因此，同一个模块就算被多次引入也只会执行一次。 Node的模块系统对于每一个已经成功编译的模块会将其文件路径作为索引缓存在Module._cache对象上，索引所对应的值是模块被编译和执行之后的对象。 另外，对于文件索引，我们需要明白，因为模块是基于其解析的文件名进行缓存的。 由于调用模块的位置的不同，模块可能被解析成不同的文件名（比如从 node_modules 目录加载），这样就不能保证 require(‘foo’) 总能返回完全相同的对象。 现在，我们来验证下，在模块第一次被引入后是否会被缓存： 1234// a.jslet a = 1;console.log(a);exports.a = a; 123456// b.jsconst m = require('./a.js');const n = require('./a.js');// 输出结果1 我们发现输出结果只有一个1，如果模块没有被缓存而是重新加载，那么输出结果应该是两个1。因此， 模块在第一次被引入后会进行缓存，之后再次引入该模块便不会再执行该模块。 模块的循环依赖我们可能会遇到这样一个场景： 模块a需要依赖模块b，而模块b又需要依赖模块a。那么这两个模块之间会进行无限的循环依赖吗？ 我们都知道无限递归有多么可怕，因此，Node也不会允许无限的循环依赖的情况发生。 Node允许一个模块在未被完全执行完毕时就可以被返回。 Node通过这样的方式来避免无限的循环依赖。 例如： 模块a 1234567891011// a.jsconsole.log('a开始');// 导出done属性为falseexports.done = false;// 此时a模块未完全被执行const b = require('./b.js');console.log(`在a模块中,b模块导出的done为$&#123;b.done&#125;`);// 导出的done属性修改为trueexports.done = true;console.log('a结束');// a模块完全被执行 模块b 1234567891011// b.jsconsole.log('b开始');// 导出done属性为trueexports.done = true;// 此时b模块未完全被执行const a = require('./a.js');console.log(`在b模块中，a模块导出的done为$&#123;a.done&#125;`);// 导出的done属性修改为falseexports.done = false;console.log('b结束');// b模块完全被执行 模块main 1234console.log('mian开始');const a = require('./a.js');const b = require('./b.js');console.log(`在main模块中，a模块导出的done为$&#123;a.done&#125;，b模块导出的done为$&#123;b.done&#125;`); 我们分别创建了a和b模块，这两个模块之间互相依赖。然后，我们在main模块将这两个模块都引入，执行main.js，最终运行结果如下： 12345678910/* 输出结果mian开始a开始b开始在b模块中，a模块导出的done为falseb结束在a模块中,b模块导出的done为falsea结束在main模块中，a模块导出的done为true，b模块导出的done为false*/ 我们来分析一下上述的运行过程： 输出’main开始’ 开始引入模块a，由于是第一次引入，那么去执行模块a 输出’a开始’ 将exports对象设置一个属性done为false，也就是说此时被导出的done为false 开始引入b模块，由于是第一引入，那么去执行模块b 输出’b开始’ 将b模块的导出值done设置为true 需要引入a模块，因为a模块此时不是第一次被加载，因此不需要去重新执行a模块。（之前提到过，因为node允许一个模块未被完全执行完毕时就可以有导出值）因此，我们从缓存区读取a模块的导出值，此时a模块导出的done值为false 因此，输出’在b模块中，a模块导出的done为false’ 继续执行b模块，将b模块的导出值done修改为false 输出’b’结束 继续执行a模块，因为b模块已经被完全执行，因此输出’在a模块中,b模块导出的done为false’ 将a模块的导出done值修改为true 输出’a结束’ 开始引入模块b，因为b模块此时不是第一次加载，因此不需要去重新执行b模块。我们从缓存中去读取b模块。 此时，a模块和b模块都在上述过程中被完全执行。并且，a和b模块都不仅仅只被引入过一次，因此，此时我们就会去从缓存中去读取a和b模块。那么输出’在main模块中，a模块导出的done为true，b模块导出的done为false’ 补充：多模块的循环依赖与上文提到的两个模块之间的循环依赖思路一致，只需要记住两点： Node允许一个模块在未被完全执行完毕时就可以被返回。 模块只有第一次被引入时会加载执行，之后都是从缓存中去读取 以下是三个模块之间的循环依赖：a模块依赖b模块，b模块依赖c模块，c模块又依赖a模块 a模块 1234567891011// a.jsconsole.log('a开始');// 导出done属性为falseexports.done = false;// 此时a模块未完全被执行const b = require('./b.js');console.log(`在a模块中,b模块导出的done为$&#123;b.done&#125;`);// 导出的done属性修改为trueexports.done = true;console.log('a结束');// a模块完全被执行 b模块 1234567891011// b.jsconsole.log('b开始');// 导出done属性为trueexports.done = true;// 此时b模块未完全被执行const c = require('./c.js');console.log(`在b模块中，c模块导出的done为$&#123;c.done&#125;`);// 导出的done属性修改为falseexports.done = false;console.log('b结束');// b模块完全被执行 c模块 1234567891011// c.jsconsole.log('c开始');// 导出done属性为trueexports.done = true;// 此时c模块未完全被执行const a = require('./a.js');console.log(`在c模块中，a模块导出的done为$&#123;a.done&#125;`);// 导出的done属性修改为falseexports.done = false;console.log('c结束');// c模块完全被执行 mian模块 12345console.log('mian开始');const a = require('./a.js');const b = require('./b.js');const c = require('./c.js')console.log(`在main模块中，a模块导出的done为$&#123;a.done&#125;，b模块导出的done为$&#123;b.done&#125;,c模块导出的done为$&#123;c.done&#125;`); 运行main.js，我们可以得到以下输出结果： 1234567891011mian开始a开始b开始c开始在c模块中，a模块导出的done为falsec结束在b模块中，c模块导出的done为falseb结束在a模块中,b模块导出的done为falsea结束在main模块中，a模块导出的done为true，b模块导出的done为false,c模块导出的done为false 模块的加载机制（require()方法的过程）模块的加载机制大致可以分为以下几步： 解析得到模块的绝对文件路径 通过得到的文件路径来判断该模块是否在缓存中，如果是，则直接取出该缓存的模块对象返回其exports属性（导出值），反之继续 判断该模块是否为核心模块，如果是，那么返回该核心模块对象的导出并且将核心模块对象加入缓存 到这一步，模块就是文件模块了。此时，创建文件模块的实例对象并存入缓存 加载并执行该文件模块 导出模块的exports属性 流程图如下： 在详细说明前，我们需要知道几点： 被缓存的模块加载时的优先级最高 部分核心模块在Node进程启动时就被直接加载进内存中，因此，核心模块的引入只需要分析它的模块标识符这一过程，而不需要对其进行模块实例的创建以及模块的加载执行 文件模块是在运行时动态加载，因此，它需要以上的完整步骤，因此，速度较慢。 接下来，我们会通过查看源码的方式来深入这一过程： 首先贴上require()方法中加载模块的源码： require()方法其实内部调用了Module._load方法 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102// 形参说明：request指代要加载的模块的标识符，parent指向第一个引用request模块的模块,isMain表示是否是入口调用（true/false）Module._load = function(request, parent, isMain) &#123; let relResolveCacheIdentifier; // 如果parent存在，也就是说有另外一个模块已经调用过该request模块（该request模块已经被处理过了） if (parent) &#123; debug('Module._load REQUEST %s parent: %s', request, parent.id); /* 同一目录中（延迟加载）模块的快速路径。 需要间接缓存以允许缓存无效而不更改旧的缓存键名称。 // 谷歌翻译 源码的解释（目前还没看懂） */ relResolveCacheIdentifier = `$&#123;parent.path&#125;\x00$&#123;request&#125;`; const filename = relativeResolveCache[relResolveCacheIdentifier]; if (filename !== undefined) &#123; // 从缓存中读取该模块 const cachedModule = Module._cache[filename]; if (cachedModule !== undefined) &#123; updateChildren(parent, cachedModule, true); return cachedModule.exports; &#125; delete relativeResolveCache[relResolveCacheIdentifier]; &#125; &#125; // 解析得到模块的真实文件路径 const filename = Module._resolveFilename(request, parent, isMain); // 判断缓存中是否有该模块 const cachedModule = Module._cache[filename]; if (cachedModule !== undefined) &#123; // 将request模块（需要引入的模块）添加到当前模块的children中 /* function updateChildren(parent, child, scan) &#123; const children = parent &amp;&amp; parent.children; if (children &amp;&amp; !(scan &amp;&amp; children.includes(child))) children.push(child); &#125; */ updateChildren(parent, cachedModule, true); // 返回该缓存模块的导出值 return cachedModule.exports; &#125; // 查看是否为核心模块，如果是，那么将该核心模块加入缓存并且返回该核心模块的导出值 /* function loadNativeModule(filename, request, experimentalModules) &#123; const mod = NativeModule.map.get(filename); if (mod) &#123; debug('load native module %s', request); mod.compileForPublicLoader(experimentalModules); return mod; &#125; &#125; */ const mod = loadNativeModule(filename, request, experimentalModules); // 如果是核心模块并且该模块可以被调用，那么返回该核心模块的导出值 if (mod &amp;&amp; mod.canBeRequiredByUsers) return mod.exports; // 此时，该request模块已经确定为是文件模块（不是缓存模块以及核心模块），那么以该文件模块创建一个Module实例 const module = new Module(filename, parent); // 如果该request模块是入口调用，那么将该模块作为入口模块 if (isMain) &#123; process.mainModule = module; module.id = '.'; &#125; // 将该文件模块存入缓存 Module._cache[filename] = module; // 如果是第一次加载该模块，那么将该模块添加到relativeResolveCache对象中，表示是最近加载过的模块 if (parent !== undefined) &#123; relativeResolveCache[relResolveCacheIdentifier] = filename; &#125; // 加载该模块并且进行异常捕获 let threw = true; try &#123; if (enableSourceMaps) &#123; try &#123; // 加载模块 module.load(filename); &#125; catch (err) &#123; rekeySourceMap(Module._cache[filename], err); throw err; &#125; &#125; else &#123; module.load(filename); &#125; threw = false; &#125; finally &#123; if (threw) &#123; delete Module._cache[filename]; if (parent !== undefined) &#123; delete relativeResolveCache[relResolveCacheIdentifier]; &#125; &#125; &#125; // 导出模块的导出值 return module.exports;&#125;; 注：以上是个人对源码的解读，并且只解释我知道的部分。]]></content>
      <categories>
        <category>Node</category>
      </categories>
      <tags>
        <tag>Node</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript常见错误类型]]></title>
    <url>AngelLikeFairy%2F2019%2F09%2F24%2FJavaScript%E5%B8%B8%E8%A7%81%E9%94%99%E8%AF%AF%E7%B1%BB%E5%9E%8B%2F</url>
    <content type="text"><![CDATA[JavaScript常见错误类型JavaScript主要包括以下几种常见错误类型 TypeError（类型错误） 对象用来表示值的类型非预期类型时发生的错误。 当传入函数的操作数或参数的类型并非操作符或函数所预期的类型时，将抛出一个 TypeError 类型错误。 SyntaxError 对象代表尝试解析语法上不合法的代码的错误 当Javascript语言解析代码时,Javascript引擎发现了不符合语法规范的tokens或token顺序时抛出SyntaxError. ReferenceError（引用错误） 对象代表当一个不存在的变量被引用时发生的错误。 当你尝试引用一个未被定义的变量时，将会抛出一个 ReferenceError 。 RangeError对象标明一个错误，当一个值不在其所允许的范围或者集合中。]]></content>
  </entry>
  <entry>
    <title><![CDATA[剑指Offer-求链表中的倒数第k个节点]]></title>
    <url>AngelLikeFairy%2F2019%2F09%2F23%2F%E5%89%91%E6%8C%87Offer-01%2F</url>
    <content type="text"><![CDATA[求链表中的倒数第k个节点题目描述输入：输入一个链表，输出该链表中倒数第k个节点。为了符合大多数人的习惯，本题从1开始计数，即链表的尾结点是倒数第一个节点。例如，一个链表有6个节点，从头结点开始，它们的值一次是1、2、3、4、5、6。这个链表的倒数第三个节点是值为4的节点。 链表节点定义如下： 1234/*function ListNode(x)&#123; this.val = x; this.next = null;&#125;*/ 核心思路我们可以设置两个双指针，cur指向头结点，anotherCur指向第k-1个节点。然后两个节点分别往下走，当anotherCur节点指向最后一个节点时，也就意味着cur指向了该链表的倒数第k个节点 但是，我们需要注意一些输入的问题以及边界情况。 输入链表head为空时的处理 k值小于等于0时的处理 k值大于链表长度时的处理 coding实现123456789101112131415161718192021222324/*function ListNode(x)&#123; this.val = x; this.next = null;&#125;*/function FindKthToTail(head, k)&#123; if(head===null||k&lt;=0) return null; let cur = head; let anotherCur = head; for(let i=1;i&lt;k;i++) &#123; if(anotherCur.next) &#123; anotherCur = anotherCur.next; &#125; else return null; &#125; while(anotherCur.next) &#123; anotherCur = anotherCur.next; cur = cur.next; &#125; return cur;&#125;module.exports = &#123; FindKthToTail : FindKthToTail&#125;; 时空复杂度分析 时间复杂度： O(n) 空间复杂度：O(1)]]></content>
      <categories>
        <category>leetcode题解与算法</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[webpack打包学习（一）]]></title>
    <url>AngelLikeFairy%2F2019%2F09%2F23%2Fwebpack%E6%89%93%E5%8C%85%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF%2F</url>
    <content type="text"><![CDATA[项目的基本搭建 新建一个项目并npm init为npm项目 安装webpck的相关模块，如下 webpack webpack-cli(webpack的命令行工具) style-loader(通过向 DOM 中注入 &lt;style&gt; 标签实现css效果) css-loader(解析引入的css文件) file-loader(处理文件包括图片文件和字体文件) webpack-dev-server(提供一个简单的web服务器) 新建源代码文件夹src目录 新建输出文件夹dist目录，并将index.html放入改文件夹中 新建webpack.config.js配置文件 在src文件夹中引入css文件方式如下： 1import './main.css' 模块css-loader会处理引入的css代码，而style-loader则负责将该css代码注入到Dom中 引入图片和字体文件方式如下： 1import img from './image.png' 模块file-loader会处理这些图片和字体文件并进行打包 编写webpack.config.jswebpack的打包都会按照这个文件的配置进行相应的打包 以上基本的打包实现如下： 12345678910111213141516171819202122232425262728293031323334353637// Node.js的原生模块，用于将相对路径转化为绝对路径const path = require('path');// 利用Common.js模块的导出语法，导出基本的配置module.exports = &#123; // 打包的入口 entry: &#123; main: './src/main.js' &#125;, // 打包的出口 output: &#123; filename: 'bundle.js', // 打包的出口文件名 path: path.resolve(__dirname,'dist')// __dirname是指当前的根目录，然后利用resolve函数就可以将__dirname于dist目录进行拼接然后转化为绝对路径，作为bundle.js文件的生成目录 &#125;, // 用来追踪错误和警告 devtool: "inline-source-map", // 服务器配置 devServer: &#123; // 告诉服务器，将 dist 目录下的文件，作为可访问文件。 contentBase: './dist' &#125;, module: &#123;\ // 创建模块时，匹配请求的规则数组。这些规则能够修改模块的创建方式。这些规则能够对模块(module)应用 loader，或者修改解析器(parser)。 rules: [ &#123; // 正则表达式匹配rule条件 test: /.css$/, //在规则条件匹配时使用的loader use: ["style-loader","css-loader"] &#125;, &#123; test: /.(jpg|png|jpeg|gif)$/, use: ["file-loader"] &#125; ] &#125;&#125;]]></content>
      <categories>
        <category>webpack</category>
      </categories>
      <tags>
        <tag>webpack</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Vue父子组件传值详解]]></title>
    <url>AngelLikeFairy%2F2019%2F09%2F22%2FVue%E7%88%B6%E5%AD%90%E7%BB%84%E4%BB%B6%E4%BC%A0%E5%80%BC%E8%AF%A6%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[父组件向子组件传值PropProp 是你可以在组件上注册的一些自定义特性。当一个值传递给一个 prop 特性的时候，它就变成了那个组件实例的一个属性。 因此，在子组件的方法代码中，我们可以使用this.xxx来访问到它 利用Prop单向数据流来使得父组件向子组件传值的基本格式如下： 123456789101112131415161718192021// 父组件 App.vue&lt;template&gt; &lt;div id="app"&gt; &lt;helloWorld :msg="msg"&gt;&lt;/helloWorld&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;import helloWorld from '@/components/HelloWorld.vue'export default &#123; data() &#123; return &#123; msg: 321 &#125; &#125;, components: &#123; helloWorld &#125;&#125;&lt;/script&gt; 123456789101112// 子组件 HelloWorld.vue&lt;template&gt; &lt;div class="hello"&gt; &#123;&#123;msg&#125;&#125; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123; props:['msg']&#125;&lt;/script&gt; 在上述父组件传值的时候是通过v-bind动态赋值的，但是我们也可以传递静态prop 1&lt;hello-world msg="qwer"&gt;&lt;/hello-world&gt; 注意的是，除了传入静态字符串之外，在传入静态的数值型，布尔型，对象型数据时我们依旧要使用v-bind来进行数据传输，否则就有可能造成数据传输失败 例如： 1234:msg='11111' //number:msg='true' //bootlean:msg='()=&gt;&#123;console.log(1)&#125; //function :msg='&#123;a:1&#125;' //object 因此，我们大可以使用v-bind动态传入，因为使用v-bind我们可以将字符串内的内容视为一个表达式进行计算 单向数据流所有的 prop 都使得其父子 prop 之间形成了一个单向下行绑定：父级 prop 的更新会向下流动到子组件中，但是反过来则不行。这样会防止从子组件意外改变父级组件的状态，从而导致你的应用的数据流向难以理解。 因此，只要父组件的数据发生了更新，子组件也会获得相应的更新。无论，发生更新的原因是异步操作还是事件操作 vm.$watch当然，我们可以使用watch方法来监听父组件数据的改变 1234567891011121314151617181920212223242526// 在父组件进行异步操作，一开始初值为undefined，经过2000毫秒后变为12345&lt;template&gt; &lt;div id="app"&gt; &lt;helloWorld :msg="msg"&gt;&lt;/helloWorld&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;import helloWorld from '@/components/HelloWorld.vue'export default &#123; data() &#123; return &#123; msg: undefined &#125; &#125;, components: &#123; helloWorld &#125;, created() &#123; setTimeout(()=&gt;&#123; this.msg=12345; &#125;,2000) &#125;&#125;&lt;/script&gt; 1234567891011121314151617// 在子组件中利用watch方法来进行监听父组件的prop值的变化&lt;template&gt; &lt;div class="hello"&gt; &#123;&#123;msg&#125;&#125; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123; props:['msg'], watch: &#123; msg(val,oldVal)&#123; console.log(val,oldVal); // 12345,undefined &#125; &#125;&#125;&lt;/script&gt; 拦截数据，过滤处理有时候，我们相对从父组件传过来的数据进行一些额外操作之后再进行渲染，此时我们可以利用计算属性来实现 12345computed: &#123; anotherMsg() &#123; return this.msg+1; &#125;&#125; 子组件向父组件传值vm.$on与vm.$emitvm.$on要与vm.$emit搭配来进行使用 vue的api文档是这么描述这两个api的 vm.$on( event, callback )参数： {string | Array} event (数组只在 2.2.0+ 中支持) {Function} callback用法： 监听当前实例上的自定义事件。事件可以由vm.$emit触发。回调函数会接收所有传入事件触发函数的额外参数。 示例： vm.$on(&apos;test&apos;, function (msg) { console.log(msg) }) vm.$emit(&apos;test&apos;, &apos;hi&apos;) // =&gt; &quot;hi&quot;vm.$emit( eventName, […args] )参数： {string} eventName[…args] 触发当前实例上的事件。附加参数都会传给监听器回调。 因此，我们可以在同一个实例上注册on监听事件函数以及emit响应事件函数 12345678910111213141516&lt;script&gt;export default &#123; created() &#123; console.log(this.msg); this.$on('test',(v)=&gt;&#123; console.log(v); &#125;) &#125;, methods: &#123; change() &#123; console.log('emit'); this.$emit('test',123456789); &#125; &#125;&#125;&lt;/script&gt; 我们在created生命周期时注册了一个监听test事件的on函数，在事件change()发生时，我们让test事件通过emit方法也进行发生。从而，监听函数会监听到该事件的发生并进行相应的输出 但是，虽然事件监听与响应都可以完成，但是这两个方法必须在同一个实例上才可以进行使用。因此，如果要进行子组件将值传递给父组件，我们可以使用v-on与vm.$emit进行搭配使用 v-on与vm.$emit因为父组件可以在使用子组件的引入模板直接用 v-on 来监听子组件触发的事件。因此，我们可以使用v-on和vm.$emit来使得子组件向父组件传值 例如： 1234567891011121314151617181920// 父组件&lt;template&gt; &lt;div id="app"&gt; // 在子组件的引入模板中使用v-on来进行监听子组件中的test事件 // 注意，@后必须是在子组件中要监听的事件名，而双引号中是父组件对于监听到事件发生后做出的处理函数。对于该例中，也就是test是要监听的事件名，getSonValue是父组件的处理函数 &lt;helloWorld :msg="msg" @test='getSonValue'&gt;&lt;/helloWorld&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;import helloWorld from '@/components/HelloWorld.vue'export default &#123; methods: &#123; getSonValue(v) &#123; console.log('v',v); &#125; &#125;&#125;&lt;/script&gt; 1234567methods: &#123; change() &#123; console.log('emit'); // 发布事件test，并传入参数123456789 this.$emit('test',123456789); &#125;&#125; 同级组件通信同级组件通信，也就是意味着某个父组件下有两个不同的子组件，这两个组件之间可以通信 父组件作为中转站一种可行的办法，就是父组件接收其中一个组件传递的值并将该值传递给另外一个子组件 例如： 1234567891011121314151617181920212223242526272829// 父组件&lt;template&gt; &lt;div id="app"&gt; &lt;component1 @msg="getMsg"&gt;&lt;/component1&gt; &lt;component2 :msg="msg"&gt;&lt;/component2&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;import component1 from '@/components/Component1'import component2 from '@/components/Component2'export default &#123; components: &#123; component1, component2 &#125;, methods: &#123; getMsg(v) &#123; this.msg=v; &#125; &#125;, data() &#123; return &#123; msg: undefined &#125; &#125;&#125;&lt;/script&gt; 123456789101112131415161718192021222324// 子组件1&lt;template&gt; &lt;div id="component1"&gt; &lt;div&gt; 子组件1的值为：&#123;&#123;msg&#125;&#125; &lt;/div&gt; &lt;button @click="sendMsg"&gt;click&lt;/button&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123; data() &#123; return &#123; msg: 123 &#125; &#125;, methods: &#123; sendMsg() &#123; this.$emit('msg',this.msg); &#125; &#125;&#125;&lt;/script&gt; 1234567891011&lt;template&gt; &lt;div id="component2"&gt; 子组件2的值为：&#123;&#123;msg&#125;&#125; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123; props: ['msg']&#125;&lt;/script&gt; 当子组件1点击按钮后，子组件2就可以获得组件1传过来的msg值 额外实例作为中央事件总线因为ES6的模块机制有一个特性 当模块内部发生变化的时候，引入模块的部分同样会发生变化 因此，我们可以创建一个额外的实例,并且在两个子组件中分别绑定vm.$emit方法进行事件发放和vm.$on方法进行事件监听 创建额外实例 1234// eventBus.jsimport Vue from 'vue'export default new Vue(); 在子组件1中引入该实例，并为其绑定分发事件vm.$emit方法 1234567891011121314151617181920212223242526&lt;template&gt; &lt;div id="component1"&gt; &lt;div&gt; 子组件1的值为：&#123;&#123;msg&#125;&#125; &lt;/div&gt; &lt;button @click="sendMsg"&gt;click&lt;/button&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;import eventBus from '@/components/eventBus.js'export default &#123; data() &#123; return &#123; msg: 123 &#125; &#125;, methods: &#123; sendMsg() &#123; console.log(eventBus); eventBus.$emit('msg',this.msg); &#125; &#125;&#125;&lt;/script&gt; 在子组件2中引入额外实例并为其绑定监听事件vm.$on方法 12345678910111213141516171819202122&lt;template&gt; &lt;div id="component2"&gt; 子组件2的值为：&#123;&#123;msg&#125;&#125; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;import eventBus from '@/components/eventBus.js'export default &#123; created() &#123; eventBus.$on('msg',(v)=&gt;&#123; this.msg=v; &#125;) &#125;, data() &#123; return &#123; msg: undefined &#125; &#125;&#125;&lt;/script&gt; 经过上述三步后，子组件2在created生命周期时就已经在额外实例上创建了事件监听方法。因此，当子组件1点击按钮之后就会向额外实例分发了一个事件msg;那么，额外实例就会监听到该事件的发生并作出处理函数，这样也就完成了两个同级组件之间的传值]]></content>
      <categories>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>Vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[nowcoder-2]]></title>
    <url>AngelLikeFairy%2F2019%2F09%2F19%2Fnowcoder-2%2F</url>
    <content type="text"><![CDATA[数组的相对排序题目描述请实现一个函数，将一个字符串中的每个空格替换成“%20”。例如，当字符串为We Are Happy.则经过替换之后的字符串为We%20Are%20Happy。 核心思路概述题意很简单，就是将所有的空格转化为’%20’的格式。因此，我们可以使用replace()方法来进行替换值，当然是使用正则表达式来进行匹配 Coding实现12345678function replaceSpace(str)&#123; let pattern=/\s/g; return str.replace(pattern,'%20');&#125;module.exports = &#123; replaceSpace : replaceSpace&#125;; 时空复杂度分析 时间复杂度：O(1) 空间复杂度：O(1)]]></content>
      <categories>
        <category>leetcode题解与算法</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[leetcode-367 有效的完全平方数]]></title>
    <url>AngelLikeFairy%2F2019%2F09%2F18%2Fleetcode-367%2F</url>
    <content type="text"><![CDATA[有效的完全平方数题目描述给定一个正整数 num，编写一个函数，如果 num 是一个完全平方数，则返回 True，否则返回 False。 说明：不要使用任何内置的库函数，如 sqrt。 示例 1： 输入：16输出：True 示例 2： 输入：14输出：False 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/valid-perfect-square著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 核心思路概述我们知道，对于大于等于4的完全平方数，它的平方根会小于或等于它的一半。因此，我们可以在2~n/2之间进行二分查找，来降低时间复杂度 解题步骤 如果给定的数为1，返回true 设定left为2，right为Math.floor(num/2)，mid为Math.floor((left+right)/2)；如果mid*mid===num那么返回true；如果小于，则left=mid+1;否则right=mid-1; 重复步骤2知道right&gt;left 如果上述二分过程中没有返回true，那么返回false Coding实现123456789101112131415161718192021/** * @param &#123;number&#125; num * @return &#123;boolean&#125; */var isPerfectSquare = function(num) &#123; if(num===1) return true; let left=2; let right=Math.floor(num/2); let mid; while(left&lt;=right) &#123; mid=Math.floor((left+right)/2); if(mid*mid===num) return true; else if(mid*mid&gt;num) &#123; right=mid-1; &#125; else &#123; left=mid+1; &#125; &#125; return false;&#125;;]]></content>
      <categories>
        <category>leetcode题解与算法</category>
      </categories>
      <tags>
        <tag>二分查找</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[nowcoder-1 二维数组中的查找]]></title>
    <url>AngelLikeFairy%2F2019%2F09%2F17%2Fnowcoder-1%2F</url>
    <content type="text"><![CDATA[数组的相对排序题目描述在一个二维数组中（每个一维数组的长度相同），每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。 核心思路概述 最直接的暴力解法遍历二维数组中的每一个元素，返回是否能找到给定的target值 利用ES6特性，将数组扁平化（但是牛客网并没有很好地支持flat()函数，因此我们可以使用concat()方法来实现扁平化）后使用includes()函数进行查找 巧妙一点的方法是：由于该二维数组的规律（每一行从左往右递增，每一列从上往下递增），我们可以发现二维数组的左下角总是当前行的最小值，当前列的最大值。因此，当给定值大于当前左下角的数值时，我们就将该数往右移动一位；当给定值小于当前左下角的数值时，我们就将该数往上移动一位。直到找到该值返回true，或者遍历到右上角仍然没有找到返回false 解题步骤Coding实现通过concat()扁平化后利用includes()来查找 12345678function Find(target, array)&#123; let arr=[].concat(...array); return arr.includes(target);&#125;module.exports = &#123; Find : Find&#125;; 左下到右上的查找 1234567891011121314151617181920function Find(target, array)&#123; let column=0; let row=array.length-1; let num; while(column&lt;array[0].length&amp;&amp;row&gt;=0)&#123; num=array[row][column]; if(target&gt;num) &#123; column++; &#125; else if(target&lt;num) &#123; row--; &#125; else return true; &#125; return false;&#125;module.exports = &#123; Find : Find&#125;;]]></content>
      <categories>
        <category>leetcode题解与算法</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[模块化]]></title>
    <url>AngelLikeFairy%2F2019%2F09%2F16%2F%E6%A8%A1%E5%9D%97%E5%8C%96%2F</url>
    <content type="text"><![CDATA[模块与脚本的区别模块不会将它的顶级变量、函数和类作为全局作用域的全局变量，并且模块顶级作用域的this值为undefined 为什么要模块化模块化可以将一个复杂的功能拆分为几个小功能，并且功能模块之间不会互相影响。这样就可以使得代码低耦合 另外，因为每个模块声明的变量并不会影响全局作用域，因此就不会有全局变量污染以及命名冲突的问题 每个模块都是独立的，因此模块具有良好的可复用性 CommonJs模块化Node.js是commonJS规范的主要实践者，它有四个重要的环境变量为模块化的实现提供支持：module、exports、require、global。实际使用时，用module.exports定义当前模块对外输出的接口（不推荐直接用exports），用require加载模块。 例如： 123456// 定义模块module.jsconst a=1;module.exports.test=()=&gt;&#123; console.log(a);&#125; 12345// 定义test模块并引入module模块const m=require('./test')m.test(); // 1 Es6模块化基本语法导出的几种形式123456789101112131415161718192021222324252627282930313233343536373839404142// 定义的同时，导出单个变量、对象、函数或类export const a=1；export const b=&#123;item:1&#125;;export const c=()=&gt;1;export class C&#123; constructor(item) &#123; this.item=item; &#125; getItem()&#123; return this.item; &#125;&#125;// 在定义之后导出单个变量const a=1;export a;// 在定义之后导出多个变量const a=1;const b=2;export &#123;a,b&#125;;// 导出时重命名，使用as关键字来指定变量等在模块外应该被称为什么名称,同时需要使用大括号const a=1;export &#123;a as itemA&#125;;// 重命名多个变量const a=1;const b=2;export &#123;a as itemA,b as itemB&#125;;// 导出模块的默认值，模块的默认值通过default关键字来指定。一个模块只能导出一个默认值（单个变量，函数，类，对象等）export default &#123; item:1&#125;// 重新导出一个引入的绑定import &#123;a&#125; from './m.js'export &#123;a&#125;; // 导出非默认值绑定import &#123;a&#125; from './m.js'export default a; // 导出默认值绑定 导入的几种形式12345678910111213141516171819202122232425// 仅为副作用而导入一个模块,整个模块仅为副作用（中性词，无贬义含义）而导入，而不导入模块中的任何内容（接口）。 这将运行模块中的全局代码, 但实际上不导入任何值。import from './test.js'//导入非默认值单个变量import &#123;a&#125; from './test.js'// 导入非默认值多个变量import &#123;a,b&#125; from './test.js'// 导入整个模块import * from './test.js'// 导入默认值时不需要大括号语法import a from './test.js'// 导入默认值和非默认值，注意默认值必须排在非默认值前export const a=1;const b=2;export default b;import b,&#123;a&#125; from './test.js'// 导入非默认值时重命名，导入默认值则无法重命名，因为默认值的导入变量命名本来就是自己定义的import &#123;a as itemA&#125; from './test.js' 注意：导入非默认值绑定看起来像是解构对象，但事实上它不是 模块化的一些注意点以下是我们需要注意的地方 当从另一个模块中导入一个绑定，该绑定就好像是使用const定义的一样。我们无法对它进行修改和重命名。 1234567import b,&#123;a as itemA&#125; from './test.js'b=1; // 报错："b" is read-only.console.log(b,itemA);import b,&#123;a as itemA&#125; from './test.js'let b=1; // 报错： Identifier 'b' has already been declaredconsole.log(b,itemA); 使用import语法时要引入的模块文件必须要加上文件后缀，例如’./test.js’；而node.js则遵循基于文件系统前缀来区分文件和包的惯例。例如，example是一个包，而example.js是一个本地文件 为了最好地兼容多个浏览器和Node.js环境，一定要在模块文件名前包含/、./或../来表示要导入的文件 模块只会执行一次，无论你多少次导入同一模块。当导入模块的代码执行后，实例化过的模块就会被保存在内存中，只要另一个import语句引用它就可以重复使用 123import &#123;a&#125; from './test.js'; // 该模块只会执行这一次import &#123;b&#125; from './test.js';import &#123;c&#125; from './test.js'; 模块语法只能在当前模块顶部(也就是该模块的最外层执行环境)使用 导入模块的标识符只是本地的一个变量名称，并不等于被引入的模块中的同名变量 模块只能设置一个默认的导出值 CommonJs模块化与ES6模块化的区别 调用时间 require是运行时调用，也就是只有代码运行到require命令时，才会运行和导入其他模块。所以,require可以放在代码的任何地方 import是编译时调用，因此，进入有import命令的模块时，被导入模块会第一时间被运行和导入，然后才会运行其他代码 例如： 12345678910111213141516// module1.jsconsole.log('module1.js');export default &#123; item: 1&#125;// module2.jsconsole.log('module2.js');import m from './module1.js'console.log(m);// 运行module2.js结果如下：'module1.js','module2.js',&#123;item:1&#125;]]></content>
      <categories>
        <category>ES6</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[js事件循环机制 event loop]]></title>
    <url>AngelLikeFairy%2F2019%2F09%2F13%2F%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF%E6%9C%BA%E5%88%B6%2F</url>
    <content type="text"><![CDATA[为什么js是单线程的众所周知，JavaScript是一门单线程语言。那么，为什么js必须是单线程的呢？ 因为，js主要的宿主环境就是浏览器，并且其一个重要的用途就是来操作Dom。反过来思考，如果js是多线程的，那么就会允许同一时间有多个代码块运行。那么，如果这多个代码块同时操作同一个Dom，比如，一个代码块要修改某dom元素，而另一个代码块又要删除这个元素，那么浏览器该如何处理这个元素。因此，为了避免这种复杂性，js必须是单线程的 执行栈（调用栈）与任务队列什么是执行栈（调用栈）执行栈，也就是“调用栈”，是一种拥有 LIFO（后进先出）数据结构的栈，被用来存储代码运行时创建的所有执行上下文（包括全局执行上下文，局部函数执行上下文以及eval函数执行上下文）。 注意，因为JavaScript是单线程的，因此，其只有一个调用栈 例如： 123456789function a() &#123; b();&#125;function b() &#123; console.log(1);&#125;a(); 对于以上代码，执行栈里面的任务是这样依次出入栈的： 进入该段整体代码 main()入栈 执行a() a()入栈 调用b b()入栈 执行b函数 console.log(1)入栈 输出完毕，console.log(1)出栈 b()出栈 a()出栈 main()出栈，代码执行完毕 任务众所周知，我们可以将js的任务分为两大类： 同步任务优先级最高，运行时立刻进入主线程运行 异步任务只有当所有同步任务执行完毕后才会去执行异步任务，异步任务的执行过程如下： 异步任务进入Event Table执行，并且注册回调函数 当指定的异步任务完成时，Event Table会将这个回调函数移入Event Queue（值得注意的是，当有多个异步任务时，先执行完毕的异步任务的回调函数会先进入该任务队列） 主线程内的任务执行完毕为空，会去Event Queue读取对应的函数，进入主线程执行 上述过程会不断重复，这也是我们后面会提到的事件循环 上述的event queue指的是就是任务队列，任务队列内存放的都是异步任务完成后要执行的函数 另外，我们需要注意的是，只有异步任务完成之后要执行的回调函数才会被放入任务队列，等待主线程中的所有同步代码被执行完毕之后再执行。 因此，比如在new Promise过程中不再回调函数内的代码都是同步代码，只有then()和catch()中的回调函数才是异步代码 例如： 12345678910new Promise((resolve,reject)=&gt;&#123; // 第一行 console.log(1); // 第二行 resolve(2); //第三行&#125;).then((v)=&gt;&#123; // 第四行 console.log(v); // 第五行&#125;) // 第六行// 输出结果12 其中，第1,2,3,4,6行都是同步代码，只有第5行是异步的代码 以下是任务执行过程: 宏任务与微任务 异步任务又可以分为宏任务与微任务 对于异步任务，它们也可以更加被细分为宏任务与微任务两种，具体如下 宏任务(macrotask)： script(整体代码)、setTimeout、setInterval、UI 渲染、 I/O、postMessage、 MessageChannel、setImmediate(Node.js 环境)、ajax、外部请求等 微任务(microtask)： Promise.then/catch、 MutaionObserver、process.nextTick(Node.js环境） 那么宏任务与微任务的执行顺序是怎么样的呢？ 网络上有两种说法，目前我还没有看到权威文章 如果，我们将整个script(整体代码)也算做是一个宏任务，那么执行顺序会是 宏任务-&gt;所有微任务-&gt;下一个宏任务 但是如果不是的话，那么就是 所有微任务-&gt;下一个宏任务 总之这些并不会影响代码的执行顺序 例如： 宏任务定时器与微任务promise 1234567891011121314151617181920212223242526272829303132setTimeout(()=&gt;&#123; console.log(1)&#125;,0)new Promise((resolve,reject)=&gt;&#123; resolve(2); console.log(3);&#125;).then(v=&gt;&#123; console.log(v); return 4;&#125;).then(v=&gt;&#123; console.log(v);&#125;)console.log(5);// 执行结果35241// 执行过程1. 先进入整体代码script这个宏任务，该任务直接进入主线程，因此要执行掉所有的同步任务2. 遇到setTimeout这一宏任务，我们将其放入宏任务队列3. 遇到Promise构造函数，立即执行该构造函数，执行console.log(3);两个then()方法依次进入微任务队列4. 执行console.log(5);5. 第一个宏任务执行结束，接下来查看微任务队列是否有要解决的微任务，按照先进先出的原则执行完所有的微任务6. 到这里，第一轮事件循环结束，进入下一轮事件循环7. 从宏任务队列中取出下一个宏任务，也就是setTimeout的回调函数，执行它... 宏任务ajax与微任务promise 123456789101112131415161718192021222324const axios=require('axios')axios.get('https://www.baidu.com').then(v=&gt;&#123; console.log(1);&#125;)new Promise((resolve,reject)=&gt;&#123; console.log(2); resolve(3);&#125;).then(v=&gt;&#123; console.log(v); return (4);&#125;).then(v=&gt;&#123; console.log(v);&#125;)console.log(5);// 运行结果25341 最后，来一段超级复杂的代码 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950console.log('1');setTimeout(function() &#123; console.log('2'); process.nextTick(function() &#123; console.log('3'); &#125;) new Promise(function(resolve) &#123; console.log('4'); resolve(); &#125;).then(function() &#123; console.log('5') &#125;)&#125;)process.nextTick(function() &#123; console.log('6');&#125;)new Promise(function(resolve) &#123; console.log('7'); resolve();&#125;).then(function() &#123; console.log('8')&#125;)setTimeout(function() &#123; console.log('9'); process.nextTick(function() &#123; console.log('10'); &#125;) new Promise(function(resolve) &#123; console.log('11'); resolve(); &#125;).then(function() &#123; console.log('12') &#125;)&#125;)//176824359111012 注意setTimeout我们知道setTimeout也是一个异步api。在每次事件循环中，会检查是否超过了指定事件，如果超过，就会将回调函放入宏任务队列等待被执行 以下是一个很棒的关于setTimeout宏任务与promise.then微任务的一个例子 123456789101112131415161718192021222324252627console.log('global')for (var i = 1;i &lt;= 5;i ++) &#123; setTimeout(function() &#123; console.log(i) &#125;,i*1000) console.log(i)&#125;new Promise(function (resolve) &#123; console.log('promise1') resolve() &#125;).then(function () &#123; console.log('then1')&#125;)setTimeout(function () &#123; console.log('timeout2') new Promise(function (resolve) &#123; console.log('timeout2_promise') resolve() &#125;).then(function () &#123; console.log('timeout2_then') &#125;)&#125;, 1000)// global 1 2 3 4 5 promise1 then1 6 timeout2 timeout2_promise timeout2_then 6 6 6 6 考虑ajax我们现在来讨论下并行ajax的执行过程 12ajax1();ajax2(); 宏任务队列出队首任务（&lt;script&gt;整体代码） 遇到ajax1()，它是一个异步任务，放入event table进行执行 遇到ajax2()，它是一个异步任务，放入event table进行执行 event table执行完毕的异步任务返回的回调函数会根据该事件的类型选择进入宏任务队列还是微任务队列（对于以上的ajax1和ajax2，先执行完毕的ajax会先进入宏任务队列） 事件循环机制检查调用堆栈是否为空，然后不断地去检查事件队列（任务队列）是否为空。如果为空，则继续检查；如果不为空，则将该队列的第一个回调函数压入主线程去进行执行 事件循环 在一次事件循环中，异步事件返回的结果会被放入到一个任务队列中，但是根据异步事件的类型，需要把事件放入到对应的微任务队列或宏任务队列中。 我们可以从两个角度去考虑事件循环，不仅仅是上文已经提到的同步与异步，还可以从微任务与宏任务来考虑事件循环 从同步与异步来看事件循环如上文提到的所述： 检查每一个进入主线程的任务，如果为同步任务，那么压入主线程堆栈；如果为异步，将该任务移到event table中，当该异步任务执行完毕后，将异步任务绑定的回调函数移入事件队列（任务队列）中 Js引擎会检查调用堆栈是否为空，然后不断地去检查事件队列（任务队列）是否为空。如果为空，则继续检查；如果不为空，则将该队列的第一个回调函数压入主线程去进行执行 对于，事件循环的思考： 为什么要进行事件循环？我觉得，不断地对事件队列去判断事件队列是否有任务的原因是因为，事件队列里存放的回调函数都是异步操作完成后才加入的。我们无法知道异步操作什么时候会完成。因此，就得不断去循环。而对于主线程，我们只需简单地判断堆栈是否为空（也就是堆栈长度是否为0）即可 以上过程可以用伪代码进行描述 12345678910// [... some initialization ...]// The Event Loopwhile (true) &#123; if (! EventQueue.isEmpty()) &#123; event = EventQueue.pop_oldest_item(); event.callback(event [or some other kind of args]); &#125; // [... defer to other non-JS tasks...]&#125; 从微任务与宏任务看事件循环准备： 检查每一个进来的任务，如果是同步任务，那么压入主线程调用栈中；如果是微任务，那么放入微任务队列；如果是宏任务，那么放入宏任务队列 Event Loop(事件循环)中，每一次循环称为 tick, 每一次tick的任务如下： 执行栈执行完主线程中的所有任务（也可以&lt;script&gt;整体代码当做一个宏任务） 检查微任务队列，查看是否存在 Microtask，如果存在则不停的执行，直至清空 microtask 队列 更新render(每一次事件循环，浏览器都可能会去更新渲染) 检查宏任务队列，查看是否存在Macrotask，如果存在则取出一个任务进行执行（执行准备阶段操作） 重复以上步骤 总结： 微任务总是在下一个宏任务之前被执行完毕 综上一次详尽的事件循环的理解： 从宏任务队列中出队列并运行最早的任务（例如“脚本”（第一个任务往往都是script整体代码）） 检查任务类型 如果是同步任务，放入主线程执行栈进行执行； 如果为异步任务时，那么就会将该任务放入event table中进行执行。当这些异步任务执行完毕后，会将异步任务的回调函数放入任务队列（event queue）中。 此时，我们需要知道任务队列并不是只有一个队列，它又可以分为宏任务队列和微任务队列； 引擎可以根据该异步事件的类型，将该异步事件放入指定的宏任务队列或者是微任务队列。 检查微任务队列，查看是否存在 Microtask，如果存在则不停的执行，直至清空 microtask 队列 更新render(每一次事件循环，浏览器都可能会去更新渲染) 如果宏任务队列为空，请等到出现宏任务。 回到步骤1]]></content>
      <categories>
        <category>javaScript基础</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[leetcode-303 区域和检索 - 数组不可变]]></title>
    <url>AngelLikeFairy%2F2019%2F09%2F13%2Fleetcode-303%2F</url>
    <content type="text"><![CDATA[区域和检索 - 数组不可变题目描述给定一个整数数组 nums，求出数组从索引 i 到 j (i ≤ j) 范围内元素的总和，包含 i, j 两点。 示例： 给定 nums = [-2, 0, 3, -5, 2, -1]，求和函数为 sumRange() sumRange(0, 2) -&gt; 1 sumRange(2, 5) -&gt; -1 sumRange(0, 5) -&gt; -3说明: 你可以假设数组不可变。 会多次调用 sumRange 方法。 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/range-sum-query-immutable著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 核心思路概述求数组中给定范围之间的和，比如说是求i&lt;=j之间范围的和，我们可以使用前j个元素的和减去前i-1个元素的和。 题目说明会多次调用求和方法，因此，我们可以在构造函数中就将前1个元素的和到第n个元素的和保存在哈希表中 解题步骤 遍历数组，以当前元素下标为键名，以从第一个元素到当前元素的和作为键值来建立哈希表 返回前j个元素的和减去前i-1个元素的和 Coding实现123456789101112131415161718192021222324252627/** * @param &#123;number[]&#125; nums */var NumArray = function(nums) &#123; this.nums=nums; let map=new Map([[-1,0]]),sum=0; for(let i=0;i&lt;nums.length;i++) &#123; sum+=nums[i]; map.set(i,sum); &#125; this.map=map;&#125;;/** * @param &#123;number&#125; i * @param &#123;number&#125; j * @return &#123;number&#125; */NumArray.prototype.sumRange = function(i, j) &#123; return this.map.get(j)-this.map.get(i-1);&#125;;/** * Your NumArray object will be instantiated and called as such: * var obj = new NumArray(nums) * var param_1 = obj.sumRange(i,j) */]]></content>
      <categories>
        <category>leetcode题解与算法</category>
      </categories>
      <tags>
        <tag>哈希表</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[leetcode-290 单词规律]]></title>
    <url>AngelLikeFairy%2F2019%2F09%2F12%2Fleetcode-290%2F</url>
    <content type="text"><![CDATA[单词规律题目描述给定一种规律 pattern 和一个字符串 str ，判断 str 是否遵循相同的规律。 这里的 遵循 指完全匹配，例如， pattern 里的每个字母和字符串 str 中的每个非空单词之间存在着双向连接的对应规律。 示例1: 输入: pattern = “abba”, str = “dog cat cat dog”输出: true 示例 2: 输入:pattern = “abba”, str = “dog cat cat fish”输出: false 示例 3: 输入: pattern = “aaaa”, str = “dog cat cat dog”输出: false 示例 4: 输入: pattern = “abba”, str = “dog dog dog dog”输出: false 说明:你可以假设 pattern 只包含小写字母， str 包含了由单个空格分隔的小写字母。 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/word-pattern著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 核心思路概述判断两个字符串是否完全匹配，也就是二者中的每个元素要互相对应，因此，我们可以使用哈希表来进行配对与比较 解题步骤 将str字符串通过split(‘ ‘)方法转化为字符串数组 遍历两个字符串，以pattern元素为键名，字符串数组对应元素作为键值，如果遇到冲突那么返回false 遍历两个字符串，以字符串数组元素为键名，pattern对应元素作为键值，如果遇到冲突那么返回false 返回true Coding实现12345678910111213141516171819202122232425262728/** * @param &#123;string&#125; pattern * @param &#123;string&#125; str * @return &#123;boolean&#125; */var wordPattern = function(pattern, str) &#123; let strArr=str.split(' '); let map=new Map(); if(pattern.length!==strArr.length) return false; for(let i=0;i&lt;pattern.length;i++) &#123; if(!map.has(pattern[i])) &#123; map.set(pattern[i],strArr[i]); &#125; else &#123; if(map.get(pattern[i])!==strArr[i]) return false; &#125; &#125; map.clear(); for(let i=0;i&lt;strArr.length;i++) &#123; if(!map.has(strArr[i])) &#123; map.set(strArr[i],pattern[i]); &#125; else &#123; if(map.get(strArr[i])!==pattern[i]) return false; &#125; &#125; return true;&#125;;]]></content>
      <categories>
        <category>leetcode题解与算法</category>
      </categories>
      <tags>
        <tag>哈希表</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[leetcode-278 第一个错误的版本]]></title>
    <url>AngelLikeFairy%2F2019%2F09%2F11%2Fleetcode-278%2F</url>
    <content type="text"><![CDATA[第一个错误的版本题目描述你是产品经理，目前正在带领一个团队开发新的产品。不幸的是，你的产品的最新版本没有通过质量检测。由于每个版本都是基于之前的版本开发的，所以错误的版本之后的所有版本都是错的。 假设你有 n 个版本 [1, 2, …, n]，你想找出导致之后所有版本出错的第一个错误的版本。 你可以通过调用 bool isBadVersion(version) 接口来判断版本号 version 是否在单元测试中出错。实现一个函数来查找第一个错误的版本。你应该尽量减少对调用 API 的次数。 示例: 给定 n = 5，并且 version = 4 是第一个错误的版本。 调用 isBadVersion(3) -&gt; false 调用 isBadVersion(5) -&gt; true 调用 isBadVersion(4) -&gt; true 所以，4 是第一个错误的版本。 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/first-bad-version著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 核心思路概述该题考查的是二分查找的思想。不过需要注意边界处理。当isBadVersion(mid)的值为false时说明，第一个坏掉的产品肯定在mid后，因此left=mid+1;注意的是：当isBadVersion(mid)的值为true时，此时的mid值可能就是那个坏掉的第一个产品，因此，right=mid，而不是right=mid-1 解题步骤 设立left=1,right=n 取mid=Math.floor((left+right)/2) 如果isBadVersion(mid)的值为false时则left=mid+1; 如果isBadVersion(mid)的值为true时则right=mid 重复2,3步骤直到left===right 返回left Coding实现123456789101112131415161718192021222324252627282930313233/** * Definition for isBadVersion() * * @param &#123;integer&#125; version number * @return &#123;boolean&#125; whether the version is bad * isBadVersion = function(version) &#123; * ... * &#125;; *//** * @param &#123;function&#125; isBadVersion() * @return &#123;function&#125; */var solution = function(isBadVersion) &#123; /** * @param &#123;integer&#125; n Total versions * @return &#123;integer&#125; The first bad version */ return function(n) &#123; let left=1,right=n,mid; while(left&lt;right) &#123; mid=Math.floor((left+right)/2); if(isBadVersion(mid)===false) &#123; left=mid+1; &#125; else &#123; right=mid; &#125; &#125; return left; &#125;;&#125;;]]></content>
      <categories>
        <category>leetcode题解与算法</category>
      </categories>
      <tags>
        <tag>二分查找</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Promise与异步编程]]></title>
    <url>AngelLikeFairy%2F2019%2F09%2F10%2FPromise%E4%B8%8E%E5%BC%82%E6%AD%A5%E7%BC%96%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[什么是异步编程异步编程是什么？为什么需要异步编程；这都要从同步说起 因为JavaScript语言是一门单线程语言。我们只能在一个线程上运行任务，该线程被称之为主线程。就像下面的例子一样，代码是按照顺序执行的 12345(function getA()&#123; a=1;&#125;)()console.log(a); // 1 显然的是，以上会先执行getA函数并设置全局变量a=1，然后就会输出a=1; 但是，我们有没有想过一个问题，如果a的值不是我们自己先行设置的，而是向某服务器请求某资源后再赋值的呢？就像下面这样： 123456789101112131415// 引入axiosconst axios=require("axios");// 声明变量alet a;(function getA()&#123; axios.get('http://www.baidu.com').then((content)=&gt;&#123; a=1; &#125;).catch((err)=&gt;&#123; console.log(err); &#125;)&#125;)()console.log(a); // undefined 我们会发现，这时候输出并不是1，而是undefined。这是为什么呢？难道代码不是顺序执行的吗？我们尝试着分析一下以上代码，我们首先声明了变量a但未定义，之后我们进入了getA()函数，在该函数中我们利用了axios工具去请求百度站点的信息。到这里，都没有任何问题。但是，去请求资源，我们都知道网络情况是不确定的，我们不知道这一过程会花费多少时间，因此我们会将该异步任务放入另一个任务队列中，当该任务完成后（也就是请求成功或请求失败）再放入主线程队列去执行相应的函数。但是，主线程也是按照队列的顺序依次来执行的，因此只有当主线程内的所有任务执行完毕后我们才能执行异步任务返回的函数代码。 getA()函数与console.log(a)都是主线程内的任务，因此，执行顺序就会是： getA() -&gt; console.log(a) -&gt; 异步任务完成后要执行的操作 这就是异步编程，我们的程序中可能会有一些要造成阻塞的代码（请求外部资源之类），如果是同步的话，那么在请求完成之前我们都无法继续执行下面的程序，但是如果异步编程。将异步任务放入一个异步任务队列，等该异步任务完成后再将其放入主线程任务队列，这样的话，在请求资源的过程中，我们仍旧可以运行后面的程序 异步编程具有的几种形式事件监听在进行事件操作的时候，例如用户点击按钮就会触发一个click事件。当点击按钮之后，onclick事件所要执行的任务就会放入异步任务队列中，只有当主线程内的所有任务完成后它才会被执行 12345678910let a=1;let button=document.getElementById('btn');button.onclick=function() &#123; console.log('Button is clicked');&#125;console.log(a); // 执行结果1Button is clicked click单击事件一开始就会被注册，但是只有被监听到click事件发生后才会执行click需要响应的操作 回调模式什么是回调函数？ 一个回调函数，也被称为高阶函数，是一个被作为参数传递给另一个函数的函数，回调函数在另外一个函数中被调用。一个回调函数本质上是一种编程模式（为一个常见问题创建的解决方案），因此，使用回调函数也叫做回调模式。 例如： 12345678function func()&#123; console.log('回调函数');&#125;(function test(a,func)&#123; console.log(a); // 1 func(); // '回调函数'&#125;)(1,func) func函数被作为参数传递给test函数并被其调用，那么func函数就被称之为回调函数 在Node.js中有大量的异步代码，因此，会大量使用回调函数来优化异步编程 例如，下面的读取文件操作 1234567891011121314const fs=require('fs');fs.readfile('example.txt',function(err,contents) &#123; if(err) &#123; console.log(err); &#125; else console.log(contents);&#125;)console.log(1);// 执行结果1example.txt内的内容或者是报错内容 上述代码在执行readFile()函数后，发现这是一个异步任务，那么就将该异步任务放入异步任务队列，等到执行完毕后再放入到主线程任务队列等待执行。 readFile()函数的功能： readFile()函数执行，然后就去读取给定的文件，读取结束后会执行回调函数。如果出现错误，就会将错误对象赋值给回调函数中的err参数；如果一切正常，文件内容就会字符串的形式赋值给contents参数 可能有些人会不理解为什么在一个函数a中将另一个函数b作为参数，这个函数b会被执行。因为，这个readFile()函数是Node.js中的一个api 接口大致意思可能如下： 123456789function readFile(fileName,func) &#123; // 读取fileName文件 if(success) &#123; contents='文件内容'; err=null; &#125; else err='失败原因'; func(err,contents);&#125; 事件发布与订阅提到发布订阅模式，我们很容易会想到Vue中也有两个api来提供这种模式，分别是vm.$on和vm.$emit 那么，什么是发布订阅模式呢？ 发布—订阅模式又叫观察者模式，它定义对象间的一种一对多的依赖关系，当一个对象的状态发生改变时，所有依赖于它的对象都将得到通知。 因此，我们可以利用这个特性来实现异步编程。我们可以先订阅几个事件，并注册几个事件发生后要执行的回调函数。然后，就可以开始监听订阅的事件。当事件被发布后，一开始订阅了事件的要处理的回调函数就会被执行。 接下来，我们实现一下这个发布订阅模式 12345678910111213141516171819202122232425262728293031323334353637383940414243let vm = &#123; // events对象保存所有订阅的事件,作为事件订阅与发布的载体 events: &#123;&#125;, // 订阅事件，如果事件不存在，那么订阅该事件，并创建该事件的所有订阅者要执行的回调函数列表同时存入该callback；如果已存在，那么将callback添加入执行列表即可 on(event,callback) &#123; if(!this.events[event]) &#123; this.events[event]=[]; &#125; this.events[event].push(callback); &#125;, // 发布事件，将指定的event事件发布。我们会去事件订阅中心events对象查看是否有该订阅事件，如果没有，提示没有该订阅事件；如果有该订阅事件，那么执行订阅该事件的所有订阅者要执行的callback，并传递...items给这些callback emit(event,...items) &#123; if(!this.events[event]) &#123; console.log('没有订阅该事件'); return false; &#125; this.events[event].forEach(v=&gt;&#123; v.call(this,...items); &#125;) &#125;&#125;vm.on('test',function(...items) &#123; console.log('test A',...items);&#125;)vm.on('test',function(...items) &#123; console.log('test B',...items);&#125;)vm.on('test1',function(...items) &#123; console.log('test1 A',...items);&#125;)vm.emit('test',1,2,3);vm.emit('test1',1,2,3);vm.emit('test2',1,2,3);// 执行结果test A 1 2 3test B 1 2 3test1 A 1 2 3没有订阅该事件 PromisePromise 对象是一个代理对象（代理一个值），被代理的值在Promise对象创建时可能是未知的。它允许你为异步操作的成功和失败分别绑定相应的处理方法。 这让异步方法可以像同步方法那样返回值，但并不是立即返回最终执行结果，而是一个能代表未来出现的结果的promise对象 为什么更推荐Promise在Promise出现以前，我们一般都是利用回调模式来处理异步操作。如果，我们在请求一个网络资源的时候需要另一个网络资源请求的返回结果，那么，利用回调模式我们一般会这么写 12345请求1(function(请求结果1)&#123; 请求2(function(请求结果2)&#123; 处理请求结果2 &#125;)&#125;) 但是，如果每一个请求都需要另一个请求的返回结果呢？ 12345678910111213请求1(function(请求结果1)&#123; 请求2(function(请求结果2)&#123; 请求3(function(请求结果3)&#123; 请求4(function(请求结果4)&#123; 请求5(function(请求结果5)&#123; 请求6(function(请求结果3)&#123; ... &#125;) &#125;) &#125;) &#125;) &#125;)&#125;) 这样我们就会很容易陷入回调地狱中。回调地狱主要带来了一下一些问题： 代码臃肿 可读性差 耦合度高，可维护性差 只能在回调里来处理异常 异步操作的顺序变更时，需要大规模的代码重构。 回调函数基本都是匿名函数，bug 追踪困难。 那么，Promise呢，Promise允许我们使用同步的方式来去处理异步代码，如下 123456new Promise(请求1) .then(请求2(请求结果1)) .then(请求3(请求结果2)) .then(请求4(请求结果3)) .then(请求5(请求结果4)) .catch(处理异常(异常信息)) 除了同步的方式之外，我们还可以在Promise链的最外层来捕获异步函数的异常信息 Promise的生命周期promise对象的生命周期包括以下三种： 进行中 pending 已完成 fulfilled/resolved 被拒绝(未能成功完成) rejected Promise构造函数创建promise用Promise构造函数可以创建一个promise，构造函数只接受一个参数，也就是包含初始化Promise代码的执行器函数。Promise构造函数运行时会立刻调用该执行器函数。执行器函数接受两个参数，分别是resolve函数和rejected函数。 执行器函数内部通常会执行一些异步操作，当异步操作成功完成时需要调用resolve()函数来将promise的状态改为fulfilled/resolved；当异步操作失败时，需要调用reject()函数来将promise的状态改为rejected。如果在执行器函数中抛出了一个错误，那么该promise的状态就会被直接修改为rejected 例如： 12345678910111213141516171819const fs=require('fs')// 异步读取文件内容let promise=new Promise((resolve,reject)=&gt;&#123; fs.readFile('test.js','utf8',(err,contents)=&gt;&#123; if(err) &#123; reject(err); &#125; else &#123; resolve(contents); &#125; &#125;)&#125;)promise.then(contents=&gt;&#123; console.log(contents); // test&#125;,err=&gt;&#123; console.log(err);&#125;) 通过Promise构造函数创建了一个promise对象，之后便会执行执行器函数，同时异步操作开始。当异步操作结束后，会调用异步操作中的回调函数，如果操作成功那么将成功获得的数据作为参数传递给resolved函数，如果失败那么将失败信息传递给rejected函数。 promise对象调用then()方法和catch()方法时，会创建一个新任务放入一个任务队列中，只有监听到promise被解决后才会被执行 then()与catch()then() 方法返回一个 Promise 。它最多需要有两个参数：Promise 的成功和失败情况的回调函数。当promise的状态发生改变后就会执行相应的resolved/fulfilled状态的回调函数或者是相应的rejectd状态的回调函数。 如果，没有提供某个状态的处理函数。那么，then()方法将会丢失该状态的回调函数信息，但是并不会产生错误。如果恰好promise的状态是没有提供回调函数信息的状态，那么then()方法将会创建一个没有经过该状态回调函数处理的新promise对象，这个新 Promise 只是简单地接受调用这个 then 的原 Promise 的终态作为它的终态。 例如: 12345678let promise = Promise.reject('error');// then()方法只具有fulfilled状态的回调函数，那么当promise的状态为rejected时，then()方法不会调用任何回调函数，只是创建一个新的promise对象，该对象的状态与原promise对象状态相同，并且传入的参数一致promise.then(content=&gt;&#123; console.log('成功',content);&#125;).catch(err=&gt;&#123; console.log('失败',err); // 'error'&#125;) catch() 方法返回一个 Promise 。它接受一个参数：失败情况的回调函数。 then()方法和catch()方法一起使用才更加方便和清晰地处理异步操作结果 例如： 1234567891011121314151617181920const fs=require('fs')let promise=new Promise((resolve,reject)=&gt;&#123; fs.readFile('test.js','utf8',(err,contents)=&gt;&#123; if(err) &#123; reject(err); &#125; else &#123; resolve(contents); &#125; &#125;)&#125;)promise.then(contents=&gt;&#123; console.log(contents);&#125;)promise.catch(err=&gt;&#123; console.log(err);&#125;) Promise.resolve()和Promise.reject()创建已处理的promise我们可以使用Promise.resolve()来创建已处理的成功完成的promise Promise.resolve(value)方法返回一个以给定值解析后的Promise 对象。如果该值为promise，返回这个promise；如果这个值是thenable（即带有”then” 方法)），返回的promise会“跟随”这个thenable的对象，采用它的最终状态；否则返回的promise将以此值完成。此函数将类promise对象的多层嵌套展平。 我们也可以使用Promise.reject()来创建已处理的拒绝态的promise 例如： 12345678// 返回给定的promise对象let promise=Promise.resolve(new Promise((resolve,reject)=&gt;&#123; resolve(1);&#125;))promise.then(v=&gt;&#123; console.log(v); // 1&#125;) 执行器错误如果执行器函数内部发生错误，那么promise的拒绝处理程序就会被调用。 例如： 1234567let promise=new Promise((resolve,reject)=&gt;&#123; throw new Error('err');&#125;)promise.catch(err=&gt;&#123; console.log(err); // 'err'&#125;) 因为，每个执行器函数中都隐含着一个try…catch块，所以所有的错误都会被捕获并传入拒绝处理程序,以上示例相当于： 1234567891011let promise=new Promise((resolve,reject)=&gt;&#123; try &#123; throw new Error('err'); &#125; catch (err) &#123; reject(err); &#125;&#125;)promise.catch(err=&gt;&#123; console.log(err); // 'err'&#125;) 串联Promise前面提到过每次调用then()方法或者catch()方法都会创建并返回了另一个Promise，只有当第一个promise完成或被拒绝后才会去解决之后的promise 调用then()方法返回的promise按照以下规则被创建：当一个Promise完成（fulfilled）或者失败（rejected），返回函数将被异步调用（由当前的线程循环来调度完成）。具体的返回值依据以下规则返回： 如果then中的回调函数返回一个值，那么then返回的Promise将会成为接受状态，并且将返回的值作为接受状态的回调函数的参数值。 如果then中的回调函数没有返回值，那么then返回的Promise将会成为接受状态，并且该接受状态的回调函数的参数值为 undefined。 如果then中的回调函数抛出一个错误，那么then返回的Promise将会成为拒绝状态，并且将抛出的错误作为拒绝状态的回调函数的参数值。 如果then中的回调函数返回一个已经是接受状态的Promise，那么then返回的Promise也会成为接受状态，并且将那个Promise的接受状态的回调函数的参数值作为该被返回的Promise的接受状态回调函数的参数值。 如果then中的回调函数返回一个已经是拒绝状态的Promise，那么then返回的Promise也会成为拒绝状态，并且将那个Promise的拒绝状态的回调函数的参数值作为该被返回的Promise的拒绝状态回调函数的参数值。 如果then中的回调函数返回一个未定状态（pending）的Promise，那么then返回Promise的状态也是未定的，并且它的终态与那个Promise的终态相同；同时，它变为终态时调用的回调函数参数与那个Promise变为终态时的回调函数的参数是相同的。 调用catch()方法返回的是一个带有错误原因的promise 例如： 123456789101112131415161718192021222324// 创建一个已处理的promiselet promise=Promise.resolve(1);// 不返回任何值promise.then(v=&gt;&#123; console.log(v); // 1&#125;).then(v=&gt;&#123; console.log(v); // undefined&#125;)// 返回一个值promise.then(v=&gt;&#123; console.log(v); // 1 return 2;&#125;).then(v=&gt;&#123; console.log(v); // 2&#125;)// 抛出错误在promise链的下一个拒绝处理程序中捕获promise.then(v=&gt;&#123; throw new Error('err');&#125;).catch(v=&gt;&#123; console.log(v); // err&#125;) 就像上述的第三个例子，在已完成处理程序中抛出了错误，我们可以使用then…catch来捕获错误。因此，在实际编程时，为了防止某些未知的错误而造成程序崩溃，我们要使用then…catch来捕获未知错误 promise链中传递数据在上面提过，在调用then()方法和catch()方法的处理程序中，如果return某些值，是会作为返回的promise对象的执行函数的参数值，因此，我们可以在promise链中往下游传递数据 例如： 12345678let promise=Promise.resolve(1);promise.then(v=&gt;&#123; console.log(v); // 1 return v+1; // 返回一个值&#125;).then(v=&gt;&#123; // 接收到这个值 console.log(v); // 2&#125;) 在处理程序中return一个promise 如果then中的回调函数返回一个已经是接受状态的Promise，那么then返回的Promise也会成为接受状态，并且将那个Promise的接受状态的回调函数的参数值作为该被返回的Promise的接受状态回调函数的参数值。 如果then中的回调函数返回一个已经是拒绝状态的Promise，那么then返回的Promise也会成为拒绝状态，并且将那个Promise的拒绝状态的回调函数的参数值作为该被返回的Promise的拒绝状态回调函数的参数值。 如果then中的回调函数返回一个未定状态（pending）的Promise，那么then返回Promise的状态也是未定的，并且它的终态与那个Promise的终态相同；同时，它变为终态时调用的回调函数参数与那个Promise变为终态时的回调函数的参数是相同的。 例如： 123456789let p1=Promise.resolve(1);let p2=Promise.reject('err');p1.then(v=&gt;&#123; console.log(v); // 1 return p2; // 返回一个拒绝态的promise&#125;).catch(v=&gt;&#123; // 接收到拒绝态promise传过来的错误原因 console.log(v); // 'err'&#125;) 响应多个PromisePromise.all()Promise.all()方法接受一个参数并返回一个promise，该参数是一个含有多个受监视Promise的可迭代对象（例如，一个数组），只有可迭代对象中的所有promise被成功解决(resolved/fulfilled态)后返回的promise才会被解决 注意： 如果传入的可迭代对象为空，Promise.all 会同步地返回一个已完成（resolved）状态的promise。 如果传入的参数不包含任何 promise，则返回一个异步完成（asynchronously resolved） Promise。 其它情况下返回一个处理中（pending）的Promise。这个返回的 promise 之后会在所有的 promise 都完成或有一个 promise 失败时异步地变为完成或失败。 更加需要注意的是： 返回值将会按照参数内的promise顺序排列，而不是由调用的promise的完成顺序来决定 例如： 123456789101112131415161718192021222324let promise1 = new Promise((resolve,reject)=&gt;&#123; setTimeout(()=&gt;&#123; resolve(1); &#125;,3000) &#125;)let promise2 = new Promise((resolve,reject)=&gt;&#123; setTimeout(()=&gt;&#123; resolve(2); &#125;,2000) &#125;)let promise3 = new Promise((resolve,reject)=&gt;&#123;setTimeout(()=&gt;&#123; resolve(3);&#125;,1000) &#125;)// 值得注意的是，此时当所有的promise都全部成功返回后，返回值的顺序是按照传递给Promise.all()方法的参数数组内的排列顺序决定，而不是根据promise完成的先后顺序Promise.all([promise2,promise1,promise3]).then(v=&gt;&#123; console.log(v); // [2,1,3]&#125;).catch(err=&gt;&#123; console.log(err);&#125;) 当然，只要所有传入的promise对象中有一个被拒绝，那么Promise.all()方法返回的promise对象就会被立刻拒绝 拒绝处理程序总是接受一个值而非数组，该值来自于被拒绝promise的拒绝值 例如： 12345678910111213let p1=Promise.resolve(1);let p2=Promise.resolve(2);// 拒绝态promiselet p3=Promise.reject(3);let p4=Promise.resolve(4);let set=new Set([p1,p2,p3,p4]);Promise.all(set).then(v=&gt;&#123; console.log(v);&#125;).catch(err=&gt;&#123; console.log(err); // 3&#125;) Promise.race()Promise.race()同样也是接受一个包含多个promise的可迭代对象，但是，一旦迭代器中的某个promise解决或拒绝，返回的 promise就会解决或拒绝。 一个待定的 Promise 只要给定的迭代中的一个promise解决或拒绝，返回的promise就采用第一个promise的值作为它的值，从而异步地解析或拒绝 例如： 123456789101112131415161718// p1在2000毫秒后成为已成功处理的promiselet p1=new Promise((resolve,reject)=&gt;&#123; setTimeout(()=&gt;&#123; resolve(1); &#125;,2000)&#125;)// 创建已完成拒绝态promiselet p2=Promise.reject(2);// 创建已完成resolved态promiselet p3=Promise.resolve(3);Promise.race([p1,p3,p2]).then(v=&gt;&#123; console.log(v);&#125;).catch(err=&gt;&#123; console.log(err); // 3&#125;) 因为，p1在2000毫秒后才会成为已成功处理的promise,p2,p3都是已完成处理程序，但是在传递给Promise.race()方法的参数数组中p3的顺序先于p2 需要注意的是，可迭代对象中promise的顺序也可能会对结果产生影响 实现一个Promise因为Promise中的方法众多，因此，我们一个方法一个方法进行实现 Promiseasync/await async function 用来定义一个返回 AsyncFunction 对象的异步函数。异步函数是指通过事件循环异步执行的函数，它会通过一个隐式的 Promise 返回其结果。 await 操作符用于等待一个Promise 对象。它只能在异步函数 async function 中使用。 async 函数返回一个 Promise 对象 async 函数内部 return 返回的值。会成为 then 方法回调函数的参数。 例如： 1234567891011async function f() &#123; return await new Promise((resolve,reject)=&gt;&#123; resolve(1); &#125;)&#125;f().then(v=&gt;&#123; console.log(v); // 1&#125;).catch(err=&gt;&#123; console.log(err);&#125;); 需要铭记的是： 异步函数可以包含await指令，该指令会暂停异步函数的执行，并等待Promise执行，然后继续执行异步函数，并返回结果。 也就是说，当在异步函数中遇到await指令后，这个异步函数会暂停运行，直到await结束。在暂停期间，]]></content>
      <categories>
        <category>ES6</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[数组创建的改进]]></title>
    <url>AngelLikeFairy%2F2019%2F09%2F09%2F%E6%95%B0%E7%BB%84%E5%88%9B%E5%BB%BA%E7%9A%84%E6%94%B9%E8%BF%9B%2F</url>
    <content type="text"><![CDATA[ES6之前数组创建的一些问题在ES6之前，数组的创建具有以下的一些问题 通过Array构造函数创建数组时具有一些怪异的行为 没有现成的方法可以将类数组对象（具有数值型索引和length属性的对象）和可迭代对象转化为数组 Array构造函数的一些怪异行为Array构造函数具有以下怪异行为 如果给Array构造函数传入一个数值型的值，此时，并不是创建一个包含该数值的数组，而是创建一个数组，将该数组的length属性设置为该值。那么显然数组内的所有元素都会是undefined 123let arr=new Array(2);console.log(arr); // [undefined,undefined]console.log(arr.length); // 2 相对于上一点，如果传入一个非数值类型的值，那么就符合常规的想法，会创建一个包含该值的数组 123let arr=new Array('man');console.log(arr); // ['man']console.log(arr.length); // 1 最后，如果传入了多个值，那么不管这些值中是否有数值类型，所有的值都会变为创建的数组的元素 123let arr=new Array(2,'man');console.log(arr); // [2,'man']console.log(arr.length); // 2 因为Array构造函数具有以上的一些怪异特性，因此ES6通过引入Array.of()方法来解决这个问题 ES5实现将类数组对象转化为数组对象对于类数组对象，在ES5中我们可以采用以下的方式来将其转化为数组对象 12345678910111213141516let a=&#123; 0:1, 1:2, length:2&#125;function getArray(obj) &#123; let ans=[]; // 类数组对象具有数值型索引和length属性 for(let i=0;i&lt;obj.length;i++) &#123; ans.push(obj[i]); &#125; return ans;&#125;console.log(getArray(a)); // [1,2] 除此之外，我们还可以利用数组方法slice()的一个特性： slice 方法可以用来将一个类数组（Array-like）对象/集合转换成一个新数组。 1234567891011let a=&#123; 0:1, 1:2, length:2&#125;function getArray(obj) &#123; return Array.prototype.slice.call(obj);&#125;console.log(getArray(a)); // [1,2] ES6对于数组创建的改进Array.of()方法对于Array构造函数的改进ES6通过引入Array.of()方法来解决Array构造函数出现的一些怪异行为 概述Array.of() 方法创建一个具有可变数量参数的新数组实例，而不考虑参数的数量或类型。 Array.of() 和 Array 构造函数之间的区别在于处理整数参数：Array.of(7) 创建一个具有单个元素 7 的数组，而 Array(7) 创建一个长度为7的空数组（注意：这是指一个有7个空位(empty)的数组，而不是由7个undefined组成的数组）。 语法 Array.of(element0[, element1[, …[, elementN]]]) 参数 elementN:任意个参数，将按顺序成为返回数组中的元素。 返回值 新的 Array 实例。 例子123456789// 使用Array构造函数并传入一个数值类型值let arr=new Array(2);console.log(arr); // [undefined,undefined]console.log(arr.length); // 2// 使用Array.of()方法并传入一个数值类型值let array=Array.of(2);console.log(array); // [2]console.log(array.length); // 1 Array.from()方法将非数组对象转化为数组对象概述Array.from() 方法从一个类似数组或可迭代对象中创建一个新的，浅拷贝的数组实例。 语法 Array.from(arrayLike[, mapFn[, thisArg]]) 参数 arrayLike 想要转换成数组的伪数组对象或可迭代对象。 mapFn (可选参数) 如果指定了该参数，新数组中的每个元素会执行该回调函数。 thisArg (可选参数) 可选参数，执行回调函数 mapFn 时 this 对象。 返回值 一个新的数组实例 例子使用Array.from()方法将类数组对象转化为数组对象 12345678910let a=&#123; 0:1, 1:2, length:2&#125;// 使用Array.from()方法将类数组对象转化为数组对象let arr=Array.from(a);console.log(arr); // [1,2] 使用Array.from()方法将可迭代对象转化为数组对象 12345678910111213141516171819202122// 将字符串转化为数组let str='hello';console.log(Array.from(str)); // ['h','e','l','l','o']// 将Set集合转化为数组console.log(Array.from(new Set([1,2,3]))); // [1,2,3]// 将Map集合转化为数组console.log(Array.from(new Map([['a',1],['b',2],['c',3]]))); // [['a',1],['b',2],['c',3]]// 将普通自定义对象利用生成器转化为可迭代对象之后再转化为数组let test=&#123; a:'a', c:'c', *[Symbol.iterator]() &#123; for(let i in test) &#123; yield test[i]; &#125; &#125;&#125;console.log(Array.from(test)); // ['a','c'] 映射转化：使用Array.from()的第二个参数将被转化对象的每一个值转化为其他形式 1234567891011let test=&#123; a:'a', c:'c', *[Symbol.iterator]() &#123; for(let i in test) &#123; yield test[i]; &#125; &#125;&#125;console.log(Array.from(test,(v)=&gt;'hello '+v)); // ['hello a','hello c']]]></content>
      <categories>
        <category>ES6</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[leetcode-263 丑数]]></title>
    <url>AngelLikeFairy%2F2019%2F09%2F09%2Fleetcode-263%2F</url>
    <content type="text"><![CDATA[丑数题目描述编写一个程序判断给定的数是否为丑数。 丑数就是只包含质因数 2, 3, 5 的正整数。 示例 1: 输入: 6输出: true解释: 6 = 2 × 3 示例 2: 输入: 8输出: true解释: 8 = 2 × 2 × 2 示例 3: 输入: 14输出: false 解释: 14 不是丑数，因为它包含了另外一个质因数 7。 说明： 1是丑数。 输入不会超过 32 位有符号整数的范围: [−231, 231 − 1]。 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/ugly-number著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。核心思路概述题目说明只包含质因数2,3,5的整数位丑数（且1为丑数）。那么，我们先排除掉小于等于0的数。那么对于正整数来说，如果该数只包含质因数2,3,5；那么我们只要将该数不断地除以2（如果可以整除），不断地除以3（如果可以整除），不断地除以5（如果可以整除）；如果最后的结果为1的话，那么该数就是丑数 解题步骤 如果给定数小于等于0，返回false 如果该数可以整除2，那么不断将该数除以2 如果该数可以整除3，那么不断将该数除以3 如果该数可以整除5，那么不断将该数除以5 执行完2,3,4步骤后如果结果为1，那么该数为丑数，返回true；否则返回false Coding实现123456789101112131415161718/** * @param &#123;number&#125; num * @return &#123;boolean&#125; */var isUgly = function(num) &#123; if(num&lt;=0) return false; while(num%2===0) &#123; num=num/2; &#125; while(num%3===0) &#123; num=num/3; &#125; while(num%5===0) &#123; num=num/5; &#125; if(num===1) return true; else return false;&#125;;]]></content>
      <categories>
        <category>leetcode题解与算法</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[类语法不得不知的几点]]></title>
    <url>AngelLikeFairy%2F2019%2F09%2F08%2F%E7%B1%BB%E8%AF%AD%E6%B3%95%E4%B8%8D%E5%BE%97%E4%B8%8D%E7%9F%A5%E7%9A%84%E5%87%A0%E7%82%B9%2F</url>
    <content type="text"><![CDATA[ES5实现模拟类ES5是通过构造函数和原型来是模拟实现类的 1234567891011function Test(item) &#123; this.item=item;&#125;Test.prototype.getItem=function ()&#123; return this.item;&#125;let test=new Test(123);console.log(test); // &#123;item:123&#125;console.log(test.getItem()); // 123 ES6类的声明基本类声明语法要声明一个类，可以按照如下的方法 123456789101112131415class Test&#123; constructor(item) &#123; this.item=item; &#125; getItem() &#123; return this.item; &#125;&#125;let test=new Test(123);console.log(test); // &#123;item:123&#125;console.log(test.getItem()); // 123// 查看test实例原型上的属性console.log(Object.getOwnPropertyNames(Object.getPrototypeOf(test))); // [ 'constructor', 'getItem' ] 其中，constructor方法用来定义构造函数，除此之外的所有方法就是定义在原型上的方法 另外，类声明其实是基于已有自定义类型声明的语法糖。如果使用typeof Test最终返回的结果会是’function’，因此，类其实就是创建了一个具有构造函数方法行为的函数 1234567class Test&#123; constructor(item) &#123; this.item=item; &#125;&#125;console.log(typeof Test); // function 类表达式语法类和函数一样(类实质上就是一个函数)，它在声明的时候也具有表达式语法 12345678910111213// 使用匿名类赋值给Testlet Test=class&#123; constructor(item) &#123; this.item=item; &#125;&#125;// 使用命名类赋值给Testlet Test=class A&#123; constructor(item) &#123; this.item=item; &#125;&#125; 类的一些特性类声明具有的一些特性 虽然类实质上是函数，函数声明可以被提升，但是类声明却是与let声明类似不能被提升 因为类实质上是函数，因此类可以作为参数传递给函数，也可以作为值赋给变量 123456789class Test&#123; constructor(item) &#123; this.item=item; &#125;&#125;let M=Test;let m=new M(1);console.log(m); // &#123;item:1&#125; 类方法与函数一样同样支持使用可计算属性名 12345678910111213let a='get Item';class Test&#123; constructor(item) &#123; this.item=item; &#125; [a]() &#123; return this.item; &#125;&#125;let M=Test;let m=new M(1);console.log(m[a]()); // 1 类是个函数，那么它也就是个对象，因此，我们可以在类中定义生成器方法 1234567891011121314151617181920class Test&#123; constructor(...item) &#123; this.a=item[0]; this.b=item[1]; this.c=item[2]; &#125; // 建立生成器方法 *[Symbol.iterator]() &#123; for(let i in this) &#123; yield this[i]; &#125; &#125;&#125;let test=new Test(3,4,5);// 可以用for...of进行迭代for(let v of test) &#123; console.log(v); // 3,4,5&#125; 静态成员静态成员通过static关键字来声明，它会作为类的一个属性。无法被类的实例调用，只能通过类本身被调用 静态公有方法例如： 1234567891011121314151617let Test=class&#123; constructor(item) &#123; this.item=item; &#125; static getValue() &#123; return 1; &#125;&#125;let test=new Test(1);console.log(test);// 通过类本身来调用静态成员console.log(Test.getValue()); // 1// 无法通过类的实例来调用，因为静态成员不会出现在构造函数的原型对象上，所以实例无法访问到该方法console.log(test.getValue()); // 报错：test.getValue is not a function 那么，静态成员一般用来做什么呢？他们通常是一些实用程序方法，例如创建或克隆对象 123456789101112let Test=class&#123; constructor(item) &#123; this.item=item; &#125; // 实用静态成员来创建对象 static create(item) &#123; return new Test(item); &#125;&#125;// 实用静态成员来创建对象let test=Test.create(1);console.log(test); // &#123;item:1&#125; 当然，也有可以很方便地被类中的非静态成员方法调用 123456789101112131415class Test&#123; constructor(item) &#123; this.item=item; &#125; getItem() &#123; // 调用静态成员方法 return Test.getItem.call(this); &#125; static getItem() &#123; return this.item; &#125;&#125;let test = new Test(1);console.log(test.getItem()); 静态公有字段静态公有字段在你想要创建一个只在每个类里面只存在一份，而不会存在于你创建的每个类的实例中的属性时可以用到。你可以用它存放缓存数据、固定结构数据或者其他你不想在所有实例都复制一份的数据。 静态公有字段是使用关键字 static 声明的。我们在声明一个类的时候，使用Object.defineProperty方法将静态公有字段添加到类的构造函数中。在类被声明之后，可以从类的构造函数访问静态公有字段。 例如： 12345678910111213141516class Test&#123; constructor(item) &#123; this.item=item; &#125; getItem() &#123; return Test.getItem.call(this); &#125; static getItem() &#123; return this.item; &#125; static a=2;&#125;let test = new Test(1);console.log(test.a); // undefinedconsole.log(Test.a); // 2 静态成员的继承如果基类有静态成员，那么这些静态成员在派生类中也可以被使用 例如： 123456789101112131415161718let Person=class&#123; constructor(item) &#123; this.item=item; &#125; // 实用静态成员来创建对象 static create(item) &#123; return new Person(item); &#125;&#125;class Man extends Person&#123; constructor(item) &#123; super(item); &#125;&#125;let man=Man.create('man');console.log(man); // &#123;item:'man'&#125; 继承与派生类ES5模拟实现继承ES5模拟实现继承主要是通过利用原型链 12345678910111213141516171819function Person(item) &#123; this.item=item;&#125;Person.prototype.sayPerson=function() &#123; console.log('person');&#125;// 利用call来继承父类的构造函数function Man(item) &#123; Person.call(this,item);&#125;// 原型对象的继承Man.prototype=new Person();let man=new Man('man');console.log(man); // &#123;item:'man'&#125;man.sayPerson(); // 'person' ES6的继承ES6使用extends关键字来指定类继承的函数，并且通过super()方法即可访问基类的构造函数 123456789101112131415161718class Person&#123; constructor(item) &#123; this.item=item; &#125; getItem() &#123; return this.item; &#125;&#125;class Man extends Person&#123; constructor(item) &#123; super(item); &#125;&#125;let man=new Man('man');console.log(man); // &#123;item:'man'&#125;console.log(man.getItem()); // 'man' 继承自其它类的类被称为派生类，因此，对于上述代码，Person类被称为基类（父类），Man类被称为派生类（子类） 注意： 如果在派生类中指定了构造函数，那么在构造函数中就必须要调用super()方法，如果不这样做程序就会报错；当然，你也可以不指定构造函数，那么派生类就会默认执行构造函数并调用super()方法并传入所有参数 例如: 1234567891011class Man extends Person&#123; // 没有构造函数&#125;// 等价于class Man extends Person&#123; constructor(...items)&#123; super(...items); &#125;&#125; 为了避免一些参数传入引起的问题，我们最好是手动建立构造函数 super()的一些注意点super()方法有一些注意点 我们只能在派生类的构造函数中使用super()方法，如果尝试在非派生类（不适用extends声明的类）或函数中使用就会导致程序抛出错误 在构造函数中访问this前一定要调用super()，它负责初始化this 类方法的遮蔽派生类的同名方法会覆盖基类中的同名方法，因为继承的本质就是原型链来实现的；而原型链的查找是从底端向上查找的，如果找到了一个符合要求的便不会再向上查找 例如： 123456789101112131415161718192021class Person&#123; constructor(item) &#123; this.item=item; &#125; sayHello() &#123; console.log('Person say hello'); &#125;&#125;class Man extends Person&#123; constructor(item) &#123; super(item); &#125; sayHello() &#123; console.log('Man say hello'); &#125;&#125;let man=new Man('man');console.log(man); // &#123;item:'man'&#125;man.sayHello(); // 'Man say hello' 继承自表达式的类只要表达式可以被解析为一个函数并且具有[[construct]]属性（箭头函数不具有该属性）和原型，那么就可以用extends进行派生 例如： 12345678910111213141516171819// 该函数为构造函数function Person(item) &#123; this.item=item;&#125;Person.prototype.sayHello=function() &#123; console.log('hello');&#125;// 继承自构造函数而非基本类class Man extends Person&#123; constructor(item) &#123; super(item); &#125;&#125;let man=new Man('man');console.log(man); // &#123;item:'man'&#125;man.sayHello(); // 'hello']]></content>
      <categories>
        <category>ES6</category>
      </categories>
      <tags>
        <tag>基础语法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[leetcode-258 各位相加]]></title>
    <url>AngelLikeFairy%2F2019%2F09%2F08%2Fleetcode-258%2F</url>
    <content type="text"><![CDATA[各位相加题目描述给定一个非负整数 num，反复将各个位上的数字相加，直到结果为一位数。 示例: 输入: 38输出: 2 解释: 各位相加的过程为：3 + 8 = 11, 1 + 1 = 2。 由于 2 是一位数，所以返回 2。 进阶:你可以不使用循环或者递归，且在 O(1) 时间复杂度内解决这个问题吗？ 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/add-digits著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 核心思路概述 如果不考虑进阶的要求的话，那么第一直觉就会是使用循环或者递归，将数的各位和一直相加，直到和为个位数 如果需要满足进阶的要求的话，那么我们需要一些数学的技巧。对于一个数abc,它等于a*100+b*10+c。将它求和的话，就会变为a+b+c,也就是求和之后减少了99*a+9*b=9*(11*a+b);因此，每次求和这个数就会减少9的倍数的值；也就是相当于，原数-9*未知值=和；这个式子可以转化为：原数%9=和；因此，若结果为 0 则考虑num本身是否为 0，若本身不为不为 0，则返回 9；此外，返回结果 解题步骤Coding实现循环版 123456789101112/** * @param &#123;number&#125; num * @return &#123;number&#125; */var addDigits = function(num) &#123; while(num&gt;=10) &#123; num=num.toString().split('').reduce((pre,value)=&gt;&#123; return pre+parseInt(value); &#125;,0) &#125; return num;&#125;; 数学推断版 12345678910111213/** * @param &#123;number&#125; num * @return &#123;number&#125; */var addDigits = function(num) &#123; if(num&gt;9) &#123; if(num%9) &#123; return num%9; &#125; else return 9; &#125; else return num;&#125;;]]></content>
      <categories>
        <category>leetcode题解与算法</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[迭代器与生成器]]></title>
    <url>AngelLikeFairy%2F2019%2F09%2F07%2F%E8%BF%AD%E4%BB%A3%E5%99%A8%E4%B8%8E%E7%94%9F%E6%88%90%E5%99%A8%2F</url>
    <content type="text"><![CDATA[什么是迭代器首先，迭代器是一个对象，一个专门为迭代过程设计的对象。所有的迭代器对象都会具有一个next()方法，用来返回一个结果对象（该结果对象包括两个属性，一个是下一个要返回的值，一个是done属性。在返回最后一个值及之前时，done值为false，否则为true）。 使用ES5模拟一个迭代器1234567891011121314151617181920212223242526272829303132// 利用闭包的特性，使得next()方法一直保存着idx的变量值function generator(items) &#123; let idx=0; return &#123; next() &#123; return &#123; value: items[idx++], done: items[idx-1]!==undefined?false:true &#125; &#125; &#125;&#125;let gen= generator([1,3,5,7,9]);console.log(gen.next());console.log(gen.next());console.log(gen.next());console.log(gen.next());console.log(gen.next());console.log(gen.next());/** 输出结果*//*&#123; value: 1, done: false &#125;&#123; value: 3, done: false &#125;&#123; value: 5, done: false &#125;&#123; value: 7, done: false &#125;&#123; value: 9, done: false &#125;&#123; value: undefined, done: true &#125;*/ 什么是生成器生成器是一个可以返回迭代器对象的函数，通过*关键字来表示该函数为生成器函数。 在生成器函数中，我们一般需要使用yield关键字来指定调用迭代器的next()方法的返回值和返回顺序。 yield关键字可以返回任何值或者表达式 例如： 12345678910111213141516171819202122232425// 使用生成器函数来返回一个迭代器，其中的yield关键字来指定调用此迭代器中的next()方法的返回值与返回顺序function *createIterator(items) &#123; for(let i=0;i&lt;items.length;i++) &#123; yield items[i]; &#125;&#125;let iterator=createIterator([3,4,5]);console.log(iterator.next());console.log(iterator.next());console.log(iterator.next());console.log(iterator.next());console.log(iterator.next());/** 输出结果*//*&#123; value: 3, done: false &#125;&#123; value: 4, done: false &#125;&#123; value: 5, done: false &#125;&#123; value: undefined, done: true &#125;&#123; value: undefined, done: true &#125;*/ 对于生成器函数中的yield，每当执行完一个yield语句后，该函数就会自动停止执行，直到再次调用返回的迭代器的next()方法 生成器函数表达式上面的例子是使用函数声明的方式来创建生成器，同样我们也可以使用函数表达式的方式来创建生成器。此时，我们只需要在function关键字和小括号中间添加*号即可 例如： 12345678910111213// 匿名函数let createIterator=function *() &#123; yield 3; yield 4; yield 5;&#125;// 非匿名函数let createIterator=function *test() &#123; yield 3; yield 4; yield 5;&#125; 生成器函数作为一个对象的方法由于生成器本身就是一个函数，因此我们可以将生成器作为一个对象的方法。 这样，我们可以使用ES6对象的简写方法来创建生成器，只需要在方法名前加上*即可 例如： 1234567let test=&#123; *createIterator() &#123; yield 3; yield 4; yield 5; &#125;&#125; 可迭代对象与for…of循环什么是可迭代对象可迭代对象都会有Symbol.iterator属性。该属性可以通过指定的函数来返回一个迭代器。 在ES6中，所有的集合对象（数组，Set集合，Map集合）和字符串都是可迭代对象。这些对象都有默认的迭代器。 而我们自己创建的对象一般都不是可迭代对象，当然我们可以将他们转变为可迭代对象 注意：由于生成器默认会为Symbol.iterator属性赋值，因此所有通过生成器创建的迭代器都会是可迭代对象。因此，我们可以这一特性将不可迭代对象转化为可迭代对象 判断一个对象是否为可迭代对象因为可迭代对象都会有Symbol.iterator方法属性，所以我们可以判断某对象中是否具有该方法来判断是否为可迭代对象 123456789function isIterable(object) &#123; return typeof object[Symbol.iterator] === 'function'&#125; console.log(isIterable([1,2,3])); // trueconsole.log(isIterable(new Set([1,2,3]))); // trueconsole.log(isIterable(new Map([[1,1],[2,2]]))); //trueconsole.log(isIterable('hello')); // trueconsole.log(isIterable(&#123;a:1,b:2&#125;)); // false for…of循环for…of循环只能循环可迭代对象。 其实质上是会调用可迭代对象的Symbol.iterator的属性方法来获取到一个迭代器，然后不断调用迭代器的next()方法直到done属性值为true时退出 例如： 1234567891011121314let test=[3,4,5];for(let v of test) &#123; console.log(v);&#125;/** 输出结果*//*345*/ 访问默认迭代器每个可迭代对象都会有一个Symbol.iterator的方法属性，该方法被调用后可以返回一个迭代器。 因此，我们可以通过该属性去访问一个可迭代对象的默认迭代器 例如： 123456789101112131415161718192021let test=[3,4,5];// 获得数组对象的默认迭代器let iterator=test[Symbol.iterator]();console.log(iterator.next());console.log(iterator.next());console.log(iterator.next());console.log(iterator.next());console.log(iterator.next());/** 输出结果*//*&#123; value: 3, done: false &#125;&#123; value: 4, done: false &#125;&#123; value: 5, done: false &#125;&#123; value: undefined, done: true &#125;&#123; value: undefined, done: true &#125;*/ 将不可迭代对象转化为可迭代对象通过添加Symbol.iterator属性因为一个对象是否可迭代是根据是否有Symbol.iterator属性的，因此，我们可以手动添加该生成器 1234567891011121314151617181920let test=&#123; a:1, b:2&#125;// 自建对象一般都是不可迭代的console.log(test[Symbol.iterator]); // undefined// 为不可迭代对象创建Symbol.iterator并赋予一个生成器,使其成为一个可迭代对象test[Symbol.iterator]=function *() &#123; // this指向test对象 for(let i in this) &#123; yield this[i]; &#125;&#125;// 验证是否成为了一个可迭代对象for(let v of test) &#123; console.log(v); // 1 2&#125; 通过生成器函数在前文提到过，由于生成器默认会为传入的对象Symbol.iterator属性赋值，因此，我们只需向生成器函数传入不可迭代对象即可 例如： 123456789101112131415function *createIterator(object) &#123; for(let i in object) &#123; yield object[i]; &#125;&#125;let test=&#123; a:1, b:2&#125;let iterator=createIterator(test);for(let v of iterator) &#123; console.log(v); // 1,2&#125;]]></content>
      <categories>
        <category>ES6</category>
      </categories>
      <tags>
        <tag>基础语法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[leetcode-257 二叉树的所有路径]]></title>
    <url>AngelLikeFairy%2F2019%2F09%2F07%2Fleetcode-257%2F</url>
    <content type="text"><![CDATA[二叉树的所有路径题目描述给定一个二叉树，返回所有从根节点到叶子节点的路径。 说明: 叶子节点是指没有子节点的节点。 示例: 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/binary-tree-paths著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 核心思路概述二叉树的路径是根节点到叶子节点上的路径。因此，我们可以传入一个数组，在递归的时候存储每个节点当前的路径，如果遇到叶子节点，就将叶子节点上的路径加入到ans数组 解题步骤 设立一个ans数组，用来存放二叉树的路径 先序遍历二叉树，同时传入一个数组，用来保存当前节点的路径 如果遇到叶子节点，则将数组存入ans数组中，并return 访问其左子树和右子树 递归2,3,4步骤，直到二叉树遍历完毕 利用map()方法和join()方法将输出满足题目要求 Coding实现1234567891011121314151617181920212223242526272829303132/** * Definition for a binary tree node. * function TreeNode(val) &#123; * this.val = val; * this.left = this.right = null; * &#125; *//** * @param &#123;TreeNode&#125; root * @return &#123;string[]&#125; */var binaryTreePaths = function(root) &#123; let ans=[]; (function getPath(root,arr) &#123; if(root===null) return; else &#123; arr.push(root.val); let arrLeft=arr.concat(); let arrRight=arr.concat(); if(!root.left&amp;&amp;!root.right) &#123; ans.push(arr); return; &#125; getPath(root.left,arrLeft); getPath(root.right,arrRight); &#125; &#125;)(root,[]) ans=ans.map(v=&gt;&#123; return v.join('-&gt;'); &#125;) return ans;&#125;;]]></content>
      <categories>
        <category>leetcode题解与算法</category>
      </categories>
      <tags>
        <tag>树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[leetcode-242 有效的字母异位词]]></title>
    <url>AngelLikeFairy%2F2019%2F09%2F05%2Fleetcode-242%2F</url>
    <content type="text"><![CDATA[有效的字母异位词题目描述给定两个字符串 s 和 t ，编写一个函数来判断 t 是否是 s 的字母异位词。 示例 1: 输入: s = “anagram”, t = “nagaram”输出: true 示例 2: 输入: s = “rat”, t = “car”输出: false 说明:你可以假设字符串只包含小写字母。 进阶:如果输入字符串包含 unicode 字符怎么办？你能否调整你的解法来应对这种情况？ 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/valid-anagram著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 核心思路概述判断两个字符串互相是不是字母异位词，这也就意味着，两个字符串内的每个字符数量都是相同的。因此，我们只需要设定一个map集合来存储每个字符的数量即可 解题步骤 如果两字符的长度不一样则返回false 如果两字符相等，返回true 设定map集合，遍历其中一个字符串，以字符和字符个数为键值对存入哈希表中 遍历另一个字符串，如果出现哈希表中没有的字符，则返回false；如果是哈希表中已有的字符，那么将该键值减一 遍历哈希表，如果所有的键值都为0，那么返回true；否则返回false Coding实现1234567891011121314151617181920212223242526272829303132/** * @param &#123;string&#125; s * @param &#123;string&#125; t * @return &#123;boolean&#125; */var isAnagram = function(s, t) &#123; if(s.length!==t.length) return false; if(s===t) return true; let map=new Map(); let flag=1; for(let v of s) &#123; if(map.has(v)) &#123; map.set(v,map.get(v)+1); &#125; else &#123; map.set(v,1); &#125; &#125; for(let v of t) &#123; if(map.has(v)) &#123; map.set(v,map.get(v)-1); &#125; else &#123; return false; &#125; &#125; map.forEach(v=&gt;&#123; if(v!==0) flag=0; &#125;) return Boolean(flag);&#125;;]]></content>
      <categories>
        <category>leetcode题解与算法</category>
      </categories>
      <tags>
        <tag>哈希表</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[set集合与map集合]]></title>
    <url>AngelLikeFairy%2F2019%2F09%2F05%2Fset%E9%9B%86%E5%90%88%E4%B8%8Emap%E9%9B%86%E5%90%88%2F</url>
    <content type="text"><![CDATA[Set集合Set集合的使用语法 new Set([iterable]); 参数 iterable 如果传递一个可迭代对象，它的所有元素将不重复地被添加到新的 Set中。如果不指定此参数或其值为null，则新的 Set为空。 返回值 一个新的Set对象 set的一些基本操作Set对象的一些基本方法 add() 向集合添加一个元素 delete() 向集合删除某个指定元素 clear() 清除集合内所有元素 has() 检查集合内是否有指定元素 Set对象的一些属性 size 集合大小 1234567let set=new Set();set.add(1);set.add('1');console.log(set.size); // 2set.delete('1'); console.log(set); // Set &#123; 1 &#125; Set的特性在set集合内，存入元素的时候不会对值进行任何强制的类型转换，这也意味着，5和’5’在set集合内是两个不同的独立的元素 另外,如果往set集合内多次传入同一数据，那么后面的操作就会被忽略。因此，set集合内的元素是不重复的 利用Set特性来实现数组去重因为展开运算符可以将诸如set集合的可迭代对象转化为数组 因此，我们可以将数组传入set集合内，利用set内元素不能重复的特性实现去重。之后利用展开运算符，将set集合转化回数组、 1234let test=[1,2,3,3,4,1,3,2]; // 创建一个具有重复元素的数组let set=new Set(test);console.log([...set]); // [1,2,3,4] Set集合的遍历set集合使用forEach()方法来实现遍历 该方法的回调函数接受三个参数 元素的值 元素的键名 自身set集合 因为set集合存储的是单个元素而不是键值对，但是为了大多数方法中回调参数的统一，该回调函数的参数也按照键值的形式传参。 但，值得注意的是，元素的键名与键值相同 12345678let set=new Set([3,4,5]);set.forEach((value,key,ownerSet)=&gt;&#123; console.log(value,key,ownerSet);&#125;);// 3,3,&#123;3,4,5&#125;// 4,4,&#123;3,4,5&#125;// 5,5,&#123;3,4,5&#125; WeakSet集合什么是WeakSet集合WeakSet 集合是一个弱引用Set集合，里面只能存储的弱引用，而不能存储基本类型值 为什么要使用WeakSet如果往set集合内加入某个引用类型值，那么set集合中的该元素也有了某个对象的引用。那么，就算在set集合外部释放了该对象（令该对象的值为null），set集合内部的那个元素仍然保持着那个对象的引用。因此，这会很容易造成内存泄漏 1234567891011121314let a=&#123; item:1&#125;// 往set内传入a对象let set=new Set([a]);// 将a对象置为空对象a=null;// 但是set集合中的元素仍然保持着该对象的引用console.log([...set][0]); // &#123; item: 1 &#125;console.log(a); // null 对于上述程序，显然我们可以看到，我们在set集合外部想要释放对象a，但是set集合引用着该对象，因此该对象的内存无法被释放 WeakSet的使用WeakSet 对象中存储的对象值都是被弱引用的, 如果没有其他的变量或属性引用这个对象值, 则这个对象值会被当成垃圾回收掉. 正因为这样, WeakSet 对象是无法被枚举的, 没有办法拿到它包含的所有元素. 1234567891011let a=&#123; item:1&#125;// 往weakSet内传入a对象let set=new WeakSet([a]);// 将a对象置为空对象a=null;console.log(a); // null 当WeakSet集合外部的引用被释放后，该引用就会被真正地完全释放 weakSet集合的一些注意点weakSet只支持3个方法 add() has() delete weakSet集合不可迭代和枚举，因此其不支持 for…of循环 …展开运算符 forEach()方法 size属性 Map集合Map类型是一种存储着许多键值对的有序列表，其中的键名和键值支持所有的数据类型。 键名的等价性判断是通过Object.is()方法来进行判断的，所以数字5和字符串’5’会被判定为两种类型，可以分IE作为独立的两个键名来存储在Map结合内 1234let map=new Map();map.set('1',1);map.set(1,1);console.log(map); // Map &#123; '1' =&gt; 1, 1 =&gt; 1 &#125; Map集合的使用语法 new Map([iterable]) 参数 iterable Iterable 可以是一个数组或者其他 iterable 对象，其元素为键值对(两个元素的数组，例如: [[ 1, ‘one’ ],[ 2, ‘two’ ]])。 每个键值对都会添加到新的 Map。null 会被当做 undefined。 Map的一些基本方法Map集合具有以下一些基本方法 set() 传入键名和键值来设定一个键值对 delete() 删除指定键值对 clear() 删除全部键值对 has() 判断某个键值对是否存在 get() 传入键名来获取键值 Map集合具有以下一些属性 size Map集合的大小 1234567let map=new Map();map.set('a','a');map.set('b','b');console.log(map.get('a')); // 'a'map.delete('a');console.log(map.size); // 1console.log(map.has('a')); // false Map集合的遍历Map集合也是使用forEach()方法来进行遍历 其回调函数接受三个参数 value 键值 key 键名3，ownerMap 自身map集合 1234567let map=new Map([[1,1],['1','1']]);map.forEach((value,key,ownerMap)=&gt;&#123; console.log(value,key,ownerMap);&#125;); // 1 1 Map &#123; 1 =&gt; 1, '1' =&gt; '1' &#125;// '1' '1' Map &#123; 1 =&gt; 1, '1' =&gt; '1' &#125; WeakMap集合类似于WeakSet集合，WeakMap是弱引用Map集合。其中，它的键名必须是非null类型的对象，键值则可以使任意类型的值 WeakMap集合中保存的是键名弱引用着的引用对象，如果在弱引用之外不再有任何其他强引用，那么垃圾回收机制就会自动回收这个对象 只有集合的键名遵守以上规则，如果键值是一个对象，那么该引用是强引用，不会触发垃圾回收机制]]></content>
      <categories>
        <category>ES6</category>
      </categories>
      <tags>
        <tag>基础语法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[解构]]></title>
    <url>AngelLikeFairy%2F2019%2F09%2F04%2F%E8%A7%A3%E6%9E%84%2F</url>
    <content type="text"><![CDATA[为什么需要解构在Es6之前，当我们需要从一个对象中取出某个属性的值时，我们通常会这么做： 123456789let test=&#123; a:1, b:2, c:3&#125;console.log(test.a); // 1console.log(test.b); // 2console.log(test.c); // 3 显然我们可以看到，我们重复写了很多同样的代码；况且这只是仅仅只有一层，如果其中还包含更多的嵌套解构的话，那么我们就需要编写更长更多的代码 然而，Es6的解构就很好地解决了这些问题 对象解构对象解构的语法形式是在一个赋值操作符左边放置一个对象字面量,那么左边对象字面量中的变量就可以获得右边对象中的同名变量的属性值 例如： 123456789let test=&#123; a:1, b:2, c:3&#125;// 变量声明的时候，解构对象获得对应属性值let &#123;a,b,c&#125;=test;console.log(a,b,c); // 1,2,3 注意：只要使用了解构来声明变量，那么就必须要给该表达式初始化（即提供等号右侧的值） 解构赋值不同于上面的那段程序，是在变量声明的时候就解构对象来得到相应的属性值。解构赋值，是在变量已经声明结束后，在普通赋值表达式的时候进行解构 但此时，一定要记住，需要用一对小括号来包裹解构赋值表达式； 因为，在之前提过，JavaScritp将一对花括号之间的区域视为一个代码块，但是代码块语句不允许出现在赋值表达式左侧。因此，我们通过在解构赋值语句外包裹一对小括号来讲该块语句转化为一个表达式 例如： 123456789let test=&#123; a:1, b:2, c:3&#125;let a,b,c;(&#123;a,b,c&#125;=test);console.log(a,b,c); 给函数传递参数的同时解构只要你想获得对象中某些参数的值，无论是在哪里你都可以利用解构，比如在函数传参的环节 例： 123456789101112let test=&#123; a:1, b:2, c:3&#125;function getValue(value) &#123; return value;&#125;console.log(getValue(&#123;a,b,c&#125;=test)); // &#123; a: 1, b: 2, c: 3 &#125;console.log(a,b,c); // 1,2,3 因为JavaScript表达式的结果会是等号右边的值，因此实参的表达式 {a,b,c}=test的结果会是test对象，因此传递给getValue函数的是test对象，但是在此表达式的执行过程中，也进行了解构操作，因此也得到了a,b,c的值 解构赋值也可以使用默认值在使用解构赋值表达式的时候，如果指定的局部变量名称在对象中并没有该属性，那么该变量会被赋予undefined 例如： 12345678let test=&#123; a:1, b:2, c:3&#125;let &#123;a,b,c,d,e&#125;=test;console.log(a,b,c,d,e); // 1,2,3,undefined,undefined 但其实，类似于之前提到过的默认参数（当形参没有获得实参时，那些提前被赋予默认值的参数就可以使用默认值），在解构赋值时也可以使用默认值 例如： 12345678let test=&#123; a:1, b:2, c:3&#125;let &#123;a='aaa',b='bbb',c='ccc',d='ddd',e='eee'&#125;=test;console.log(a,b,c,d,e); // 1,2,3,'ddd','eee' 当指定的属性不存在时，我们变量就会获得预先设定的默认值 为非同名局部变量赋值有些时候，我们只想取得某个对象中的属性值而不是命名与属性名相同的变量名，也就是为非同名局部变量解构赋值 12345678910let test=&#123; a:1, b:2, c:3&#125;// 使用冒号语法来为非同名变量赋值let &#123;a:itemA,b:itemB,c:itemC&#125;=test;console.log(itemA,itemB,itemC); // 1,2,3console.log(a,b,c); // 报错：a is not defined 嵌套对象解构无论嵌套多少层，我们只需要记住将赋值操作符左边的解构对象看作是一个对象字面量，这个对象字面量等于右边给定的对象，那么我们就可以很容易对比两个对象得到需要的属性值 例如： 1234567891011121314let test=&#123; a:1, b:2, c:&#123; a:'a', b:'b', c:'c' &#125;&#125;// 解构嵌套对象时，我们只能获得当前解构对象内的最深层变量赋值let &#123;c:&#123;b&#125;&#125;=test;console.log(b); // 'b'console.log(c); // 报错 c is not defined 数组解构数组解构使用的数组字面量，且解构操作全部在数组内完成 在数组解构语法中，我们是通过值在数组中的位置来进行获取数组元素值的 例如： 1234let test=[1,2,&#123;item:3&#125;];let [a,b,c]=test;console.log(a,b,c); // 1,2,&#123; item: 3 &#125;console.log(c===test[2]); // true 当然我们也可以只取得其中的几项，未显示声明的元素都会被忽略（通过设置空白占位符） 例如： 123let test=[1,2,&#123;item:3&#125;];let [a, ,c]=test;console.log(a,c); // 1,&#123;item:3&#125; 数组解构赋值数组解构不像对象解构，因为数组使用[]包裹的，而不是对象字面量的{}，因此，数组的解构赋值会被当做一个表达式 12345let test=[1,2,&#123;item:3&#125;];let a,b,c; // 声明a,b,c[a,b,c]=test;console.log(a,b,c); // 1,2,&#123;item:3&#125; 交换变量数组解构赋值语法有一个独特的用例，可以用来交换两个变量的值 123let a=1,b=2;[a,b]=[b,a];console.log(a,b); // 2,1 对于上述代码，在表达式赋值之前，我们会先求得表达式左右两侧的值之后在进行赋值。右侧根据a,b生成一个数组对象，因此，这就符合了数组解构赋值的语法 因为在数组解构语法中，我们是通过值在数组中的位置来进行获取数组元素值的，而不是像对象解构是根据同名变量来的，因此，在这里，局部变量a会获得数组[b,a]的第一个元素也就是2，局部变量b会获得数组[b,a]的第二个元素也就是1 上述代码可以转化为 12345let a=1,b=2;let arr=[b,a];console.log(arr); // [2,1][a,b]=arr;console.log(a,b); // 2,1 数组解构赋值中的默认值类似于对象解构赋值我们可以使用默认值，在数组解构赋值中我们同样也可以使用默认值 123let test=[1,2,&#123;item:3&#125;];let [a='aaa',b='bbb',c='ccc',d='ddd',e='eee']=test;console.log(a,b,c,d,e); // 1,2,&#123;item:3&#125;,ddd,eee 嵌套数组解构类似于对象的嵌套解构 123let test=[1,2,[3,4,5]];let [a, ,[ , ,c]]=test;console.log(a,c); // 1,5 不定元素在数组中，我们可以通过…语法将数组中的其余元素都赋值给一个特定的变量。我们把这称之为不定元素 注意：在被解构的数组中，不定元素必须为最后一个条目，在不定元素后面继续添加都好会导致程序抛出语法错误 123let test=[1,2,&#123;item:3&#125;,[4,5,6]];let [a, , ,[...d]]=test;console.log(a,d); // 1,[4,5,6] 混合解构顾名思义，就是在任何混杂真对象和数组的数据解构得到某些值 1234567891011121314let test=&#123; a:1, b:2, c:&#123; a:1, b:&#123; b:2 &#125;, c:[1,2,3] &#125;&#125;let &#123;c:&#123;b,c:[ , ,d]&#125;&#125;=test;console.log(b,d); // &#123;b:2&#125;,3 在上述代码中的冒号前的变量代表对象的属性，并不是声明的局部变量 解构参数解构可以用在函数参数的传递过程中，我们可以使用对象或数组解构模式来替代命名参数 例如： 1234567891011function getValue(&#123;a,b,c&#125;) &#123; console.log(a,b,c); // 1,2,3&#125;let test=&#123; a:1, b:2, c:3&#125;getValue(test); 注意，解构参数必须传值，对于上述代码，我们就不能穿一个null空对象或者undefined，不然就会使程序抛出语法错误]]></content>
      <categories>
        <category>ES6</category>
      </categories>
      <tags>
        <tag>基础语法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[leetcode-235 二叉搜索树的最近公共祖先]]></title>
    <url>AngelLikeFairy%2F2019%2F09%2F04%2Fleetcode-235%2F</url>
    <content type="text"><![CDATA[二叉搜索树的最近公共祖先题目描述给定一个二叉搜索树, 找到该树中两个指定节点的最近公共祖先。 百度百科中最近公共祖先的定义为：“对于有根树 T 的两个结点 p、q，最近公共祖先表示为一个结点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（一个节点也可以是它自己的祖先）。” 例如，给定如下二叉搜索树: root = [6,2,8,0,4,7,9,null,null,3,5] 示例 1: 输入: root = [6,2,8,0,4,7,9,null,null,3,5], p = 2, q = 8输出: 6解释: 节点 2 和节点 8 的最近公共祖先是 6。示例 2: 输入: root = [6,2,8,0,4,7,9,null,null,3,5], p = 2, q = 4输出: 2解释: 节点 2 和节点 4 的最近公共祖先是 2, 因为根据定义最近公共祖先节点可以为节点本身。 说明: 所有节点的值都是唯一的。p、q 为不同节点且均存在于给定的二叉搜索树中。 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/lowest-common-ancestor-of-a-binary-search-tree著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 核心思路概述因为该树为二叉搜索树，因此，每个节点的左子树均小于等于它的值；每个节点的右子树均大于等于它的值；那么，如果当给定的节点分别位于某节点的两侧时，则该节点为给定两节点的最近公共祖先 解题步骤 先序遍历该二叉搜索树，如果给定两节点的值均小于该节点，那么遍历该节点的左子树 如果给定两节点的值均大于该节点，那么遍历该节点的右子树 如果该节点的值小于某节点的值又大于另一节点的值，那么返回该节点 Coding实现123456789101112131415161718192021222324252627/** * Definition for a binary tree node. * function TreeNode(val) &#123; * this.val = val; * this.left = this.right = null; * &#125; *//** * @param &#123;TreeNode&#125; root * @param &#123;TreeNode&#125; p * @param &#123;TreeNode&#125; q * @return &#123;TreeNode&#125; */var lowestCommonAncestor = function(root, p, q) &#123; if(root===null) return; else &#123; if(p.val&gt;root.val&amp;&amp;q.val&gt;root.val) &#123; return lowestCommonAncestor(root.right,p,q); &#125; else if(p.val&lt;root.val&amp;&amp;q.val&lt;root.val) &#123; return lowestCommonAncestor(root.left,p,q); &#125; else &#123; return root; &#125; &#125;&#125;;]]></content>
      <categories>
        <category>leetcode题解与算法</category>
      </categories>
      <tags>
        <tag>树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[原型对象的设置与访问]]></title>
    <url>AngelLikeFairy%2F2019%2F09%2F03%2F%E5%8E%9F%E5%9E%8B%E5%AF%B9%E8%B1%A1%E7%9A%84%E8%AE%BE%E7%BD%AE%E4%B8%8E%E8%AE%BF%E9%97%AE%2F</url>
    <content type="text"><![CDATA[原型对象的访问__proto__proto属性是Object.prototype 一个简单的访问器属性，其中包含了get（获取）和set（设置）的方法 proto的读取器(getter)暴露了一个对象的内部 [[Prototype]] 。对于使用对象字面量创建的对象，这个值是 Object.prototype。对于使用数组字面量创建的对象，这个值是 Array.prototype。对于functions，这个值是Function.prototype。 proto 的设置器(setter)允许对象的 [[Prototype]]被变更。要变更的值必须是一个object或null，提供其它值将不起任何作用。 12345678910111213function Test(item) &#123; this.item=item;&#125;Test.prototype.sayHello=function() &#123; console.log('hello');&#125;let test=new Test();// 使用__proto__属性访问原型console.log(test.__proto__); // Test &#123; sayHello: [Function] &#125;test.sayHello(); // 'hello' Object.getPrototypeOf()概述Object.getPrototypeOf() 方法返回指定对象的原型（内部[[Prototype]]属性的值）。 语法 Object.getPrototypeOf(object) 参数：obj: 要返回的对象的原型 例子12345678910111213function Test(item) &#123; this.item=item;&#125;Test.prototype.sayHello=function() &#123; console.log('hello');&#125;let test=new Test();// 使用Object.getPrototypeOf()方法访问原型let proto=Object.getPrototypeOf(test);console.log(proto); // Test &#123; sayHello: [Function] &#125; 原型对象的设置Object.setPrototypeOf()概述Object.setPrototypeOf() 方法设置一个指定的对象的原型 ( 即, 内部[[Prototype]]属性）到另一个对象或 null。 语法 Object.setPrototypeOf(obj, prototype) 参数：obj: 要设置其原型的对象 prototype: 该对象的新原型（一个对象或null） 例子1234567891011121314151617181920function Test(item) &#123; this.item=item;&#125;Test.prototype.sayHello=function() &#123; console.log('hello');&#125;let test=new Test();// 使用Object.setPrototypeOf()方法修改对象的原型let a=&#123; sayHello() &#123; console.log('say hello'); &#125;&#125;Object.setPrototypeOf(test,a);console.log(Object.getPrototypeOf(test)===a); // truetest.sayHello(); // 'say hello' Object.create()概述Object.create()方法创建一个新对象，使用现有的对象来提供新创建的对象的proto。 语法 Object.create(proto[, propertiesObject]) 参数：proto 新创建对象的原型对象。 propertiesObject 可选。如果没有指定为 undefined，则是要添加到新创建对象的可枚举属性（即其自身定义的属性，而不是其原型链上的枚举属性）对象的属性描述符以及相应的属性名称。这些属性对应Object.defineProperties()的第二个参数。 返回值 一个新对象，带着指定的原型对象和属性。 例子12345678910111213141516function Test(item) &#123; this.item=item;&#125;Test.prototype.sayHello=function() &#123; console.log('hello');&#125;// 使用Object.create创建一个新对象，该新对象的原型对象为给定值let test=Object.create(Test.prototype);Test.call(test,1);console.log(Object.getPrototypeOf(test)===Test.prototype); // truetest.sayHello(); // 'hello'console.log(test.item); // 1console.log(test); // Test &#123; item: 1 &#125; __proto__例子1234567891011121314151617function Test(item) &#123; this.item=item;&#125;Test.prototype.sayHello=function() &#123; console.log('hello');&#125;// 使用__Proto__属性来设置原型let test=&#123;&#125;;test.__proto__=Test.prototype;Test.call(test,1);console.log(Object.getPrototypeOf(test)===Test.prototype); // truetest.sayHello(); // 'hello'console.log(test.item); // 1console.log(test); // Test &#123; item: 1 &#125;]]></content>
      <categories>
        <category>javaScript基础</category>
      </categories>
      <tags>
        <tag>基础语法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[获取对象属性名和属性值的几种方法]]></title>
    <url>AngelLikeFairy%2F2019%2F09%2F03%2F%E8%8E%B7%E5%8F%96%E5%AF%B9%E8%B1%A1%E5%B1%9E%E6%80%A7%E5%90%8D%E7%9A%84%E5%87%A0%E7%A7%8D%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[什么是可枚举属性和不可枚举属性可枚举属性是指那些内部 “可枚举” 标志（[[ Enumerable]]）设置为 true 的属性。 对于通过直接的赋值和属性初始化的属性，该标识值默认为即为 true; 对于通过 Object.defineProperty 等定义的属性，该标识值默认为 false（当然该方法也可以设置 enumerable的值为true，使其变为可枚举属性）。 Object.keys() –只返回自身对象的可枚举属性Object.keys() 方法会返回一个由一个给定对象的自身可枚举属性组成的数组，数组中属性名的排列顺序和使用 for…in 循环遍历该对象时返回的顺序一致 。如果对象的键-值都不可枚举，那么将返回由键组成的数组。 1234567891011121314151617181920212223242526let a=&#123; item:1&#125;let b=&#123; b:2, c() &#123; return this.b; &#125;&#125;// 设置a对象的不可枚举属性Object.defineProperty(a,'_item',&#123; get:function() &#123; return this.item; &#125;, set:function(item) &#123; this.item=item; &#125;&#125;)// 设置b对象为a的原型对象Object.setPrototypeOf(a,b);// 只会返回当前对象的所有可枚举属性，而不会返回其原型对象上的可枚举属性console.log(Object.keys(a)); // ['item'] for…in –返回整条原型链上的可枚举属性for…in语句以任意顺序遍历一个对象的除Symbol以外的可枚举属性。 循环将遍历对象本身的所有可枚举属性，以及对象从其构造函数原型中继承的属性（更接近原型链中对象的属性覆盖原型属性）。 123456789101112131415161718192021222324252627282930let a=&#123; item:1&#125;let b=&#123; b:2, c() &#123; return this.b; &#125;&#125;// 设置a对象的不可枚举属性Object.defineProperty(a,'_item',&#123; get:function() &#123; return this.item; &#125;, set:function(item) &#123; this.item=item; &#125;&#125;)// 设置b对象为a对象的原型对象Object.setPrototypeOf(a,b);// 会返回其自身的所有可枚举属性以及其原型链上的所有可枚举属性(包括其原型对象，其原型对象的原型对象一直到除Object,prototype的顶端原型对象)let ans=[];for(let i in a) &#123; ans.push(i);&#125;console.log(ans); // ['item','b','c'] getOwnPropertyNames() –返回自身对象的所有属性（包括不可枚举但不包括Symbol值）Object.getOwnPropertyNames()方法返回一个由指定对象的所有自身属性的属性名（包括不可枚举属性但不包括Symbol值作为名称的属性）组成的数组。 它与上述两种方法的不同之处在于其可以返回不可枚举属性 1234567891011121314151617181920212223242526let a=&#123; item:1&#125;let b=&#123; b:2, c() &#123; return this.b; &#125;&#125;// 设置a对象的不可枚举属性Object.defineProperty(a,'_item',&#123; get:function() &#123; return this.item; &#125;, set:function(item) &#123; this.item=item; &#125;&#125;)// 设置b对象为a对象的原型对象Object.setPrototypeOf(a,b);// 返回自身对象的所有属性，包括可枚举属性和不可枚举属性console.log(Object.getOwnpropertyNames(a)); //['item','_item'] Object.values获取对象的属性值Object.values()方法返回一个给定对象自身的所有可枚举属性值的数组，值的顺序与使用for…in循环的顺序相同 ( 区别在于 for-in 循环枚举原型链中的属性 )。 12345678910let test= &#123; a: 1, b: 2, c: 3&#125;console.log(Object.values(test));// [1,2,3]console.log(Object.keys(test));// ['a','b','c'] Object.entries()获取对象的键值对Object.entries()方法返回一个给定对象自身可枚举属性的键值对数组，其排列与使用 for…in 循环遍历该对象时返回的顺序一致（区别在于 for-in 循环也枚举原型链中的属性）。 1234567let test= &#123; a: 1, b: 2, c: 3&#125;console.log(Object.entries(test));// [ [ 'a', 1 ], [ 'b', 2 ], [ 'c', 3 ] ]]]></content>
      <categories>
        <category>javaScript基础</category>
      </categories>
      <tags>
        <tag>基础语法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[leetcode-234 回文链表]]></title>
    <url>AngelLikeFairy%2F2019%2F09%2F03%2Fleetcode-234%2F</url>
    <content type="text"><![CDATA[回文链表题目描述请判断一个链表是否为回文链表。 示例 1: 输入: 1-&gt;2输出: false 示例 2: 输入: 1-&gt;2-&gt;2-&gt;1输出: true 进阶：你能否用 O(n) 时间复杂度和 O(1) 空间复杂度解决此题？ 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/palindrome-linked-list著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 核心思路概述一个简单的想法就是，将该链表的所有节点值都取出来，然后判断是否回文。但是，题目要求为O(1)的空间复杂度，因此不能使用数组来存储。因此，我们可以使用哈希表来存储，以链表节点的下标为键名，节点值为键值来存入哈希表 之后利用双指针来判断是否回文 解题步骤 建立哈希表 遍历该链表，以链表节点的下标为键名，节点值为键值来存入哈希表 设置前后双指针，如果指针未相遇时，前后指针在哈希表中的键值不相同的话那么返回false 否则，返回true Coding实现1234567891011121314151617181920212223242526272829/** * Definition for singly-linked list. * function ListNode(val) &#123; * this.val = val; * this.next = null; * &#125; *//** * @param &#123;ListNode&#125; head * @return &#123;boolean&#125; */var isPalindrome = function(head) &#123; let cur=head; let map=new Map(); let index=0; while(cur) &#123; map.set(index,cur.val); index++; cur=cur.next; &#125; let left=0; let right=index-1; while(left&lt;right) &#123; if(map.get(left)!==map.get(right)) return false; left++; right--; &#125; return true;&#125;;]]></content>
      <categories>
        <category>leetcode题解与算法</category>
      </categories>
      <tags>
        <tag>链表</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[浅拷贝与深拷贝]]></title>
    <url>AngelLikeFairy%2F2019%2F09%2F02%2F%E6%B5%85%E6%8B%B7%E8%B4%9D%E4%B8%8E%E6%B7%B1%E6%8B%B7%E8%B4%9D%2F</url>
    <content type="text"><![CDATA[什么是浅拷贝与深拷贝 浅拷贝与深拷贝是只针对Object和Array这样的引用数据类型的 浅拷贝指的是在复制对象的时候，对第一层键值进行独立的复制。若键值为基本类型值，则复制该基本类型值；若键值为引用类型值，则复制该引用类型值的引用 深拷贝则会创造另一个对象，只是这个对象与被拷贝的对象一模一样，但是并没有占用同一块内存 赋值操作是浅拷贝吗在将一个对象赋值给另一个对象的时候，其实是将该对象的引用地址复制给了它。因此两个对象占用同一个内存 但是，浅拷贝是在复制对象的时候，对第一层键值进行独立的复制。因此，新旧对象并不占用同一个内存，所以，原对象在浅拷贝之后做的任何操作都不会影响浅拷贝得到的对象 例如： 12345678910111213141516171819let a=&#123; item:1&#125;// 使用赋值操作得到的对象let b=a;console.log(b); // &#123;item:1&#125;console.log(b===a); // true// 使用浅拷贝得到的对象let c=&#123;&#125;;Object.assign(c,a);console.log(c); // &#123;item:1&#125;console.log(c===a); // false// 修改原对象a.item=2;console.log(b.item); // 2console.log(c.item); // 1 显然，赋值得到的对象与原对象占用同一个内存；而浅拷贝得到的对象与原对象并没有占有同一个内存，因此，原对象做出的任何修改都不会影响浅拷贝得到的对象 实现浅拷贝的几种方法Object.assign()概述Object.assign() 方法用于将所有可枚举属性的值从一个或多个源对象复制到目标对象。它将返回目标对象。 如果目标对象中的属性具有相同的键，则属性将被源对象中的属性覆盖。后面的源对象的属性将类似地覆盖前面的源对象的属性。 语法 Object.assign(target, …sources) 参数：target: 拷贝得到的对象sources: 被拷贝的对象，可以是多个 Object.assign()方法主要做的工作就是，遍历要拷贝对象的属性，如果该属性值为基本类型值，那么就复制该属性值；如果，该属性值为引用类型值，那么就复制该引用类型值的引用。 因此，该方法只拷贝对象的第一层属性 例子1234567891011121314151617181920let a=&#123; item:1, tree:&#123; k:2 &#125;&#125;// 使用浅拷贝得到的对象let c=&#123;&#125;;Object.assign(c,a);console.log(c); // &#123;item:1,tree:&#123;k:2&#125;&#125;console.log(c===a); // false// 修改原对象的第一层基本类型值a.item=2;console.log(c.item); // 1// 修改原对象的第二层基本类型值a.tree.k=3;console.log(c.tree.k); // 3 因此，使用浅拷贝得到的对象，如果其第一层属性值为基本类型值，那么原对象修改后，不会影响浅拷贝得到的对象； 如果其第一层属性值为引用类型值，那么原对象修改后会影响拷贝得到的对象 实现Object.assign()方法知道浅拷贝的思想之后，那么实现Object.assign()方法就很容易了 1234567function shallowCopy(receiver=&#123;&#125;,supplier) &#123; let keys=Object.keys(supplier); keys.forEach(v=&gt;&#123; receiver[v]=supplier[v]; &#125;) return receiver;&#125; 使用展开运算符展开运算符在构造字面量对象时，可以进行克隆或者属性拷贝（ECMAScript 2018规范新增特性）： let objClone = { …obj }; 其行为是, 将已有对象的所有可枚举(enumerable)属性拷贝到新构造的对象中. 浅拷贝(Shallow-cloning, 不包含 prototype) 和对象合并, 可以使用更简短的展开语法。而不必再使用 Object.assign() 方式. 12345678910111213141516let a=&#123; item:1, tree:&#123; item:2 &#125;&#125;let b=&#123;...a&#125;;console.log(b); // &#123;item:1,tree:&#123;item:2&#125;&#125;console.log(b===a); // falsea.item=2;console.log(b.item); // 1a.tree.item=3;console.log(b.tree.item); // 3 当然，使用展开运算符也可以拷贝多个对象。它像Object.assign方法一样，可以接受任意数量的原对象，并按指定顺序将属性复制到接受对象中。所以，如果多个原对象具有相同的属性名，那么排位靠后的原对象的属性值会覆盖排位靠前的 12345678910111213let a=&#123; item:1, tree:&#123; item:2 &#125;&#125;let b=&#123; item:2&#125;let c=&#123;...a,...b&#125;;console.log(c); // &#123; item: 2, tree: &#123; item: 2 &#125; &#125; 对于数组对象对于数组对象，可以使用以下方法 Array.prototype.concat() Array.prototype.slice() Array.of()结合不定参数 12345678910111213141516171819202122232425262728293031let test=[1,&#123;item:1&#125;]// 使用concat()方法let arr1=test.concat();console.log(arr1); // [1,&#123;item:1&#125;]console.log(arr1===test); // falseconsole.log(arr1[1]===test[1]); // true// 使用slice()方法let arr2=test.concat();console.log(arr2); // [1,&#123;item:1&#125;]console.log(arr2===test); // falseconsole.log(arr2[1]===test[1]); // true// 使用new Array()方法let arr3=new Array(...arr1);console.log(arr3); // [1,&#123;item:1&#125;]console.log(arr3===test); // falseconsole.log(arr3[1]===test[1]); // true// 修改数组中引用类型元素的值test[1].item=2;console.log(`$&#123;arr1[1].item&#125;$&#123;arr2[1].item&#125; $&#123;arr3[1].item&#125;`);// 2// 2// 2 数组对象的浅拷贝实质上就是，遍历整个数组将数组元素复制到另一个新的数组对象中去； 因此，当数组元素为基本类型值时，复制的就是基本类型值，原数组改变该值不会影响新数组 但是当数组元素为引用类型值时，复制的就是引用类型值的引用，那么原数组修改该值就会影响新的数组 实现深拷贝的几种方法利用JSON我们可以使用JSON.stringify将对象转成JSON字符串，再用JSON.parse()把字符串解析成对象。此时生成的对象与原对象会是完全不同的对象，里面的任何属性都不会占用同一个内存 12345678910111213141516171819let a=&#123; item:1, tree:&#123; item:2, tree:&#123; item:3 &#125; &#125;&#125;// 使用JSON方法深拷贝let b=JSON.parse(JSON.stringify(a));console.log(b); // &#123; item: 1, tree: &#123; item: 2, tree: &#123; item: 3 &#125; &#125; &#125;console.log(a===b); // falseconsole.log(a.tree===b.tree); // false// 修改原对象的引用类型属性a.tree.tree.item=4；console.log(b.tree.tree.item); // 3 这种方法虽然简便，但还是有一些缺点，比如 会忽略undefined 不能序列化函数 这是因为JSON.stringify() 方法是将一个JavaScript值(对象或者数组)转换为一个 JSON字符串，不能接受函数 无法拷贝Symbol 递归拷贝在深拷贝一个对象时，我们需要考虑要拷贝的这个对象时常规键值对对象还是数组对象。因为，遇到前者我们需要生成一个新的空对象{}，而遇到后者时我们需要生成一个新的空数组对象[] 那么，我们需要通过什么方法来检测，某个对象究竟是数组对象还是常规对象呢?可以采用如下方式： 123456function check(target) &#123; return Object.prototype.toString.call(target).slice(8,-1);&#125;console.log(check(new Object())); // Objectconsole.log(check(new Array())); // Array 因此，深拷贝完整代码如下： 123456789101112131415161718192021222324function deepClone(target) &#123; let ans; if(check(target)==='Array') ans=[]; else if(check(target)==='Object') ans=&#123;&#125;; else return target; for(let i in target) &#123; if(check(target[i])==='Array'||check(target[i])==='Object') &#123; ans[i]=deepClone(target[i]); &#125; else &#123; ans[i]=target[i]; &#125; &#125; return ans;&#125;function check(obj) &#123; return Object.prototype.toString.call(obj).slice(8,-1);&#125;let target=&#123;item:1,a:[1,2,&#123;item:2&#125;],tree:&#123;tree:&#123;item:3&#125;&#125;&#125;;let rev=deepClone(target);console.log(rev); // &#123; item: 1, a: [ 1, 2, &#123; item: 2 &#125; ], tree: &#123; tree: &#123; item: 3 &#125; &#125; &#125;console.log(rev.a===target.a); // false]]></content>
      <categories>
        <category>javaScript基础</category>
      </categories>
      <tags>
        <tag>基础语法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ES6中对于对象作出了哪些扩展]]></title>
    <url>AngelLikeFairy%2F2019%2F09%2F02%2FES6%E4%B8%AD%E5%AF%B9%E4%BA%8E%E5%AF%B9%E8%B1%A1%E4%BD%9C%E5%87%BA%E4%BA%86%E5%93%AA%E4%BA%9B%E6%89%A9%E5%B1%95%2F</url>
    <content type="text"><![CDATA[对象字面量语法的扩展属性初始值的简写在ES6之前，当我们声明一个对象时，可能该对象的属性名与该对象可访问到的作用链上的某变量同名。那么显然此时会发生一些重复 例如: 123456function Person(name,age) &#123; return &#123; name:name, age:age &#125;&#125; 为了消除这种属性名称与局部变量之间的重复书写。在ES6中，当一个对象的属性与本地变量同名时，不必再写冒号和值，简单地只写属性名即可。 这也意味着，当在声明属性时，如果采用这种简写语法，只要保证能够访问到以该属性名为变量名的变量即可。（也就是，该变量所在的活动对象需在当前对象的所能访问到的作用链上） 例如： 12345// 同一个作用域内声明对象let a=1;let b=2;console.log(&#123;a,b&#125;); // &#123;a:1,b:2&#125; 123456789101112// 变量处在同一作用域链上时声明对象let a=1;let b=2;function test() &#123; return &#123; a, b &#125;&#125;console.log(test()); // &#123;a:1,b:2&#125; 123456789101112131415// 变量不处在同一作用域上声明对象&#123; let a=1; let b=2;&#125;function test() &#123; return &#123; a, b &#125;&#125;console.log(test()); // 报错：ReferenceError: a is not defined 当对象字面量中只有一个属性的名称时，JavaScript引擎会在可访问作用域中查找其同名变量；如果找到，则该变量的值被赋给对象字面量里的同名属性 对象方法的简写语法在ES6中，通过对象字面量法创建对象时，如果为对象添加方法，可以不再使用键值对来声明方法 例如： 1234567let a=&#123; test()&#123; console.log('test'); &#125;&#125;a.test(); // 'test' 可计算属性名点记法与方括号法当想访问一个对象的属性时，可以采用点记法和方括号法 例如： 12345678910111213let a=&#123; name:'ming', age:18&#125;console.log(a.name); // 'ming'// 方括号内为字符串console.log(a['age']); // 18// 方括号内可以表示为字符串的变量let age='age';console.log(a[age]); // 18 注意，当使用方括号语法时，方括号内必须是字符串或者表示字符串的变量 当然，该字符串可以不是一个合法的标识符；它可以是任意值 例如: 1234let a=&#123;&#125;;let firstName='first name';a[firstName]='ming';console.log(a); // &#123; 'first name': 'ming' &#125; 另外,使用点表示法时，点的后面必须是一个有效的 JavaScript 标识符，例如，一串字母数字字符，也包括下划线及美元符号，但不能以数字作为开头。比如，object.$1是合法的，而 object.1是无效不合法的。但是可以通过方括号表示法来解决这个问题 例如： 1234567let item=1;let a=&#123; [item]:123&#125;console.log(a); // &#123; '1': 123 &#125;// 将1转化为一个字符串console.log(a['1']); //123 在对象字面量中使用可计算属性名在对象字面量中使用方括号语法表示该属性名是可以被计算的。也就是说方括号内如果是一个变量，那么这个变量将会被求值并转化为一个字符串；如果方括号内是一个字符串，那么就使用这个字符串 12345678910// 方括号内为一个变量，该变量表示一个字符串//变量会被求值得到字符串let item='itemA';let a=&#123; [item]:1&#125;console.log(a); // &#123; itemA: 1 &#125;console.log(a[item]); // 1console.log(a.itemA); // 1 12345678// 方括号内为字符串，那么就使用这个字符串let a=&#123; ['itemA']:1&#125;console.log(a); // &#123; itemA: 1 &#125;console.log(a['itemA']); // 1console.log(a.itemA); // 1 1234567891011// 方括号内为一个变量，该变量表示的不是一个字符串// 变量会通过String()转型函数被转化为字符串，因此undefined和null也可以let item=1;let test=undefined;let a=&#123; [item]:123, [test]:987&#125;console.log(a); // &#123; '1': 123, undefined: 987 &#125;console.log(a.undefined); // 987 当然，可计算属性名也可以计算表达式 123456let first='first 'let a=&#123; [first+'name']:'ming'&#125;console.log(a); // &#123; 'first name': 'ming' &#125;console.log(a['first name']); // ming]]></content>
      <categories>
        <category>ES6</category>
      </categories>
      <tags>
        <tag>基础语法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[leetcode-232 用栈实现队列]]></title>
    <url>AngelLikeFairy%2F2019%2F09%2F02%2Fleetcode-232%2F</url>
    <content type="text"><![CDATA[用栈实现队列题目描述使用栈实现队列的下列操作： push(x) -- 将一个元素放入队列的尾部。 pop() -- 从队列首部移除元素。 peek() -- 返回队列首部的元素。 empty() -- 返回队列是否为空。示例: MyQueue queue = new MyQueue(); queue.push(1); queue.push(2); queue.peek(); // 返回 1 queue.pop(); // 返回 1 queue.empty(); // 返回 false说明: 你只能使用标准的栈操作 – 也就是只有 push to top, peek/pop from top, size, 和 is empty 操作是合法的。 你所使用的语言也许不支持栈。你可以使用 list 或者 deque（双端队列）来模拟一个栈，只要是标准的栈操作即可。 假设所有操作都是有效的 （例如，一个空的队列不会调用 pop 或者 peek 操作）。 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/implement-queue-using-stacks著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 核心思路概述队列与栈不一样的地方就在于，栈是先进后出，而队列是先进先出；因此，在利用栈实现队列，只有出队列方法不一样而已； 解题步骤 在实现出队列的方法时，需要准备一个备用栈，来存储出栈的元素。 当需要出队列时，将栈内所有元素出栈并以此存入到备用栈中； 将备用栈的栈顶元素出栈并保存到一个变量ans中； 将备用栈的所有元素出栈并以此存入回基本栈中 返回ans Coding实现1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556/** * Initialize your data structure here. */var MyQueue = function() &#123; this.stack=[];&#125;;/** * Push element x to the back of queue. * @param &#123;number&#125; x * @return &#123;void&#125; */MyQueue.prototype.push = function(x) &#123; this.stack.push(x);&#125;;/** * Removes the element from in front of queue and returns that element. * @return &#123;number&#125; */MyQueue.prototype.pop = function() &#123; let anotherStack=[]; while(this.stack.length) &#123; anotherStack.push(this.stack.pop()); &#125; let ans=anotherStack.pop(); while(anotherStack.length) &#123; this.stack.push(anotherStack.pop()); &#125; return ans;&#125;;/** * Get the front element. * @return &#123;number&#125; */MyQueue.prototype.peek = function() &#123; return this.stack[0];&#125;;/** * Returns whether the queue is empty. * @return &#123;boolean&#125; */MyQueue.prototype.empty = function() &#123; return this.stack.length===0;&#125;;/** * Your MyQueue object will be instantiated and called as such: * var obj = new MyQueue() * obj.push(x) * var param_2 = obj.pop() * var param_3 = obj.peek() * var param_4 = obj.empty() */]]></content>
      <categories>
        <category>leetcode题解与算法</category>
      </categories>
      <tags>
        <tag>栈</tag>
        <tag>队列</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[leetcode-113 路径总和 II]]></title>
    <url>AngelLikeFairy%2F2019%2F09%2F01%2Fleetcode-113%2F</url>
    <content type="text"><![CDATA[路径总和 II题目描述给定一个二叉树和一个目标和，找到所有从根节点到叶子节点路径总和等于给定目标和的路径。 说明: 叶子节点是指没有子节点的节点。 示例:给定如下二叉树，以及目标和 sum = 22， 返回: 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/path-sum-ii著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 核心思路概述不同于上题，这次还要记录路径和为给定值的路径上的所有值。那么我们可以用数组来进行记录，每次传入一个新的数组（包括该条路径上当前记录的所有的值）。 采用先序遍历，当遍历到叶子节点时，判断路径和是否为给定值，如果是，那么将该数组插入到ans数组中；否则，return； 解题步骤 创建ans数组 创建遍历函数(传入的参数为当前节点，当前路径和，当前已经被记录的节点值的数组)，如果节点为空，那么return 否则，将该节点的值记录到传入的数组中；如果当前节点为叶子节点，那么判断此时的路径和是否为给定值，如果是，那么将此时的数组push入ans数组中；如果不是，则return，接着遍历直到整棵树遍历完毕 Coding实现123456789101112131415161718192021222324252627282930313233/** * Definition for a binary tree node. * function TreeNode(val) &#123; * this.val = val; * this.left = this.right = null; * &#125; *//** * @param &#123;TreeNode&#125; root * @param &#123;number&#125; sum * @return &#123;number[][]&#125; */var pathSum = function(root, sum) &#123; let ans=[]; (function path(root,s,array) &#123; if(root===null) return; else &#123; array.push(root.val); let arrayCloneLeft=array.slice(0); let arrayCloneRight=array.slice(0); s+=root.val; if(!root.left&amp;&amp;!root.right) &#123; if(s===sum) &#123; ans.push(array); &#125; return; &#125; path(root.left,s,arrayCloneLeft); path(root.right,s,arrayCloneRight); &#125; &#125;)(root,0,[]) return ans;&#125;;]]></content>
      <categories>
        <category>leetcode题解与算法</category>
      </categories>
      <tags>
        <tag>树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[getter与setter函数]]></title>
    <url>AngelLikeFairy%2F2019%2F08%2F31%2Fgetter%E4%B8%8Esetter%E5%87%BD%E6%95%B0%2F</url>
    <content type="text"><![CDATA[访问器属性对象属性分为数据属性与访问器属性。访问器属性不包含数据值，它们包含一对getter与setter函数。在读取访问器属性时，会调用getter函数，这个函数负责返回有效的值；在写入访问器属性时，会调用setter函数并传入新值 什么是getter/setter getter是获得属性值的方法，setter是设置属性值的方法 get与set并不是对象的属性，可以说是伪属性，特性只有内部才用，一般利用Object.getOwnPropertyDescriptor()方法来查询属性的特性；利用Object.defineProperty来定义和修改属性的特性 怎么定义getter与setterget与set语法get/set语法会将对象属性绑定到查询/调用的函数 例： 12345678910111213let a=&#123; item:1, get getItem() &#123; return this.item; &#125;, set setItem(item) &#123; this.item=item; &#125;&#125;console.log(a); // &#123; item: 1, getItem: [Getter], setItem: [Setter] &#125;console.log(a.getItem); // 1a.setItem=2;console.log(a.getItem); // 2 get与set绑定的函数名可以是一样的 12345678910111213let a=&#123; item:1, get _item() &#123; return this.item; &#125;, set _item(item) &#123; this.item=item; &#125;&#125;console.log(a); // &#123; item: 1, _item: [Getter/Setter] &#125;console.log(a._item); // 1a._item=2;console.log(a._item); // 2 当然,get与set也可以绑定多个函数名 1234567891011121314151617181920212223let a=&#123; item:1, name:'ming', get _item() &#123; return this.item; &#125;, set _item(item) &#123; this.item=item; &#125;, get _name() &#123; return this.name; &#125;, set _name(name) &#123; this.name=name; &#125;&#125;console.log(a); // &#123;item: 1,name: 'ming',_item: [Getter/Setter],_name: [Getter/Setter]&#125;console.log(a._item); // 1a._item=2;console.log(a._item); // 2console.log(a._name); // minga._name='xiao ming';console.log(a._name); // xioa ming defineProperty()方法Object.defineProperty() 方法会直接在一个对象上定义一个新属性，或者修改一个对象的现有属性， 并返回这个对象。 语法： Object.defineProperty(obj, prop, descriptor) 参数 obj 要在其上定义属性的对象。 prop 要定义或修改的属性的名称。 descriptor 将被定义或修改的属性描述符 例： 12345678910111213let a=&#123;item:1&#125;;Object.defineProperty(a,'_item',&#123; get: function () &#123; return this.item; &#125;, set: function (item) &#123; this.item=item; &#125;&#125;)console.log(a._item); // 1a._item=2;console.log(a._item); // 2 getter与setter的作用getter与setter的作用我觉得是可以在对赋值和取值之前做一层封装，拦截这些操作，定义一些其他操作（在赋值与取值之前进行一些额外的操作） 1234567891011121314151617let a=&#123;item:1&#125;;Object.defineProperty(a,'_item',&#123; get: function () &#123; return this.item; &#125;, set: function (item) &#123; let date=new Date(); console.log(`a.item的值在$&#123;date.toLocaleString()&#125;被修改`); this.item=item; &#125;&#125;)console.log(a._item); // 1a._item=2;console.log(a._item);// a.item的值在2019-8-31 20:50:59被修改// 2 在上述代码中,我在setter函数赋值后，输出属性值被修改的时间。从而可以监测到值何时被修改。 这就是拦截了赋值操作,先进行了额外定义的检测值被修改的方法]]></content>
      <categories>
        <category>javaScript基础</category>
      </categories>
      <tags>
        <tag>基础语法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Es6一些新的函数参数知识]]></title>
    <url>AngelLikeFairy%2F2019%2F08%2F31%2FEs6%E4%B8%80%E4%BA%9B%E6%96%B0%E7%9A%84%E5%87%BD%E6%95%B0%E5%8F%82%E6%95%B0%E7%9F%A5%E8%AF%86%2F</url>
    <content type="text"><![CDATA[arguments对象每个函数都会有一个arguments对象(类数组对象)，它引用着函数的实参而非形参。 因此，Js函数有一个十分特别的特性，即无论形参有几个，都可以传入任意个实参值，并且由arguments对象引用着 例： 12345function test(a,b) &#123; console.log(arguments); // [Arguments] &#123; '0': 1, '1': 2, '2': 3 &#125;&#125;test(1,2,3); 函数参数的默认值因为在函数定义中声明了多少形参，都可以传入任意数量的参数。那么，如果，传入的参数要比形参少时，我们能否给没有得到传值的形参赋予默认值呢？ Es5模拟默认参数值如果一个参数没有传入值，那么那个形参就会是已声明但未定义，因此，形参就会被默认赋予undefined 如： 12345function test(a,b) &#123; console.log(b); // undefined&#125;test(1); 那么，我们可以在函数体中检测该形参值是否为undefined来判断是否来赋予形参默认值 123456789function test(a,b) &#123; a=((typeof a)!=='undefined')?a:1; b=((typeof b)!=='undefined')?b:2; console.log(a,b);&#125;test(0,0); // 0,0test(0); // 0,2test(); // 1,2 Es6中的默认参数值Es6简化了像Es5模拟默认参数值进行检测形参值是否为undefined的操作，它可以在形参后赋予一个初始值，当没有实参传入时，则使用那个初始值 例如： 12345function test(a,b=1,c) &#123; console.log(a,b,c); // undefined,1,undefined&#125;test(); 如上所示，test函数调用时没有传入任何参数，因此没有赋予初始值的a,c会输出undefined，而赋予初始值的形参在没有获得实参传入时就会获得该初始值 但是，其实质上也是像Es5一样检测了形参值是否为undefined；因此，当你显示地传入undefined值时，它还是会获得被赋予的初始值； 注意，null是一个空对象指针，它不等于undefined 123456function test(a,b=1,c) &#123; console.log(a,b,c); // undefined,1,undefined&#125;test(undefined,undefined,undefined);test(null,null,null); // null,null,null 默认参数值对arguments对象的影响没有使用默认参数值在Es5非严格模式下，当形参值发生变化时，arguments对象也会做出相应的改变；即，命名参数的变化会同步更新到arguments对象中 例： 123456789101112function test(a,b) &#123; console.log(a,b,arguments); // 1 2 [Arguments] &#123; '0': 1, '1': 2 &#125; a=++a; b=++b; console.log(a,b,arguments); // 2 3 [Arguments] &#123; '0': 2, '1': 3 &#125; // arguments对象发生了变化&#125;test(1,2); 使用默认参数值在Es6中，如果函数使用了默认参数值（哪怕所有形参都被传入了实参值），那么所有形参值的变化都不会影响arguments对象，即，默认参数值的存在使得arguments对象保持与命名参数的分离 例： 123456789101112function test(a=3,b=4) &#123; console.log(a,b,arguments); // 1 2 [Arguments] &#123; '0': 1, '1': 2 &#125; a=++a; b=++b; console.log(a,b,arguments); // 2 3 [Arguments] &#123; '0': 1, '1': 2 &#125; // arguments对象没有发生变化&#125;test(1,2); 默认参数表达式默认参数初始值的赋予可以通过函数来进行 例： 123456789function getB() &#123; return 3;&#125;function test(a,b=getB()) &#123; console.log(a,b); // undefined 3&#125;test(); 对于上面的test函数，初次解析函数声明的时候并不会执行getB方法，只有放该函数被调用且没有传入b的实参时才会被执行 因此，默认参数值的赋予是在函数调用时进行的，所以，我们就可以使用先定义的参数来作为后定义的参数的初始值 1234567function test(a,b=a) &#123; console.log(a,b); // 1,1 // b形参没有传入实现值，因此会赋予形参a的值，此时a传入了实参值1，因此b也被赋予为1&#125;test(1); 但是，如果先定义的参数使用后定义的参数来作为初始值，就会发生错误 123456function test(a=b,b) &#123; console.log(a,b); // 报错： ReferenceError: Cannot access 'b' before initialization&#125;test(undefined,1); 具体原因，类似于let与const声明会具有的临时死区(TDZ) 默认参数的临时死区与let和const声明类似，默认参数也具有临时死区，在临时死区内的参数不可访问。 在参数被定义时，在预编译阶段，这些参数会被放入临时死区内，如果在运行到这些参数声明语句之前就访问这些参数，那么就会导致程序抛出错误 例： 123456function test(a=b,b) &#123; console.log(a,b); // 报错： ReferenceError: Cannot access 'b' before initialization&#125;test(undefined,1); 上述参数赋值阶段的行为类似于以下 123let a=undefined;a=b; // 此时b还在临时死区内，无法被访问let b=1; 不定参数当传入的实参数量小于形参数量时，我们可以使用默认参数值； 那么，如果，当传入的实参数量大于形参数量，我们一般会想到使用arguments对象来表示这些实参；而Es6给我们引入了不定参数的特性，来方便地表示传入的实参 概念在函数的命名参数前添加三个点（…）就表明这是一个不定参数，该参数为一个数组，包含着自它之后传入的所有实参，通过这个数组名可以逐一访问到里面的参数 例如： 12345function test(a,...arr) &#123; console.log(a,arr); // 1,[2,3,4]&#125;test(1,2,3,4); 注意： 每个函数最多只能声明一个不定参数，并且该不定参数一定要放在所有的参数的末尾 不定参数不能用于对象字面量的setter函数中,因为，setter函数的参数有且只能有一个。因此不能传入不定参数，哪怕即使只是传入一个值 1234567891011let a=&#123; item:1, set _item(...item)&#123; this.item=item[0]; &#125;&#125;a._item=3;// 赋值时会报错// Setter function argument must not be a rest parameterconsole.log(a.item); 怎么判断函数是被new还是被普通调用JavaScript函数有两个内部方法：[[Call]]和[[Construct]]。当通过new关键字调用函数时，执行的是[[Construct]]；而当为普通调用时，执行的时[[Call]]函数。 具有[[construct]]方法的函数被称为构造函数，但不是所有的函数都有[[Construct]]方法，比如箭头函数，因此箭头函数不能被new关键字调用 元素性 new.target为了解决判断函数是否通过new关键字调用的问题，Es6引入了new.target元属性。 当调用[[Construct]]方法，即使用new关键字调用函数时，new.target被赋值为当前构造函数；如果是普通调用，那么new.target值为undefined 例如： 12345678function Test(item) &#123; console.log(new.target); this.item=item;&#125;let test=new Test(1); // [Function Test]Test(1); // undefinedconsole.log(test); // &#123;item:1&#125; 注意：在函数外面使用new.target会造成语法错误 123456function test() &#123; // ...&#125;console.log(new.target);// SyntaxError: new.target only allowed within functions 尾调用优化]]></content>
      <categories>
        <category>ES6</category>
      </categories>
      <tags>
        <tag>基础语法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[leetcode-231 2的幂]]></title>
    <url>AngelLikeFairy%2F2019%2F08%2F31%2Fleetcode-231%2F</url>
    <content type="text"><![CDATA[2的幂题目描述给定一个整数，编写一个函数来判断它是否是 2 的幂次方。 示例 1: 输入: 1输出: true解释: 20 = 1 示例 2: 输入: 16输出: true解释: 24 = 16 示例 3: 输入: 218输出: false 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/power-of-two著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 核心思路概述题目给定要求的是整数，那么也就是自然数，因为2的幂次方大于0，因此我们只要考虑大于等于1的整数即可。 对于，这些整数，我们可以将该数不断除以2，如果得到的结果不是整数，那么该数就不是2的幂次方；如果，最终得到的结果为1，那么该数就是2的幂次方 解题步骤 如果输入为0，返回false; 如果该数为1，返回true 否则，将该数除以2，如果结果不为整数，返回false；如果为整数，那么重复该步骤直到结果为1或者返回fase Coding实现1234567891011121314/** * @param &#123;number&#125; n * @return &#123;boolean&#125; */var isPowerOfTwo = function(n) &#123; if(n===0) return false; while(n) &#123; if(n===1) return true; else &#123; if(n/2!==Math.floor(n/2)) return false; &#125; n=n/2; &#125;&#125;;]]></content>
      <categories>
        <category>leetcode题解与算法</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[模板字面量]]></title>
    <url>AngelLikeFairy%2F2019%2F08%2F30%2F%E6%A8%A1%E6%9D%BF%E5%AD%97%E9%9D%A2%E9%87%8F%2F</url>
    <content type="text"><![CDATA[什么是模板字面量模板字面量 是允许嵌入表达式的字符串字面量。你可以使用多行字符串和字符串插值功能。它们在ES2015规范的先前版本中被称为“模板字符串”。 基础语法12345678`string text` // 相当于普通字符串`string text line 1 string text line 2` // 多行字符串 `string text $&#123;expression&#125; string text` // 带有占位符tag `string text $&#123;expression&#125; string text` 模板字符串使用反引号 () 来代替普通字符串中的用双引号和单引号。模板字符串可以包含特定语法（${expression}）的占位符。占位符中的表达式和周围的文本会一起传递给一个默认函数，该函数负责将所有的部分连接起来，如果一个模板字符串由表达式开头，则该字符串被称为带标签的模板字符串，该表达式通常是一个函数，它会在模板字符串处理后被调用，在输出最终结果前，你都可以通过该函数来对模板字符串进行操作处理。在模版字符串内使用反引号（`）时，需要在它前面加转义符（\）。 在模板字符串中，不需要转义单双引号 多行字符串123456console.log(`abc def`); // 输出结果：abcdef 注意： 在两个反引号之间的所有空白字符串都是有效的，都属于字符串的一部分。 123456console.log(`abc def`);// 输出结果abc def 因此我们可以考虑使用第一行留白的方法来对齐缩进文本 12345678console.log(` abc def`);// 输出结果 abc def 当然我们也可以使用\n在模板字符串中显示换行 12345console.log(`abc\ndef`);// 输出结果abcdef 字符串占位符在一个模板字面量中，你可以任何合法的JavaScript表达式嵌入到占位符中并将其作为字符串中的一部分输出到结果中去 占位符由${}组成，中间可以包含任意的表达式 例： 12let name='ming';console.log(`My name is $&#123;name&#125;`); // My name is ming 除了变量，占位符还可以嵌入其他表达式，包括运算式、函数调用等等 1234567function getName()&#123; return `ming`;&#125;console.log(`My name is $&#123;getName()&#125;`); // My name is mingconsole.log(`My name is $&#123;'xiao'+'ming'&#125;`); // My name is xiaoming 嵌套模板模板字面量本身也是Js表达式，所以你可以在任意一个模板字面量里嵌入另外一个模板字面量 注意： 是另外一个模板字面量而不是占位符，即：应该是 1`$&#123;`$&#123;&#125;`&#125;` 而不是 1`&amp;&#123;&amp;&#123;&#125;&#125;` // 会报错 1console.log(`$&#123;2&gt;1?`$&#123;2&gt;1?'yes':'no'&#125;`:'no'`) // 'yes' 标签模板更高级的形式的模板字符串是带标签的模板字符串。标签使您可以用函数解析模板字符串。标签函数的第一个参数包含一个字符串值的数组。其余的参数与表达式相关。最后，你的函数可以返回处理好的的字符串（或者它可以返回完全不同的东西，）。用于该标签的函数的名称可以被命名为任何名字。 定义标签标签可以是一个函数，其函数名可以任意（符合变量命名规则） 标签函数语法： 123function tag(literals,...substitutions)&#123; // 返回一个字符串&#125; 参数解释 literals: 该参数是一个字符串数组，其包括模板字面量中占位符之前，之后，以及之间的字符串 例如，对于模板字符串${girlName},my name is ${boyName}则，其数组为[‘’,’,my name is ‘,’’] substitutions:该参数是模板字符串中所有占位符结果的值，例如以上模板字符串，则数组应该为${girlName}的值和${boyName}的值 注意 不难发现,literals数组的长度永远比substitutions数组长度多1 标签模板例子1234567891011121314151617function tag(literals,...sub)&#123; console.log(literals,sub); let ans=''; for(let i in sub) &#123; ans+=literals[i]; ans+=sub[i]; &#125; ans+=literals[literals.length-1]; return ans;&#125;let name='ming';let mes=tag`my name is $&#123;name&#125;`;console.log(mes);// 输出结果[ 'my name is ', '' ] [ 'ming' ]my name is ming]]></content>
      <categories>
        <category>ES6</category>
      </categories>
      <tags>
        <tag>基础语法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[leetcode-226 翻转二叉树]]></title>
    <url>AngelLikeFairy%2F2019%2F08%2F30%2Fleetcode-226%2F</url>
    <content type="text"><![CDATA[翻转二叉树题目描述翻转一棵二叉树。 示例： 输入： 输出： 备注:这个问题是受到 Max Howell 的 原问题 启发的 ： 谷歌：我们90％的工程师使用您编写的软件(Homebrew)，但是您却无法在面试时在白板上写出翻转二叉树这道题，这太糟糕了。 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/invert-binary-tree著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 核心思路概述翻转二叉树，可以利用深度优先遍历，对于二叉树来说也就是先序遍历；在遍历的同时交换其左右子树 解题步骤 如果节点为空，那么返回null 否则，交换其左右子树 递归遍历左右子树 重复1,2,3步骤直到整颗二叉树遍历完毕 Coding实现12345678910111213141516171819202122/** * Definition for a binary tree node. * function TreeNode(val) &#123; * this.val = val; * this.left = this.right = null; * &#125; *//** * @param &#123;TreeNode&#125; root * @return &#123;TreeNode&#125; */var invertTree = function(root) &#123; if(root===null) return null; else &#123; let empty=root.left; root.left=root.right; root.right=empty; invertTree(root.left); invertTree(root.right); &#125; return root;&#125;;]]></content>
      <categories>
        <category>leetcode题解与算法</category>
      </categories>
      <tags>
        <tag>树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数组扁平化]]></title>
    <url>AngelLikeFairy%2F2019%2F08%2F29%2F%E6%95%B0%E7%BB%84%E6%89%81%E5%B9%B3%E5%8C%96%2F</url>
    <content type="text"><![CDATA[数组扁平化数组的扁平化，就是将一个嵌套多层的数组按照给定深度转化为原本深度减去给定深度的数组 例如： 12let arr=[1,2,[3,4]];console.log(arr.flat()); // [1,2,3,4] flat()方法概述flat() 方法会按照一个可指定的深度递归遍历数组，并将所有元素与遍历到的子数组中的元素合并为一个新数组返回。 语法 var newArray = arr.flat(depth) 参数depth(可选) 指定要提取嵌套数组的结构深度，默认值为1 返回值一个包含数组与子数组所有元素的新数组 实现数组扁平化flat()方法利用递归实现思路根据给定深度遍历，那么我们需要知道每一层数组的深度。当遍历每一层数组时，若遇到了内一层的数组，那么对该数组再执行Flat函数，也就是进行递归；若不是，则放入ans数组 代码实现12345678910111213141516171819202122function Flat(arr,num) &#123; return (function f(arr,dep)&#123; let ans=[]; arr.forEach(v=&gt;&#123; if(dep&lt;num) &#123; if(!Array.isArray(v)) &#123; ans.push(v); &#125; else &#123; ans.push(...f(v,dep+1)); &#125; &#125; else ans.push(v); &#125;) return ans; &#125;)(arr,0)&#125;console.log(Flat([1,2, ,[3,4,[5,6]],[7,8,[9,10,[11,12]]]],2))// 输出结果[ 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, [ 11, 12 ] ] 利用reduce方法实现reduce方法就是遍历原数组，将每个元素利用concat方法进行拼接。因为concat方法进行拼接时会将被拼接的数组的最外层数组去掉，只取得内部的元素 12345678910111213141516171819function Flat(arr,depth)&#123; return (function flat(arr,dep) &#123; dep++; return arr.reduce((pre,cur)=&gt;&#123; if(dep&gt;=depth) &#123; return pre.concat(cur); &#125; else &#123; return Array.isArray(cur)?pre.concat(flat(cur,dep)):pre.concat(cur); &#125; &#125;,[]) &#125;)(arr,0)&#125;console.log(Flat([1,2,[3,4,[5,6,[7,8]]]],2))// 输出结果[ 1, 2, 3, 4, 5, 6, [ 7, 8 ] ] 利用toString()方法实现使用toString()方法我目前能想到的好像只能将数组完全扁平化到一维数组，而不能根据给定深度来扁平化 12345678function Flat(arr) &#123; return arr.toString().split(',').map(value=&gt;parseInt(value));&#125;console.log(Flat([1,2,[3,4,[5,6]]]));// 输出结果[ 1, 2, 3, 4, 5, 6 ] 使用展开运算符…类似于使用reduce配合concat,但是还是离不开递归]]></content>
      <categories>
        <category>javaScript基础</category>
      </categories>
      <tags>
        <tag>基础语法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[leetcode-566 重塑矩阵]]></title>
    <url>AngelLikeFairy%2F2019%2F08%2F29%2Fleetcode-566%2F</url>
    <content type="text"><![CDATA[重塑矩阵题目描述在MATLAB中，有一个非常有用的函数 reshape，它可以将一个矩阵重塑为另一个大小不同的新矩阵，但保留其原始数据。 给出一个由二维数组表示的矩阵，以及两个正整数r和c，分别表示想要的重构的矩阵的行数和列数。 重构后的矩阵需要将原始矩阵的所有元素以相同的行遍历顺序填充。 如果具有给定参数的reshape操作是可行且合理的，则输出新的重塑矩阵；否则，输出原始矩阵。 示例 1: 输入:\nums = [[1,2], [3,4]]r = 1, c = 4输出: [[1,2,3,4]]解释:行遍历nums的结果是 [1,2,3,4]。新的矩阵是 1 * 4 矩阵, 用之前的元素值一行一行填充新矩阵。 示例 2: 输入: nums = [[1,2], [3,4]]r = 2, c = 4输出: [[1,2], [3,4]]解释:没有办法将 2 * 2 矩阵转化为 2 * 4 矩阵。 所以输出原矩阵。 注意： 给定矩阵的宽和高范围在 [1, 100]。 给定的 r 和 c 都是正数。 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/reshape-the-matrix著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 核心思路概述重塑矩阵，意思也就是将原先的nm矩阵转化为题目要求的rc矩阵；一种思路是我们在遍历数组的所有元素的时候就插入到rc新矩阵中；另一种思路是，将整个二维数组扁平化为一维数组，然后再转化为新的rc矩阵 解题步骤 将数组扁平化 转化为r*c矩阵 Coding实现1234567891011121314151617181920/** * @param &#123;number[][]&#125; nums * @param &#123;number&#125; r * @param &#123;number&#125; c * @return &#123;number[][]&#125; */var matrixReshape = function(nums, r, c) &#123; let ans=[]; let numsFlat=nums.flat(); if(r*c!==numsFlat.length) return nums; else &#123; for(let i=0;i&lt;r;i++) &#123; ans[i]=[]; for(let k=0;k&lt;c;k++) &#123; ans[i].push(numsFlat.shift()); &#125; &#125; &#125; return ans;&#125;;]]></content>
      <categories>
        <category>leetcode题解与算法</category>
      </categories>
      <tags>
        <tag>数组</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Javascript与简单正则表达式]]></title>
    <url>AngelLikeFairy%2F2019%2F08%2F28%2FJavascript%E4%B8%8E%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[正则表达式正则表达式(regular expression)描述了一种字符串匹配的模式（pattern），可以用来检查一个串是否含有某种子串、将匹配的子串替换或者从某个串中取出符合某个条件的子串等。 Js怎么支持正则表达式Es是通过RegExp类型来支持正则表达式。 怎么创建正则表达式使用正则表达式字面量语法 let pat=/pattern/flags 其中,pattern部分是正则表达式，而flags部分是标志，可以是0或多个，其中标志包括下列三种： g: 表示全局模式，即模式将被应用到所有的字符串，而非在发现第一个匹配项时就立刻停止；若没有该标志，则表示该模式时在发现第一个匹配项时就立刻停止 i: 表示不区分大小写模式，即在确定匹配项时忽略模式与字符串的大小写 m: 表示多行模式，即在到达一行文本末尾时还会继续查找下一行中是否存在于模式匹配的项 使用RegExp构造函数创建语法 let re=new RegExp(“pattern”,”flags”); 其中，pattern与flags意义同上 正则表达式的一些相关重要方法exec()方法exec()方法是专门为捕获组而设计的。exec()接受一个参数，即要应用模式的字符串，然后返回包括第一个匹配项信息的数组；或者在没有匹配的情况下返回null 例： 123let pattern=/.at/g;let str='cat pat hat';console.oog(pattern.exec(str)); // [ 'cat', index: 0, input: 'cat pat hat', groups: undefined ] test()方法test()方法接受一个字符串参数。在模式与该参数匹配的情况下返回true;否则，返回false。经常被用于if判断语句 只要在字符串中存在某字符串能够匹配正则表达式的模式，那么就会返回true 例： 123let pattern=/.at/g;let str='cat pat hat';console.log(pattern.test(str)); // true String.match()方法match() 方法检索返回一个字符串匹配正则表达式的的结果。 语法： str.match(regexp); 参数： regexp:一个正则表达式对象。如果传入的是一个非正则表达式对象，则会隐式地使用new RegExp(obj)将其转化为一个正则表达式对象。如果没有给定任何参数，那么则会返回一个空数组 返回值： 如果使用g标志，那么则返回所有与正则表达式匹配的结果(Array)，但不会返回捕获组；或者没有匹配项返回null 如果不使用g标志，那么则返回第一个完整匹配及相关的捕获组。 例： 123let pattern=/.at/g;let str='cat pat hat';console.log(str.match(pattern)); // ['cat','pat','hat'] 元字符元字符是正则表达式的基本组成元素。 具体元字符如下： 元字符 描述 . 匹配除了换行符以外的任意字符 [] 匹配方括号中的任意一个字符,可以使用连字符’-‘来表示范围，例如 [a,b,c]可以表示为[a-c] [^] 上一个的反状态，即匹配除了括号内的任意一个字符 {n,m} 匹配前面的字符[n,m]次，即至少n次，但是不超过m次 (xyz) 相当于四则运算中常用的小括号，解释为按照确切的顺序来匹配字符xyz | 分支结构，匹配符号之前的字符或后面的字符 \ 转义符，它可以还原元字符原来的含义，允许你匹配保留元字符 * 匹配前面的子表达式0次或多次 + 匹配前面的子表达式一次或多次 ? 匹配前面的子表达式0次或一次，或指定一个非贪婪限定符 ^ 匹配行的开始 $ 匹配行的结束 \d 表示[0-9]，即1位数字 \D 表示除数字外的任意字符 \w 表示[0-9a-zA-z_]，即数字、大小写字母或下划线 \W 表示非单词字符，\w的对立 \s 表示空白符，包括空格、水平制表符、垂直制表符、换行符、回车符、换页符 \S 非空白符 如果想要匹配任意字符，根据以上元字符可以使用 \d|\D 或 [\d\D] \w|\W 或 [\w\W] \s|\S 或 [\s\S] [^] 元字符详解与例子元字符 .元字符.可以用来匹配除了换行符之外的所有单个字符 123let pattern=/.at/g;let str='cat pat hat';console.log(str.match(pattern)); // ['cat','pat','hat'] 元字符 []元字符 []用来匹配方括号内的任意一个字符 123let pattern=/[cph]at/g;let str='cat pat hat';console.log(str.match(pattern)); // ['cat','pat','hat'] 元字符 [^]元字符 [^]用来匹配除了方括号内字符的任意一个字符 123let pattern=/[^cph]at/g;let str='cat pat hat';console.log(str.match(pattern)); // null 元字符 {n,m}元字符 {n,m}用来匹配该元字符的前一个字符[n,m]次（即至少n次但不超过m次） 123let pattern=/.a&#123;1,2&#125;t/g;let str='cat paat haaat';console.log(str.match(pattern)); // ['cat','paat','aaat'] 元字符 (xyz)元字符 (xyz)我觉得其实相当于四则运算中的小括号，先执行小括号内的部分 123let pattern=/.(a|b|c)t/g;let str='cat pbt hct';console.log(str.match(pattern)); // ['cat','pbt','hct'] 元字符 |元字符 | 用来定义分支结构，分支结构就是相当于或运算。即要么执行元字符之前的字符要么执行之后的字符或者都不； 注意： 该元字符类似于或运算具有短路操作 123let pattern=/.(a|b|c)t/g;let str='cat pbt hct';console.log(str.match(pattern)); // ['cat','pbt','hct'] 1234567let pattern=/good|goodbye/g;let str='good goodbye';console.log(str.match(pattern)); // ['good','good']// 元字符 | 类似或运算具有短路操作，当前面的字符成立时就不会执行元字符之后的字符。// 上面的代码中，str字符串中的第一个'good'字符串满足正则表达式模式中的'good'，而后一个'goodbye'字符串虽然也满足'goodbye'，但是它先满足元字符之前的字符'good'，因此该运算被短路了，所以只返回了'good' 123let pattern=/goodbye|good/g;let str='good goodbye';console.log(str.match(pattern)); // ['good','goodbye'] 元字符 \元字符 \用来转义它的下一个字符。这将允许你使用保留字符来作为匹配元字符 123let pattern=/.at\./g;let str='cat\ pat/ hat.';console.log(str.match(pattern)); // ['hat.'] 元字符 *元字符 *用来匹配上一个匹配规则的0次或多次 123let pattern=/zk*/g;let str='zk z zkkk';console.log(str.match(pattern)); // [ 'zk', 'z', 'zkkk' ] 元字符 +元字符 +用来匹配上一个字符的一次或多次 123let pattern=/zk+/g;let str='zk z zkkk';console.log(str.match(pattern)); // [ 'zk','zkkk' ] 元字符 ?元字符 ?用来匹配前一个字符的0次或一次 123let pattern=/zk?/g;let str='zk z zkkk';console.log(str.match(pattern)); // [ 'zk','z','zk' ] 元字符 ^元字符 ^用来检查匹配字符是否是输入字符串的第一个字符 123let pattern=/(T|t)he/g;let str='The the';console.log(str.match(pattern)); // ['The','the'] 123let pattern=/^(T|t)he/g;let str='The the';console.log(str.match(pattern)); // ['The'] 元字符 $元字符 $用来检查匹配字符是否是输入字符串的最后一个字符 123let pattern=/.he/g;let str='The the';console.log(str.match(pattern)); // ['The','the'] 123let pattern=/.he$/g;let str='The the';console.log(str.match(pattern)); // ['the']]]></content>
      <categories>
        <category>javaScript基础</category>
      </categories>
      <tags>
        <tag>正则表达式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[leetcode-190 颠倒二进制位]]></title>
    <url>AngelLikeFairy%2F2019%2F08%2F28%2Fleetcode-190%2F</url>
    <content type="text"><![CDATA[颠倒二进制位题目描述颠倒给定的 32 位无符号整数的二进制位。 示例 1： 输入: 00000010100101000001111010011100输出: 00111001011110000010100101000000解释: 输入的二进制串 00000010100101000001111010011100 表示无符号整数 43261596， 因此返回 964176192，其二进制表示形式为 00111001011110000010100101000000。 示例 2： 输入：11111111111111111111111111111101输出：10111111111111111111111111111111解释：输入的二进制串 11111111111111111111111111111101 表示无符号整数 4294967293， 因此返回 3221225471 其二进制表示形式为 10101111110010110010011101101001。 提示： 请注意，在某些语言（如 Java）中，没有无符号整数类型。在这种情况下，输入和输出都将被指定为有符号整数类型，并且不应影响您的实现，因为无论整数是有符号的还是无符号的，其内部的二进制表示形式都是相同的。 在 Java 中，编译器使用二进制补码记法来表示有符号整数。因此，在上面的 示例 2 中，输入表示有符号整数 -3，输出表示有符号整数 -1073741825。 进阶:如果多次调用这个函数，你将如何优化你的算法？ 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/reverse-bits著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 核心思路概述输入的会是一个无符号整数可以转化为32位二进制表示；要求输出的是反转该32位二进制并转化为整数输出 解题步骤 利用模二取余法得到32位二进制数 将32位二进制数反转后转化为整数并返回 Coding实现1234567891011121314151617/** * @param &#123;number&#125; n - a positive integer * @return &#123;number&#125; - a positive integer */var reverseBits = function(n) &#123; let s=[]; while(n) &#123; s.unshift(n%2); n=Math.floor(n/2); &#125; while(s.length&lt;32) &#123; s.unshift(0); &#125; return s.reduce((pre,cur,curIndex)=&gt;&#123; return pre+cur*Math.pow(2,curIndex); &#125;,0)&#125;;]]></content>
      <categories>
        <category>leetcode题解与算法</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[全局变量的声明以及如何避免声明全局变量]]></title>
    <url>AngelLikeFairy%2F2019%2F08%2F27%2F%E5%85%A8%E5%B1%80%E5%8F%98%E9%87%8F%E7%9A%84%E5%A3%B0%E6%98%8E%E4%BB%A5%E5%8F%8A%E5%A6%82%E4%BD%95%E9%81%BF%E5%85%8D%E5%A3%B0%E6%98%8E%E5%85%A8%E5%B1%80%E5%8F%98%E9%87%8F%2F</url>
    <content type="text"><![CDATA[全局变量的声明 全局变量会成为全局对象的属性 哪种方式的变量声明会形成全局变量呢？ Javascript运行环境分为浏览器环境和非浏览器环境（比如Node.js） 在浏览器环境中,有三种方式可以声明全局变量 使用var关键字在全局作用域下显示声明 不使用任何声明关键字(var,let,const)直接给变量赋值，这属于隐式声明 使用全局对象作为其属性来声明 浏览器环境中（全局对象为window对象） 123456a=1;var b=2;window.c=3;console.log(a===window.a); // trueconsole.log(b===window.b); // trueconsole.log(c); // 3 但是，在Node.js中，上述方法中的方法1就不成立 Node.js环境（全局对象为global对象) 123456a=1;var b=2;global.c=3;console.log(a===global.a); // trueconsole.log(b===global.b); // falseconsole.log(c===global.c); // 3 如何避免声明全局变量使用let与const声明关键字 如果你在全局作用域中使用let或const来声明变量，那么会在全局作用域下创建一个新的绑定，但该绑定不会添加为全局对象的属性。 换句话说，用let或const不能覆盖全局变量，而只能遮蔽它 浏览器环境中 12345678910window.a=1;var a=2;console.log(a); // 2 全局对象的属性a被var声明修改了console.log(a===window.a); // truewindow.b=1;let b=2;console.log(b); // 2console.log(b===window.b); // false// b不是全局变量，因为使用let声明的b没有成为全局对象的属性 总结如果不想为全局变量创建属性或修改全局变量的属性，那么使用let和const要安全的多]]></content>
      <categories>
        <category>javaScript基础</category>
      </categories>
      <tags>
        <tag>基础语法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Js中的字符与Unicode编码操作]]></title>
    <url>AngelLikeFairy%2F2019%2F08%2F27%2FJs%E4%B8%AD%E7%9A%84%E5%AD%97%E7%AC%A6%E4%B8%8EUnicode%E7%BC%96%E7%A0%81%E6%93%8D%E4%BD%9C%2F</url>
    <content type="text"><![CDATA[字符转化为Unicode编码charAt()概述charAt() 方法从一个字符串中返回指定的字符。 语法 str.charAt(index) 参数： index: 一个介于0和字符转长度减1之间的整数。即0~str.length-1。如果没有提供索引值，那么index默认为0，即第一位 返回值： 返回值是一个根据给定索引的指定字符；如果，给定值超过了上述的要求范围（0~str.length-1），那么该方法返回一个空字符串 例子12345let str='abc'console.log(str.charAt()); // 'a'console.log(str.charAt(1)); // 'b'console.log(str.charAt(2)); // 'c'console.log(str.charAt(7)); // '' charCodeAt()概述charCodeAt()方法 返回给定索引处（String中index索引处）字符的 UTF-16 代码单元值的数字 语法 str.charCodeAt(index) 参数 index:一个大于等于0，小于字符串长度的整数。如果不是一个数值，则默认为0 返回值 返回值是一表示给定索引处（String中index索引处）字符的 UTF-16 代码单元值的数字；如果索引超出范围，则返回 NaN。 例子123456let str1='a';console.log(str1.charCodeAt()); // 97let str2='abc';console.log(str2.charCodeAt(0)); // 97console.log(str2.charCodeAt(1)); // 98console.log(str2.charCodeAt(7)); // NaN Unicode编码转化为字符String.fromCharCode()概述静态 String.fromCharCode() 方法返回由指定的UTF-16代码单元序列创建的字符串。 语法 String.fromCharCode(num1, …, numN) 参数 num1, …, numN一系列UTF-16代码单元的数字。 范围介于0到65535（0xFFFF）之间。 大于0xFFFF的数字将被截断。 不进行有效性检查。 返回值 一个长度为N的字符串，由N个指定的UTF-16代码单元组成；如果不给定参数，那么则返回空字符串 例子123console.log(String.fromCharCode(97)); 'a'console.log(String.fromCharCode(97,98,99)) // 'abc'console.log(String.fromCharCode()); // '']]></content>
      <categories>
        <category>javaScript基础</category>
      </categories>
      <tags>
        <tag>基础语法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[leetcode-168 Excel表列名称]]></title>
    <url>AngelLikeFairy%2F2019%2F08%2F27%2Fleetcode-168%2F</url>
    <content type="text"><![CDATA[Excel表列名称题目描述给定一个正整数，返回它在 Excel 表中相对应的列名称。 例如， 1 -&gt; A 2 -&gt; B 3 -&gt; C ... 26 -&gt; Z 27 -&gt; AA 28 -&gt; AB ...示例 1: 输入: 1输出: “A” 示例 2: 输入: 28输出: “AB” 示例 3: 输入: 701输出: “ZY” 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/excel-sheet-column-title著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 核心思路概述题目要求的是1~26对应的是A~Z，然而如果使用进制来表示的话，我们一般习惯使用0开始的。因此，我们可以用0~25来表示A~Z；这样，我们之后在利用类似二进制中的模二取余法时就可以避免遇到余数0没有对应值的问题。 那么，对于输入值，每次取余时我们就应该讲值减去一之后再进行取余。这样就可以将0~25对应到输入值 解题步骤 建立哈希表，将025作为键，对应到AZ的键值 使用类似二进制的模二取余法，将给定值取余；每次取余先将值减一；取得的余数放入unshift入队列数组中 遍历队列数组，从哈希表中取出对应的键值，添加到字符串ans中 返回ans Coding实现123456789101112131415161718192021/** * @param &#123;number&#125; n * @return &#123;string&#125; */var convertToTitle = function(n) &#123; let map=new Map(); let queue=[]; let ans=''; for(let i=0;i&lt;26;i++) &#123; map.set(i,String.fromCharCode(65+i)); &#125; while(n) &#123; n--; queue.unshift(n%26); n=Math.floor(n/26); &#125; queue.forEach(value=&gt;&#123; ans+=map.get(value); &#125;) return ans;&#125;;]]></content>
      <categories>
        <category>leetcode题解与算法</category>
      </categories>
      <tags>
        <tag>哈希表</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[leetcode-811 子域名访问计数]]></title>
    <url>AngelLikeFairy%2F2019%2F08%2F26%2Fleetcode-811%2F</url>
    <content type="text"><![CDATA[子域名访问计数题目描述一个网站域名，如”discuss.leetcode.com”，包含了多个子域名。作为顶级域名，常用的有”com”，下一级则有”leetcode.com”，最低的一级为”discuss.leetcode.com”。当我们访问域名”discuss.leetcode.com”时，也同时访问了其父域名”leetcode.com”以及顶级域名 “com”。 给定一个带访问次数和域名的组合，要求分别计算每个域名被访问的次数。其格式为访问次数+空格+地址，例如：”9001 discuss.leetcode.com”。 接下来会给出一组访问次数和域名组合的列表cpdomains 。要求解析出所有域名的访问次数，输出格式和输入格式相同，不限定先后顺序。 示例 1: 输入: [“9001 discuss.leetcode.com”]输出: [“9001 discuss.leetcode.com”, “9001 leetcode.com”, “9001 com”]说明: 例子中仅包含一个网站域名：”discuss.leetcode.com”。按照前文假设，子域名”leetcode.com”和”com”都会被访问，所以它们都被访问了9001次。 示例 2 输入: [“900 google.mail.com”, “50 yahoo.com”, “1 intel.mail.com”, “5 wiki.org”]输出: [“901 mail.com”,”50 yahoo.com”,”900 google.mail.com”,”5 wiki.org”,”5 org”,”1 intel.mail.com”,”951 com”]说明: 按照假设，会访问”google.mail.com” 900次，”yahoo.com” 50次，”intel.mail.com” 1次，”wiki.org” 5次。而对于父域名，会访问”mail.com” 900+1 = 901次，”com” 900 + 50 + 1 = 951次，和 “org” 5 次。 注意事项： cpdomains 的长度小于 100。 每个域名的长度小于100。 每个域名地址包含一个或两个”.”符号。 输入中任意一个域名的访问次数都小于10000。 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/subdomain-visit-count著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 核心思路概述题目给定包含一系列域名和访问次数的字符串数组。对于每个域名字符串，我们可以从后往前遍历该字符串，当遇到’.’或者到达最前端时，将’.’之后部分或全部字符串放入哈希表中并存放次数；当遇到，哈希表中已经存在该键时，则更新该键值 解题步骤 建立哈希表以及ans数组 遍历字符串数组，取当前字符串赋为s 将s分为次数count和域名domains两部分 遍历domains字符串。当遇到’.’或者到达最前端时，将’.’之后部分或全部字符串放入哈希表中并存放次数；当遇到，哈希表中已经存在该键时，则更新该键值 重复3、4直到字符串数组遍历完毕 遍历哈希表，将键值和键名合成字符串放入ans数组中 返回ans Coding实现1234567891011121314151617181920212223242526272829303132333435/** * @param &#123;string[]&#125; cpdomains * @return &#123;string[]&#125; */var subdomainVisits = function(cpdomains) &#123; if(cpdomains.length===0) return []; let map=new Map(); let ans=[]; for(let i=0;i&lt;cpdomains.length;i++) &#123; let s=cpdomains[i]; let count=s.split(' ')[0]; let domains=s.split(' ')[1]; let k=domains.length-1; while(k&gt;=0) &#123; if(domains[k]==='.'||k===0) &#123; let domain; if(k===0) &#123; domain=domains.slice(k); &#125; else domain=domains.slice(k+1); if(!map.has(domain)) &#123; map.set(domain,parseInt(count)); &#125; else &#123; map.set(domain,map.get(domain)+parseInt(count)); &#125; &#125; k--; &#125; &#125; map.forEach((value,key)=&gt;&#123; ans.push(value+' '+key); &#125;) return ans;&#125;;]]></content>
      <categories>
        <category>leetcode题解与算法</category>
      </categories>
      <tags>
        <tag>哈希表</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[leetcode-160 相交链表]]></title>
    <url>AngelLikeFairy%2F2019%2F08%2F25%2Fleetcode-160%2F</url>
    <content type="text"><![CDATA[相交链表题目描述编写一个程序，找到两个单链表相交的起始节点。 如下面的两个链表： 在节点 c1 开始相交。 示例 1： 输入：intersectVal = 8, listA = [4,1,8,4,5], listB = [5,0,1,8,4,5], skipA = 2, skipB = 3输出：Reference of the node with value = 8输入解释：相交节点的值为 8 （注意，如果两个列表相交则不能为 0）。从各自的表头开始算起，链表 A 为 [4,1,8,4,5]，链表 B 为 [5,0,1,8,4,5]。在 A 中，相交节点前有 2 个节点；在 B 中，相交节点前有 3 个节点。 示例 2： 输入：intersectVal = 2, listA = [0,9,1,2,4], listB = [3,2,4], skipA = 3, skipB = 1输出：Reference of the node with value = 2输入解释：相交节点的值为 2 （注意，如果两个列表相交则不能为 0）。从各自的表头开始算起，链表 A 为 [0,9,1,2,4]，链表 B 为 [3,2,4]。在 A 中，相交节点前有 3 个节点；在 B 中，相交节点前有 1 个节点。 示例 3： 输入：intersectVal = 0, listA = [2,6,4], listB = [1,5], skipA = 3, skipB = 2输出：null输入解释：从各自的表头开始算起，链表 A 为 [2,6,4]，链表 B 为 [1,5]。由于这两个链表不相交，所以 intersectVal 必须为 0，而 skipA 和 skipB 可以是任意值。解释：这两个链表不相交，因此返回 null。 注意： 如果两个链表没有交点，返回 null. 在返回结果后，两个链表仍须保持原有的结构。 可假定整个链表结构中没有循环。 程序尽量满足 O(n) 时间复杂度，且仅用 O(1) 内存。 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/intersection-of-two-linked-lists著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 核心思路因为题目要求使用O(1)内存，那么显然就不能使用多余的数组。并且程序尽量满足O(n)时间复杂度。因此，解法有二： 哈希表法 哈希表的内存占用为O(1)，遍历第一条链表，将链表内的所有节点存入哈希表中。再遍历第二条链表，如果遇到某节点存在于哈希表中，那么就将结果返回 双指针 创建两个指针 pA 和 pB，分别初始化为链表 A 和 B 的头结点。然后让它们向后逐结点遍历。当 pA 到达链表的尾部时，将它重定位到链表 B 的头结点 (你没看错，就是链表 B); 类似的，当 pB 到达链表的尾部时，将它重定位到链表 A 的头结点。若在某一时刻 pApA 和 pBpB 相遇，则 pApA/pBpB 为相交结点。（原因如下，若两链表相交，那么相交部分加上两链表之前未相交部分的和是一定的。那么若能相交，这样子移动指针必能相遇） 解题步骤coding实现哈希表法 123456789101112131415161718192021222324252627/** * Definition for singly-linked list. * function ListNode(val) &#123; * this.val = val; * this.next = null; * &#125; *//** * @param &#123;ListNode&#125; headA * @param &#123;ListNode&#125; headB * @return &#123;ListNode&#125; */var getIntersectionNode = function(headA, headB) &#123; let map=new Map(); let cur=headA; while(cur) &#123; map.set(cur,1); cur=cur.next; &#125; cur=headB; while(cur) &#123; if(map.has(cur)) return cur; cur=cur.next; &#125; return null;&#125;; 双指针法 123456789101112131415161718192021222324252627282930313233343536/** * Definition for singly-linked list. * function ListNode(val) &#123; * this.val = val; * this.next = null; * &#125; *//** * @param &#123;ListNode&#125; headA * @param &#123;ListNode&#125; headB * @return &#123;ListNode&#125; */var getIntersectionNode = function(headA, headB) &#123; let top=headA; let down=headB; let bool=false; while(top&amp;&amp;down) &#123; if(top===down) return top; if(top.next===null) &#123; top=headB; bool=!bool; if(bool===false) return null; &#125; else &#123; top=top.next; &#125; if(down.next===null) &#123; down=headA; &#125; else &#123; down=down.next; &#125; &#125; return null;&#125;;]]></content>
      <categories>
        <category>leetcode题解与算法</category>
      </categories>
      <tags>
        <tag>链表</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[leetcode-268 缺失数字]]></title>
    <url>AngelLikeFairy%2F2019%2F08%2F24%2Fleetcode-268%2F</url>
    <content type="text"><![CDATA[缺失数字题目描述给定一个包含 0, 1, 2, …, n 中 n 个数的序列，找出 0 .. n 中没有出现在序列中的那个数。 示例 1: 输入: [3,0,1]输出: 2 示例 2: 输入: [9,6,4,2,3,5,7,0,1]输出: 8 说明:你的算法应具有线性时间复杂度。你能否仅使用额外常数空间来实现? 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/missing-number著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 核心思路概述 第一种方法是将数组排序后再遍历，如果某个数与下标不相同的话，那么那个下标就是缺失的数 第二种方法是利用哈希表，在第一次遍历数组时将值记录在哈希表中。然后从0遍历到n，查看每个数是否在哈希表中，若无，则是缺失的数 第三种方法，是将0~n的和减去数组的和就是缺失的数 第四种方法，利用位运算（待补充） 解题步骤步骤易懂，直接贴代码 Coding实现第一种方法：排序遍历 12345678910/** * @param &#123;number[]&#125; nums * @return &#123;number&#125; */var missingNumber = function(nums) &#123; nums.sort((a,b)=&gt;a-b); for(let i=0;i&lt;=nums.length;i++) &#123; if(i!==nums[i]) return i; &#125;&#125;; 第二种方法：哈希表存值 12345678910111213/** * @param &#123;number[]&#125; nums * @return &#123;number&#125; */var missingNumber = function(nums) &#123; let map=new Map(); for(let i=0;i&lt;nums.length;i++) &#123; map.set(nums[i],1); &#125; for(let i=0;i&lt;=nums.length;i++) &#123; if(!map.has(i)) return i; &#125; &#125;; 第三种方法：数组求和 12345678910/** * @param &#123;number[]&#125; nums * @return &#123;number&#125; */var missingNumber = function(nums) &#123; let sum=nums.reduce((pre,value)=&gt;&#123; return pre+value; &#125;,0) return ((0+nums.length)*(nums.length+1)/2)-sum;&#125;; 第四种方法：位运算 12]]></content>
      <categories>
        <category>leetcode题解与算法</category>
      </categories>
      <tags>
        <tag>数组</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[leetcode-121 买卖股票的最佳时机]]></title>
    <url>AngelLikeFairy%2F2019%2F08%2F23%2Fleetcode-121%2F</url>
    <content type="text"><![CDATA[买卖股票的最佳时机题目描述给定一个数组，它的第 i 个元素是一支给定股票第 i 天的价格。 如果你最多只允许完成一笔交易（即买入和卖出一支股票），设计一个算法来计算你所能获取的最大利润。 注意你不能在买入股票前卖出股票。 示例 1: 输入: [7,1,5,3,6,4]输出: 5解释: 在第 2 天（股票价格 = 1）的时候买入，在第 5 天（股票价格 = 6）的时候卖出，最大利润 = 6-1 = 5 。注意利润不能是 7-1 = 6, 因为卖出价格需要大于买入价格。 示例 2: 输入: [7,6,4,3,1]输出: 0解释: 在这种情况下, 没有交易完成, 所以最大利润为 0。 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 核心思路如果使用暴力解法，对每一天作为买入天进行遍历，再遍历每一天的后面的几天，找到差值最大的天数，这样就会有O(n^2)的时间复杂度。那么，一次遍历可以解决吗？ 当然，我们换一种思路，加入第一次遍历不把它当做买入天，而是当做卖出天。那么，我们只要找到当前天之前的那几天中价格最小的即可。而这最小价格，我们可以设定一个min，在遍历中不断改变。 解题步骤 设定min为第一天价格，最大差值max=0 从第二天开始遍历，因为卖出天需要在买入天之后，如果当前天的股票价格大于min，那么求得差价与max比较，赋予max较大值；若小于min，那么将当日股票价格赋予min 循环结束，返回max coding实现123456789101112131415/** * @param &#123;number[]&#125; prices * @return &#123;number&#125; */var maxProfit = function(prices) &#123; let min=prices[0]; let max=0; for(let i=1;i&lt;prices.length;i++)&#123; if(prices[i]&gt;min) &#123; max=max&gt;prices[i]-min?max:prices[i]-min; &#125; else min=prices[i]; &#125; return max;&#125;;]]></content>
      <categories>
        <category>leetcode题解与算法</category>
      </categories>
      <tags>
        <tag>数组</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[leetcode-119]]></title>
    <url>AngelLikeFairy%2F2019%2F08%2F22%2Fleetcode-119%2F</url>
    <content type="text"><![CDATA[题目类似与leetcode-118 杨辉三角 不解释，直接上代码 123456789101112131415/** * @param &#123;number&#125; rowIndex * @return &#123;number[]&#125; */var getRow = function(rowIndex) &#123; let arr=[[1]]; for(let i=1;i&lt;=rowIndex;i++) &#123; arr[i]=[]; arr[i][0]=arr[i][i]=1; for(let k=1;k&lt;i;k++) &#123; arr[i][k]=arr[i-1][k-1]+arr[i-1][k]; &#125; &#125; return arr[rowIndex];&#125;;]]></content>
      <categories>
        <category>leetcode题解与算法</category>
      </categories>
      <tags>
        <tag>数组</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[闭包]]></title>
    <url>AngelLikeFairy%2F2019%2F08%2F22%2F%E9%97%AD%E5%8C%85%2F</url>
    <content type="text"><![CDATA[什么是闭包闭包，实际上也是个函数，只不过他的外部被另外一个函数包围。因此，在一个函数内部创建另一个函数，就会产生闭包。 红宝书是这么定义的： 闭包是指有权访问另一个函数作用域中的变量的函数 那么这段话又该如何理解？ 执行环境分为全局执行环境和局部执行环境。全局执行环境永远存在于某条作用域链的最末端。那么，局部执行环境呢？当进入某个函数时，该函数的局部执行环境就会被压入环境栈，同时会生成一个存储当前环境所有变量、函数的活动对象。 因此，在一个函数中创建了另外一个函数，那么内部那个函数的作用域链上就包含了外部函数的活动对象，而该活动对象又具有其作用域中的所有的变量 来看一个例子： 12345678function test()&#123; let a=1; return function ()&#123; console.log(a); &#125;&#125;test()(); // 1console.log(a); // ReferenceError: a is not defined 我们首先在全局作用域下创建了一个test函数，在当前作用域中定义了a变量为1；然后在内部定义了一个新的匿名函数并返回； 从输出上，我们很容易就能验证闭包的特性。闭包的作用域链包含着自己的作用域，以及外部函数的作用域直到全局作用域 定时器与闭包我们经常可以看到这样的例子 123456for(var i=0;i&lt;10;i++)&#123; setTimeout(function ()&#123; console.log(i); // 10个10 后输出 &#125;,1000)&#125;console.log('i',i); // i 10 先输出 初学者们一般都会以为会按照0~9的顺序依次输出，然而并不是，它会打印出10个10. 那么，这又是为什么呢？ 定时器的作用是当定时器到期时，会执行传入定时器的函数； 我们往该函数中传入了一个新的匿名函数去打印i；那么对于该段代码，定时器中的匿名函数会在全局作用中被执行。因袭该匿名函数的作用域链会是其自身的作用域以及全局作用域 我们需要注意的是，在定时器开始启动之前，这10次循环已经结束了，相当于已经创建了10个还未执行的定时器，于此同时i已经变为了10 在执行定时器时，也就是每1000毫秒要去执行一次匿名函数。匿名函数就会顺着作用域去寻找i，那么，显然它会在全局作用域中找到i为10，所以也就会输出10个10了 那么如果我们顺着作用域链查找的思路稍微修改一下代码 1234567for(var i=0;i&lt;10;i++)&#123; setTimeout(function ()&#123; i=1; console.log(i); // 10个1 后输出 &#125;,1000)&#125;console.log('i',i); // i 10 先输出 显然，查找作用域链时在自身作用域中就找到了i，因此不会再向上查找位于全局作用域的i 定时器函数的优化我们已经发现了以上那个函数并不能达到想要的效果。本质上是因为作用域链的缘故。 那么使用es6的let就可以解决这个问题 let会将当前变量的作用域限制在当前代码块内，因此，上面的10次循环就会形成10个作用域，每一个函数都能够查找到正确的i 12345678910111213for(let i=0;i&lt;10;i++)&#123; setTimeout(function ()&#123; console.log(i); // 0~9 &#125;,1000)&#125;// 执行以上代码会是如下情形&#123;i=0;setTimeout();&#125;...&#123;i=9;setTimeout();&#125; 如果，此时在全局作用域下去执行console.log(i)；会报出错误i为定义。因为，全局作用下并没有定义i 闭包的应用私有变量闭包的主要应用是设计私有变量 任何在函数中定义的变量，都可以被认为是私有变量，因为不能在函数外部访问这些变量。 私有变量包括函数的参数，局部变量和在函数内部定义的其他函数 然而，闭包可以通过自身的作用域链访问到这些私有变量。因此我们经常利用闭包来创建用于访问私有变量的共有方法，又被称之为特权方法。 例如： 1234567891011121314function Person(name) &#123; // 私有变量 let rigion='Hang Zhou' // 特权方法 this.get=function ()&#123; return rigion; &#125;&#125;let ming=new Person('ming');console.log(ming); // Person &#123; get: [Function] &#125;console.log(ming.get()); // Hang Zhouconsoel.log(ming.rigion); // undefined 这个Person构造函数不同于一般的构造函数，一般的构造函数会像下例一样声明属性与方法 12345678910function Person(name) &#123; // 公有属性 this.rigion='Hang Zhou'&#125;let ming=new Person('ming');console.log(ming.rigion); // 'Hang Zhou'ming.rigion='Shang Hai';console.log(ming.rigion); // 'Shang Hai'// 此时rigion属性是公有属性，实例化之后可以直接访问和修改 而该构造函数创建的实例并不会直接添加私有变量到实例的属性上，而是需要通过get()方法去访问。此时get()方法是一个闭包，其作用链上拥有外部构造函数的作用域，因此可以访问到私有变量 模块模式模块模式是用来为单例创建私有变量和特权方法的。所谓单例，指的就是只有一个实例的对象 12345678910111213141516function Person()&#123; // 私有变量和私有函数 let rigion='Hang Zhou'; let get=function ()&#123; return rigion; &#125; // 特权方法和属性 return &#123; get:get &#125;&#125;let ming=new Person();console.log(ming); // &#123; get: [Function: get] &#125;console.log(ming.get()); // 'Hang Zhou' 闭包的缺陷一般来说，一个函数执行完毕后，会销毁其作用域及其变量对象；但是，在创建了一个闭包以后，这个函数的的作用域会一直保存到闭包不存在（手动令这个闭包函数为null）为止。 在javascript中，如果一个对象不再被引用，那么这个对象就会被垃圾回收机制回收； 如果两个对象互相引用，而不再被第3者所引用，那么这两个互相引用的对象也会被回收。有些闭包可能会被返回到全局作用域被执行 因此，闭包会携带包含它的函数的作用域，从而会占用比其他函数更多的内存。过得使用闭包会导致内存占用过多。]]></content>
      <categories>
        <category>javaScript基础</category>
      </categories>
      <tags>
        <tag>基础语法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[滑动窗口]]></title>
    <url>AngelLikeFairy%2F2019%2F08%2F21%2F%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%2F</url>
    <content type="text"><![CDATA[什么是滑动窗口算法滑动窗口可以看做是一个区间。但是，这个区间是可以动态变化的。可以左右移动，也可以变大或变小 例如，假如有一个字符串为’abcabcbb’，那么对于大小为5的滑动窗口在该字符串上滑动，则有 1234abcab bcabc cabcb abcbb 滑动窗口，在我理解看来无非是一种用来大幅降低时间复杂度的算法。在某一个字符串或者一个数组中，要找到某个子字符串或者子数组来满足某些条件，那么利用滑动窗口便可以将时间复杂度降低到O(n) 用什么来实现滑动窗口leetcode题目引入题目引入：leetcode-3 无重复字符的最长子串给定一个字符串，请你找出其中不含有重复字符的 最长子串 的长度。 示例 1:输入: “abcabcbb”输出: 3 解释: 因为无重复字符的最长子串是 “abc”，所以其长度为 3。 示例 2:输入: “bbbbb”输出: 1解释: 因为无重复字符的最长子串是 “b”，所以其长度为 1。 示例 3:输入: “pwwkew”输出: 3解释: 因为无重复字符的最长子串是 “wke”，所以其长度为 3。 请注意，你的答案必须是 子串 的长度，”pwke” 是一个子序列，不是子串。 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/longest-substring-without-repeating-characters著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 解决思路如果使用常规的暴力解法。因为要找到一个字符串没有任何重复字符且是最长的。那么，很容易想到，找到以该字符串的每个字符为开头的最长无重复字符的字符串，然后比较那个字符串更长返回即可。思路很简单，但是，稍加考虑就会发现这样的时间复杂度会达到O(n^2)，很可能无法通过题目要求的时间限制 那么，滑动窗口呢。照着暴力解法的思路，在外循环遍历每一个字符时，如果遇到了与子串中已经重复的字符那么就会停止内循环遍历下去（因为这会是以当前字符为开头的最长子串）。按照暴力的思路，接下来我们会以外循环中的下一个字符来开始内循环。那么，我们很容易就会发现一个问题，倘若那个重复字符并不是外循环中立即接下去的那一个呢，那么遇到那个重复字符，我们依然要停下来。因此，我们可以直接滑动窗口到那个重复字符的后一位，再接着遍历后面的字符 队列来实现滑动窗口我们很容易可以想到利用队列来实现滑动窗口，当该窗口向右移动时，左边不需要的元素只要shift()移除队列即可 对于上题的队列实现滑动窗口解法 1234567891011121314151617181920/** * @param &#123;string&#125; s * @return &#123;number&#125; */var lengthOfLongestSubstring = function(s) &#123; if(s.length===0) return s.length; let maxLength=0; let queue=[]; for(let v of s)&#123; if(queue.includes(v)) &#123; while(queue[0]!==v) &#123; queue.shift() &#125; queue.shift(); &#125; queue.push(v); maxLength=queue.length&gt;maxLength?queue.length:maxLength; &#125; return maxLength;&#125;; 双指针来实现滑动窗口滑动窗口不过就是个动态的区间，那么使用双指针来表示区间也是不错的选择。而且对于队列滑动只能一格一格滑动，而双指针可以直接滑动多格 使用双指针来实现核心就是，要找到该次滑动的终点位置 123456789101112131415161718192021/** * @param &#123;string&#125; s * @return &#123;number&#125; */var lengthOfLongestSubstring = function(s) &#123; if(s.length===0) return s.length; let maxLength=0; let left=0; let right=0; let arr=[]; for(let v of s) &#123; if(arr.includes(v)) &#123; let index=s.indexOf(v,left); left=index+1; &#125; right++; arr=s.slice(left,right); maxLength=arr.length&gt;maxLength?arr.length:maxLength; &#125; return maxLength;&#125;; 双指针实现的优化：利用哈希表map来使字符搜索时间复杂度降至为O(1)上面的解法中，找到重复字符的位置，利用了indexOf()函数，实际上该函数的时间复杂度为O(n)，但是，如果在遍历的同时将字符下标不断更新的话，那么查找起来时间复杂度就会变为O(1) 这也是常用的以空间换时间的策略 1234567891011121314151617181920212223/** * @param &#123;string&#125; s * @return &#123;number&#125; */var lengthOfLongestSubstring = function(s) &#123; if(s.length===0) return s.length; let maxLength=0; let left=0; let right=0; let arr=[]; let map=new Map(); for(let i=0;i&lt;s.length;i++) &#123; if(arr.includes(s[i])) &#123; let index=map.get(s[i]); left=index+1; &#125; map.set(s[i],i) right++; arr=s.slice(left,right); maxLength=arr.length&gt;maxLength?arr.length:maxLength; &#125; return maxLength;&#125;; 当然，对于队列也可以像这样进行优化]]></content>
      <categories>
        <category>算法笔记</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[leetcode-112 路径总和]]></title>
    <url>AngelLikeFairy%2F2019%2F08%2F21%2Fleetcode-112%2F</url>
    <content type="text"><![CDATA[路径总和题目描述给定一个二叉树和一个目标和，判断该树中是否存在根节点到叶子节点的路径，这条路径上所有节点值相加等于目标和。 说明: 叶子节点是指没有子节点的节点。 示例:给定如下二叉树，以及目标和 sum = 22， 5 / \ 4 8 / / \ 11 13 4 / \ \ 7 2 1返回 true, 因为存在目标和为 22 的根节点到叶子节点的路径 5-&gt;4-&gt;11-&gt;2。 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/path-sum著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 核心思路概述求根节点到叶子节点上的路径和，利用深度优先搜索（DFS）即可做到。当遍历到某节点时，若该节点不为空就加上该节点的值，如果遇到是叶子节点，那么就说明一条路径已经出现。比较该路径和与给定sum,若相同则返回true;否则返回false 解题步骤递归 递归式 return test(root.left,count)||test(root.right,count); 或运算是短路运算 递归终止条件： 该节点为null，返回false 该节点为叶子节点，如果路径和等于给定sum返回true,否则返回false Coding实现1234567891011121314151617181920212223/** * Definition for a binary tree node. * function TreeNode(val) &#123; * this.val = val; * this.left = this.right = null; * &#125; *//** * @param &#123;TreeNode&#125; root * @param &#123;number&#125; sum * @return &#123;boolean&#125; */var hasPathSum = function(root, sum) &#123; return (function test(root,count) &#123; if(root===null) return false; count+=root.val; if(root.left===null&amp;&amp;root.right===null) &#123; if(count===sum) return true; else return false; &#125; return test(root.left,count)||test(root.right,count); &#125;)(root,0)&#125;;]]></content>
      <categories>
        <category>leetcode题解与算法</category>
      </categories>
      <tags>
        <tag>树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[leetcode-111]]></title>
    <url>AngelLikeFairy%2F2019%2F08%2F20%2Fleetcode-111%2F</url>
    <content type="text"><![CDATA[二叉树的层次遍历 II题目描述给定一个二叉树，找出其最小深度。 最小深度是从根节点到最近叶子节点的最短路径上的节点数量。 说明: 叶子节点是指没有子节点的节点。 示例: 给定二叉树 [3,9,20,null,null,15,7], 返回它的最小深度 2. 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/minimum-depth-of-binary-tree著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 核心思路概述关于二叉树的最小深度，我们可以考虑利用广度优先搜索，在这里即层序遍历的思想。当遍历到第一个叶子节点时，返回其深度即可。因为，层序遍历是从定至下，从左至右遍历的，所以遍历到的第一个叶子节点的深度必定是二叉树的最小深度 解题步骤 利用队列queue来实现层序遍历，为根节点设置属性depth=0； 判断当前节点是否有左右子树，若有，则左右子树的根节点的属性depth=当前节点的属性depth值+1；并且将子树入队列； 若没有，则返回该节点的深度 重复2,3步骤 Coding实现123456789101112131415161718192021222324252627282930/** * Definition for a binary tree node. * function TreeNode(val) &#123; * this.val = val; * this.left = this.right = null; * &#125; *//** * @param &#123;TreeNode&#125; root * @return &#123;number&#125; */var minDepth = function(root) &#123; if(root===null) return 0; else &#123; let queue=[root]; root.depth=1; while(queue.length!==0) &#123; let key=queue.shift(); if(!key.left&amp;&amp;!key.right) return key.depth; if(key.left) &#123; key.left.depth=key.depth+1; queue.push(key.left); &#125; if(key.right) &#123; key.right.depth=key.depth+1; queue.push(key.right); &#125; &#125; &#125;&#125;;]]></content>
      <categories>
        <category>leetcode题解与算法</category>
      </categories>
      <tags>
        <tag>树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[leetcode-107 二叉树的层次遍历 II]]></title>
    <url>AngelLikeFairy%2F2019%2F08%2F19%2Fleetcode-107%2F</url>
    <content type="text"><![CDATA[二叉树的层次遍历 II题目描述给定一个二叉树，返回其节点值自底向上的层次遍历。 （即按从叶子节点所在层到根节点所在的层，逐层从左向右遍历） 例如： 给定二叉树 [3,9,20,null,null,15,7], 返回其自底向上的层次遍历为： [ [15,7], [9,20], [3]] 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/binary-tree-level-order-traversal-ii著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 核心思路概述返回节点值自底部向上的遍历，也就是相当于节点值自顶部向下的遍历的倒转；那么，利用队列将二叉树进行层序遍历的同时，为节点添加depth属性（表示这为第几层）；根据depth值，添加到对应的二维数组ans中;最后，返回ans数组的倒序 解题步骤 利用队列queue来实现层序遍历，为根节点设置属性depth=0； 判断ans数组的key.depth项是否为数组，若是则直接将该值加入数组；若不是，则创建数组[key] 判断当前节点是否有左右子树，若有，则左右子树的根节点的属性depth=当前节点的属性depth值+1；并且将子树入队列； 重复2,3步骤直到queue为空 返回ans.reverse() Coding实现1234567891011121314151617181920212223242526272829303132333435363738/** * Definition for a binary tree node. * function TreeNode(val) &#123; * this.val = val; * this.left = this.right = null; * &#125; *//** * @param &#123;TreeNode&#125; root * @return &#123;number[][]&#125; */var levelOrderBottom = function(root) &#123; let ans=[]; if(root===null) return ans; else &#123; let queue=[]; queue.push(root); root.depth=0; while(queue.length!==0) &#123; let key=queue.shift(); if(Array.isArray(ans[key.depth])) &#123; ans[key.depth].push(key.val); &#125; else &#123; ans[key.depth]=[key.val]; &#125; if(key.left) &#123; key.left.depth=key.depth+1; queue.push(key.left); &#125; if(key.right) &#123; key.right.depth=key.depth+1; queue.push(key.right); &#125; &#125; &#125; return ans.reverse();&#125;;]]></content>
      <categories>
        <category>leetcode题解与算法</category>
      </categories>
      <tags>
        <tag>树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[leetcode-104 二叉树的最大深度]]></title>
    <url>AngelLikeFairy%2F2019%2F08%2F18%2Fleetcode-104%2F</url>
    <content type="text"><![CDATA[二叉树的最大深度题目描述给定一个二叉树，找出其最大深度。 二叉树的深度为根节点到最远叶子节点的最长路径上的节点数。 说明: 叶子节点是指没有子节点的节点。 示例： 给定二叉树 [3,9,20,null,null,15,7]， 返回它的最大深度 3 。 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/maximum-depth-of-binary-tree著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 核心思路概述获取一棵树的二叉树地最大深度，也就是需要获得该树的层数。那么，很自然可以想到利用层序遍历来获取到层数 解题步骤 利用队列来实现层序遍历，为根节点设置属性depth=1；并使最大层数max=1; 判断当前节点是否有左右子树，若有，则左右子树的根节点的属性depth=当前节点的属性depth值+1；并且将子树入队列 每个节点depth值与max值进行比较，将max赋予较大值 返回max Coding实现12345678910111213141516171819202122232425262728293031323334/** * Definition for a binary tree node. * function TreeNode(val) &#123; * this.val = val; * this.left = this.right = null; * &#125; *//** * @param &#123;TreeNode&#125; root * @return &#123;number&#125; */var maxDepth = function(root) &#123; let max=0; if(root===null) return max; else &#123; let queue=[]; queue.push(root); max=root.depth=1; while(queue.length!==0)&#123; let key=queue.shift(); if(key.left!==null) &#123; key.left.depth=key.depth+1; if(key.left.depth&gt;max) max=key.left.depth; queue.push(key.left) &#125;; if(key.right!==null) &#123; key.right.depth=key.depth+1; if(key.right.depth&gt;max) max=key.right.depth; queue.push(key.right) &#125; &#125; return max; &#125;&#125;;]]></content>
      <categories>
        <category>leetcode题解与算法</category>
      </categories>
      <tags>
        <tag>树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[leetcode-101 对称二叉树]]></title>
    <url>AngelLikeFairy%2F2019%2F08%2F18%2Fleetcode-101%2F</url>
    <content type="text"><![CDATA[对称二叉树题目描述给定一个二叉树，检查它是否是镜像对称的。 例如，二叉树 [1,2,2,3,4,4,3] 是对称的。 但是下面这个 [1,2,2,null,3,null,3] 则不是镜像对称的: 说明: 如果你可以运用递归和迭代两种方法解决这个问题，会很加分。 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/symmetric-tree著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 核心思路概述对于对称二叉树，我们只需要判断根节点的左子树和右子树是否是镜像对称的。那么，我们只需要将其中一个子树的所有节点的子树对换位置，再与另一个子树比较是否是相同的树（树结构相同，节点值也一样，参考leetcode100-相同的树） 那么按照这个思路，我们可以直接比较根节点的左子树中的每一个节点的左右子树是否都与右子树中的每一个节点的左右子树镜像对称，也就是leftTree.left===rightTree.right&amp;&amp;leftTree.right===rightTree.left对于每个节点是否成立 解题步骤 如果树为空，那么该树为对称数组，直接返回true 如果该树非空，那么遍历根节点的左右子树的每一个节点，如果他们的左右子树都相同那么返回true，否则返回false Coding实现1234567891011121314151617181920212223/** * Definition for a binary tree node. * function TreeNode(val) &#123; * this.val = val; * this.left = this.right = null; * &#125; *//** * @param &#123;TreeNode&#125; root * @return &#123;boolean&#125; */var isSymmetric = function(root) &#123; if(root===null) return true; let rightTree=root.right; let leftTree=root.left; function isSame(leftTree,rightTree)&#123; if(leftTree==null&amp;&amp;rightTree==null) return true; if(leftTree==null||rightTree==null) return false; if(leftTree.val!==rightTree.val) return false; return isSame(leftTree.left,rightTree.right)&amp;&amp;isSame(leftTree.right,rightTree.left); &#125; return isSame(root.left,root.right);&#125;;]]></content>
      <categories>
        <category>leetcode题解与算法</category>
      </categories>
      <tags>
        <tag>树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[leetcode-100 相同的树]]></title>
    <url>AngelLikeFairy%2F2019%2F08%2F16%2Fleetcode-100%2F</url>
    <content type="text"><![CDATA[相同的树题目描述给定两个二叉树，编写一个函数来检验它们是否相同。 如果两个树在结构上相同，并且节点具有相同的值，则认为它们是相同的。 示例 1: 示例 2: 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/same-tree著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 核心思路概述想要确定两棵树是否结构相同，并且节点的值也相同。那么从两树的根节点开始遍历每棵树的每个节点，如果值都相同，那么两棵树就是相同的 解题步骤以下是递归终止条件 遍历节点，如果两树的节点不同，那么返回false 如果两树的节点都为null那么返回true 如果两树的节点一个为null，另一个不为null，那么返回false Coding实现123456789101112131415161718192021/** * Definition for a binary tree node. * function TreeNode(val) &#123; * this.val = val; * this.left = this.right = null; * &#125; *//** * @param &#123;TreeNode&#125; p * @param &#123;TreeNode&#125; q * @return &#123;boolean&#125; */var isSameTree = function(p, q) &#123; if(p == null &amp;&amp; q == null) return true; if(p == null || q == null) return false; if(p.val != q.val) return false; return isSameTree(p.left, q.left) &amp;&amp; isSameTree(p.right, q.right);&#125;;]]></content>
      <categories>
        <category>leetcode题解与算法</category>
      </categories>
      <tags>
        <tag>树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[leetcode-38 报数]]></title>
    <url>AngelLikeFairy%2F2019%2F08%2F15%2Fleetcode-38%2F</url>
    <content type="text"><![CDATA[报数题目描述报数序列是一个整数序列，按照其中的整数的顺序进行报数，得到下一个数。其前五项如下： 1. 1 2. 11 3. 21 4. 1211 5. 1112211 被读作 “one 1” (“一个一”) , 即 11。11 被读作 “two 1s” (“两个一”）, 即 21。21 被读作 “one 2”, “one 1” （”一个二” , “一个一”) , 即 1211。 给定一个正整数 n（1 ≤ n ≤ 30），输出报数序列的第 n 项。 注意：整数顺序将表示为一个字符串。 示例 1: 输入: 1输出: “1” 示例 2: 输入: 4输出: “1211” 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/count-and-say著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 核心思路概述报数，指报的是前一个数。当前一个数有连续个同样地数比如’111’，那么把这个念作（3个1），因此会输出31；又比如’123’，因为这三个数都不同，我们会报数为（1个1；1个2；1个3），因此会输出111213 解题步骤不想多说，直接上代码 Coding实现12345678910111213141516171819202122/** * @param &#123;number&#125; n * @return &#123;string&#125; */var countAndSay = function(n) &#123; let ans=[]; ans[0]='1'; for(let i=1;i&lt;n;i++)&#123; let sum=1; ans[i]=''; for(let k=0;k&lt;ans[i-1].length;k++)&#123; if(ans[i-1][k]!==ans[i-1][k+1])&#123; ans[i]+=sum.toString()+ans[i-1][k]; sum=1; &#125; else &#123; sum++; &#125; &#125; &#125; return ans[n-1];&#125;;]]></content>
      <categories>
        <category>leetcode题解与算法</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[二叉树与二叉搜索树]]></title>
    <url>AngelLikeFairy%2F2019%2F08%2F15%2F%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%8E%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%2F</url>
    <content type="text"><![CDATA[二叉树的定义二叉树的递归定义 要么二叉树没有根节点，是一棵空树 要么二叉树是由根节点、左子树、右子树组成，且左子树和右子树都是二叉树 简单来说，就是二叉树要么是一棵空树，要么这棵树的每一个节点最多只有两个节点，并且左右子树是严格区分的 二叉搜索树（BST）定义二叉搜索树（Binary Search Tree）是一种特殊的二叉树，又称为排序二叉树，二叉查找树、二叉排序树。 二叉搜索树的递归定义 要么二叉搜索树是一棵空树 要么二叉搜索树是由根节点、左子树、右子树组成，其中左子树和右子树都是二叉搜索树，且左子树上所有节点的数据域均小于根节点的数据域，右子树上所有节点的数据域均大于或等于根节点的数据域 简单来说，二叉搜索树是二叉树的一种，但是它只允许你在左侧节点存储比父节点小的值；在右侧节点存储比父节点大或等于的值 二叉搜索树的插入如果要插入的树为空树，那么就将要插入的节点作为这颗二叉搜索树的根节点； 如果不是，那么就根据二叉搜索树的特性，判断它与根节点的大小关系不断递归直到找到它的位置 二叉搜索树的插入实现 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162class Node&#123; // 节点类 constructor(key)&#123; this.key=key; this.left=null; this.right=null; &#125;&#125;class BinarySearchTree&#123; // 二叉搜索树类 constructor(root)&#123; this.root=root; &#125; insert(node)&#123; // 二叉搜索树的插入方法 if(this.root===null)&#123; this.root=node; &#125; else &#123; this.insertNode(this.root,node); &#125; &#125; insertNode(root,node)&#123; // insertNode方法（用来找到合适的位置进行插入） if(node.key&lt;root.key)&#123; if(root.left===null) &#123; root.left=node; return; &#125; else &#123; this.insertNode(root.left,node); &#125; &#125; else &#123; if(root.right===null) &#123; root.right=node; return; &#125; else &#123; this.insertNode(root.right,node); &#125; &#125; &#125;&#125;let A=new Node(10);let B=new Node(15);let C=new Node(13);let D=new Node(7);let root=new BinarySearchTree(A);root.insert(B);root.insert(C);root.insert(D);console.log(root);/** 输出结果*//*BinarySearchTree &#123; root: Node &#123; key: 10, left: Node &#123; key: 7, left: null, right: null &#125;, right: Node &#123; key: 15, left: [Node], right: null &#125; &#125;&#125;*/ 二叉搜索树的性质因为二叉搜索树的所有节点的左子树会小于它，右子树会大于它，因此，对二叉搜索树使用中序遍历会得到一个有序序列 二叉树（二叉搜索树）的四种遍历因为二叉搜索树是特殊的二叉树，因此讲清楚二叉树地遍历即可 先序遍历对于先序遍历来说，总是先访问根节点，然后才去访问左子树和右子树，因此先序遍历的遍历顺序是根节点-&gt;左子树-&gt;右子树 先序遍历的代码实现 12345678function preOrder(root)&#123; if(root===null) return; else &#123; console.log(root); preOrder(root.left); preOrder(root.right); &#125;&#125; 中序遍历和后序遍历的代码实现与先序遍历类似，就不再展开 层序遍历层序遍历是指按照层次的顺序从根节点向下逐层进行遍历，且对同一层次的节点为从左到右遍历 层序遍历的实现步骤对于层序遍历，我们需要一层一层的访问，因此像之前的三种遍历方式使用递归我们无法做到，因此我们可以考虑使用队列来实现 将根节点tree.root加入队列queue 取出队首节点，访问它 如果该节点有左孩子，将左孩子入队 如果该节点有右孩子，将右孩子入队 返回2，直到队列为空 1234567891011121314151617function layerOrder(tree)&#123; if(tree.root===null) return; else &#123; let queue=[]; queue.push(tree.root); while(queue.length!==0)&#123; let key=queue.shift(); console.log(key); if(key.left!==null)&#123; queue.push(key.left); &#125; if(key.right!==null)&#123; queue.push(key.right); &#125; &#125; &#125;&#125; 根据遍历序列重建二叉树中序序列可以与先序序列、后序序列、层序序列中的任意一个来构建唯一的二叉树，而后三者两两搭配或是三个一起上都无法构建唯一的二叉树 原因是先序、后序、层序均是提供根节点。然而只有中序序列才能区分出左右子树 给定二叉树的先序遍历和中序遍历来重建二叉树的步骤 通过先序遍历来确定根节点，一开始会是数组的第一项 通过中序遍历来确定这棵树根节点的左子树和右子树，左子树会是数组中根节点项的前面那所有项；右子树会是数组中根节点项的后面的所有值 通过步骤2确定的中序遍历中的左子树数组和右子树数组来确定先序遍历中的左子树数组和右子树数组 递归左子树数组和右子树数组，重复步骤1,2,3直到数组为空 代码实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354class Node&#123; constructor(key)&#123; this.key=key; this.left=null; this.right=null; &#125;&#125;let A=new Node('A');let B=new Node('B');let C=new Node('C');let D=new Node('D');let E=new Node('E');let F=new Node('F');let G=new Node('G');// 给定二叉树的先序遍历和中序遍历重建二叉树函数function createTree(m,n)&#123; if(m.length===0) &#123;return;&#125;; let root=m[0]; let rootIndex=n.indexOf(root); let leftNTree=n.slice(0,rootIndex); let rightNTree=n.slice(rootIndex+1); let leftMTree=m.slice(1,leftNTree.length+1); let rightMTree=m.slice(rootIndex+1); if(leftMTree[0])&#123;root.left=leftMTree[0];&#125; if(rightMTree[0])&#123;root.right=rightMTree[0];&#125; createTree(leftMTree,leftNTree); createTree(rightMTree,rightNTree);&#125;createTree([A,B,C,D,E,F,G],[B,D,C,A,F,E,G]);console.log(A);/** 输出结果*//*Node &#123; key: 'A', left: Node &#123; key: 'B', left: null, right: Node &#123; key: 'C', left: [Node], right: null &#125; &#125;, right: Node &#123; key: 'E', left: Node &#123; key: 'F', left: null, right: null &#125;, right: Node &#123; key: 'G', left: null, right: null &#125; &#125;&#125;*/]]></content>
      <categories>
        <category>算法笔记</category>
      </categories>
      <tags>
        <tag>排序</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[leetcode-118 杨辉三角]]></title>
    <url>AngelLikeFairy%2F2019%2F08%2F14%2Fleetcode-118%2F</url>
    <content type="text"><![CDATA[杨辉三角题目描述给定一个非负整数 numRows，生成杨辉三角的前 numRows 行。 在杨辉三角中，每个数是它左上方和右上方的数的和。 示例: 输入: 5输出:[ [1], [1,1], [1,2,1], [1,3,3,1], [1,4,6,4,1]] 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/pascals-triangle著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 核心思路杨辉三角的每一行，除了首尾都是为1外，每一项都是前一行的两项之和 解题步骤 设置一个数组 建立numRows行二维数组，每一行除了首尾都是为1外，每一项都是前一行的两项之和 返回数组 coding实现12345678910111213141516/** * @param &#123;number&#125; numRows * @return &#123;number[][]&#125; */var generate = function(numRows) &#123; let ans=[]; for(let i=0;i&lt;numRows;i++)&#123; ans[i]=[]; ans[i][0]=1; ans[i][i]=1; for(let k=1;k&lt;i;k++)&#123; ans[i][k]=ans[i-1][k-1]+ans[i-1][k]; &#125; &#125; return ans;&#125;;]]></content>
      <categories>
        <category>leetcode题解与算法</category>
      </categories>
      <tags>
        <tag>数组</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[操作符new到底做了哪些事]]></title>
    <url>AngelLikeFairy%2F2019%2F08%2F13%2F%E6%93%8D%E4%BD%9C%E7%AC%A6new%E5%88%B0%E5%BA%95%E5%81%9A%E4%BA%86%E5%93%AA%E4%BA%9B%E4%BA%8B%2F</url>
    <content type="text"><![CDATA[new的基本语法 new constructor[([arguments])] 参数 constructor 一个指定对象实例的类型的类或函数。 arguments 一个用于被 constructor 调用的参数列表。 从语法中可以看出，后面的参数列表不是必须的。换言之: new Test = new Test() new操作符的作用new操作符可以快速创建构造函数的实例，如： 12345678910111213function Person(name,age,job)&#123; this.name=name; this.age=age; this.job=job;&#125;Person.prototype.sayHello=function ()&#123; console.log('hello');&#125;let man=new Person('zjb','18','frontEnd');console.log(man); // Object &#123; name: "zjb", age: "18", job: "frontEnd" &#125;man.sayHello(); // 'hello' 那么，使用new操作符来创建某构造函数的实例会经历以下四个步骤： 内部创建一个新对象 将构造函数的作用域赋给新对象（因此this就指向了这个新对象） 执行构造函数中的代码 返回新对象 构造函数是否返回值在上述的例子中，我们可以看到如果new的目标构造函数没有显式返回任何值的话，那么new操作就会默认返回this 显式返回基本类型值我们来测试下，如果构造函数显式返回基本类型值会有怎样的影响 1234567function Test(item) &#123; this.item = item; return 1;&#125;let test = new Test('hello');console.log(test); // &#123; item: 'hello' &#125; 我们可以看到返回的原始值并没有对实例产生任何影响。 也就是说在构造函数中显式返回一个基本类型值并不会对实例产生任何影响 显式返回引用类型值那么，如果是返回复杂引用类型值呢？ 1234567function Test(item) &#123; this.item = item; return &#123;a:1&#125;;&#125;let test = new Test('hello');console.log(test); // &#123; a: 1 &#125; 我们可以看到得到的实例发生了变化，输出值变为构造函数中显式返回的值 另外，我们知道new创建的实例对象，都会有一个proro访问器属性绑定到构造函数的原型上；但是，如果，构造函数显式地返回了其他对象的话，那么该对象的proro访问器属性不会绑定到构造函数的原型上 例如： 1234567891011function Test(item) &#123; this.item = item; return &#123;a:1&#125;;&#125;Test.prototype.sayHello = function() &#123; console.log('hello');&#125;let test = new Test('hello');test.sayHello(); // 报错：test.sayHello is not a function 我们可以看到，输出报错找不到该函数。也就是说，返回的对象的Proto访问器属性不是绑定到构造函数的原型上 自己实现一个new操作符既然new操作符的作用是创建一个构造函数的实例，那么new操作无非就是创建一个新的对象，将这个新对象的proto属性指向其构造函数的原型对象，然后该新对象绑定到构造函数上并获得传入的值，从而执行代码获得自身的对象属性 new操作符的代码实现 12345678910111213function New(constructor,...arr) &#123; // 检测传递进来的是否为构造函数，并且不是箭头函数（因为箭头函数没有[[construct]]方法，所以不能被作为构造函数。） if(typeof constructor!=='function') return false; else &#123; if(!constructor.prototype) return false; &#125; // 使用Object.create()方法将传入的参数作为创建的对象的原型对象来创建一个新的对象 let ans=Object.create(constructor.prototype); // 得到构造函数的返回值 let result=constructor.apply(ans,arr); // 根据构造函数的返回值做出相应的返回。如果，构造函数返回基本类型值，那么就返回ans对象；如果构造函数返回一个对象，那么返回该对象 return result instanceof Object?result:ans;&#125; 另附：一道关于new优先级的面试题链接网址]]></content>
      <categories>
        <category>javaScript基础</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[如何优雅地使用箭头函数]]></title>
    <url>AngelLikeFairy%2F2019%2F08%2F13%2F%E5%A6%82%E4%BD%95%E4%BC%98%E9%9B%85%E5%9C%B0%E4%BD%BF%E7%94%A8%E7%AE%AD%E5%A4%B4%E5%87%BD%E6%95%B0%2F</url>
    <content type="text"><![CDATA[什么是箭头函数箭头函数是ES6新增语法特性，它是一种使用箭头（=&gt;）定义函数的新语法，但是，他与传统的函数有些许的不同，主要集中在以下方面： 没有this,super,arguments和new.target绑定 箭头函数中的this,supper,arguments及new.target这些值由外围最近一层非箭头函数决定 不能通过new关键字调用 箭头函数没有[ [Constuct]]方法，所以不能被作为构造函数 没有原型 箭头函数不存在prototype这个属性 不可以改变this的绑定 箭头函数不能使用函数声明式语法，只能使用表达式语法 箭头函数语法当函数右侧的表达式只有一个时，可以没有显式的返回语句 12const test=a=&gt;a+1;console.log(test(1)); // 2 如果函数没有参数，则要在声明的时候写一组没有内容的小括号 12const test=()=&gt;'hello';console.log(test()); // 'hello' 如果想要返回一个对象字面量，则需要将该字面量包裹在小括号里 12const test=()=&gt;(&#123;item:1&#125;);console.log(test()); // &#123;item:1&#125; 没有this绑定箭头函数中没有this绑定，必须通过查找作用域链来确定this的值。 箭头函数的this在定义时就确定了，是由其外层代码的this决定（箭头函数的this指向就是该箭头函数所处的作用域） 对于其外层代码的this指向我们可以参考另一篇博文《Js中的this到底指向哪》 简单来说，假设外层代码里有一句输出语句console.log(this); 那么输出的对象即为this的指向 被全局环境中定义的函数包含 123(function test()&#123; console.log((()=&gt;this)()); // window&#125;)() 被对象中定义的方法包含 12345678const obj=&#123; a()&#123; return ()=&gt;&#123; console.log(this); &#125; &#125;&#125;obj.a()(); // obj &#123; a: a() &#125; 全局环境下定义 12const a=()=&gt;this;console.log(a()); // window 被另一个箭头函数包含 12345678910111213const obj=&#123; a()&#123; return ()=&gt;&#123; console.log('outter'); console.log(this); // Object &#123; a: a() &#125; (()=&gt;&#123; console.log('inner'); console.log(this); // Object &#123; a: a() &#125; &#125;)() &#125; &#125;&#125;obj.a()(); 最后，因为箭头函数没有 this，所以也不能用 call()、apply()、bind() 这些方法改变 this 的指向 123const test=()=&gt;this;const obj=&#123;&#125;console.log(test.apply(obj)); // window 创建立即执行表达式立即执行表达式，即可以定义一个匿名函数并调用，自始至终不保存对该函数的引用 123(()=&gt;&#123; console.log('hello'); // 'hello'&#125;)(); 没有arguments绑定箭头函数没有自己的arguments对象，且未来无论函数在哪个上下文中执行，箭头函数始终可以访问到外围函数的arguments对象 123456(function a()&#123; console.log(arguments[0]); // 5 ((m)=&gt;&#123; console.log(arguments[0]); // 5 &#125;)(1)&#125;)(5)]]></content>
      <categories>
        <category>ES6</category>
      </categories>
      <tags>
        <tag>基础语法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Js中的this到底指向哪]]></title>
    <url>AngelLikeFairy%2F2019%2F08%2F13%2FJs%E4%B8%AD%E7%9A%84this%E5%88%B0%E5%BA%95%E6%8C%87%E5%90%91%E5%93%AA%2F</url>
    <content type="text"><![CDATA[什么是this对于this,我们可以下一个定义 this是在执行上下文创建时确定的一个在执行过程中不可更改的变量。 简单来说,this应当是当前执行代码的环境对象 在函数中使用this函数调用一般会有以下四种情境： 在全局环境或是普通函数中直接调用 作为对象的方法 使用apply和call 作为构造函数 在全局环境或是普通函数中直接调用ps：全文均在浏览器环境下执行 在全局环境中直接调用1234567console.log(this===window); // truevar a=1;function test()&#123; var a=2; console.log(this.a);&#125;test(); // 1 在函数中直接调用123456789var a=1;function test()&#123; let a=2; function m()&#123; console.log(this.a); // 1 &#125; m();&#125;test(); 从这两个例子中，我们很容易可以得到：当函数在全局环境下或在某个函数中被直接调用时，那么其中的this会指向全局对象（window） 函数作为对象的方法被调用先说结论，当函数作为对象的方法被调用时，this就会指向该对象 如： 12345678var a=1;let obj=&#123; a:2, func()&#123; console.log(this.a); // 2 &#125;&#125;obj.func(); 由于func函数被作为obj的对象调用，那么this就会指向obj 然而，我们经常会遇到这样的陷阱： 123456789var a=1;let obj=&#123; a:2, func()&#123; console.log(this.a); // 1 &#125;&#125;const func=obj.func;func(); 此时，fnc函数被赋值给了全局作用域下的func变量。因为我们知道，函数名只是一个指向函数对象的指针，因此，此时全局作用域下定义的func域obj对象中的func一样指向了同一个函数对象；然后，这个函数在全局作用域下被直接调用，所以this指向了window 使用apply,call,bind apply() 方法调用一个具有给定this值的函数，以及作为一个数组（或类似数组对象）提供的参数。 call() 方法使用一个指定的 this 值和单独给出的一个或多个参数来调用一个函数。 注意：该方法的语法和作用与 apply() 方法类似，只有一个区别，就是 call() 方法接受的是一个参数列表，而 apply() 方法接受的是一个包含多个参数的数组。 bind()方法创建一个新的函数，在bind()被调用时，这个新函数的this被bind的第一个参数指定，其余的参数将作为新函数的参数供调用时使用。 其中，apply和call方法返回的是调用有指定this值和参数的函数的结果。 而bind方法是返回构建的新的函数 apply与call的使用例子123456789var a=1;function test()&#123; console.log(this.a);&#125;function func()&#123; console.log(this===window); // true test.apply(this); // 1&#125;func(); 执行func函数，因为func函数被直接调用，因此func函数内部的this指向全局对象，在浏览器中即为window。然后，test函数通过apply方法被调用，因此test函数被传入的this值也是指向window的。 另一个例子： 1234567891011var name='bjz'function test()&#123; let name='fairy' console.log(this.name);&#125;var obj=&#123; name:'angel'&#125;test.apply(obj); // 'angel' 与上个例子同理，test函数通过apply方法传入的this指向的是obj对象。 因为call方法与apply方法的作用是一样的，只是参数传递的形式有区别，因此，call的例子将会在下面列出 apply与call方法的参数传递区别1234567891011function sum(num1,num2)&#123; this.sum=num1+num2; console.log(this); // &#123; sum: 3, callSum: callSum() &#125;&#125;var obj=&#123; sum:0, callSum()&#123; sum.call(this,1,2)// 或者是sum.apply(this,[1,2]) &#125;&#125;obj.callSum(); callSum函数被作为obj的对象被调用，因此callSum函数内部的this指向obj对象。因此，sum函数通过call方法被传入的this对象也指向obj对象 bind的使用例子mdn上的解释 bind() 最简单的用法是创建一个函数，不论怎么调用，这个函数都有同样的 this 值。JavaScript新手经常犯的一个错误是将一个方法从对象中拿出来，然后再调用，期望方法中的 this 是原来的对象（比如在回调中传入这个方法）。如果不做特殊处理的话，一般会丢失原来的对象。基于这个函数，用原始的对象创建一个绑定函数，巧妙地解决了这个问题： 官方例子： 12345678910111213141516this.x = 9; // 在浏览器中，this指向全局的 "window" 对象var module = &#123; x: 81, getX: function() &#123; return this.x; &#125;&#125;;module.getX(); // 81var retrieveX = module.getX;retrieveX(); // 返回9 - 因为函数是在全局作用域中调用的// 创建一个新函数，把 'this' 绑定到 module 对象// 新手可能会将全局变量 x 与 module 的属性 x 混淆var boundGetX = retrieveX.bind(module);boundGetX(); // 81 一个简单的小例子： 1234567function test()&#123; console.log(this);&#125;var obj=&#123; item:1&#125;test.bind(obj)() //&#123;item:1&#125; 由此可以看出，bind方法的返回值是一个新创建的函数，函数内部的this指向为传入的this值 函数作为构造函数被调用何为构造函数？所谓构造函数就是用来new对象的函数，像Function、Object、Array、Date等都是全局定义的构造函数。 来看例子： 12345function Test()&#123; this.item=1;&#125;let b=new Test();console.log(b.item); // 1 如果函数作为构造函数用，那么其中的this就代表它即将new出来的对象。 箭头函数参考另一篇博文 如何优雅地使用箭头函数]]></content>
      <categories>
        <category>javaScript基础</category>
      </categories>
      <tags>
        <tag>基础语法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[leetcode-867 转置矩阵]]></title>
    <url>AngelLikeFairy%2F2019%2F08%2F13%2Fleetcode-867%2F</url>
    <content type="text"><![CDATA[转置矩阵题目描述给定一个矩阵 A， 返回 A 的转置矩阵。 矩阵的转置是指将矩阵的主对角线翻转，交换矩阵的行索引与列索引。 示例 1： 输入：[[1,2,3],[4,5,6],[7,8,9]]输出：[[1,4,7],[2,5,8],[3,6,9]] 示例 2： 输入：[[1,2,3],[4,5,6]]输出：[[1,4],[2,5],[3,6]] 提示： 1&lt;= A.length &lt;= 1000 1&lt;= A[0].length &lt;= 1000 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/transpose-matrix著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 核心思路概述对于转置矩阵的特点，我们很容易得到，对于原数组A，ans[k][i]=A[i][k] 解题步骤 根据矩阵列数来创建ans二维数组的行数 由ans[k][i]=A[i][k]循环得到ans数组并返回 Coding实现1234567891011121314/** * @param &#123;number[][]&#125; A * @return &#123;number[][]&#125; */var transpose = function(A) &#123; let ans=[]; for(let i=0;i&lt;A[0].length;i++)&#123; ans[i]=[]; for(let k=0;k&lt;A.length;k++)&#123; ans[i][k]=A[k][i]; &#125; &#125; return ans;&#125;;]]></content>
      <categories>
        <category>leetcode题解与算法</category>
      </categories>
      <tags>
        <tag>数组</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[对象的属性类型与特性]]></title>
    <url>AngelLikeFairy%2F2019%2F08%2F12%2F%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%B1%9E%E6%80%A7%E7%B1%BB%E5%9E%8B%E4%B8%8E%E7%89%B9%E6%80%A7%2F</url>
    <content type="text"><![CDATA[对象的属性类型对象包括两种属性类型，分别是 数据属性 访问器属性 数据属性定义及特性数据属性相对于访问器属性来说，它拥有数据值 数据属性有4个描述其行为的特性，分别是 configurable：可配置。（具体来说指的是，1.能否通过delete删除属性从而重新定义属性； 2.能否修改属性的特性；3.能否把属性修改为访问器属性；默认为true） enumerable：可枚举。（表示是否可以通过for-in循环来返回属性；对于直接在对象上定义的属性，这个特性值默认为true） writable：可写。（表示能否修改属性的值；默认为true） 以上三个属性取值为true或false。 value：属性值。 我们可以通过Object.getOwnPropertyDescriptor()这个方法来查看对象属性的特性 此方法可得到对象的数据属性，传入两个参数：第一个是要查找的对象名；第二个是要查找的属性名。 如下： 12345let test=&#123; item:1&#125;console.log(Object.getOwnPropertyDescriptor(test,'item')) //&#123; value: 1, writable: true, enumerable: true, configurable: true &#125; Object.defineProperty()要修改属性的默认特性，我们可以使用Object.defineProperty()来进行修改。当然我们也可以使用该方法来新建属性并同时制定它的属性特性 注意： 在调用该方法创建新的属性时，如果不指定，默认会将除value外的特性值置为false;如果调用该方法只是修改已有属性，则无此限制 这个方法接收三个参数：属性所在的对象、属性的名字(字符串类型),一个描述符对象。其中描述符对象的属性必须是数据属性四个特性中的一或多个 12345678910111213141516171819202122232425let test=&#123; item:1, name:2&#125;Object.defineProperty(test,'item',&#123; enumerable:false // 该属性无法被枚举&#125;)for(let i in test)&#123; console.log(i) // name&#125;Object.defineProperty(test,'item',&#123; configurable:false //让该属性不能被配置，具体指无法被删除，无法修改属性特性，无法修改为访问器属性&#125;)delete test.item // 该属性无法被删除console.log(test); // &#123;item:1&#125;Object.defineProperty(test,'item',&#123; value:2 // 修改该属性的值为2&#125;)console.log(test); // &#123;item:2&#125;Object.defineProperty(test,'item',&#123; writable:false // 该属性的值无法被修改&#125;)test.item=3;console.log(test); // &#123;item:2&#125; 访问器属性访问器属性不包含数据值；他们包含一对儿getter和setter函数；在读取访问器属性时，会调用getter函数，这个函数负责返回有效的值；在写入访问器属性时，会调用setter函数并传入新值，这个函数负责决定如何处理数据 访问器属性有4个描述其行为的特性，分别是 configurable：可配置。（具体来说指的是，1.能否通过delete删除属性从而重新定义属性； 2.能否修改属性的特性；3.能否把属性修改为访问器属性；默认为true） enumerable：可枚举。（表示是否可以通过for-in循环来返回属性；对于直接在对象上定义的属性，这个特性值默认为true） get：在读取属性时调用的函数。默认值为undefined set：在写入属性时调用的函数。默认值为undefined 访问器属性不像数据属性一样可以直接被定义，它只能通过Object.defineProperty()来定义。如果通过这种方式来进行定义的话，那么[[Enumerable]]可枚举属性会默认为false,当然我们可以在定义的时候将其设置为true 如下： 12345678910111213141516let test=&#123; _item:1&#125;Object.defineProperty(test,'item',&#123; get:function()&#123; return this._item; &#125;, set:function(num)&#123; if(num&gt;10)&#123; this._item++; &#125; &#125;&#125;)test.item=15;console.log(test.item); // 2 除此之外，我们也可以通过在对象上直接定义访问器属性使得其可枚举 12345678910111213141516171819202122let test=&#123; _item:1, get item() &#123; return this._item; &#125;, set item(num) &#123; if(num&gt;10) &#123; this._item++; &#125; &#125;&#125;console.log(Object.getPropertyDescriptor(test,item));/* &#123; get: [Function: get item], set: [Function: set item], enumerable: true, configurable: true&#125; */for(let i in test) &#123; console.log(i); // '_item','item'&#125; 访问器属性的意义 修改访问器属性动态修改相关联的数据属性 监听访问器属性的修改去操作其它业务逻辑]]></content>
      <categories>
        <category>javaScript基础</category>
      </categories>
      <tags>
        <tag>基础语法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[leetcode-509 斐波那契数]]></title>
    <url>AngelLikeFairy%2F2019%2F08%2F12%2Fleetcode-509%2F</url>
    <content type="text"><![CDATA[斐波那契数题目描述斐波那契数，通常用 F(n) 表示，形成的序列称为斐波那契数列。该数列由 0 和 1 开始，后面的每一项数字都是前面两项数字的和。也就是： F(0) = 0, F(1) = 1F(N) = F(N - 1) + F(N - 2), 其中 N &gt; 1.给定 N，计算 F(N)。 示例 1： 输入：2输出：1解释：F(2) = F(1) + F(0) = 1 + 0 = 1. 示例 2： 输入：3输出：2解释：F(3) = F(2) + F(1) = 1 + 1 = 2. 示例 3： 输入：4输出：3解释：F(4) = F(3) + F(2) = 2 + 1 = 3. 提示： 0 ≤ N ≤ 30 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/fibonacci-number著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 核心思路概述一开始会很容易想到用递归的方式来解决，但是递归会很容易超出时间限制。因此，利用动态规划就很容易解决这个问题 解题步骤 建立一个数组，数组的第一项和第二项分别为0,1 从第三项开始一直到第N项，每一项等于前两项的和，并存放到数组中 返回数组第N项存储的值 Coding实现1234567891011/** * @param &#123;number&#125; N * @return &#123;number&#125; */var fib = function(N) &#123; let arr=[0,1]; for(let i=2;i&lt;=N;i++)&#123; arr[i]=arr[i-1]+arr[i-2]; &#125; return arr[N];&#125;;]]></content>
      <categories>
        <category>leetcode题解与算法</category>
      </categories>
      <tags>
        <tag>数组</tag>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[leetcode-561 数组拆分 I]]></title>
    <url>AngelLikeFairy%2F2019%2F08%2F09%2Fleetcode-561%2F</url>
    <content type="text"><![CDATA[数组拆分 I题目描述给定长度为 2n 的数组, 你的任务是将这些数分成 n 对, 例如 (a1, b1), (a2, b2), …, (an, bn) ，使得从1 到 n 的 min(ai, bi) 总和最大。 示例 1: 输入: [1,4,3,2]输出: 4解释: n 等于 2, 最大总和为 4 = min(1, 2) + min(3, 4). 提示: n 是正整数,范围在 [1, 10000]. 数组中的元素范围在 [-10000, 10000]. 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/array-partition-i著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 核心思路概述当将整个数组排序后，第一个数必定为最小的数也是必须参加和运算的数假设为a。那么假如与这个最小的数a配对的数n并不是这个数组排序后a的后一个数b，那么b此时成为了剩下的数中最小的数因此必定也要参加和运算；但显然的是，此时a+b所组成的和运算中必定不是最大的和了 解题步骤 将原数组按从小到大进行排序 将数组中所有下标为偶数的数组元素相加得到的和返回 Coding实现1234567891011121314/** * @param &#123;number[]&#125; nums * @return &#123;number&#125; */var arrayPairSum = function(nums) &#123; let ans=0; nums.sort((a,b)=&gt;&#123; return a-b; &#125;); for(let i=0;i&lt;nums.length;i=i+2)&#123; ans+=nums[i]; &#125; return ans;&#125;;]]></content>
      <categories>
        <category>leetcode题解与算法</category>
      </categories>
      <tags>
        <tag>数组</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[leetcode-905 按奇偶排序数组]]></title>
    <url>AngelLikeFairy%2F2019%2F08%2F08%2Fleetcode-905%2F</url>
    <content type="text"><![CDATA[按奇偶排序数组题目描述给定一个非负整数数组 A，返回一个数组，在该数组中， A 的所有偶数元素之后跟着所有奇数元素。 你可以返回满足此条件的任何数组作为答案。 示例： 输入：[3,1,2,4]输出：[2,4,3,1]输出 [4,2,3,1]，[2,4,1,3] 和 [4,2,1,3] 也会被接受。 提示： 1&lt;= A.length &lt;= 5000 0&lt;= A[i] &lt;= 5000 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/sort-array-by-parity著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 核心思路概述 数组 遍历原数组，将奇数放到奇数数组，偶数放到偶数数组，concat后返回 双指针 left指针从前往后遍历,right指针从后往前遍历，如果left指针指向奇数而right指针指向偶数，那么两数交换，直到left&gt;=right 解题步骤数组 设定奇数数组、偶数数组 遍历原数组，将奇数放到奇数数组，偶数放到偶数数组 返回 奇数数组concat偶数数组 双指针 设定left=0,right=A.length-1 left指针从前往后遍历,right指针从后往前遍历，如果left指针指向奇数而right指针指向偶数，那么两数交换，直到left&gt;=right 返回ACoding实现数组实现1234567891011121314151617/** * @param &#123;number[]&#125; A * @return &#123;number[]&#125; */var sortArrayByParity = function(A) &#123; let odd=[]; let even=[]; A.forEach(value=&gt;&#123; if(value%2===0)&#123; even.push(value); &#125; else &#123; odd.push(value); &#125; &#125;) return even.concat(odd);&#125;; 双指针实现12345678910111213141516171819202122/** * @param &#123;number[]&#125; A * @return &#123;number[]&#125; */var sortArrayByParity = function(A) &#123; let left=0; let right=A.length-1; while(left&lt;right)&#123; if(A[left]%2===0)&#123; left++; continue; &#125; if(A[right]%2!==0)&#123; right--; continue; &#125; let temp=A[left]; A[left]=A[right]; A[right]=temp; &#125; return A;&#125;;]]></content>
      <categories>
        <category>leetcode题解与算法</category>
      </categories>
      <tags>
        <tag>数组</tag>
        <tag>双指针</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[引用类型]]></title>
    <url>AngelLikeFairy%2F2019%2F08%2F07%2F%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B%2F</url>
    <content type="text"><![CDATA[引言 新对象的创建可以通过new操作符后跟一个构造函数来创建 例： 1let a=new Object() Object类型创建Object实例的两个方法new操作符1let a=new Object() 对象字面量法1let a=&#123;item:1&#125; 在使用对象字面量语法时，属性名也可以使用字符串和可计算属性名 字符串属性名 1234let a=&#123; 'item':1&#125;console.log(a.item); // 1 可计算属性名(方括号语法：使用变量来访问属性) 12345let n=123;let a=&#123; [n+'abc']:'hello'&#125;console.log(a['123abc']); // hello Array类型创建数组的几种方式 Array构造函数 12let a=new Array(1,2,3);console.log(a); // [1,2,3] 数组字面量法 12let a=[1,2,3];console.log(a); //[1,2,3] 数组的length属性设置值的索引下标超过数组长度当设置值的索引下标超过数组长度时，那么数组的长度会自动加到该索引值加一的长度，并且中间未设置的元素还是undefined 1234let a=[1,2,3];a[8]=1;console.log(a); //[ 1, 2, 3, &lt;5 empty items&gt;, 1 ]console.log(a[5]); //undefined 利用数组的length属性来移除数组项和添加项当将数组的length值设置为小于原数组的length时，则会将原数组后面的几项移除掉 123let a=[1,2,3];a.length=1;console.log(a); //[1] 常用的数组方法栈方法 方法名 作用 返回值 push() 接受任意参数并添加到数组末尾 修改后的数组长度 pop() 从数组末尾移除最后一项 被移除的项 队列方法 方法名 作用 返回值 shift() 移除数组的第一个项 被移除的项 unshift() 接受任意参数并添加到数组前端 修改后的数组长度 重排序方法 方法名 作用 返回值 reverse() 翻转数组项的顺序 修改后的数组 sort() 默认是将数组元素转化为字符串进行比较并按升序排列，但可以添加比较函数 修改后的数组 操作方法 方法名 作用 返回值 concat() 该方法会先创建当前数组的一个副本，然后将接收到的参数添加到这个副本的末尾，最后返回构建的数组 新数组 slice() 返回给定起始位置和结束位置之间的项（左开右闭）（该方法不会影响原始数组） 新数组 splice() 1.删除（删除的第一项的位置和要删除的项数） 2.插入（插入的第一项的位置，0，要插入的元素） 3.替换（替换的第一项位置，要替换的项数，要插入的项数） 从原始数组中删除的项（如果没有删除任何项，则返回一个空数组） 位置方法 方法名 作用 返回值 indexOf() 从数组开头查找第一个全等于给定参数的数组项的下标，若没找到则返回-1 要查找的项在数组中的位置或-1 lastIndexOf() 从数组末尾查找第一个全等于给定参数的数组项的下标，若没找到则返回-1 要查找的项在数组中的位置或-1 迭代方法 方法名 作用 返回值 every() 对数组中的每一项运行给定函数，如果该函数对每一项都返回true，则返回true true或false some() 对数组中的每一项运行给定函数，如果该函数对任一项返回true，则返回true true或false filter() 过滤得到满足给定函数的项的组成的数组 新数组 forEach() 对数组中的每一项运行给定函数 undefined map() 对数组中的每一项运行给定函数，返回每次函数调用的结果组成的数组 新数组 归并方法 方法名 作用 返回值 reduce() 从数组第一项开始，向后对数组中的每个元素执行一个由您提供的reducer函数(升序执行)，将其结果汇总为单个返回值。 新数组 reduceRight() 从数组最后一项开始，向前对数组中的每个元素执行一个由您提供的reducer函数(升序执行)，将其结果汇总为单个返回值。 新数组 方法参数：这两个方法都接收两个参数：一个在每一项上调用的reucer函数和（可选的）作为归并基础的初始值 reducer函数参数：接收四个参数：前一个值、当前值、项的索引和数组对象。这个函数的显式返回的任何值都会作为第一个参数自动传给下一项，如果没有显式返回语句，那么就将undefined传给下一项 reduce()函数语法： arr.reduce(callback(accumulator, currentValue[, index[, array]])[, initialValue]) 参数 callback 执行数组中每个值的函数，包含四个参数： 1. accumulator 累计器累计回调的返回值; 它是上一次调用回调时返回的累积值，或initialValue（见于下方）。 2. currentValue 数组中正在处理的元素。 3. currentIndex可选 数组中正在处理的当前元素的索引。 如果提供了initialValue，则起始索引号为0，否则为1。 4. array可选 调用reduce()的数组initialValue (可选) 作为第一次调用 callback函数时的第一个参数的值。 如果没有提供初始值，则将使用数组中的第一个元素。 在没有初始值的空数组上调用 reduce 将报错。返回值 函数累计处理的结果 值得注意的是： 回调函数第一次执行时，accumulator 和currentValue的取值有两种情况：如果调用reduce()时提供了initialValue，accumulator取值为initialValue，currentValue取数组中的第一个值；如果没有提供 initialValue，那么accumulator取数组中的第一个值，currentValue取数组中的第二个值。Date类型创建日期对象 12let date=new Date();console.log(date.toLocaleString()); RegExp类型Function类型函数实际上是对象。因此函数名实际上也是一个指向函数对象的指针，并不会与某个函数绑定 因此使用不带圆括号的函数名是访问函数指针，而非调用函数 语法 函数声明式语法 （整体提升） 123function test()&#123; console.log(1);&#125; 函数表达式语法 （变量提升，给变量赋值为undefined）123const test=function()&#123; console.log(1);&#125; 作为值的函数因为函数名只是一个指向函数对象的指针，因此函数也可以作为参数的值进行传递 123456789function test()&#123; console.log(1);&#125;function a(test)&#123; test();&#125;a(test); //1 基本包装类型组成 Boolean Number String 基本包装类型与基本数据类型的区别123456789// Boolean转型函数，创建的是基本类型值console.log(Boolean(false)); // false console.log(Boolean(1)); // true // 基本包装类型，创建的是基本包装对象console.log(new Boolean(false)); //Boolean &#123; false &#125;console.log(new Boolean(1)); //Boolean &#123; false &#125; Number与String基本包装类型与基本数据类型的区别也是类似的 定义每当读取一个基本类型值的时候，后台就会自动创建一个对应的基本包装类型的对象。 处理步骤：\ 创建基本包装类型的一个实例 在实例上调用制定的方法 销毁这个实例 生命周期：自动创建的基本包装类型的对象，只存在于一行代码的执行瞬间，然后立即被销毁，这意味着我们不能在运行时为基本类型值添加属性和方法 123let a='hello';a.test=4;console.log(a.test); // undefined Boolean类型Number类型String类型String类型的每个实例都有一个length属性，表示字符串中包含多少个字符 123let a='hello';a.length=1; // 创建a的基本包装类型对象，修改掉length之后，被立即销毁console.log(a.length); // 5 创建a的基本包装类型对象，并返回length属性值 字符方法charAt()与charCodeAt() 字符串操作方法 concat() slice() substr() substring() indexOf() lastIndexOf() toLowerCase() toUpperCase() split() 单体内置对象Global对象Math对象]]></content>
      <categories>
        <category>javaScript基础</category>
      </categories>
      <tags>
        <tag>基础语法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[leetcode-1051 高度检查器]]></title>
    <url>AngelLikeFairy%2F2019%2F08%2F07%2Fleetcode-1051%2F</url>
    <content type="text"><![CDATA[高度检查器题目描述学校在拍年度纪念照时，一般要求学生按照 非递减 的高度顺序排列。 请你返回至少有多少个学生没有站在正确位置数量。该人数指的是：能让所有学生以 非递减 高度排列的必要移动人数。 示例： 输入：[1,1,4,2,1,3]输出：3解释：高度为 4、3 和最后一个 1 的学生，没有站在正确的位置。 提示： 1&lt;= heights.length &lt;= 100 1&lt;= heights[i] &lt;= 100 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/height-checker著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 核心思路概述只需比较原数组和排序后的数组的每个位置上的元素有几个不一样即可 解题步骤 复制原数组，并排序 比较原数组和排序后的数组的各个位置上的元素，若不同则ans++ 返回ans Coding实现12345678910111213141516/** * @param &#123;number[]&#125; heights * @return &#123;number&#125; */var heightChecker = function(heights) &#123; let heightsSort=(new Array(...heights)).sort((a,b)=&gt;&#123; return a-b; &#125;); let ans=0; for(let i in heights)&#123; if(heights[i]!==heightsSort[i])&#123; ans++; &#125; &#125; return ans;&#125;;]]></content>
      <categories>
        <category>leetcode题解与算法</category>
      </categories>
      <tags>
        <tag>数组</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[leetcode-832 翻转图像]]></title>
    <url>AngelLikeFairy%2F2019%2F08%2F06%2Fleetcode-832%2F</url>
    <content type="text"><![CDATA[翻转图像题目描述 给定一个二进制矩阵 A，我们想先水平翻转图像，然后反转图像并返回结果。 水平翻转图片就是将图片的每一行都进行翻转，即逆序。例如，水平翻转 [1, 1, 0] 的结果是 [0, 1, 1]。 反转图片的意思是图片中的 0 全部被 1 替换， 1 全部被 0 替换。例如，反转 [0, 1, 1] 的结果是 [1, 0, 0]。 示例 1: 输入: [[1,1,0],[1,0,1],[0,0,0]]输出: [[1,0,0],[0,1,0],[1,1,1]]解释: 首先翻转每一行: [[0,1,1],[1,0,1],[0,0,0]]； 然后反转图片: [[1,0,0],[0,1,0],[1,1,1]] 示例 2: 输入: [[1,1,0,0],[1,0,0,1],[0,1,1,1],[1,0,1,0]]输出: [[1,1,0,0],[0,1,1,0],[0,0,0,1],[1,0,1,0]]解释: 首先翻转每一行: [[0,0,1,1],[1,0,0,1],[1,1,1,0],[0,1,0,1]]； 然后反转图片: [[1,1,0,0],[0,1,1,0],[0,0,0,1],[1,0,1,0]] 说明: 1&lt;= A.length = A[0].length &lt;= 20 0&lt;= A[i][j] &lt;= 1 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/flipping-an-image著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 核心思路概述利用es6数组方法map()快速地修改数组元素 解题步骤 因为是二维数组，遍历该二维数组将一维数组倒序，并且1变成0,0变成1 Coding实现12345678910111213141516/** * @param &#123;number[][]&#125; A * @return &#123;number[][]&#125; */var flipAndInvertImage = function(A) &#123; return A.map(value=&gt;&#123; value.reverse(); return value.map(value1=&gt;&#123; if(value1===0)&#123; value1=1; &#125; else value1=0; return value1; &#125;); &#125;)&#125;;]]></content>
      <categories>
        <category>leetcode题解与算法</category>
      </categories>
      <tags>
        <tag>数组</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[leetcode-345 反转字符串中的元音字母]]></title>
    <url>AngelLikeFairy%2F2019%2F08%2F05%2Fleetcode-345%2F</url>
    <content type="text"><![CDATA[反转字符串中的元音字母题目描述编写一个函数，以字符串作为输入，反转该字符串中的元音字母。 示例 1: 输入: “hello”输出: “holle” 示例 2: 输入: “leetcode”输出: “leotcede” 说明:元音字母不包含字母”y”。 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/reverse-vowels-of-a-string著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 核心思路概述元音字母一共有5个，分别为’a’,’e’,’i’,’o’,’u’; 当然该题要注意元音字母对应的大写形式也算 因此，使用双指针，一个在首，一个在尾，当两指针未相遇时，如果两个指针指的都是元音字母或其大写形式，那么就交换两个字母；如果不是，那么就左指针向后，右指针往前 解题步骤 建立left,right双指针；将字符串s转换为字符串数组 left与right双指针，一个在首，一个在尾，当两指针未相遇时，如果两个指针指的都是元音字母或其大写形式，那么就交换两个字母；如果不是，那么就左指针向后，右指针往前 Coding实现123456789101112131415161718192021222324/** * @param &#123;string&#125; s * @return &#123;string&#125; */var reverseVowels = function(s) &#123; s=s.split(''); let left=0; let yuan=['a','e','i','o','u']; let right=s.length-1; while(left&lt;right)&#123; if(yuan.includes(s[left].toLowerCase())&amp;&amp;yuan.includes(s[right].toLowerCase()))&#123; [s[left],s[right]]=[s[right],s[left]]; left++; right--; &#125; if(!yuan.includes(s[left].toLowerCase())) &#123; left++; &#125; if(!yuan.includes(s[right].toLowerCase())) &#123; right--; &#125; &#125; return s.join('');&#125;;]]></content>
      <categories>
        <category>leetcode题解与算法</category>
      </categories>
      <tags>
        <tag>双指针</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[leetcode-933 最近的请求次数]]></title>
    <url>AngelLikeFairy%2F2019%2F08%2F04%2Fleetcode-933%2F</url>
    <content type="text"><![CDATA[最近的请求次数题目描述写一个 RecentCounter 类来计算最近的请求。 它只有一个方法：ping(int t)，其中 t 代表以毫秒为单位的某个时间。 返回从 3000 毫秒前到现在的 ping 数。 任何处于 [t - 3000, t] 时间范围之内的 ping 都将会被计算在内，包括当前（指 t 时刻）的 ping。 保证每次对 ping 的调用都使用比之前更大的 t 值。 示例： 输入：inputs = [“RecentCounter”,”ping”,”ping”,”ping”,”ping”], inputs = [[],[1],[100],[3001],[3002]]输出：[null,1,2,3,3] 提示： 每个测试用例最多调用 10000 次 ping。 每个测试用例会使用严格递增的 t 值来调用 ping。 每次调用 ping 都有 1 &lt;= t &lt;= 10^9。 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/number-of-recent-calls著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 核心思路概述该题目的意思就是计算在当前时刻往前3000毫秒到此时（即[t - 3000, t]）的所有Ping的数量 解题步骤 在RecentCounter构造函数中设置一个队列queue用来保存按时间顺序到来的ping的时间 利用出队列来删去当前队列中小于当前时间-3000毫秒的队列项 返回队列长度 Coding实现1234567891011121314151617181920212223242526var RecentCounter = function() &#123; this.queue=[];&#125;;/** * @param &#123;number&#125; t * @return &#123;number&#125; */RecentCounter.prototype.ping = function(t) &#123; let queue=this.queue; if(t===null) return null; else&#123; queue.push(t); while(queue[0]&lt;t-3000)&#123; queue.shift(); &#125; return queue.length; &#125;&#125;;/** * Your RecentCounter object will be instantiated and called as such: * var obj = new RecentCounter() * var param_1 = obj.ping(t) */]]></content>
      <categories>
        <category>leetcode题解与算法</category>
      </categories>
      <tags>
        <tag>队列</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[变量、作用域和内存问题]]></title>
    <url>AngelLikeFairy%2F2019%2F08%2F04%2F%E5%8F%98%E9%87%8F%E3%80%81%E4%BD%9C%E7%94%A8%E5%9F%9F%E5%92%8C%E5%86%85%E5%AD%98%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[基本类型值和引用类型值的存储与复制变量类型与内存的关系栈内存基本数据类型保存在栈内存中，因为基本数据类型占用空间小、大小固定，通过按值来访问，属于被频繁使用的数据 堆内存引用数据类型存储在堆内存中，因为引用数据类型占据空间大、大小不固定。 如果存储在栈中，将会影响程序运行的性能； 引用数据类型在栈中存储了指针，该指针指向堆中该实体的起始地址。 当解释器寻找引用值时，会首先检索其在栈中的地址，取得地址后从堆中获得实体 变量复制基本类型值的变量复制如果从一个变量向另一个变量复制基本类型的值，那么就会在变量对象（每个执行环境都有一个与之相关联的变量对象，当前环境中的所有变量和函数都会保存在这个对象中）上创建一个新的值，然后把该值复制到为新变量分配的位置上。 基本类型变量复制完毕后，两个变量是相互独立的。因为两个变量占据的是不同的栈内存空间。 12345const a=20;let b=a;console.log(a,b); // 20,20b=30;console.log(a,b); // 20,30 引用数据类型值的变量复制当从一个变量向另一个变量复制引用类型的值时，同样也会将存储在变量对象中的值复制一份放到位新变量分配的空间中。不同的是，这个值的副本实际上是一个指针，而这个指针指向存储在堆中的一个对象。 两个变量实际上引用的是同一个对象，因此改变其中一个变量，就会影响另一个变量。 123let m=&#123;a:10,b:20&#125;;let n=m;console.log(n); //&#123;a:10,b:20&#125; 函数的参数传递相当于变量复制es中所有函数的参数传递都是按值传递的。 基本类型值的参数传递就相当于基本类型值的变量复制，即创建了一个新的局部变量，值为传过来的参数值。 1234567let a=1;function test(n)&#123; console.log(n); //1 n++;&#125;test(a);console.log(a); // 1 引用类型值的参数传递也相当于引用类型值的变量传递，即创建了一个新的局部变量，保存的是传过来的参数的指针地址，两个变量在栈内存中有着不同的内存空间，但是指向堆内存中的同一个对象。 函数内部变量有变化时（指的是不改变该变量的指针指向地址）也会影响函数外部对象 而当该变量的指针指向地址改变后，两个变量就不在指向了同一个变量，因此之后函数内部变量的变化不会体现在函数外部 123456let a=&#123;item:1&#125;;function test(n)&#123; console.log(a===n); //true n=&#123;&#125;; console.log(a===n);&#125; 执行环境及作用域执行环境(执行上下文)执行环境可能有三种情况 全局执行环境(浏览器中的window对象和node环境中的global对象) —— 代码第一次执行的默认环境 函数执行环境 —— 执行流进入函数体 当执行流进入一个函数时，函数的执行环境会被推入一个环境中。当该函数执行完毕后，栈将其环境弹出，把控制权返回给之前的执行环境 Eval code（Eval code）——代码在eval函数内部执行 每个执行环境中都有一个与之关联的变量对象，用来存储在该环境中定义的变量和函数(但是我们无法访问到这个变量对象，是解析器在后台处理数据时会使用到) 作用域对于作用域，我的理解是它在某种程度上相当于执行环境，每个作用域都有当前作用域的变量和对象。但是作用域之间的变量和函数时相互隔离的，也就说不同作用域下的同名变量不会产生冲突 作用域链当代码在一个环境中执行时，会创建变量对象的一个作用域链。 作用域链的用途：是用来保证对执行环境有权访问的所有变量和函数的有序访问。 作用域的前端，始终都是当前的执行环境的变量对象。如果这个环境是函数，那么将其环境对象作为变量对象。作用链中的下一个对象是包含当前执行环境的执行环境的变量对象。这样，一直延续到全局执行环境。全局执行环境的变量对象始终都是作用域链的最后一个对象 12345678910function a()&#123; let m=1; function b()&#123; let m=2; console.log(m); // 2 &#125; b(); console.log(m); // 1&#125;a(); 延长作用域链有两种方式可以延长作用域链 try-catch语句的catch块 with语句 这两个语句都会在当前作用域链的前端添加一个变量对象。 对with语句来说，会将指定的对象添加到作用域链中。 对catch语句来说，会创建一个新的变量对象，其中包含的是被抛出的错误对象的声明 垃圾收集JavaScript 具有自动垃圾收集机制（GC：Garbage Collecation），也就是说，执行环境会负责管理代码执行过程中使用的内存。 标记清除JavaScript中最常用的垃圾收集方式就是标记清除，当变量进入环境后，就将这个变量标记为“进入环境”；而当变量离开环境时，就将其标记为“离开环境”。从而垃圾回收器完成垃圾回收工作 管理内存优化内存占用的最佳方式，就是为执行中的代码只保存必要的数据。一旦数据不再有用，最好将其值设置为null来释放其引用————这个做法叫做解除引用。 局部变量在离开执行环境是会自动被解除引用。 因此我们通常来解除全局执行环境中的引用]]></content>
      <categories>
        <category>javaScript基础</category>
      </categories>
      <tags>
        <tag>基础语法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[leetcode-237 删除链表中的节点]]></title>
    <url>AngelLikeFairy%2F2019%2F08%2F03%2Fleetcode-237%2F</url>
    <content type="text"><![CDATA[删除链表中的节点题目描述请编写一个函数，使其可以删除某个链表中给定的（非末尾）节点，你将只被给定要求被删除的节点。 现有一个链表 – head = [4,5,1,9]，它可以表示为: 示例 1: 输入: head = [4,5,1,9], node = 5输出: [4,1,9]解释: 给定你链表中值为 5 的第二个节点，那么在调用了你的函数之后，该链表应变为 4 -&gt; 1 -&gt; 9. 示例 2: 输入: head = [4,5,1,9], node = 1输出: [4,5,9]解释: 给定你链表中值为 1 的第三个节点，那么在调用了你的函数之后，该链表应变为 4 -&gt; 5 -&gt; 9. 说明: 链表至少包含两个节点。 链表中所有节点的值都是唯一的。 给定的节点为非末尾节点并且一定是链表中的一个有效节点。 不要从你的函数中返回任何结果。 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/delete-node-in-a-linked-list著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 核心思路概述一开始看到这个题目也是傻了一下，为什么只是传入一个要删除的节点，而不传入整个链表。后来一想，题目给定的初始链表中，每个节点的next存在的指向关系是一定的。那么我们就可以不需要考虑要删除节点之前的节点，只需要将要删除的节点的val值和next指向改变就可以了 解题步骤 改变要删除节点的val值为其下一个节点的val值 改变要删除节点的next指向为其下一个节点的下一个节点 Coding实现123456789101112131415/** * Definition for singly-linked list. * function ListNode(val) &#123; * this.val = val; * this.next = null; * &#125; *//** * @param &#123;ListNode&#125; node * @return &#123;void&#125; Do not return anything, modify node in-place instead. */var deleteNode = function(node) &#123; node.val=node.next.val; node.next=node.next.next;&#125;;]]></content>
      <categories>
        <category>leetcode题解与算法</category>
      </categories>
      <tags>
        <tag>链表</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[arguments与模拟函数重载]]></title>
    <url>AngelLikeFairy%2F2019%2F08%2F03%2Farguments%E4%B8%8E%E6%A8%A1%E6%8B%9F%E5%87%BD%E6%95%B0%E9%87%8D%E8%BD%BD%2F</url>
    <content type="text"><![CDATA[argumentsarguments对象是所有（非箭头）函数中都可用的局部变量。 通过该对象可以访问参数数组。因为此对象包含传递给函数的每个参数，第一个参数在索引0处。 12345function a()&#123; console.log(arguments); //Arguments &#123; 0: 1, 1: 2, 2: 3, … &#125; console.log(arguments[0]); //1&#125;a(1,2,3); 由此可以看到，arguments对象并不是Array的实例，它是类数组对象。因此，可以通过方括号语法访问它的每一个元素 arguments对象内的属性值永远与对应命名参数的值保持同步 123456function a(num)&#123; console.log(arguments[0]); //1 num=11; console.log(arguments[0]); //11&#125;a(1,2,3); 模拟函数重载重载的概念在Java语言中，函数或者方法有相同的名称，但是参数的类型或数量不同，这样的同名不同参数的函数或者方法之间，互相称之为重载函数。 为什么js没有重载然而，js中并没有重载的概念，因为： 1234567function a(num)&#123; console.log(1);&#125;function a(num1,num2)&#123; console.log(2);&#125;a(); // 2 如果定义了多个同名函数，那么该名字只属于后定义的函数，所以js中不能像Java一样有传统意义上的重载 js模拟函数重载其实，通过arguments,我们就可以通过检查传入函数中的参数类型和数量来做出不同的反应，从而模拟方法的重载 12345678910function a()&#123; if(arguments.length===0)&#123; console.log(0); &#125; else if(arguments.length===1)&#123; console.log(1); &#125;&#125;a(); // 0a(1); // 1]]></content>
      <categories>
        <category>javaScript基础</category>
      </categories>
      <tags>
        <tag>基础语法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[循环 (for...of与for...in)]]></title>
    <url>AngelLikeFairy%2F2019%2F08%2F03%2F%E5%BE%AA%E7%8E%AF%2F</url>
    <content type="text"><![CDATA[循环语句类型 for 语句 do…while 语句 while 语句 labeled 语句 break 语句 continue 语句 for…in 语句 for…of 语句 for…infor…in 语句循环一个指定的变量来循环一个对象所有可枚举的属性。JavaScript 会为每一个不同的属性执行指定的语句。 123456789const items=&#123; item1:1, item2:2, item3:3&#125;for(let a in items)&#123; console.log(a); // item1,item2,item3 console.log(items[a]); //1,2,3&#125; for…offor…of语句在可迭代的对象(在es6中，所有的集合对象(数组、Set集合及Map集合)和字符串都是可迭代对象)上创建了一个循环 ，对值的每一个独特的属性调用一个将被执行的自定义的和语句挂钩的迭代。 for…of循环每执行一次都会调用可迭代对象的next()方法，并将迭代器返回的结果对象的value属性存储在一个变量中，循环将持续执行这一过程直到返回对象的done属性的值为true 与 for…in 循环遍历的结果是数组元素的下标不同的是， for…of 遍历的结果是元素的值： 1234567891011121314151617181920let arr=[4,5,6];let str='string';let set=new Set([1,'a',3]);let map=new Map([['a',1],['b',2]]);//遍历数组for(let a of arr)&#123; console.log(a); //4,5,6&#125;//遍历字符串for(let s of str)&#123; console.log(s); //s,t,r,i,n,g&#125;//遍历set集合for(let k of set)&#123; console.log(k); //1,'a',3&#125;//遍历map集合for(let m of map)&#123; console.log(m); //[ 'a', 1 ],[ 'b', 2 ]&#125; 总结 倘若是遍历普通对象(非迭代对象)，那么使用for…in最佳，遍历得到属性名 倘若是遍历可迭代对象，那么根据需求来，如果不需要一些下标信息（例如set集合，字符串）那么使用for…of最佳 如果是数组和map，那么使用forEach会更加方便]]></content>
      <categories>
        <category>javaScript基础</category>
      </categories>
      <tags>
        <tag>基础语法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[null与{}其实不相等]]></title>
    <url>AngelLikeFairy%2F2019%2F08%2F03%2F%E7%A9%BA%E5%AF%B9%E8%B1%A1%2F</url>
    <content type="text"><![CDATA[引言{}与null相等吗？看一下下面的例子： 1console.log(&#123;&#125;===null); //false 显然，{}与null是不相等的 关于{}与null当我们在浏览器环境下，输入以下代码会发现： 1console.log(&#123;&#125;); // Object &#123; &#125; 作为比较，当需要输出null时会发现： 1console.log(null); // null 关于是否是空对象，我们可以采用instanceof的方法来检测 1console.log(&#123;&#125; instanceof Object); //true 那么，{}这个对象的原型链顶部会是Object，那么{}是一个不完全空的对象，只不过他没有任何属性罢了 1console.log(null instanceof Object); //false 而null的原型链上都找不到Object，那么null就是一个完完全全的空对象指针 更深层次的探讨为什么typeof null === object，其实这是一个js早期的bug。 在早期版本中，值以32位为单位存储，由小型标签（1-3位）和值的实际数据组成。类型标签存储在单元的低位中。 其中有五种： 000: object. 数据是对象的引用。1: int. 数据是31位有符号整数。010: double. 数据是对双浮点数的引用。100: string. 数据是对字符串的引用。110: boolean. 数据是布尔值。 那么，而null的类型标签正好与对象一致，因此，typeof null === object]]></content>
      <categories>
        <category>javaScript基础</category>
      </categories>
      <tags>
        <tag>基础语法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[布尔操作符(1&&2和1||2)]]></title>
    <url>AngelLikeFairy%2F2019%2F08%2F03%2F%E5%B8%83%E5%B0%94%E6%93%8D%E4%BD%9C%E7%AC%A6%2F</url>
    <content type="text"><![CDATA[mdn总结 运算符 语法 说明 逻辑与，AND（&amp;&amp;） expr1 &amp;&amp; expr2 若 expr1 可转换为 true，则返回 expr2；否则，返回 expr1。 逻辑或，OR（||） expr1 || expr2 若 expr1 可转换为 true，则返回 expr1；否则，返回 expr2。 逻辑非，NOT（!） !expr 若 expr 可转换为 true，则返回 false；否则，返回 true。 逻辑非 – !逻辑非操作符首先会将它的操作数转换为一个布尔值，然后再对其求反 123456console.log(!123); //falseconsole.log(!''); //trueconsole.log(!undefined); //trueconsole.log(!null); //trueconsole.log(!new String('1')); //falseconsole.log(!false); //true 逻辑与 – &amp;&amp;注意：逻辑与(&amp;&amp;)操作可以应用于任何类型的操纵数，而不仅仅是布尔值。 在有一个操作数不是布尔值的情况下，逻辑与操作就不一定返回布尔值；因此若要显示返回布尔值，则可以使用Boolean转型函数显示返回 逻辑与操作属于短路操作，即如果第一个操作数能够决定结果，那么就不会再对第二个操作数求值。 1234console.log(1&amp;&amp;2); //2console.log(0&amp;&amp;1); //0console.log(123&amp;&amp;'qwe'); //'qwe'console.log(&#123;&#125;&amp;&amp;null); //null 因为&#123;&#125;并不等于null，&#123;&#125;是一个不完全为空的对象，所以&#123;&#125;转换为逻辑值会是true 多个与运算当有多个与运算时，该表达式会返回第一个为false的值，或者是当前面所有值都为true时返回最后一个值 例如： 123console.log(1&amp;&amp;0&amp;&amp;true); // 0console.log(1&amp;&amp;true&amp;&amp;false); // false 逻辑或 – ||与逻辑与操作类似，逻辑或操作也是短路操作。也就是说，如果第一个操作数的求值结果为true,就不会对第二个操作数求值了 1234console.log(1||2); //1console.log(0||1); //1console.log(123||'qwe'); //123console.log(&#123;&#125;||null); //&#123;&#125; 多个或运算当有多个或运算时，该表达式会返回第一个为true的值，或者是当前面所有值都为false时返回最后一个值 例如： 123console.log(0||1||false); // 1console.log(0||false||false); // false]]></content>
      <categories>
        <category>javaScript基础</category>
      </categories>
      <tags>
        <tag>基础语法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[leetcode-283 移动零]]></title>
    <url>AngelLikeFairy%2F2019%2F08%2F02%2Fleetcode-283%2F</url>
    <content type="text"><![CDATA[移动零题目描述给定一个数组 nums，编写一个函数将所有 0 移动到数组的末尾，同时保持非零元素的相对顺序。 示例: 输入: [0,1,0,3,12]输出: [1,3,12,0,0] 说明: 必须在原数组上操作，不能拷贝额外的数组。 尽量减少操作次数。 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/move-zeroes著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 核心思路概述利用双指针，一个left指针用来寻找为0的元素，当找到后，该元素后面的所有元素前移，并将第二个指向数组末尾的指针right的元素值赋为0；如此循环直到left&gt;right 解题步骤 设置left指针指向数组第一个元素，设置right指针指向数组的最后一个元素 移动Left寻找数组中为0元素，当找到后，该元素后面的所有元素前移，并将第二个指向数组末尾的指针right的元素值赋为0；如此循环直到left&gt;right Coding实现123456789101112131415161718192021/** * @param &#123;number[]&#125; nums * @return &#123;void&#125; Do not return anything, modify nums in-place instead. */var moveZeroes = function(nums) &#123; let left=0; let right=nums.length-1; while(left&lt;right)&#123; if(nums[left]===0)&#123; for(let i=left;i&lt;right;i++)&#123; nums[i]=nums[i+1]; &#125; nums[right]=0; right--; &#125; else &#123; left++; &#125; &#125; return nums;&#125;;]]></content>
      <categories>
        <category>leetcode题解与算法</category>
      </categories>
      <tags>
        <tag>双指针</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据类型]]></title>
    <url>AngelLikeFairy%2F2019%2F08%2F01%2F%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%2F</url>
    <content type="text"><![CDATA[数据类型简单数据类型 Null (null值本质上是一个空对象指针) Undefined String Number Boolean Symbol 复杂数据类型 Object(包括Array、Function、Date、RegExp、Error、Arguments等更为具体的引用类型) 数据类型的检测判断typeof typeof 常用于判断基本数据类型 一些注意点 typeof返回的是一个字符串,因此 typeof typeof 1 //(任意数据类型)都会返回string null是一个空对象指针，因此typeof null会返回object 对于函数function的判断，tpeof function会返回function而不是对象object 从技术角度讲，函数在es中是对象，而不是一种数据类型。然而，函数也确实有一些特殊的属性，因此通过typeof操作符来区分函数和其他对象是有必要的 对于除function外的复杂数据类型，例如数组，set,map都会返回对象object 1234567891011121314151617181920212223typeof 123 // "number"typeof "abc" // "string" typeof (new String()) //objecttypeof true // "boolean" typeof &#123;a: 1&#125; // "object" typeof null //objecttypeof function foo() &#123;&#125; // "function" typeof undefined // "undefined" typeof Symbol('foo') // "symbol"typeof (new Set()) //"object"typeof (new Map()) //"object"typeof typeof 1 //"string" typeof的不足使用 typeof 方法来检测数据类型，基本类型大部分都能被准确检测并返回正确的字符串（除了 Null 类型，其返回 object 字符串），而引用类型大部分都不能够被准确检测（除了 Function 类型能够准确返回 function 字符串外，其它的都返回了 object 字符串）。 instanceofinstanceof用于判断引用类型 instanceof 运算符用于测试构造函数的prototype属性是否出现在对象的原型链中的任何位置 12let str=new String();console.log(str instanceof String); //true 123456function Person()&#123;&#125;;function Student()&#123;&#125;;let person=new Person();Student.prototype=person;let student=new Student();console.log(student instanceof Person) //true 语法 object instanceof constructor 因此当使用instanceof判断基本数据类型时就会返回false,与此同时,instanceof 右端也必须是某个构造函数 12'a' instanceof String //false123 instanceof Number //false null instanceof object那么基本数据类型中的null呢，既然typeof null===object;那么null instanceof object呢？很不幸,返回的会是false 简单来说，null并不是以Object为原型创建出来的 1null instanceof object //false instanceof基本类型值我们知道string,number和boolean基本类型值在被访问的时候可以在一行的生命周期内被转化为基本包装类型，那么使用instanceof来判断这三个可以转化为基本包装类型的基本类型值会怎么样呢？ 1234567console.log(1 instanceof Number); // falseconsole.log('nice' instanceof String); // falseconsole.log(true instanceof String); // falseconsole.log(new Number(1) instanceof Number); // trueconsole.log(new String('nice') instanceof String); // trueconsole.log(new Boolean(true) instanceof Boolean); // true 我们可以看到并没有，那么它究竟有没有被转化为基本包装类型呢？ 因此，我们可以得到一个结论： 如果，不需要访问或操作基本类型值的属性和方法，那么它就不会在一行的生命周期里被转化为基本包装类型。 函数模拟instanceof知道instaceof的原理是判断构造函数的prototype属性是否出现在对象的原型链中的任何位置时，那么就不难模拟一个函数来实现instanceof 12345678910111213141516171819function instance(obj,construct) &#123; // 利用typeof判断obj是否为基本类型值，如果是返回false if(typeof obj!=='function') &#123; if((typeof obj!=='object')||obj===null) return false; &#125; // 利用Object.prototype.toString.call()来判断construct是否为构造函数，如果不是则返回false if(Object.prototype.toString.call(construct).slice(8,-1)!=='Function') &#123; return false &#125; // 判断construct的原型对象是否在obj的原型链上 let proto = Object.getPrototypeOf(obj); while(proto) &#123; if(proto===construct.prototype) return true; else &#123; proto = Object.getPrototypeOf(proto); &#125; &#125; return false;&#125; Object.prototype.toString()一个完善的类型检测方案 每个对象都有一个toString()方法，当该对象被表示为一个文本值时，或者一个对象以预期的字符串方式引用时自动调用。默认情况下，toString()方法被每个Object对象继承。如果此方法在自定义对象中未被覆盖，toString() 返回 “[object type]”，其中type是对象的类型 可以通过toString() 来获取每个对象的类型。为了每个对象都能通过 Object.prototype.toString() 来检测，需要以 Function.prototype.call() 或者 Function.prototype.apply() 的形式来调用，传递要检查的对象作为第一个参数，称为thisArg。 以下使用该方法检测基本类型值和对象 123456789101112var toString=Object.prototype.toString;console.log(toString.call(undefined)); // [object Undefined]console.log(toString.call(null)); // [object Null]console.log(toString.call(true)); // [object Boolean]console.log(toString.call(123)); // [object Number]console.log(toString.call('a')); // [object String]console.log(toString.call(new Object()); // [object Object]console.log(toString.call([1,2,3])); // [object Array]console.log(toString.call(function a()&#123;&#125;)); // [object Function]console.log(toString.call(new Date())); // [object Date] 注意，所有构造函数都会返回[Object Function]，因为构造函数实际上就是函数 1234console.log(Object.prototype.toString.call(Object)); // [object Function]console.log(Object.prototype.toString.call(Array)); // [object Function]console.log(Object.prototype.toString.call(Date)); // [object Function]console.log(Object.prototype.toString.call(String)); // [object Function] 数组判断isArray() Array.isArray() 用于确定传递的值是否是一个 Array。 12345678Array.isArray([1, 2, 3]); // trueArray.isArray(&#123;foo: 123&#125;); // falseArray.isArray("foobar"); // falseArray.isArray(undefined); // false instanceof12let a=[1,2,3];console.log(a instanceof Array); // true 综述一个较好的解决方案应该是检测基本数据类型时使用typeof，当然null除外；检测复杂数据类型时使用Object.prototype.toString() Undefined类型undefined指那些被声明但未被初始化的值 Null类型null值表示一个空对象指针，因此typeof null === object Boolean类型及相应转换规则转型函数Boolean()12let str='hello';console.log(Boolean(str)); //true Boolean自动转换规则 数据类型 转换为true值 转换为false值 Number 任何非0数值 0和NaN String 非空字符串 空字符串（””） Bollean true false Object 任何object(包括{}，因为{}是一个不完全空的对象) null Undefined 无 undefined 使用!!123console.log(!!0); // falseconsole.log(!!'123'); // trueconsole.log(!!new Array); // true Number类型为什么0.1+0.2!==0.3 NaNNaN,指的是非数值，用来表示一个本来要返回数值的操作数未返回数值的情况，例如： 1console.log('a'-1); //NaN 任何设置NaN的操作都会返回NaN,甚至NaN与任何值都不相等包括其本身，包括但不限于： 12console.log(NaN-1); //NaNconsole.log(NaN===NaN); //false isNaN函数 isNaN() 函数用来确定一个值是否为NaN 。注：isNaN函数内包含一些非常有趣的规则；你也可以使用 ECMAScript 2015 中定义的 Number.isNaN() 来判断。 下一个版本的ECMAScript (ES2015)包含Number.isNaN()函数。通过Number.isNaN(x)来检测变量x是否是一个NaN将会是一种可靠的做法。然而，在缺少Number.isNaN函数的情况下, 通过表达式(x != x) 来检测变量x是否是NaN会更加可靠。 一个isNaN的 polyfill 可以理解为（这个polyfill利用了NaN自身永不相等于自身这一特征 ）： 1234var isNaN = function(value) &#123; var n = Number(value); //利用Number()函数进行数值转换 return n !== n;&#125;; 例子12345678910111213141516171819202122isNaN(NaN); // trueisNaN(undefined); // trueisNaN(&#123;&#125;); // trueisNaN(true); // falseisNaN(null); // falseisNaN(37); // false// stringsisNaN("37"); // false: 可以被转换成数值37isNaN("37.37"); // false: 可以被转换成数值37.37isNaN("37,5"); // trueisNaN('123ABC'); // true: parseInt("123ABC")的结果是 123, 但是Number("123ABC")结果是 NaNisNaN(""); // false: 空字符串被转换成0isNaN(" "); // false: 包含空格的字符串被转换成0// datesisNaN(new Date()); // falseisNaN(new Date().toString()); // trueisNaN("blabla") // true: "blabla"不能转换成数值 // 转换成数值失败， 返回NaN 数值转换 Number() parseInt() parseFloat() 使用+运算符 123console.log(+'123'); // 123console.log(+'123.5'); // 123.5console.log(+'123xyz'); // NaN String类型toString()方法作用：返回值的字符串表现数值，布尔值，对象和字符串都有该方法但是undefined和null没有该方法 1234console.log(123.toString()); //'123'console.log(true.toString()); //'true'let a=&#123;item:1&#125;;console.log(a.toString()); //'[object Object]' String()转型函数该函数不同于toString不能转换null和undefined;该方法可以转换任何类型的值 转换规则如下： 如果该类型有toString()方法，那么就调用该方法 如果为null，则返回”null” 如果为undefined，则返回”undefined” Object类型Object类型是所有对象的基础，也就是所有对象都是继承与Object的 123456let a=new Object();let str=new String();let date=new Date();console.log(a instanceof Object); //trueconsole.log(str instanceof Object); //trueconsole.log(date instanceof Object); //true 对象可以通过执行new操作符后跟要创建的对象类型的名称来创建，例 123let a=new Object();let str=new String();let date=new Date(); Object实例的一些属性与方法 constructor: 指向构造函数 isPrototypeOf(object)：用于检查传入的对象是否是当前对象的原型 toString()：返回对象的字符串表示 valueOf(): 返回对象的字符串、数值或布尔值表示。通常与toString()方法返回值相同]]></content>
      <categories>
        <category>javaScript基础</category>
      </categories>
      <tags>
        <tag>基础语法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[leetcode-1021 删除最外层的括号]]></title>
    <url>AngelLikeFairy%2F2019%2F07%2F31%2Fleetcode-1021%2F</url>
    <content type="text"><![CDATA[删除最外层的括号题目描述有效括号字符串为空 (“”)、”(“ + A + “)” 或 A + B，其中 A 和 B 都是有效的括号字符串，+ 代表字符串的连接。例如，””，”()”，”(())()” 和 “(()(()))” 都是有效的括号字符串。 如果有效字符串 S 非空，且不存在将其拆分为 S = A+B 的方法，我们称其为原语（primitive），其中 A 和 B 都是非空有效括号字符串。 给出一个非空有效字符串 S，考虑将其进行原语化分解，使得：S = P_1 + P_2 + … + P_k，其中 P_i 是有效括号字符串原语。 对 S 进行原语化分解，删除分解中每个原语字符串的最外层括号，返回 S 。 示例 1： 输入：”(()())(())”输出：”()()()”解释：输入字符串为 “(()())(())”，原语化分解得到 “(()())” + “(())”，删除每个部分中的最外层括号后得到 “()()” + “()” = “()()()”。 示例 2： 输入：”(()())(())(()(()))”输出：”()()()()(())”解释：输入字符串为 “(()())(())(()(()))”，原语化分解得到 “(()())” + “(())” + “(()(()))”，删除每隔部分中的最外层括号后得到 “()()” + “()” + “()(())” = “()()()()(())”。 示例 3： 输入：”()()”输出：””解释：输入字符串为 “()()”，原语化分解得到 “()” + “()”，删除每个部分中的最外层括号后得到 “” + “” = “”。 提示： S.length &lt;= 10000 S[i] 为 “(“ 或 “)” S 是一个有效括号字符串 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/remove-outermost-parentheses著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 核心思路概述关于括号匹配问题，很容易想到用栈来解决。 遇到 ‘ ( ‘ 入栈，遇到 ‘ ) ‘ 则出栈。则当该栈为空时，则代表之前的括号都已匹配。那么就可以将先前的括号去掉最外层的括号 解题步骤 设定一个数组stack用来表示栈操作，并预先压入第一个元素’(‘ 设定一个数组temp用来存放已经匹配完成的括号，并预先设定第一个元素’(‘ 从第二个元素开始遍历，遇到 ‘ ( ‘ 入栈，遇到 ‘ ) ‘ 则出栈。则当该栈为空时，则代表之前的括号都已匹配。那么就可以将先前的括号去掉最外层的括号,并压入结果数组ans 返回ans Coding实现123456789101112131415161718192021222324/** * @param &#123;string&#125; S * @return &#123;string&#125; */var removeOuterParentheses = function(S) &#123; let stack=['(']; let temp=['(']; let ans=[]; S=S.split(''); for(let i=1;i&lt;S.length;i++)&#123; temp.push(S[i]); if(S[i]===')')&#123; stack.pop(); if(stack.length===0)&#123; temp.pop(); temp.shift(); ans.push(...temp); temp=[]; &#125; &#125; else stack.push(S[i]); &#125; return ans.join('');&#125;;]]></content>
      <categories>
        <category>leetcode题解与算法</category>
      </categories>
      <tags>
        <tag>栈</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[leetcode-1122 数组的相对排序]]></title>
    <url>AngelLikeFairy%2F2019%2F07%2F30%2Fleetcode-1122%2F</url>
    <content type="text"><![CDATA[数组的相对排序题目描述给你两个数组，arr1 和 arr2， arr2 中的元素各不相同 arr2 中的每个元素都出现在 arr1 中 对 arr1 中的元素进行排序，使 arr1 中项的相对顺序和 arr2 中的相对顺序相同。未在 arr2 中出现过的元素需要按照升序放在 arr1 的末尾。 示例： 输入：arr1 = [2,3,1,3,2,4,6,7,9,2,19], arr2 = [2,1,4,3,9,6]输出：[2,2,2,1,4,3,3,9,6,7,19] 提示： arr1.length, arr2.length &lt;= 1000 0 &lt;= arr1[i], arr2[i] &lt;= 1000 arr2 中的元素 arr2[i] 各不相同 arr2 中的每个元素 arr2[i] 都出现在 arr1 中 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/relative-sort-array著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 核心思路概述目前觉得暴力解法最简单 解题步骤双循环，时间复杂度为O(n*m) Coding实现1234567891011121314151617181920212223/** * @param &#123;number[]&#125; arr1 * @param &#123;number[]&#125; arr2 * @return &#123;number[]&#125; */var relativeSortArray = function(arr1, arr2) &#123; let ans=[]; let el=[]; arr1.forEach(value=&gt;&#123; if(!arr2.includes(value))&#123; el.push(value); &#125; &#125;) arr2.forEach(value2=&gt;&#123; arr1.forEach(value1=&gt;&#123; if(value1===value2)&#123; ans.push(value2); &#125; &#125;) &#125;) el.sort((a,b)=&gt;&#123;return a-b;&#125;) return ans.concat(el);&#125;;]]></content>
      <categories>
        <category>leetcode题解与算法</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[leetcode-344 反转字符串]]></title>
    <url>AngelLikeFairy%2F2019%2F07%2F30%2Fleetcode-344%2F</url>
    <content type="text"><![CDATA[反转字符串题目描述编写一个函数，其作用是将输入的字符串反转过来。输入字符串以字符数组 char[] 的形式给出。 不要给另外的数组分配额外的空间，你必须原地修改输入数组、使用 O(1) 的额外空间解决这一问题。 你可以假设数组中的所有字符都是 ASCII 码表中的可打印字符。 示例 1： 输入：[“h”,”e”,”l”,”l”,”o”]输出：[“o”,”l”,”l”,”e”,”h”] 示例 2： 输入：[“H”,”a”,”n”,”n”,”a”,”h”]输出：[“h”,”a”,”n”,”n”,”a”,”H”] 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/reverse-string著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 核心思路概述题目要求是原地修改数组，并且只能使用O(1)的额外空间。因此，不能创建新的数组来存放数组元素，此时可以考虑使用双指针，一个置首，一个置尾。首向后，尾向前，交换两个指针的值即可。 解题步骤 建立left,right双指针 当left&lt;=right时，交换两指针元素 Coding实现1234567891011121314/** * @param &#123;character[]&#125; s * @return &#123;void&#125; Do not return anything, modify s in-place instead. */var reverseString = function(s) &#123; let left=0; let right=s.length-1; while(left&lt;=right)&#123; [s[left],s[right]]=[s[right],s[left]]; left++; right--; &#125; return s;&#125;;]]></content>
      <categories>
        <category>leetcode题解与算法</category>
      </categories>
      <tags>
        <tag>双指针</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[leetcode-977 有序数组的平方]]></title>
    <url>AngelLikeFairy%2F2019%2F07%2F29%2Fleetcode-977%2F</url>
    <content type="text"><![CDATA[有序数组的平方题目描述给定一个按非递减顺序排序的整数数组 A，返回每个数字的平方组成的新数组，要求也按非递减顺序排序。 示例 1： 输入：[-4,-1,0,3,10]输出：[0,1,9,16,100] 示例 2： 输入：[-7,-3,2,3,11]输出：[4,9,9,49,121] 提示： 1&lt;= A.length &lt;= 10000 -10000 &lt;= A[i] &lt;= 10000 A 已按非递减顺序排序。 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/squares-of-a-sorted-array著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 核心思路概述将该数组的每一个元素平方后在将该数组排序并返回 解题步骤 将该数组的每一个元素平方 排序该数组并返回 Coding实现123456789/** * @param &#123;number[]&#125; A * @return &#123;number[]&#125; */var sortedSquares = function(A) &#123; return A.map(value=&gt;&#123; return value*value; &#125;).sort((a,b)=&gt;&#123;return a-b;&#125;)&#125;;]]></content>
      <categories>
        <category>leetcode题解与算法</category>
      </categories>
      <tags>
        <tag>数组</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[leetcode-350 两个数组的交集 II]]></title>
    <url>AngelLikeFairy%2F2019%2F07%2F28%2Fleetcode-350%2F</url>
    <content type="text"><![CDATA[两个数组的交集 II题目描述给定两个数组，编写一个函数来计算它们的交集。 示例 1: 输入: nums1 = [1,2,2,1], nums2 = [2,2]输出: [2,2] 示例 2: 输入: nums1 = [4,9,5], nums2 = [9,4,9,8,4]输出: [4,9] 说明： 输出结果中每个元素出现的次数，应与元素在两个数组中出现的次数一致。我们可以不考虑输出结果的顺序。 进阶: 如果给定的数组已经排好序呢？你将如何优化你的算法？ 如果 nums1 的大小比 nums2 小很多，哪种方法更优？ 如果 nums2 的元素存储在磁盘上，磁盘内存是有限的，并且你不能一次加载所有的元素到内存中，你该怎么办？ 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/intersection-of-two-arrays-ii著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 核心思路概述该题可以考虑用双指针方法和哈希表去解决。双指针主要循环比较两个数是否相等；哈希表主要是记录每个数组中每个元素出现的次数 解题步骤双指针 将两个数组进行排序 设定两个指针，分别指向两个数组的第一个元素 如果两个指针指向的元素相等，那么就把该元素push入ans数组；并且两个指针向后移动 如果不等，那么指向较小元素的那个指针向后移动 哈希表 建立两个哈希表，分别存储每个数组中的每个元素存储的个数 遍历其中一个哈希表，如果另一个哈希表中也存在该键，比较两个键值大小，按照小的那个键值循环则将该键push入ans数组； Coding实现双指针解法代码12345678910111213141516171819202122232425262728/** * @param &#123;number[]&#125; nums1 * @param &#123;number[]&#125; nums2 * @return &#123;number[]&#125; */var intersect = function(nums1, nums2) &#123; let nums1Index=0; let nums2Index=0; let ans=[]; nums1.sort((a,b)=&gt;&#123;return a-b;&#125;); nums2.sort((a,b)=&gt;&#123;return a-b;&#125;); while(nums1Index&lt;nums1.length&amp;&amp;nums2Index&lt;nums2.length)&#123; let num1=nums1[nums1Index]; let num2=nums2[nums2Index]; if(num1===num2)&#123; ans.push(num1); nums1Index++; nums2Index++; &#125; else if(num1&lt;num2)&#123; nums1Index++; &#125; else&#123; nums2Index++; &#125; &#125; return ans;&#125;; 哈希表解法代码12345678910111213141516171819202122232425262728293031/** * @param &#123;number[]&#125; nums1 * @param &#123;number[]&#125; nums2 * @return &#123;number[]&#125; */var intersect = function(nums1, nums2) &#123; let map1=new Map(); let map2=new Map(); let ans=[]; function count(nums,map)&#123; nums.forEach(value=&gt;&#123; if(!map.has(value))&#123; map.set(value,1); &#125; else &#123; map.set(value,map.get(value)+1); &#125; &#125;) &#125; count(nums1,map1); count(nums2,map2); map1.forEach((value,key)=&gt;&#123; if(map2.has(key))&#123; let num=value&gt;map2.get(key)?map2.get(key):value; for(let i=0;i&lt;num;i++)&#123; ans.push(key); &#125; &#125; &#125;) return ans;&#125;;]]></content>
      <categories>
        <category>leetcode题解与算法</category>
      </categories>
      <tags>
        <tag>哈希表</tag>
        <tag>双指针</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[二分查找]]></title>
    <url>AngelLikeFairy%2F2019%2F07%2F27%2F%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE%2F</url>
    <content type="text"><![CDATA[二分查找概述 二分查找的高效之处在于，每一步都可以去除当前区间中的一半元素，因此时间复杂度为O(logn) 严格递增序列的二分查找 输入：[1,2,3,7,9,11] , 3返回: 2 输入：[1,2,3,7,9,11] , 8返回：false 1234567891011121314151617function F(n,m)&#123; let left=0; let right=n.length-1; while(left&lt;=right)&#123; let mid=Math.floor((left+right)/2); if(m===n[mid])&#123; return mid; &#125; if(m&lt;n[mid])&#123; right=mid-1; &#125; else&#123; left=mid+1; &#125; &#125; return false;&#125; 在整体递增，局部重复的序列中二分查找第一个符合要求的元素位置 输入：[1,2,3,3,3,7,9,11],3返回: 2 输入：[1,2,3,3,3,7,9,11],8返回：false 123456789101112131415function F(n,m)&#123; let left=0; let right=n.length; while(left&lt;right)&#123; let mid=Math.floor((left+right)/2); //floor()函数，不大于当前数的最大数 if(m&lt;=n[mid])&#123; right=mid; &#125; else&#123; left=mid+1; &#125; &#125; if(n[left]===m) return left; else return false;&#125; 在整体递增，局部重复的序列中二分查找第一个大于给定元素的元素位置 输入：[1,2,3,3,3,7,9,11],3返回：5 输入：[1,2,3,3,3,7,9,11],4返回: ‘给定元素不存在’ 1234567891011121314151617function F(n,m)&#123; let left=0; let right=n.length-1; while(left&lt;right)&#123; let mid=Math.ceil((left+right)/2); //ceil()函数，不小于当前数的最小整数 if(m&gt;=n[mid])&#123; left=mid; &#125; else&#123; right=mid-1; &#125; &#125; if(n[right]===m) return right+1; else &#123; return ('给定元素不存在'); &#125;&#125; 求根号2的近似值 输入：0.00001 //精确度返回：(1.4142074584960938,1.414215087890625) 123456789101112131415function F(x)&#123; let left=1; let right=2; let num=Math.sqrt(2); while(right-left&gt;x)&#123; let mid=(left+right)/2; if(num&lt;mid)&#123; right=mid; &#125; if(num&gt;mid)&#123; left=mid; &#125; &#125; return `($&#123;left&#125;,$&#123;right&#125;)`&#125; 快速幂用于求解高次幂的快速求法比如2^10 基于二分的思想，又被称之为二分幂 快速幂基于以下原理： 如果b是奇数，那么有a^b=a*a^(b-1) 如果b是偶数，那么有a^b=(a^(b/2))*(a^(b/2)) 因此可以利用递归来求解快速幂 输入 2,10返回: 1024 123456789function F(a,n)&#123; if(n===0) return 1; if(n%2===1)&#123; return F(a,n-1)*a; &#125; else &#123; return F(a,n/2)*F(a,n/2); &#125;&#125;]]></content>
      <categories>
        <category>算法笔记</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[leetcode-852 山脉数组的峰顶索引]]></title>
    <url>AngelLikeFairy%2F2019%2F07%2F27%2Fleetcode-852%2F</url>
    <content type="text"><![CDATA[山脉数组的峰顶索引题目描述我们把符合下列属性的数组 A 称作山脉： A.length &gt;= 3 存在 0 &lt; i &lt; A.length - 1 使得A[0] &lt; A[1] &lt; … A[i-1] &lt; A[i] &gt; A[i+1] &gt; … &gt; A[A.length - 1] 给定一个确定为山脉的数组，返回任何满足 A[0] &lt; A[1] &lt; … A[i-1] &lt; A[i] &gt; A[i+1] &gt; … &gt; A[A.length - 1] 的 i 的值。 示例 1： 输入：[0,1,0]输出：1 示例 2： 输入：[0,2,1,0]输出：1 提示： 3&lt;= A.length &lt;= 10000 0&lt;= A[i] &lt;= 10^6 A是如上定义的山脉 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/peak-index-in-a-mountain-array著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 核心思路概述要找某个特定的值，都可以使用二分查找来提高效率 解题步骤 二分法查找山脉的下标 一开始设定left为0，right为A.length-1,mid为Math.floor((left+right)/2) 如果A[mid]&gt;A[mid+1]&amp;&amp;A[mid]&gt;A[mid-1],那么此时mid就是山脉的下标 如果A[mid]&lt;A[mid+1]，那么就说明山脉应该在mid的右边区间，故left=mid+1 如果A[mid]&gt;A[mid+1]，那么就说明山脉应该在mid的右边区间，故right=mid-1 Coding实现1234567891011121314151617181920/** * @param &#123;number[]&#125; A * @return &#123;number&#125; */var peakIndexInMountainArray = function(A) &#123; let left=0; let right=A.length-1; while(left&lt;=right)&#123; let mid=Math.floor((left+right)/2); if(A[mid]&gt;A[mid+1]&amp;&amp;A[mid]&gt;A[mid-1])&#123; return mid; &#125; else if(A[mid]&lt;A[mid+1])&#123; left=mid+1; &#125; else&#123; right=mid-1; &#125; &#125;&#125;; 时间复杂度时间复杂度为O(log2N);]]></content>
      <categories>
        <category>leetcode题解与算法</category>
      </categories>
      <tags>
        <tag>二分查找</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[leetcode-944 删列造序]]></title>
    <url>AngelLikeFairy%2F2019%2F07%2F26%2Fleetcode-944%2F</url>
    <content type="text"><![CDATA[删列造序题目描述给定由 N 个小写字母字符串组成的数组 A，其中每个字符串长度相等。 删除 操作的定义是：选出一组要删掉的列，删去 A 中对应列中的所有字符，形式上，第 n 列为 [A[0][n], A[1][n], …, A[A.length-1][n]]）。 比如，有 A = [“abcdef”, “uvwxyz”]， 要删掉的列为 {0, 2, 3}，删除后 A 为[“bef”, “vyz”]， A 的列分别为[“b”,”v”], [“e”,”y”], [“f”,”z”]。 你需要选出一组要删掉的列 D，对 A 执行删除操作，使 A 中剩余的每一列都是 非降序 排列的，然后请你返回 D.length 的最小可能值。 示例 1： 输入：[“cba”, “daf”, “ghi”]输出：1解释：当选择 D = {1}，删除后 A 的列为：[“c”,”d”,”g”] 和 [“a”,”f”,”i”]，均为非降序排列。若选择 D = {}，那么 A 的列 [“b”,”a”,”h”] 就不是非降序排列了。 示例 2： 输入：[“a”, “b”]输出：0解释：D = {} 示例 3： 输入：[“zyx”, “wvu”, “tsr”]输出：3解释：D = {0, 1, 2} 提示： 1&lt;= A.length &lt;= 100 1&lt;= A[i].length &lt;= 1000 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/delete-columns-to-make-sorted著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 核心思路概述题目要求得到删去列数的最小值来使剩余的每一列都是非降序的，那么对于贪心思想，只要找到某些列存在降序的删除即可，而无需删除那些已经是非降序的列 解题步骤 根据数组第一个字符串元素长度来确认列数 根据列数，遍历每一个字符串中的那一列 如果某一列存在降序则将ans加1 返回ans Coding实现12345678910111213141516/** * @param &#123;string[]&#125; A * @return &#123;number&#125; */var minDeletionSize = function(A) &#123; let ans=0; for(let i=0;i&lt;A[0].length;i++)&#123; for(let k=0;k&lt;A.length-1;k++)&#123; if(A[k+1][i].charCodeAt()-A[k][i].charCodeAt()&lt;0)&#123; ans++; break; &#125; &#125; &#125; return ans; &#125;;]]></content>
      <categories>
        <category>leetcode题解与算法</category>
      </categories>
      <tags>
        <tag>贪心</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[贪心]]></title>
    <url>AngelLikeFairy%2F2019%2F07%2F26%2F%E8%B4%AA%E5%BF%83%2F</url>
    <content type="text"><![CDATA[##简单贪心 贪心法是求解一类最优化问题的方法，它总是考虑在当前状态下局部最优（或较优）的策略，来使全局的结果达到最优（或较优） 简单来说，也就是，在对问题求解时，总是做出在当前看来是最好的选择。 贪心算法的基本思路 将求解的问题分成若干子问题 对于每一个子问题，考虑得到该子问题的局部最优解 把所有子问题的局部最优解合成一个原问题的解 贪心算法的适用前提和问题 局部最优解能够影响全局最优解 贪心算法得到的不一定就是问题的最优解 贪心算法题目设有n个正整数，将它们连接成一排，组成一个最大的多位整数。 例如：n=3时，3个整数13，312，343，连成的最大整数为34331213。又如：n=4时，4个整数7，13，4，246，连成的最大整数为7424613。 输入：nN个数输出：连成的多位数 思路因为要得到最大的正整数，那么高位数据越大则值越大。因此，使用贪心算法，每次选值的时候优先选择最高位最大的，如若相同，则比较次高位，直到选出较优值 因此，通过这个思路，比较高位可以利用字符串UniCode码来比较，比如’7’&gt;’432’ js的sort()函数可以完美解决，利用sort函数对输入值由高到低进行排序，最后转化为数值进行返回 Coding实现123function F(n)&#123; return parseInt(n.sort().reverse().join(''));&#125; 区间贪心]]></content>
      <categories>
        <category>算法笔记</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[排序]]></title>
    <url>AngelLikeFairy%2F2019%2F07%2F25%2F%E6%8E%92%E5%BA%8F%2F</url>
    <content type="text"><![CDATA[选择排序定义选择排列是指，对一个序列A中的元素，令i从0到n-1枚举，进行n趟操作，每趟从待排序部分（i+1,n）中选择最小的元素，令其与待排序部分的第一个元素A[i]进行交换，这样在n趟操作后，所有元素都会是有序的 动图演示 Coding实现1234567891011121314function selectSort(n)&#123; for(let i=0;i&lt;n.length-1;i++)&#123; let min=i; for(let k=i;k&lt;n.length;k++)&#123; if(n[k]&lt;n[min])&#123; min=k; &#125; &#125; let temp=n[min]; n[min]=n[i]; n[i]=temp; &#125; return n;&#125; 插入排序直接插入排序定义直接插入排序是指，对序列A的n个元素A[0]到A[n-1],令n从1到n-1枚举，进行n-1趟操作。每一趟排序时，该待排列元素之前的所有元素已经是有序的，则在该有序队列中寻找一个位置进行插入，使得该序列依旧有序 动图演示 Coding实现1234567891011function insertionSort(n)&#123; for(let i=1;i&lt;n.length;i++)&#123; let num=n[i]; while(num&lt;n[i-1])&#123; n[i]=n[i-1]; i--; &#125; n[i]=num; &#125; return n;&#125; 折半插入排序定义 有一组数据待排序，排序区间为Array[0] ~ Array[n-1]。将数据分为有序数据和无序数据，第一次排序时默认Array[0]为有序数据，Array[1]~Array[n-1]为无序数据。有序数据分区的第一个元素位置为low，最后一个元素的位置为high。 遍历无序区间的所有元素，每次取无序区间的第一个元素Array[i]，因为0 ~ i-1是有序排列的，所以用中点m将其平分为两部分，然后将待排序数据同中间位置为m的数据进行比较，若待排序数据较大，则low ~ m-1分区的数据都比待排序数据小，反之，若待排序数据较小，则m+1 ~ high分区的数据都比 待排序数据大，此时将low或high重新定义为新的合适分区的边界，对新的小分区重复上面操作。直到low和high 的前后顺序改变，此时high+1所处位置为待排序数据的合适位置。 作者：weixin_42245157来源：CSDN原文：https://blog.csdn.net/weixin_42245157/article/details/80458542版权声明：本文为博主原创文章，转载请附上博文链接！ Coding实现123456789101112131415161718192021function BinaryInsertSortup(n)&#123; for(let i=1;i&lt;n.length;i++)&#123; let low=0; let high=i-1; let num=n[i]; while(low&lt;=high)&#123; let mid=Math.floor((low+high)/2); if(num&lt;n[mid])&#123; high=mid-1; &#125; else&#123; low=mid+1; &#125; &#125; for(k=i;k&gt;low;k--)&#123; n[k]=n[k-1]; &#125; n[k]=num; &#125; return n;&#125; 冒泡排序定义冒泡排序旨在每次冒泡一个最大或最小的元素到顶端，因此需遍历n次。（若冒泡较大元素）则每次遍历，比较相邻两个元素大小，若底部元素（数组下标较小）大于其相邻顶部元素，则两元素交换位置，直至最大的元素冒泡到最顶端 动图演示 Coding实现12345678910111213141516function bubbleSort(n)&#123; let flag; do&#123; flag=0; for(let i=0;i&lt;n.length;i++)&#123; let temp; if(n[i]&gt;n[i+1])&#123; temp=n[i]; n[i]=n[i+1]; n[i+1]=temp; flag=1; &#125; &#125; &#125;while(flag===1) return n;&#125; 归并排序定义归并排序是一种基于归并思想的排序方法。 实现思路： 将序列分成Math.ceil(n/2)个组，组内单独排序 将这些组两两归并，这样就会变成Math.ceil(n/4)个组，组内再单独排序 以此类推，直到最后只剩下一个组为止 Coding实现1234567891011121314151617181920212223242526272829303132333435363738394041function mergeSort(arr) &#123; const length = arr.length; if (length === 1) &#123; //递归算法的停止条件，即为判断数组长度是否为1 return arr; &#125; const mid = Math.floor(length / 2); const left = arr.slice(0, mid); const right = arr.slice(mid, length); return merge(mergeSort(left), mergeSort(right)); //要将原始数组分割直至只有一个元素时，才开始归并&#125;function merge(left, right) &#123; const result = []; let il = 0; let ir = 0; //left, right本身肯定都是从小到大排好序的 while( il &lt; left.length &amp;&amp; ir &lt; right.length) &#123; if (left[il] &lt; right[ir]) &#123; result.push(left[il]); il++; &#125; else &#123; result.push(right[ir]); ir++; &#125; &#125; //不可能同时存在left和right都有剩余项的情况, 要么left要么right有剩余项, 把剩余项加进来即可 while (il &lt; left.length) &#123; result.push(left[il]); il++; &#125; while(ir &lt; right.length) &#123; result.push(right[ir]); ir++; &#125; return result;&#125; 快速排序定义快速排序是排序算法中平均时间复杂度为O(logn)的一种算法。 其主要步骤为 调整序列中的元素，使得当前序列的第一个元素在调整后所处的位置的左侧元素都小于等于它，在右侧的位置都大于它 对该元素的左侧和右侧区间分别进行递归操作 Coding实现123456789101112131415161718function quickSort&lt;T&gt;(arr: Array&lt;T&gt;): Array&lt;T&gt; &#123; if(arr.length === 0) return []; let leftArr = [],rightArr = []; for(let i=1;i&lt;arr.length;i++) &#123; if(arr[i]&lt;=arr[0]) leftArr.push(arr[i]); else rightArr.push(arr[i]); &#125; return quickSort&lt;T&gt;(leftArr).concat([arr[0]],quickSort&lt;T&gt;(rightArr));&#125;console.log(quickSort&lt;number&gt;([4,4,14,783,22,11,99,3,2,7,89,134])); /* [ 2, 3, 4, 4, 7, 11, 14, 22, 89, 99, 134, 783 ]*/ 时间复杂度分析]]></content>
      <categories>
        <category>算法笔记</category>
      </categories>
      <tags>
        <tag>排序</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[leetcode-1002 查找常用字符]]></title>
    <url>AngelLikeFairy%2F2019%2F07%2F24%2Fleetcode-1002%2F</url>
    <content type="text"><![CDATA[查找常用字符题目描述给定仅有小写字母组成的字符串数组 A，返回列表中的每个字符串中都显示的全部字符（包括重复字符）组成的列表。例如，如果一个字符在每个字符串中出现 3 次，但不是 4 次，则需要在最终答案中包含该字符 3 次。 你可以按任意顺序返回答案。 示例 1： 输入：[“bella”,”label”,”roller”]输出：[“e”,”l”,”l”] 示例 2： 输入：[“cool”,”lock”,”cook”]输出：[“c”,”o”] 提示： 1&lt;= A.length &lt;= 100 1&lt;= A[i].length &lt;= 100 A[i][j] 是小写字母 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/find-common-characters著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 核心思路概述统计每个字符串中字符的出现个数，返回出现相同字符的最少个数字符 解题步骤 建立哈希表A，存储第一个字符串个字符的出现次数 遍历后面的字符串，在每个循环中建立新的哈希表，存储该字符串中第一个字符串所有字符的个数；比较新哈希表与步骤1建立的哈希表A，更新A哈希表中的键值为两者较小值 遍历A哈希表，存储value次key到ans数组并返回 Coding实现12345678910111213141516171819202122232425262728293031323334353637383940/** * @param &#123;string[]&#125; A * @return &#123;string[]&#125; */var commonChars = function(A) &#123; let map=new Map(); let ans=[]; for(let i=0;i&lt;A[0].length;i++)&#123; if(!map.has(A[0][i]))&#123; map.set(A[0][i],1); &#125; else &#123; map.set(A[0][i],map.get(A[0][i])+1); &#125; &#125; for(let i=1;i&lt;A.length;i++)&#123; let mapEve=new Map(); map.forEach((value,key)=&gt;&#123; mapEve.set(key,0); &#125;) for(let k=0;k&lt;A[i].length;k++)&#123; if(map.has(A[i][k]))&#123; mapEve.set(A[i][k],mapEve.get(A[i][k])+1); &#125; &#125; map.forEach((value,key)=&gt;&#123; if(value&gt;mapEve.get(key))&#123; map.set(key,mapEve.get(key)); &#125; &#125;) &#125; map.forEach((value,key)=&gt;&#123; if(value&gt;0)&#123; for(let i=0;i&lt;value;i++)&#123; ans.push(key); &#125; &#125; &#125;); return ans;&#125;;]]></content>
      <categories>
        <category>leetcode题解与算法</category>
      </categories>
      <tags>
        <tag>哈希表</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[递归与分治]]></title>
    <url>AngelLikeFairy%2F2019%2F07%2F24%2F%E9%80%92%E5%BD%92%E4%B8%8E%E5%88%86%E6%B2%BB%2F</url>
    <content type="text"><![CDATA[分治分治的全称为“分而治之”。分治法将原问题划分为若干个规模较小而结构与原问题相同或类似的子问题，然后分别解决这些子问题，最后合并子问题的解，即可得到原问题的解 减治、分治 一般把子问题个数为1的情况称为减治（例如对n!的求解） 123456function F(n)&#123; if(n===1) return 1; else &#123; return F(n-1)*n; &#125;&#125; 子问题个数大于1的情况称为分治（例如对Fibonacci数列的求解） 1234function F(n)&#123; if(n===1||n===0) return 1; else return F(n-1)+F(n-2);&#125; 递归 递归适合用来实现分治思想 递归的两个核心概念 递归边界 递归式（递归调用） 对于n!的求解，可以很容易的到F(n)=F(n-1)*n ;这就是递归式而F(1)=1; 这是递归的边界 分治思想的应用全排列n皇后问题]]></content>
      <categories>
        <category>算法笔记</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[leetcode-349 两个数组的交集]]></title>
    <url>AngelLikeFairy%2F2019%2F07%2F23%2Fleetcode-349%2F</url>
    <content type="text"><![CDATA[两个数组的交集题目描述给定两个数组，编写一个函数来计算它们的交集。 示例 1: 输入: nums1 = [1,2,2,1], nums2 = [2,2]输出: [2] 示例 2: 输入: nums1 = [4,9,5], nums2 = [9,4,9,8,4]输出: [9,4] 说明: 输出结果中的每个元素一定是唯一的。我们可以不考虑输出结果的顺序。 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/intersection-of-two-arrays著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 核心思路概述将两个数组都去重后，比较另一个数组是否包含这个数组的某些元素，返回即可 解题步骤 使用set将两个数组去重 比较去重后的两个数组的大小，遍历较小的那个数组，查看另一个数组是否includes这个数组中的某些元素，有则添加到ans数组返回 Coding实现12345678910111213141516171819/** * @param &#123;number[]&#125; nums1 * @param &#123;number[]&#125; nums2 * @return &#123;number[]&#125; */var intersection = function(nums1, nums2) &#123; let ans=[]; nums1=[...new Set(nums1)]; nums2=[...new Set(nums2)]; function inter(nums1,nums2)&#123; nums1.forEach(value=&gt;&#123; if(nums2.includes(value))&#123; ans.push(value); &#125; &#125;) &#125; nums1.length&gt;nums2.length?inter(nums2,nums1):inter(nums1,nums2); return ans;&#125;;]]></content>
      <categories>
        <category>leetcode题解与算法</category>
      </categories>
      <tags>
        <tag>数组</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[leetcode-961 重复 N 次的元素]]></title>
    <url>AngelLikeFairy%2F2019%2F07%2F23%2Fleetcode-961%2F</url>
    <content type="text"><![CDATA[重复 N 次的元素题目描述在大小为 2N 的数组 A 中有 N+1 个不同的元素，其中有一个元素重复了 N 次。 返回重复了 N 次的那个元素。 示例 1： 输入：[1,2,3,3]输出：3 示例 2： 输入：[2,1,2,5,3,2]输出：2 示例 3： 输入：[5,1,5,2,5,3,5,4]输出：5 提示： 4 &lt;= A.length &lt;= 100000 &lt;= A[i] &lt; 10000A.length 为偶数 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/n-repeated-element-in-size-2n-array著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 核心思路概述因为该数组大小为2N，其中由N+1个不同的元素，并且有一个元素重复了N次，那么剩余的N个数都是不同的 所以题目可转化为返回有重复的那个数 解题步骤 建立哈希表 遍历给定数组，若哈希表中没有该键名，则加入哈希表；若有，则直接返回该数组元素 Coding实现123456789101112131415/** * @param &#123;number[]&#125; A * @return &#123;number&#125; */var repeatedNTimes = function(A) &#123; let map=new Map(); for(let i=0;i&lt;A.length;i++)&#123; if(!map.has(A[i]))&#123; map.set(A[i],0); &#125; else&#123; return A[i]; &#125; &#125;&#125;;]]></content>
      <categories>
        <category>leetcode题解与算法</category>
      </categories>
      <tags>
        <tag>哈希表</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[leetcode-500 键盘行]]></title>
    <url>AngelLikeFairy%2F2019%2F07%2F23%2Fleetcode-500%2F</url>
    <content type="text"><![CDATA[键盘行题目描述 给定一个单词列表，只返回可以使用在键盘同一行的字母打印出来的单词。键盘如下图所示。 示例： 输入: [“Hello”, “Alaska”, “Dad”, “Peace”]输出: [“Alaska”, “Dad”] 注意： 你可以重复使用键盘上同一字符。你可以假设输入的字符串将只包含字母。 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/keyboard-row著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 核心思路概述利用哈希表,分别即字母为键名，字母所在行号为键值建立哈希表。遍历给定字符串，若字符串的所有字符的所在哈希表的键值都一样，则说明该字符串的字符都在同一行上 解题步骤 建立哈希表以及键盘字符数组 将每个字符以字符为键名，字符所在行号为键值建立哈希表。 遍历题目给定字符串数组，若每个字符串中的字符在哈希表中的键值都一样，则将该字符串加入到要返回的数组中 遍历字符串方法：先得到字符串的第一个字符的所在行号，接着循环得到后面的字符的行号，若不一样则直接退出该循环 注意 将所有字符都转换为小写形式再去得到字符的键值 Coding实现123456789101112131415161718192021222324252627282930313233/** * @param &#123;string&#125; J * @param &#123;string&#125; S * @return &#123;number&#125; *//** * @param &#123;string[]&#125; words * @return &#123;string[]&#125; */var findWords = function(words) &#123; const str=['qwertyuiop','asdfghjkl','zxcvbnm']; let ans=[]; let map=new Map(); str.forEach((value,index)=&gt;&#123; for(let i=0;i&lt;value.length;i++)&#123; map.set(value[i],index+1); &#125; &#125;); words.forEach(value=&gt;&#123; let flag=0; let first=map.get(value[0].toLowerCase()); for(let i=1;i&lt;value.length;i++)&#123; if(map.get(value[i].toLowerCase())!=first)&#123; flag=1; break; &#125; &#125; if(flag===0)&#123; ans.push(value); &#125; &#125;) return ans;&#125;;]]></content>
      <categories>
        <category>leetcode题解与算法</category>
      </categories>
      <tags>
        <tag>哈希表</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[散列]]></title>
    <url>AngelLikeFairy%2F2019%2F07%2F22%2F%E6%95%A3%E5%88%97%2F</url>
    <content type="text"><![CDATA[散列的定义 简单来说：就是将某个元素通过一个函数转换为整数，使得该整数可以尽量唯一地代表这个元素 常用的散列函数 直接定址法 直接把key值作为哈希表的下标 平方取中法 取key的平方的中间若干位作为哈希表的下标 除留余数法（常用） 指把key除以一个数得到的余数作为hash值的方法 冲突处理 线性探查法 如果该hash值已经被占用，那么就不断检查下一个位置，直到找到没被占用的。如果检查过程中超过了表长，则返回到哈希表的首位继续循环查找，或是发现所有的位置都被占用 该方法容易造成扎堆现象，即表中的若干个连续位置都被使用 平方探查法 按照下列的顺序进行探查： H(key)+1^2,H(key)-1^2, H(key)+2^2,H(key)-2^2, H(key)+3^2,H(key)-3^2, … … 如果，检查过程中H(key)+k^2超过了表长Tsize，那么就把(H(key)+k^2) % Tsize 作为hash值 链地址法 链地址法不计算新的hash值，而是把所有H(key)相同的key连接成一条单链表 字符串hash字符串hash是指将字符串S映射为一个整数，使得该整数尽可能唯一地代表该字符串 假设字符串只由AZ构成，那么可以将AZ映射为0~25；比如，ABC则就可以看作是012。显然，与二进制类似，我们可以把其看作为26进制，再将其转化为10进制，即可得到该字符串唯一地hash映射。 代码 1234567const hashFunc(str,length)&#123; let hash=0; for(let i=0;i&lt;length;i++)&#123; hash=hash*26+str[i].charCodeAt()-'A'.charCodeAt(); &#125; return hash;&#125; 如果外加有小写字母，则就是52进制转换若还有数字，则就是62进制转换 一些散列表算法题散列表相关算法题]]></content>
      <categories>
        <category>算法笔记</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[leetcode-771 宝石与石头]]></title>
    <url>AngelLikeFairy%2F2019%2F07%2F22%2Fleetcode-771%2F</url>
    <content type="text"><![CDATA[宝石与石头题目描述 给定字符串J 代表石头中宝石的类型，和字符串 S代表你拥有的石头。 S 中每个字符代表了一种你拥有的石头的类型，你想知道你拥有的石头中有多少是宝石。 J 中的字母不重复，J 和 S中的所有字符都是字母。字母区分大小写，因此”a”和”A”是不同类型的石头。 示例 1: 输入: J = “aA”, S = “aAAbbbb”输出: 3 示例 2: 输入: J = “z”, S = “ZZ”输出: 0 注意: S 和 J 最多含有50个字母。 J 中的字符不重复。 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/jewels-and-stones著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 核心思路概述利用哈希表，遍历宝石类型字符串，建立以宝石类型为键名，宝石数量为值的哈希表。哈希表中的所有键值之和就是所拥有的宝石的数量。 解题步骤 建立哈希表，声明所拥有的宝石数量为ans=0 遍历J字符串，以字符为键名，0为键值建立哈希表 遍历S字符串，若哈希表中存在该键名，则ans++ 返回ans Coding实现123456789101112131415161718/** * @param &#123;string&#125; J * @param &#123;string&#125; S * @return &#123;number&#125; */var numJewelsInStones = function(J, S) &#123; let map=new Map(); let ans=0; for(let i=0;i&lt;J.length;i++)&#123; map.set(J[i],0); &#125;; for(let i=0;i&lt;S.length;i++)&#123; if(map.has(S[i]))&#123; ans++; &#125; &#125; return ans;&#125;;]]></content>
      <categories>
        <category>leetcode题解与算法</category>
      </categories>
      <tags>
        <tag>哈希表</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[leetcode-219 存在重复元素 II]]></title>
    <url>AngelLikeFairy%2F2019%2F07%2F21%2Fleetcode-219%2F</url>
    <content type="text"><![CDATA[存在重复元素 II题目描述给定一个整数数组和一个整数 k，判断数组中是否存在两个不同的索引 i 和 j，使得 nums [i] = nums [j]，并且 i 和 j 的差的绝对值最大为 k。 示例 1: 输入: nums = [1,2,3,1], k = 3输出: true 示例 2: 输入: nums = [1,0,1,1], k = 1输出: true 示例 3: 输入: nums = [1,2,3,1,2,3], k = 2输出: false 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/contains-duplicate-ii著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 核心思路概述利用哈希表，存储以值为键，下标为键值的哈希表。当某个键值需要更新时，比较当前下标与键值的差值是否小于题目给定值，若是则返回true; 解题步骤 建立哈希表 当以当前数组元素的值为键名的键不存在时，则以值为键，下标为键值添加到哈希表中。若存在，则比较当前下标与键值的差值是否小于题目给定值，若是则返回true; Coding实现1234567891011121314151617181920/** * @param &#123;number[]&#125; nums * @param &#123;number&#125; k * @return &#123;boolean&#125; */var containsNearbyDuplicate = function(nums, k) &#123; let map = new Map(); return nums.some((value, index) =&gt; &#123; if (!map.has(value)) &#123; map.set(value, index); &#125; else &#123; if (index - map.get(value) &lt;= k) &#123; return true; &#125; else &#123; map.set(value, index); &#125; &#125; return false; &#125;);&#125;;]]></content>
      <categories>
        <category>leetcode题解与算法</category>
      </categories>
      <tags>
        <tag>哈希表</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[leetcode-217 存在重复元素]]></title>
    <url>AngelLikeFairy%2F2019%2F07%2F20%2Fleetcode-217%2F</url>
    <content type="text"><![CDATA[存在重复元素题目描述给定一个整数数组，判断是否存在重复元素。 如果任何值在数组中出现至少两次，函数返回 true。如果数组中每个元素都不相同，则返回 false。 示例 1: 输入: [1,2,3,1]输出: true 示例 2: 输入: [1,2,3,4]输出: false 示例 3: 输入: [1,1,1,3,3,4,3,2,4,2]输出: true 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/contains-duplicate著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 核心思路概述将该数组去重之后的元素个数与原数组长度进行比较，不一样则有重复； 解题步骤 建立set集合，用于数组去重 将set集合的size与数组长度进行比较 不相同则有重复,返回true;反之,false Coding实现123456789/** * @param &#123;number[]&#125; nums * @return &#123;boolean&#125; */var containsDuplicate = function(nums) &#123; let set=new Set(nums); if(set.size===nums.length) return false; else return true;&#125;;]]></content>
      <categories>
        <category>leetcode题解与算法</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[leetcode-206 反转链表]]></title>
    <url>AngelLikeFairy%2F2019%2F07%2F19%2Fleetcode-206%2F</url>
    <content type="text"><![CDATA[反转链表题目描述反转一个单链表。 示例: 输入: 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL输出: 5-&gt;4-&gt;3-&gt;2-&gt;1-&gt;NULL 进阶:你可以迭代或递归地反转链表。你能否用两种方法解决这道题？ 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/reverse-linked-list著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 核心思路概述将链表所有的元素取出并倒序放到数组，按照数组元素创建新链表并返回 解题步骤 遍历链表，并将数组元素unshift入数组 按照数组元素添加节点到新创建的链表上 Coding实现12345678910111213141516171819202122232425/** * Definition for singly-linked list. * function ListNode(val) &#123; * this.val = val; * this.next = null; * &#125; *//** * @param &#123;ListNode&#125; head * @return &#123;ListNode&#125; */var reverseList = function(head) &#123; let newList=new ListNode(0); let newHead=newList; let numArray=[]; while(head)&#123; numArray.unshift(head.val); head=head.next; &#125; numArray.forEach(value=&gt;&#123; newHead.next=new ListNode(value); newHead=newHead.next; &#125;) return newList.next;&#125;;]]></content>
      <categories>
        <category>leetcode题解与算法</category>
      </categories>
      <tags>
        <tag>链表</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[leetcode-205 同构字符串]]></title>
    <url>AngelLikeFairy%2F2019%2F07%2F18%2Fleetcode-205%2F</url>
    <content type="text"><![CDATA[同构字符串题目描述给定两个字符串 s 和 t，判断它们是否是同构的。 如果 s 中的字符可以被替换得到 t ，那么这两个字符串是同构的。 所有出现的字符都必须用另一个字符替换，同时保留字符的顺序。两个字符不能映射到同一个字符上，但字符可以映射自己本身。 示例 1: 输入: s = “egg”, t = “add”输出: true 示例 2: 输入: s = “foo”, t = “bar”输出: false 示例 3: 输入: s = “paper”, t = “title”输出: true 说明:你可以假设 s 和 t 具有相同的长度。 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/isomorphic-strings著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 核心思路概述解法1利用哈希表进行映射，两个字符串相互映射 解法2对比两个字符串对应位置的字符在字符串内第一次出现的位置，若不同则返回false 解题步骤解法1 建立哈希映射函数，若哈希表中没有该键值对，则插入表中；若有，则比较值是否相同，不同则返回fasle 两个字符串依次使用哈希映射函数进行比较 解法2 同时遍历两字符串，若当前字符的第一次出现的位置不相同则返回false Coding实现解法1123456789101112131415161718192021222324252627/** * @param &#123;string&#125; s * @param &#123;string&#125; t * @return &#123;boolean&#125; */function match(map,s,t)&#123; for(let i=0;i&lt;s.length;i++)&#123; if(!map.has(s[i]))&#123; map.set(s[i],t[i]); &#125; else&#123; if(map.get(s[i])!=t[i])&#123; return false; &#125; &#125; &#125; return true;&#125;var isIsomorphic = function(s, t) &#123; s=s.split(''); t=t.split(''); let map=new Map(); if(!match(map,s,t)) return false; map.clear(); return match(map,t,s);&#125;; 解法2123456789101112/** * @param &#123;string&#125; s * @param &#123;string&#125; t * @return &#123;boolean&#125; */var isIsomorphic = function(s, t) &#123; for (let i = 0; i &lt; s.length; i++) &#123; if (s.indexOf(s[i]) !== t.indexOf(t[i])) return false; &#125; return true;&#125;]]></content>
      <categories>
        <category>leetcode题解与算法</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[leetcode-204 计数质数]]></title>
    <url>AngelLikeFairy%2F2019%2F07%2F17%2Fleetcode-204%2F</url>
    <content type="text"><![CDATA[计数质数题目描述统计所有小于非负整数 n 的质数的数量。 示例: 输入: 10输出: 4解释: 小于 10 的质数一共有 4 个, 它们是 2, 3, 5, 7 。 核心思路概述质数的定义 质数又称素数。一个大于1的自然数，除了1和它自身外，不能被其他自然数整除的数叫做质数；否则称为合数。 此题的基本解法即为遍历给定数之前的数，若为质数则计数加一 解题步骤 建立一个函数用来判断当前数是否为质数 对于1中的函数质数判断条件，若在1~开根号n的左开右闭的区间内无法被整除，那么该数即为质数。 遍历给定数之前的数，若为质数则计数加一 Coding实现1234567891011121314151617181920212223/** * @param &#123;number&#125; n * @return &#123;number&#125; */const checkPrimes=function(n)&#123; if(n===2) return true; if(n===1) return false; if(n%2===1)&#123; for(let i=1;i&lt;=Math.sqrt(n);i=i+2)&#123; if(n%i===0&amp;&amp;i!==1) return false; &#125; return true; &#125;&#125;var countPrimes = function(n) &#123; let count=0; for(let i=2;i&lt;n;i++)&#123; if(checkPrimes(i))&#123; count++; &#125; &#125; return count;&#125;;]]></content>
      <categories>
        <category>leetcode题解与算法</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[leetcode-203 移除链表元素]]></title>
    <url>AngelLikeFairy%2F2019%2F07%2F16%2Fleetcode-203%2F</url>
    <content type="text"><![CDATA[移除链表元素题目描述删除链表中等于给定值 val 的所有节点。 示例: 输入: 1-&gt;2-&gt;6-&gt;3-&gt;4-&gt;5-&gt;6, val = 6输出: 1-&gt;2-&gt;3-&gt;4-&gt;5 核心思路概述此题为单链表删除指定元素 解题步骤单独考虑头节点（因为头节点之前没有节点） 考虑头节点即为指定需删除元素，那么应当将头指针指向下一个元素。循环检验，当头节点不是指定需删除元素时则退出循环 若步骤1之后，该链表为空链表则直接返回该空链表 1、2步骤之后，当前链表则为头节点不为指定需删除元素的非空链表。遍历当前链表，设置pre和cur指针方便删除链表节点。 设置虚拟头节点（指向头节点的节点） 创建新节点指向当前头节点 遍历该链表，删除指定元素 返回以创建的新节点的下一个节点为头节点所在的链表 Coding实现单独处理头节点的Coding1234567891011121314151617181920212223242526272829/** * Definition for singly-linked list. * function ListNode(val) &#123; * this.val = val; * this.next = null; * &#125; *//** * @param &#123;ListNode&#125; head * @param &#123;number&#125; val * @return &#123;ListNode&#125; */var removeElements = function(head, val) &#123; while(head&amp;&amp;head.val===val)&#123; head=head.next &#125; if(head===null) return head; let cur=head; let pre=head; while(cur.next)&#123; pre=cur; cur=cur.next; if(cur.val===val)&#123; pre.next=cur.next; cur=pre; &#125; &#125; return head;&#125;; 设置指向头节点的指针节点的Coding12345678910111213141516171819202122232425/** * Definition for singly-linked list. * function ListNode(val) &#123; * this.val = val; * this.next = null; * &#125; *//** * @param &#123;ListNode&#125; head * @param &#123;number&#125; val * @return &#123;ListNode&#125; */var removeElements = function(head, val) &#123; let listNode=new ListNode(val-1); listNode.next=head; let list=listNode; while(list.next)&#123; if(list.next.val===val)&#123; list.next=list.next.next; continue; &#125; list=list.next; &#125; return listNode.next;&#125;;]]></content>
      <categories>
        <category>leetcode题解与算法</category>
      </categories>
      <tags>
        <tag>链表</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[leetcode-202 快乐数]]></title>
    <url>AngelLikeFairy%2F2019%2F07%2F15%2Fleetcode-202%2F</url>
    <content type="text"><![CDATA[快乐数题目描述编写一个算法来判断一个数是不是“快乐数”。 一个“快乐数”定义为：对于一个正整数，每一次将该数替换为它每个位置上的数字的平方和，然后重复这个过程直到这个数变为 1，也可能是无限循环但始终变不到 1。如果可以变为 1，那么这个数就是快乐数。 示例: 输入: 19输出: true解释: 12 + 92 = 8282 + 22 = 6862 + 82 = 10012 + 02 + 02 = 1 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/happy-number著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 核心思路概述 正面解题，寻找快乐数。当重复过程变为1则为快乐数，若当循环过程中得到的数与之前出现过的数相重复，则表示之后会在这两数之间无限循环，此时即可返回false. 快慢指针解法：使用快慢指针来判断该循环是否为无限死循环。 解题步骤正面解题法(遇到重复数字则退出) 若输入为1，则直接返回true 设置set集合用来存储循环过程中得到的数 进入do-while循环，将参数转化为数组，利用reduce函数进行平方和累加，判断该得到的数是否存在于set集合中，若存在则返回false，否则则将该数放入set集合中。同时,若该数为1则返回true退出函数快慢指针法 设置两个指针，一个指针移动较快，一个指针移动较慢，若两指针相遇，则代表该循环中存在死循环，则应退出该函数。Coding实现正面解题的Coding12345678910111213141516var isHappy = function(n) &#123; if(n===1) return true; let arr; let set=new Set([n]); do&#123; arr=n.toString().split(''); n=arr.reduce((pre,value)=&gt;&#123; return pre+Math.pow(parseInt(value),2) &#125;,0); if(set.has(n))&#123; return false; &#125; set.add(n); &#125;while(n!=1) return true;&#125;; 递归法的Coding12]]></content>
      <categories>
        <category>leetcode题解与算法</category>
      </categories>
      <tags>
        <tag>快慢指针</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[var、let与const的比较以及作用域]]></title>
    <url>AngelLikeFairy%2F2019%2F07%2F15%2Fvar%E3%80%81let%E4%B8%8Econst%2F</url>
    <content type="text"><![CDATA[var、let与const的比较以及作用域 var、let与const的比较 \ var let const 变量提升机制 有 无 无 重声明 允许 在同个作用域下禁止,不同作用域下允许 同let 能否更改 允许 允许 不允许 初始化 可以不用 可以不用 必须 const的一些注意点 const不允许修改基本类型值，但是允许修改对象的属性值（没有修改对象的绑定）；123456789101112(function test()&#123; const person = &#123; a:1 &#125; console.log(person.a); // 1 person.a=2; console.log(person.a); // 2 person=&#123; a:3 &#125; console.log(person.a); // 报错： 不允许修改使用const声明的对象的绑定&#125;)() 预编译与词法分析预编译 JS引擎会在正式执行代码之前进行一次”预编译“，预编译简单理解就是在内存中开辟一些空间，存放一些变量和函数。 具体步骤 页面创建全局对象（Global Object）对象（window对象）。 加载第一个脚本文件 脚本加载完毕后，进行语法分析。 开始预编译 查找函数声明，作为GO属性，值赋予函数体（函数声明优先） 查找变量声明（除了函数内部的），作为GO属性，值赋予undefined 若函数声明与变量声明同名，则函数声明会优先于变量声明。具体来说即是1. 函数声明替换变量声明 2. 后面的函数声明替换前面的函数声明 3. 后面的变量声明无效 例如 1234567console.log(a); //[function: a]a(); //hellofunction a()&#123; console.log('hello');&#125;var a=1;console.log(a); //1 词法分析 创建AO活动对象（Active Object 每个执行环境都有一个与之对应的活动对象） 查找形参和变量声明，值赋予undefined 实参值赋给形参 查找函数声明，值赋给函数体 解释执行函数中的代码 提升机制对于用var定义的变量会被提升到当前作用域的顶端并赋值为undefined123console.log(a); //undefinedvar a='hello';console.log(a); //hello 函数声明整体提升1234a(); //hellofunction a()&#123; console.log('hello');&#125; 123456console.log(a); //undefineda(); //报错：a is not a functionvar a=function()&#123; /*遇见var a= 会直接将a当作一个变量提升并赋值为undefined;*/console.log('hello');&#125; 123456console.log(a); /*报错：Cannot access 'a' before initialization*/a(); let a=function()&#123; /*这里为let a= ,不会有变量提升机制*/console.log('hello');&#125; 块级声明与块级作用域块级作用域存在于： 1.函数内部2.块中（{ }之间的区域） 注意： 只有使用let和const声明（const与let都是块级标识符），块语句（{ } 比如for循环语句和if判断语句）才会将快语句中声明的变量限制在该块级作用域；而使用var声明则不会 例如 12345678910111213(function test()&#123; console.log(a); // undefined if(true)&#123; var a=1; &#125;&#125;)()(function test()&#123; console.log(a); //报错：a is not defined if(true)&#123; let a=1; &#125;&#125;)() let声明不会被提升 用let声明变量，会将变量的作用域限制在当前代码块中（即块级作用域）;因此块级作用域外部无法访问 禁止重声明同一作用域中不能使用let来重复定义已经存在的标识符 1234(function test()&#123; var a=1; let a=2; // Identifier 'a' has already been declared&#125;)() 但是在不同作用域下声明同名变量是没有问题的，因为不同作用域之间的变量是没有关系的。内部作用域的变量会遮蔽外部作用域的同名变量 12345678(function test()&#123; let a=1; &#123; let a=2; console.log(a); // 2 &#125; console.log(a); // 1&#125;)() 临时死区 javascript引擎在预编译阶段时，要么将变量提升至作用域顶部（遇到var声明）,要么就将其放到TDZ（临时死区中，遇到let或const声明）。访问临时死区的变量会触发运行错误，即使是相对安全的typeof操作也会报错 我对于临时死区的理解是，相当于临时死区内部的代码在预编译阶段时被放进了一个黑匣子内（暂时从代码块中移除）。这些声明在预编译阶段不会进行任何操作；只有当运行代码块到这些声明时，这些代码才会被执行声明 例如 12console.log(typeof a); //报错: Cannot access 'a' before initializationlet a=1; 为什么typeof是相对安全的？ 如果某个变量未声明就被调用，那么一般其他操作就会报错，然而typeof只会返回undefined而不报错 12console.log(typeof a); // undefinedconsole.log(a); // 报错 a未定义 for循环中的块级作用域使用var声明变量的一些偏离预想的问题来看一段代码 12345678let funcs=[];for(var i=0;i&lt;10;i++) &#123; funcs.push(function ()&#123; console.log(i); &#125;)&#125;console.log('i',i); // 10funcs.forEach(value=&gt;value()); // 输出10个10 为什么不是我们想要的结果0~9，而是输出10个10 因为，使用var声明的变量在预编译阶段会被提升到当前作用域顶部；因此，当函数执行前i已经变为了10 那么，我们该怎么解决这个问题呢？ 使用IIFE（立即执行函数）来解决使用立即执行函数，说的更加明确一点，应该是利用闭包的特性，将当时的变量保存在闭包的作用域链上 12345678910let funcs=[];for(var i=0;i&lt;10;i++) &#123; funcs.push((function (value)&#123; return function ()&#123; console.log(value); &#125; &#125;)(i))&#125;console.log('i',i); // 10funcs.forEach(value=&gt;value()); // 0~9 使用let声明来解决12345678let funcs=[];for(let i=0;i&lt;10;i++) &#123; funcs.push(function ()&#123; console.log(i); &#125;)&#125;funcs.forEach(value=&gt;value()); // 0~9console.log('i',i); // 报错 i未定义 每次迭代循环都会创建一个块级作用域，而使用let声明则可以将变量绑定在当前作用域，因此每个作用域中的同名变量不会相互影响，并且会是0~9 循环中的const声明在不改变const定义的值得情况下，const声明在循环中的作用和表现与let一样 12345678910111213let obj=&#123; a:1, b:2&#125;let funcs=[];for(const key in obj) &#123; funcs.push(function ()&#123; console.log(key); &#125;)&#125;funcs.forEach(value=&gt;value()); // 'a' 'b' 但是，如果在某个作用内企图改变const定义的变量就会报错 1234567891011121314let obj=&#123; a:1, b:2&#125;let funcs=[];for(const key in obj) &#123; funcs.push(function ()&#123; key='c'; // 试图修改const定义的变量key console.log(key); &#125;)&#125;funcs.forEach(value=&gt;value()); // 报错]]></content>
      <categories>
        <category>javaScript基础</category>
      </categories>
      <tags>
        <tag>基础语法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[leetcode-172 阶乘后的零]]></title>
    <url>AngelLikeFairy%2F2019%2F07%2F14%2Fleetcode-172%2F</url>
    <content type="text"><![CDATA[阶乘后的零题目描述给定一个整数 n，返回 n! 结果尾数中零的数量。 示例 1: 输入: 3输出: 0解释: 3! = 6, 尾数中没有零。 示例 2: 输入: 5输出: 1解释: 5! = 120, 尾数中有 1 个零. 说明: 你算法的时间复杂度应为 O(log n) 。 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/factorial-trailing-zeroes著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 核心思路概述一开始看到题目时的第一反应就是求解出n!的值，再遍历得到0的个数。然后提交之后，报错提示：超出最大堆栈大小（RangeError: Maximum call stack size exceeded）。因此，看题解之后得到提示，开始寻找规律。 若要某个数中有某位为0,那么他必定是10的倍数。而10=2 * 5；因此，该阶乘中有几对2 * 5，则该数就有几个0；又因为该阶乘为递减，则5的个数必定小于2的个数，则题目即可转化为求出5的个数即可。 解题步骤 归纳得： n 式子 5的个数 5的总个数 5 1*5 1 1 10 2*5 1 2 15 3*5 1 3 20 4*5 1 4 25 5*5 2 6 因此，可以通过 1234while (n &gt;= 5) &#123; n = Math.floor(n / 5); total += n;&#125; 得到5的个数 Coding实现一开始使用递归报错的coding1234567891011121314151617var trailingZeroes = function(n) &#123; let sum=(function circle(n)&#123; if(n!=1)&#123; return circle(n-1)*n; &#125; return 1; &#125;)(n) console.log(sum); sum=sum.toString().split(''); let count=0; sum.forEach(value=&gt;&#123; if(value==0)&#123; count++; &#125; &#125;); return count;&#125;; 优化过的coding12345678const trailingZeroes = n =&gt; &#123; let total = 0; while (n &gt;= 5) &#123; n = Math.floor(n / 5); total += n; &#125; return total;&#125;;]]></content>
      <categories>
        <category>leetcode题解与算法</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[leetcode-171 Excel表列序号]]></title>
    <url>AngelLikeFairy%2F2019%2F07%2F13%2Fleetcode-171%2F</url>
    <content type="text"><![CDATA[Excel表列序号题目描述给定一个Excel表格中的列名称，返回其相应的列序号。 例如， A -&gt; 1 B -&gt; 2 C -&gt; 3 ... Z -&gt; 26 AA -&gt; 27 AB -&gt; 28 ...示例 1: 输入: “A” 输出: 1 示例 2: 输入: “AB” 输出: 28 示例 3: 输入: “ZY”输出: 701 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/excel-sheet-column-number著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 核心思路概述通过观察，不难发现其实这类似于二进制之类的表示形式。只不过对于该题可以把其称之为26进制。再按照二进制转化为十进制方法将其转化为对应的表示数 A的Unicode编码为65，在该题目中对应的是1.因此可以通过letter.charCodeAt()函数得到的Unicode编码值减去64即可得到对应的单个字母对应值。 解题步骤 将字符串转化为数组从而可以进行遍历 将转化得到的数组反转(reverse()) 【类似于二进制转化为十进制的方法，因此，反转后的数组的下标index就是他们在累加时的26幂的次方】 利用reduce()函数进行累加 Coding实现我一开始的coding12345678910var titleToNumber = function(s) &#123; const sArray=s.split(''); let length=sArray.length-1; let sum=0; sArray.forEach(value=&gt;&#123; sum+=(value.charCodeAt()%'A'.charCodeAt()+1)*Math.pow(26,length); length--; &#125;); return sum;&#125;; 优化过的coding123456var titleToNumber = function(s) &#123; const sArray=s.split('').reverse(); return (sArray.reduce((pre,cur,index)=&gt;&#123; return pre+(cur.charCodeAt()-64)*Math.pow(26,index); &#125;,0))&#125;;]]></content>
      <categories>
        <category>leetcode题解与算法</category>
      </categories>
      <tags>
        <tag>数组</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Vue项目代码与命名规范]]></title>
    <url>AngelLikeFairy%2F2019%2F07%2F11%2FVue%E9%A1%B9%E7%9B%AE%E4%BB%A3%E7%A0%81%E4%B8%8E%E5%91%BD%E5%90%8D%E8%A7%84%E8%8C%83%2F</url>
    <content type="text"><![CDATA[Vue项目代码与命名规范 项目结构文件命名 单文件组件命名规范 组件名为多个单词 组件名应该始终是多个单词的，根组件 App 以及 &lt; transition &gt;、&lt; component &gt; 之类的 Vue 内置组件除外。 这样做可以避免跟现有的以及未来的 HTML 元素相冲突，因为所有的 HTML 元素名称都是单个单词的。 MyComponent.vue 语义化及单词顺序 SearchButtonRun.vue 文件名以单词大写开头 MyComponent.vue 组件名应该倾向于完整单词而不是缩写 UserProfileOptions.vue 文件夹命名规范 属于components文件夹下的子文件夹，使用大写字母开头的PascalBase风格 所有组件放在components文件夹下，对于各个页面应当新建立业务页面组件文件夹。 一些通用组件可以建立common文件夹放在components文件夹下 应当建立api文件夹，统一定义管理接口请求 建立router文件夹，进行路由管理 建立store文件夹，进行vuex状态管理]]></content>
      <categories>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>命名规范</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Vue项目的快速搭建]]></title>
    <url>AngelLikeFairy%2F2019%2F07%2F11%2FVue%E9%A1%B9%E7%9B%AE%E7%9A%84%E5%BF%AB%E9%80%9F%E6%90%AD%E5%BB%BA%2F</url>
    <content type="text"><![CDATA[Vue项目的快速搭建 vue-cli创建项目12vue create &lt;项目名&gt;//选择手动设置特性（Manually select features） 安装必要依赖包括但不限于vue-router,vuex,vue-axios,axios1cnpm install vue-router --save 建立基本路由管理在router.js中配置路由 1234567891011121314151617181920212223242526import Vue from 'vue'import VueRouter from 'vue-router'import RouterView1 from '@/component/RouterView1'//@默认表示src文件夹Vue.use(VueRouter) /*安装 Vue.js 插件。如果插件是一个对象，必须提供 install 方法。如果插件是一个函数，它会被作为 install 方法。install 方法调用时，会将 Vue 作为参数传入。*/export default new VueRouter(&#123; routes:[ &#123; path:'/RouterView1', name:'view1', component:RouterView1 &#125;, &#123; path:'/RouterView2', name:'view2', component:()=&gt;&#123; import('@/component/RouterView2') &#125; /*import() es6函数，动态异步加载模块，返回一个promise*/ &#125; ]&#125;) 在main.js中注册12345new Vue(&#123; router, store, render: h =&gt; h(App)&#125;).$mount("#app"); 使用axios（或vue-axios）引入 第一种方式（main.js直接引入) 1234import axios from 'axios'import VueAxios from 'vue-axios'Vue.use(axios,vue-axios) 第二种方式（在api文件夹中引入） 建立api.js文件用来编写接口函数 建立index.js导出api.js的所有函数 使用 1234567891011Vue.axios.get(api).then((response) =&gt; &#123;console.log(response.data)&#125;)this.axios.get(api).then((response) =&gt; &#123;console.log(response.data)&#125;)this.$http.get(api).then((response) =&gt; &#123;console.log(response.data)&#125;)]]></content>
      <categories>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>Vue Cli</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[leetcode-169 求众数]]></title>
    <url>AngelLikeFairy%2F2019%2F07%2F09%2Fleetcode-169%2F</url>
    <content type="text"><![CDATA[求众数核心方法：哈希表题目描述 给定一个大小为 n 的数组，找到其中的众数。众数是指在数组中出现次数大于 ⌊ n/2 ⌋ 的元素。 你可以假设数组是非空的，并且给定的数组总是存在众数。 示例 1: 输入: [3,2,3]输出: 3 示例 2: 输入: [2,2,1,1,1,2,2]输出: 2 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/majority-element著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 核心思路 利用哈希表这一数据结构来存储每个数的出现次数。元素作为键名，他们所出现的次数作为键值，进行存储。 遍历给定数组，若当前数组元素未在哈希表map中（map.has(key)===false），则以该元素为键名添加该元素，并置键值为1（map.set(value,1)）；若已存在，则更新该键值（键值加1:map.set(value,map.get(value)+1)） 遍历哈希表map，找到键值最大的那个键名并返回 coding实现1234567891011121314151617181920var majorityElement = function(nums) &#123; let maxCount=0; let num=0; let numsMap=new Map() nums.forEach(value=&gt;&#123; if(!numsMap.has(value))&#123; numsMap.set(value,1); &#125; else&#123; numsMap.set(value,numsMap.get(value)+1); &#125; &#125;) numsMap.forEach((value,key)=&gt;&#123; if(value&gt;maxCount)&#123; maxCount=value; num=key; &#125; &#125;) return num;&#125;;]]></content>
      <categories>
        <category>leetcode题解与算法</category>
      </categories>
      <tags>
        <tag>哈希表</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[leetcode-167 两数之和|| - 输入有序数组]]></title>
    <url>AngelLikeFairy%2F2019%2F07%2F08%2Fleetcode-167%2F</url>
    <content type="text"><![CDATA[两数之和|| - 输入有序数组核心方法：双指针题目描述给定一个已按照升序排列 的有序数组，找到两个数使得它们相加之和等于目标数。 函数应该返回这两个下标值 index1 和 index2，其中 index1 必须小于 index2。 说明: 返回的下标值（index1 和 index2）不是从零开始的。 你可以假设每个输入只对应唯一的答案，而且你不可以重复使用相同的元素。 示例: 输入: numbers = [2, 7, 11, 15], target = 9输出: [1,2]解释: 2 与 7 之和等于目标数 9 。因此 index1 = 1, index2 = 2 。 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/two-sum-ii-input-array-is-sorted著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 核心思路题目给定的是有序数组，所以使用双指针方法较为方便。设定min指向第一个数组元素（也就是当前最小数），max指向最后一个数组元素。令sum=numbers[min]+numbers[max] 循环比较sum与target是否相等，若想等则输出。小于target则代表min指向的元素值比输出值要小，则min++;反之，则max–; coding实现1234567891011121314var twoSum = function(numbers, target) &#123; let min=0; let max=numbers.length-1; let sum; while((sum=numbers[min]+numbers[max])!==target)&#123; if(sum&lt;target)&#123; min++; &#125; else&#123; max--; &#125; &#125; return [min+1,max+1];&#125;]]></content>
      <categories>
        <category>leetcode题解与算法</category>
      </categories>
      <tags>
        <tag>双指针</tag>
      </tags>
  </entry>
</search>
