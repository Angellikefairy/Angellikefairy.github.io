<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Vue父子组件传值详解]]></title>
    <url>%2F2019%2F09%2F22%2FVue%E7%88%B6%E5%AD%90%E7%BB%84%E4%BB%B6%E4%BC%A0%E5%80%BC%E8%AF%A6%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[父组件向子组件传值PropProp 是你可以在组件上注册的一些自定义特性。当一个值传递给一个 prop 特性的时候，它就变成了那个组件实例的一个属性。 因此，在子组件的方法代码中，我们可以使用this.xxx来访问到它 利用Prop单向数据流来使得父组件向子组件传值的基本格式如下： 123456789101112131415161718192021// 父组件 App.vue&lt;template&gt; &lt;div id="app"&gt; &lt;helloWorld :msg="msg"&gt;&lt;/helloWorld&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;import helloWorld from '@/components/HelloWorld.vue'export default &#123; data() &#123; return &#123; msg: 321 &#125; &#125;, components: &#123; helloWorld &#125;&#125;&lt;/script&gt; 123456789101112// 子组件 HelloWorld.vue&lt;template&gt; &lt;div class="hello"&gt; &#123;&#123;msg&#125;&#125; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123; props:['msg']&#125;&lt;/script&gt; 在上述父组件传值的时候是通过v-bind动态赋值的，但是我们也可以传递静态prop 1&lt;hello-world msg="qwer"&gt;&lt;/hello-world&gt; 注意的是，除了传入静态字符串之外，在传入静态的数值型，布尔型，对象型数据时我们依旧要使用v-bind来进行数据传输，否则就有可能造成数据传输失败 例如： 1234:msg='11111' //number:msg='true' //bootlean:msg='()=&gt;&#123;console.log(1)&#125; //function :msg='&#123;a:1&#125;' //object 因此，我们大可以使用v-bind动态传入，因为使用v-bind我们可以将字符串内的内容视为一个表达式进行计算 单向数据流所有的 prop 都使得其父子 prop 之间形成了一个单向下行绑定：父级 prop 的更新会向下流动到子组件中，但是反过来则不行。这样会防止从子组件意外改变父级组件的状态，从而导致你的应用的数据流向难以理解。 因此，只要父组件的数据发生了更新，子组件也会获得相应的更新。无论，发生更新的原因是异步操作还是事件操作 vm.$watch当然，我们可以使用watch方法来监听父组件数据的改变 1234567891011121314151617181920212223242526// 在父组件进行异步操作，一开始初值为undefined，经过2000毫秒后变为12345&lt;template&gt; &lt;div id="app"&gt; &lt;helloWorld :msg="msg"&gt;&lt;/helloWorld&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;import helloWorld from '@/components/HelloWorld.vue'export default &#123; data() &#123; return &#123; msg: undefined &#125; &#125;, components: &#123; helloWorld &#125;, created() &#123; setTimeout(()=&gt;&#123; this.msg=12345; &#125;,2000) &#125;&#125;&lt;/script&gt; 1234567891011121314151617// 在子组件中利用watch方法来进行监听父组件的prop值的变化&lt;template&gt; &lt;div class="hello"&gt; &#123;&#123;msg&#125;&#125; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123; props:['msg'], watch: &#123; msg(val,oldVal)&#123; console.log(val,oldVal); // 12345,undefined &#125; &#125;&#125;&lt;/script&gt; 拦截数据，过滤处理有时候，我们相对从父组件传过来的数据进行一些额外操作之后再进行渲染，此时我们可以利用计算属性来实现 12345computed: &#123; anotherMsg() &#123; return this.msg+1; &#125;&#125; 子组件向父组件传值vm.$on与vm.$emitvm.$on要与vm.$emit搭配来进行使用 vue的api文档是这么描述这两个api的 vm.$on( event, callback )参数： {string | Array} event (数组只在 2.2.0+ 中支持) {Function} callback用法： 监听当前实例上的自定义事件。事件可以由vm.$emit触发。回调函数会接收所有传入事件触发函数的额外参数。 示例： vm.$on(&apos;test&apos;, function (msg) { console.log(msg) }) vm.$emit(&apos;test&apos;, &apos;hi&apos;) // =&gt; &quot;hi&quot;vm.$emit( eventName, […args] )参数： {string} eventName[…args] 触发当前实例上的事件。附加参数都会传给监听器回调。 因此，我们可以在同一个实例上注册on监听事件函数以及emit响应事件函数 12345678910111213141516&lt;script&gt;export default &#123; created() &#123; console.log(this.msg); this.$on('test',(v)=&gt;&#123; console.log(v); &#125;) &#125;, methods: &#123; change() &#123; console.log('emit'); this.$emit('test',123456789); &#125; &#125;&#125;&lt;/script&gt; 我们在created生命周期时注册了一个监听test事件的on函数，在事件change()发生时，我们让test事件通过emit方法也进行发生。从而，监听函数会监听到该事件的发生并进行相应的输出 但是，虽然事件监听与响应都可以完成，但是这两个方法必须在同一个实例上才可以进行使用。因此，如果要进行子组件将值传递给父组件，我们可以使用v-on与vm.$emit进行搭配使用 v-on与vm.$emit因为父组件可以在使用子组件的引入模板直接用 v-on 来监听子组件触发的事件。因此，我们可以使用v-on和vm.$emit来使得子组件向父组件传值 例如： 1234567891011121314151617181920// 父组件&lt;template&gt; &lt;div id="app"&gt; // 在子组件的引入模板中使用v-on来进行监听子组件中的test事件 // 注意，@后必须是在子组件中要监听的事件名，而双引号中是父组件对于监听到事件发生后做出的处理函数。对于该例中，也就是test是要监听的事件名，getSonValue是父组件的处理函数 &lt;helloWorld :msg="msg" @test='getSonValue'&gt;&lt;/helloWorld&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;import helloWorld from '@/components/HelloWorld.vue'export default &#123; methods: &#123; getSonValue(v) &#123; console.log('v',v); &#125; &#125;&#125;&lt;/script&gt; 1234567methods: &#123; change() &#123; console.log('emit'); // 发布事件test，并传入参数123456789 this.$emit('test',123456789); &#125;&#125; 同级组件通信同级组件通信，也就是意味着某个父组件下有两个不同的子组件，这两个组件之间可以通信 父组件作为中转站一种可行的办法，就是父组件接收其中一个组件传递的值并将该值传递给另外一个子组件 例如： 1234567891011121314151617181920212223242526272829// 父组件&lt;template&gt; &lt;div id="app"&gt; &lt;component1 @msg="getMsg"&gt;&lt;/component1&gt; &lt;component2 :msg="msg"&gt;&lt;/component2&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;import component1 from '@/components/Component1'import component2 from '@/components/Component2'export default &#123; components: &#123; component1, component2 &#125;, methods: &#123; getMsg(v) &#123; this.msg=v; &#125; &#125;, data() &#123; return &#123; msg: undefined &#125; &#125;&#125;&lt;/script&gt; 123456789101112131415161718192021222324// 子组件1&lt;template&gt; &lt;div id="component1"&gt; &lt;div&gt; 子组件1的值为：&#123;&#123;msg&#125;&#125; &lt;/div&gt; &lt;button @click="sendMsg"&gt;click&lt;/button&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123; data() &#123; return &#123; msg: 123 &#125; &#125;, methods: &#123; sendMsg() &#123; this.$emit('msg',this.msg); &#125; &#125;&#125;&lt;/script&gt; 1234567891011&lt;template&gt; &lt;div id="component2"&gt; 子组件2的值为：&#123;&#123;msg&#125;&#125; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123; props: ['msg']&#125;&lt;/script&gt; 当子组件1点击按钮后，子组件2就可以获得组件1传过来的msg值 额外实例作为中央事件总线因为ES6的模块机制有一个特性 当模块内部发生变化的时候，引入模块的部分同样会发生变化 因此，我们可以创建一个额外的实例,并且在两个子组件中分别绑定vm.$emit方法进行事件发放和vm.$on方法进行事件监听 创建额外实例 1234// eventBus.jsimport Vue from 'vue'export default new Vue(); 在子组件1中引入该实例，并为其绑定分发事件vm.$emit方法 1234567891011121314151617181920212223242526&lt;template&gt; &lt;div id="component1"&gt; &lt;div&gt; 子组件1的值为：&#123;&#123;msg&#125;&#125; &lt;/div&gt; &lt;button @click="sendMsg"&gt;click&lt;/button&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;import eventBus from '@/components/eventBus.js'export default &#123; data() &#123; return &#123; msg: 123 &#125; &#125;, methods: &#123; sendMsg() &#123; console.log(eventBus); eventBus.$emit('msg',this.msg); &#125; &#125;&#125;&lt;/script&gt; 在子组件2中引入额外实例并为其绑定监听事件vm.$on方法 12345678910111213141516171819202122&lt;template&gt; &lt;div id="component2"&gt; 子组件2的值为：&#123;&#123;msg&#125;&#125; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;import eventBus from '@/components/eventBus.js'export default &#123; created() &#123; eventBus.$on('msg',(v)=&gt;&#123; this.msg=v; &#125;) &#125;, data() &#123; return &#123; msg: undefined &#125; &#125;&#125;&lt;/script&gt; 经过上述三步后，子组件2在created生命周期时就已经在额外实例上创建了事件监听方法。因此，当子组件1点击按钮之后就会向额外实例分发了一个事件msg;那么，额外实例就会监听到该事件的发生并作出处理函数，这样也就完成了两个同级组件之间的传值]]></content>
      <categories>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>Vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[nowcoder-2]]></title>
    <url>%2F2019%2F09%2F19%2Fnowcoder-2%2F</url>
    <content type="text"><![CDATA[数组的相对排序题目描述请实现一个函数，将一个字符串中的每个空格替换成“%20”。例如，当字符串为We Are Happy.则经过替换之后的字符串为We%20Are%20Happy。 核心思路概述题意很简单，就是将所有的空格转化为’%20’的格式。因此，我们可以使用replace()方法来进行替换值，当然是使用正则表达式来进行匹配 Coding实现12345678function replaceSpace(str)&#123; let pattern=/\s/g; return str.replace(pattern,'%20');&#125;module.exports = &#123; replaceSpace : replaceSpace&#125;; 时空复杂度分析 时间复杂度：O(1) 空间复杂度：O(1)]]></content>
      <categories>
        <category>牛客网算法题刷题记录</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[leetcode-367 有效的完全平方数]]></title>
    <url>%2F2019%2F09%2F18%2Fleetcode-367%2F</url>
    <content type="text"><![CDATA[有效的完全平方数题目描述给定一个正整数 num，编写一个函数，如果 num 是一个完全平方数，则返回 True，否则返回 False。 说明：不要使用任何内置的库函数，如 sqrt。 示例 1： 输入：16输出：True 示例 2： 输入：14输出：False 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/valid-perfect-square著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 核心思路概述我们知道，对于大于等于4的完全平方数，它的平方根会小于或等于它的一半。因此，我们可以在2~n/2之间进行二分查找，来降低时间复杂度 解题步骤 如果给定的数为1，返回true 设定left为2，right为Math.floor(num/2)，mid为Math.floor((left+right)/2)；如果mid*mid===num那么返回true；如果小于，则left=mid+1;否则right=mid-1; 重复步骤2知道right&gt;left 如果上述二分过程中没有返回true，那么返回false Coding实现123456789101112131415161718192021/** * @param &#123;number&#125; num * @return &#123;boolean&#125; */var isPerfectSquare = function(num) &#123; if(num===1) return true; let left=2; let right=Math.floor(num/2); let mid; while(left&lt;=right) &#123; mid=Math.floor((left+right)/2); if(mid*mid===num) return true; else if(mid*mid&gt;num) &#123; right=mid-1; &#125; else &#123; left=mid+1; &#125; &#125; return false;&#125;;]]></content>
      <categories>
        <category>leetcode题解与算法</category>
      </categories>
      <tags>
        <tag>二分查找</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[nowcoder-1 二维数组中的查找]]></title>
    <url>%2F2019%2F09%2F17%2Fnowcoder-1%2F</url>
    <content type="text"><![CDATA[数组的相对排序题目描述在一个二维数组中（每个一维数组的长度相同），每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。 核心思路概述 最直接的暴力解法遍历二维数组中的每一个元素，返回是否能找到给定的target值 利用ES6特性，将数组扁平化（但是牛客网并没有很好地支持flat()函数，因此我们可以使用concat()方法来实现扁平化）后使用includes()函数进行查找 巧妙一点的方法是：由于该二维数组的规律（每一行从左往右递增，每一列从上往下递增），我们可以发现二维数组的左下角总是当前行的最小值，当前列的最大值。因此，当给定值大于当前左下角的数值时，我们就将该数往右移动一位；当给定值小于当前左下角的数值时，我们就将该数往上移动一位。直到找到该值返回true，或者遍历到右上角仍然没有找到返回false 解题步骤Coding实现通过concat()扁平化后利用includes()来查找 12345678function Find(target, array)&#123; let arr=[].concat(...array); return arr.includes(target);&#125;module.exports = &#123; Find : Find&#125;; 左下到右上的查找 1234567891011121314151617181920function Find(target, array)&#123; let column=0; let row=array.length-1; let num; while(column&lt;array[0].length&amp;&amp;row&gt;=0)&#123; num=array[row][column]; if(target&gt;num) &#123; column++; &#125; else if(target&lt;num) &#123; row--; &#125; else return true; &#125; return false;&#125;module.exports = &#123; Find : Find&#125;;]]></content>
      <categories>
        <category>牛客网算法题刷题记录</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[模块化]]></title>
    <url>%2F2019%2F09%2F16%2F%E6%A8%A1%E5%9D%97%E5%8C%96%2F</url>
    <content type="text"><![CDATA[模块与脚本的区别模块不会将它的顶级变量、函数和类作为全局作用域的全局变量，并且模块顶级作用域的this值为undefined 为什么要模块化模块化可以将一个复杂的功能拆分为几个小功能，并且功能模块之间不会互相影响。这样就可以使得代码低耦合 另外，因为每个模块声明的变量并不会影响全局作用域，因此就不会有全局变量污染以及命名冲突的问题 每个模块都是独立的，因此模块具有良好的可复用性 CommonJs模块化Node.js是commonJS规范的主要实践者，它有四个重要的环境变量为模块化的实现提供支持：module、exports、require、global。实际使用时，用module.exports定义当前模块对外输出的接口（不推荐直接用exports），用require加载模块。 例如： 123456// 定义模块module.jsconst a=1;module.exports.test=()=&gt;&#123; console.log(a);&#125; 12345// 定义test模块并引入module模块const m=require('./test')m.test(); // 1 Es6模块化基本语法导出的几种形式123456789101112131415161718192021222324252627282930313233343536373839404142// 定义的同时，导出单个变量、对象、函数或类export const a=1；export const b=&#123;item:1&#125;;export const c=()=&gt;1;export class C&#123; constructor(item) &#123; this.item=item; &#125; getItem()&#123; return this.item; &#125;&#125;// 在定义之后导出单个变量const a=1;export a;// 在定义之后导出多个变量const a=1;const b=2;export &#123;a,b&#125;;// 导出时重命名，使用as关键字来指定变量等在模块外应该被称为什么名称,同时需要使用大括号const a=1;export &#123;a as itemA&#125;;// 重命名多个变量const a=1;const b=2;export &#123;a as itemA,b as itemB&#125;;// 导出模块的默认值，模块的默认值通过default关键字来指定。一个模块只能导出一个默认值（单个变量，函数，类，对象等）export default &#123; item:1&#125;// 重新导出一个引入的绑定import &#123;a&#125; from './m.js'export &#123;a&#125;; // 导出非默认值绑定import &#123;a&#125; from './m.js'export default a; // 导出默认值绑定 导入的几种形式123456789101112131415161718192021//导入非默认值单个变量import &#123;a&#125; from './test.js'// 导入非默认值多个变量import &#123;a,b&#125; from './test.js'// 导入整个模块import * from './test.js'// 导入默认值时不需要大括号语法import a from './test.js'// 导入默认值和非默认值，注意默认值必须排在非默认值前export const a=1;const b=2;export default b;import b,&#123;a&#125; from './test.js'// 导入非默认值时重命名，导入默认值则无法重命名，因为默认值的导入变量命名本来就是自己定义的import &#123;a as itemA&#125; from './test.js' 注意：导入非默认值绑定看起来像是解构对象，但事实上它不是 模块化的一些注意点以下是我们需要注意的地方 当从另一个模块中导入一个绑定，该绑定就好像是使用const定义的一样。我们无法对它进行修改和重命名。 1234567import b,&#123;a as itemA&#125; from './test.js'b=1; // 报错："b" is read-only.console.log(b,itemA);import b,&#123;a as itemA&#125; from './test.js'let b=1; // 报错： Identifier 'b' has already been declaredconsole.log(b,itemA); 使用import语法时要引入的模块文件必须要加上文件后缀，例如’./test.js’；而node.js则遵循基于文件系统前缀来区分文件和包的惯例。例如，example是一个包，而example.js是一个本地文件 为了最好地兼容多个浏览器和Node.js环境，一定要在模块文件名前包含/、./或../来表示要导入的文件 模块只会执行一次，无论你多少次导入同一模块。当导入模块的代码执行后，实例化过的模块就会被保存在内存中，只要另一个import语句引用它就可以重复使用 123import &#123;a&#125; from './test.js'; // 该模块只会执行这一次import &#123;b&#125; from './test.js';import &#123;c&#125; from './test.js'; 模块语法只能在当前模块顶部(也就是该模块的最外层执行环境)使用 导入模块的标识符只是本地的一个变量名称，并不等于被引入的模块中的同名变量 模块只能设置一个默认的导出值]]></content>
      <categories>
        <category>ES6</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[js事件循环机制 event loop]]></title>
    <url>%2F2019%2F09%2F13%2F%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF%E6%9C%BA%E5%88%B6%2F</url>
    <content type="text"><![CDATA[为什么js是单线程的众所周知，JavaScript是一门单线程语言。那么，为什么js必须是单线程的呢？ 因为，js主要的宿主环境就是浏览器，并且其一个重要的用途就是来操作Dom。反过来思考，如果js是多线程的，那么就会允许同一时间有多个代码块运行。那么，如果这多个代码块同时操作同一个Dom，比如，一个代码块要修改某dom元素，而另一个代码块又要删除这个元素，那么浏览器该如何处理这个元素。因此，为了避免这种复杂性，js必须是单线程的 执行栈与任务队列什么是执行栈执行栈，也就是“调用栈”，是一种拥有 LIFO（后进先出）数据结构的栈，被用来存储代码运行时创建的所有执行上下文（包括全局执行上下文，局部函数执行上下文以及eval函数执行上下文）。 任务众所周知，我们可以将js的任务分为两大类： 同步任务优先级最高，运行时立刻进入主线程运行 异步任务只有当所有同步任务执行完毕后才会去执行异步任务，异步任务的执行过程如下： 异步任务进入Event Table执行，并且注册回调函数 当指定的异步任务完成时，Event Table会将这个回调函数移入Event Queue 主线程内的任务执行完毕为空，会去Event Queue读取对应的函数，进入主线程执行 上述过程会不断重复，也就是常说的Event Loop(事件循环) 上述的event queue指的是就是任务队列，任务队列内存放的都是异步任务完成后要执行的函数 另外，我们需要注意的是，只有异步任务完成之后要执行的回调函数才会被放入任务队列，等待主线程中的所有同步代码被执行完毕之后再执行。 因此，比如在new Promise过程中不再回调函数内的代码都是同步代码，只有then()和catch()中的回调函数才是异步代码 例如： 12345678910new Promise((resolve,reject)=&gt;&#123; // 第一行 console.log(1); // 第二行 resolve(2); //第三行&#125;).then((v)=&gt;&#123; // 第四行 console.log(v); // 第五行&#125;) // 第六行// 输出结果12 其中，第1,2,3,4,6行都是同步代码，只有第5行是异步的代码 以下是任务执行过程: 宏任务与微任务任务也可以更加被细分为宏任务与微任务两种，具体如下 宏任务(macrotask)： script(整体代码)、setTimeout、setInterval、UI 渲染、 I/O、postMessage、 MessageChannel、setImmediate(Node.js 环境)、ajax、外部请求等 微任务(microtask)： Promise.then/catch、 MutaionObserver、process.nextTick(Node.js环境） 那么宏任务与微任务的执行顺序是怎么样的呢？ 网络上有两种说法，目前我还没有看到权威文章 如果，我们将整个script(整体代码)也算做是一个宏任务，那么执行顺序会是 宏任务-&gt;所有微任务-&gt;下一个宏任务 但是如果不是的话，那么就是 所有微任务-&gt;下一个宏任务 总之这些并不会影响代码的执行顺序 例如： 宏任务定时器与微任务promise 1234567891011121314151617181920212223242526272829303132setTimeout(()=&gt;&#123; console.log(1)&#125;,0)new Promise((resolve,reject)=&gt;&#123; resolve(2); console.log(3);&#125;).then(v=&gt;&#123; console.log(v); return 4;&#125;).then(v=&gt;&#123; console.log(v);&#125;)console.log(5);// 执行结果35241// 执行过程1. 先进入整体代码script这个宏任务，该任务直接进入主线程，因此要执行掉所有的同步任务2. 遇到setTimeout这一宏任务，我们将其放入宏任务队列3. 遇到Promise构造函数，立即执行该构造函数，执行console.log(3);两个then()方法依次进入微任务队列4. 执行console.log(5);5. 第一个宏任务执行结束，接下来查看微任务队列是否有要解决的微任务，按照先进先出的原则执行完所有的微任务6. 到这里，第一轮事件循环结束，进入下一轮事件循环7. 从宏任务队列中取出下一个宏任务，也就是setTimeout的回调函数，执行它... 宏任务ajax与微任务promise 123456789101112131415161718192021222324const axios=require('axios')axios.get('https://www.baidu.com').then(v=&gt;&#123; console.log(1);&#125;)new Promise((resolve,reject)=&gt;&#123; console.log(2); resolve(3);&#125;).then(v=&gt;&#123; console.log(v); return (4);&#125;).then(v=&gt;&#123; console.log(v);&#125;)console.log(5);// 运行结果25341 最后，来一段超级复杂的代码 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950console.log('1');setTimeout(function() &#123; console.log('2'); process.nextTick(function() &#123; console.log('3'); &#125;) new Promise(function(resolve) &#123; console.log('4'); resolve(); &#125;).then(function() &#123; console.log('5') &#125;)&#125;)process.nextTick(function() &#123; console.log('6');&#125;)new Promise(function(resolve) &#123; console.log('7'); resolve();&#125;).then(function() &#123; console.log('8')&#125;)setTimeout(function() &#123; console.log('9'); process.nextTick(function() &#123; console.log('10'); &#125;) new Promise(function(resolve) &#123; console.log('11'); resolve(); &#125;).then(function() &#123; console.log('12') &#125;)&#125;)//176824359111012 事件循环 所有同步任务都在主线程上执行，形成一个执行栈 主线程之外，还存在一个”消息队列”。只要异步操作执行完成，就到消息队列中排队 一旦执行栈中的所有同步任务执行完毕，系统就会按次序读取消息队列中的异步任务，于是被读取的异步任务结束等待状态，进入执行栈，开始执行 主线程不断重复上面的第三步 由于主线程不断的重复获得消息、执行消息、再取消息、再执行。所以，这种机制被称为事件循环]]></content>
      <categories>
        <category>javaScript基础</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[leetcode-303 区域和检索 - 数组不可变]]></title>
    <url>%2F2019%2F09%2F13%2Fleetcode-303%2F</url>
    <content type="text"><![CDATA[区域和检索 - 数组不可变题目描述给定一个整数数组 nums，求出数组从索引 i 到 j (i ≤ j) 范围内元素的总和，包含 i, j 两点。 示例： 给定 nums = [-2, 0, 3, -5, 2, -1]，求和函数为 sumRange() sumRange(0, 2) -&gt; 1 sumRange(2, 5) -&gt; -1 sumRange(0, 5) -&gt; -3说明: 你可以假设数组不可变。 会多次调用 sumRange 方法。 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/range-sum-query-immutable著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 核心思路概述求数组中给定范围之间的和，比如说是求i&lt;=j之间范围的和，我们可以使用前j个元素的和减去前i-1个元素的和。 题目说明会多次调用求和方法，因此，我们可以在构造函数中就将前1个元素的和到第n个元素的和保存在哈希表中 解题步骤 遍历数组，以当前元素下标为键名，以从第一个元素到当前元素的和作为键值来建立哈希表 返回前j个元素的和减去前i-1个元素的和 Coding实现123456789101112131415161718192021222324252627/** * @param &#123;number[]&#125; nums */var NumArray = function(nums) &#123; this.nums=nums; let map=new Map([[-1,0]]),sum=0; for(let i=0;i&lt;nums.length;i++) &#123; sum+=nums[i]; map.set(i,sum); &#125; this.map=map;&#125;;/** * @param &#123;number&#125; i * @param &#123;number&#125; j * @return &#123;number&#125; */NumArray.prototype.sumRange = function(i, j) &#123; return this.map.get(j)-this.map.get(i-1);&#125;;/** * Your NumArray object will be instantiated and called as such: * var obj = new NumArray(nums) * var param_1 = obj.sumRange(i,j) */]]></content>
      <categories>
        <category>leetcode题解与算法</category>
      </categories>
      <tags>
        <tag>哈希表</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[leetcode-290 单词规律]]></title>
    <url>%2F2019%2F09%2F12%2Fleetcode-290%2F</url>
    <content type="text"><![CDATA[单词规律题目描述给定一种规律 pattern 和一个字符串 str ，判断 str 是否遵循相同的规律。 这里的 遵循 指完全匹配，例如， pattern 里的每个字母和字符串 str 中的每个非空单词之间存在着双向连接的对应规律。 示例1: 输入: pattern = “abba”, str = “dog cat cat dog”输出: true 示例 2: 输入:pattern = “abba”, str = “dog cat cat fish”输出: false 示例 3: 输入: pattern = “aaaa”, str = “dog cat cat dog”输出: false 示例 4: 输入: pattern = “abba”, str = “dog dog dog dog”输出: false 说明:你可以假设 pattern 只包含小写字母， str 包含了由单个空格分隔的小写字母。 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/word-pattern著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 核心思路概述判断两个字符串是否完全匹配，也就是二者中的每个元素要互相对应，因此，我们可以使用哈希表来进行配对与比较 解题步骤 将str字符串通过split(‘ ‘)方法转化为字符串数组 遍历两个字符串，以pattern元素为键名，字符串数组对应元素作为键值，如果遇到冲突那么返回false 遍历两个字符串，以字符串数组元素为键名，pattern对应元素作为键值，如果遇到冲突那么返回false 返回true Coding实现12345678910111213141516171819202122232425262728/** * @param &#123;string&#125; pattern * @param &#123;string&#125; str * @return &#123;boolean&#125; */var wordPattern = function(pattern, str) &#123; let strArr=str.split(' '); let map=new Map(); if(pattern.length!==strArr.length) return false; for(let i=0;i&lt;pattern.length;i++) &#123; if(!map.has(pattern[i])) &#123; map.set(pattern[i],strArr[i]); &#125; else &#123; if(map.get(pattern[i])!==strArr[i]) return false; &#125; &#125; map.clear(); for(let i=0;i&lt;strArr.length;i++) &#123; if(!map.has(strArr[i])) &#123; map.set(strArr[i],pattern[i]); &#125; else &#123; if(map.get(strArr[i])!==pattern[i]) return false; &#125; &#125; return true;&#125;;]]></content>
      <categories>
        <category>leetcode题解与算法</category>
      </categories>
      <tags>
        <tag>哈希表</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[leetcode-278 第一个错误的版本]]></title>
    <url>%2F2019%2F09%2F11%2Fleetcode-278%2F</url>
    <content type="text"><![CDATA[第一个错误的版本题目描述你是产品经理，目前正在带领一个团队开发新的产品。不幸的是，你的产品的最新版本没有通过质量检测。由于每个版本都是基于之前的版本开发的，所以错误的版本之后的所有版本都是错的。 假设你有 n 个版本 [1, 2, …, n]，你想找出导致之后所有版本出错的第一个错误的版本。 你可以通过调用 bool isBadVersion(version) 接口来判断版本号 version 是否在单元测试中出错。实现一个函数来查找第一个错误的版本。你应该尽量减少对调用 API 的次数。 示例: 给定 n = 5，并且 version = 4 是第一个错误的版本。 调用 isBadVersion(3) -&gt; false 调用 isBadVersion(5) -&gt; true 调用 isBadVersion(4) -&gt; true 所以，4 是第一个错误的版本。 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/first-bad-version著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 核心思路概述该题考查的是二分查找的思想。不过需要注意边界处理。当isBadVersion(mid)的值为false时说明，第一个坏掉的产品肯定在mid后，因此left=mid+1;注意的是：当isBadVersion(mid)的值为true时，此时的mid值可能就是那个坏掉的第一个产品，因此，right=mid，而不是right=mid-1 解题步骤 设立left=1,right=n 取mid=Math.floor((left+right)/2) 如果isBadVersion(mid)的值为false时则left=mid+1; 如果isBadVersion(mid)的值为true时则right=mid 重复2,3步骤直到left===right 返回left Coding实现123456789101112131415161718192021222324252627282930313233/** * Definition for isBadVersion() * * @param &#123;integer&#125; version number * @return &#123;boolean&#125; whether the version is bad * isBadVersion = function(version) &#123; * ... * &#125;; *//** * @param &#123;function&#125; isBadVersion() * @return &#123;function&#125; */var solution = function(isBadVersion) &#123; /** * @param &#123;integer&#125; n Total versions * @return &#123;integer&#125; The first bad version */ return function(n) &#123; let left=1,right=n,mid; while(left&lt;right) &#123; mid=Math.floor((left+right)/2); if(isBadVersion(mid)===false) &#123; left=mid+1; &#125; else &#123; right=mid; &#125; &#125; return left; &#125;;&#125;;]]></content>
      <categories>
        <category>leetcode题解与算法</category>
      </categories>
      <tags>
        <tag>二分查找</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[mpvue踩坑记]]></title>
    <url>%2F2019%2F09%2F11%2Fmpvue%E8%B8%A9%E5%9D%91%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[页面跳转 微信官方接口 mpvue接口 组件传值当将其他子组件引入到某个父组件中的时候，那么就需要组件之间进行传值，否则父组件无法获得子组件定义的值]]></content>
  </entry>
  <entry>
    <title><![CDATA[Promise与异步编程]]></title>
    <url>%2F2019%2F09%2F10%2FPromise%E4%B8%8E%E5%BC%82%E6%AD%A5%E7%BC%96%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[什么是异步编程异步编程是什么？为什么需要异步编程；这都要从同步说起 因为JavaScript语言是一门单线程语言。我们只能在一个线程上运行任务，该线程被称之为主线程。就像下面的例子一样，代码是按照顺序执行的 12345(function getA()&#123; a=1;&#125;)()console.log(a); // 1 显然的是，以上会先执行getA函数并设置全局变量a=1，然后就会输出a=1; 但是，我们有没有想过一个问题，如果a的值不是我们自己先行设置的，而是向某服务器请求某资源后再赋值的呢？就像下面这样： 123456789101112131415// 引入axiosconst axios=require("axios");// 声明变量alet a;(function getA()&#123; axios.get('http://www.baidu.com').then((content)=&gt;&#123; a=1; &#125;).catch((err)=&gt;&#123; console.log(err); &#125;)&#125;)()console.log(a); // undefined 我们会发现，这时候输出并不是1，而是undefined。这是为什么呢？难道代码不是顺序执行的吗？我们尝试着分析一下以上代码，我们首先声明了变量a但未定义，之后我们进入了getA()函数，在该函数中我们利用了axios工具去请求百度站点的信息。到这里，都没有任何问题。但是，去请求资源，我们都知道网络情况是不确定的，我们不知道这一过程会花费多少时间，因此我们会将该异步任务放入另一个任务队列中，当该任务完成后（也就是请求成功或请求失败）再放入主线程队列去执行相应的函数。但是，主线程也是按照队列的顺序依次来执行的，因此只有当主线程内的所有任务执行完毕后我们才能执行异步任务返回的函数代码。 getA()函数与console.log(a)都是主线程内的任务，因此，执行顺序就会是： getA() -&gt; console.log(a) -&gt; 异步任务完成后要执行的操作 这就是异步编程，我们的程序中可能会有一些要造成阻塞的代码（请求外部资源之类），如果是同步的话，那么在请求完成之前我们都无法继续执行下面的程序，但是如果异步编程。将异步任务放入一个异步任务队列，等该异步任务完成后再将其放入主线程任务队列，这样的话，在请求资源的过程中，我们仍旧可以运行后面的程序 异步编程具有的几种形式事件监听在进行事件操作的时候，例如用户点击按钮就会触发一个click事件。当点击按钮之后，onclick事件所要执行的任务就会放入异步任务队列中，只有当主线程内的所有任务完成后它才会被执行 12345678910let a=1;let button=document.getElementById('btn');button.onclick=function() &#123; console.log('Button is clicked');&#125;console.log(a); // 执行结果1Button is clicked click单击事件一开始就会被注册，但是只有被监听到click事件发生后才会执行click需要响应的操作 回调模式什么是回调函数？ 一个回调函数，也被称为高阶函数，是一个被作为参数传递给另一个函数的函数，回调函数在另外一个函数中被调用。一个回调函数本质上是一种编程模式（为一个常见问题创建的解决方案），因此，使用回调函数也叫做回调模式。 例如： 12345678function func()&#123; console.log('回调函数');&#125;(function test(a,func)&#123; console.log(a); // 1 func(); // '回调函数'&#125;)(1,func) func函数被作为参数传递给test函数并被其调用，那么func函数就被称之为回调函数 在Node.js中有大量的异步代码，因此，会大量使用回调函数来优化异步编程 例如，下面的读取文件操作 1234567891011121314const fs=require('fs');fs.readfile('example.txt',function(err,contents) &#123; if(err) &#123; console.log(err); &#125; else console.log(contents);&#125;)console.log(1);// 执行结果1example.txt内的内容或者是报错内容 上述代码在执行readFile()函数后，发现这是一个异步任务，那么就将该异步任务放入异步任务队列，等到执行完毕后再放入到主线程任务队列等待执行。 readFile()函数的功能： readFile()函数执行，然后就去读取给定的文件，读取结束后会执行回调函数。如果出现错误，就会将错误对象赋值给回调函数中的err参数；如果一切正常，文件内容就会字符串的形式赋值给contents参数 可能有些人会不理解为什么在一个函数a中将另一个函数b作为参数，这个函数b会被执行。因为，这个readFile()函数是Node.js中的一个api 接口大致意思可能如下： 123456789function readFile(fileName,func) &#123; // 读取fileName文件 if(success) &#123; contents='文件内容'; err=null; &#125; else err='失败原因'; func(err,contents);&#125; 事件发布与订阅PromisePromise 对象是一个代理对象（代理一个值），被代理的值在Promise对象创建时可能是未知的。它允许你为异步操作的成功和失败分别绑定相应的处理方法。 这让异步方法可以像同步方法那样返回值，但并不是立即返回最终执行结果，而是一个能代表未来出现的结果的promise对象 Promise的生命周期promise对象的生命周期包括以下三种： 进行中 pending 已完成 fulfilled/resolved 被拒绝(未能成功完成) rejected Promise构造函数创建promise用Promise构造函数可以创建一个promise，构造函数只接受一个参数，也就是包含初始化Promise代码的执行器函数。该执行器函数接受两个参数，分别是resolve函数和rejected函数。执行器成功完成时调用resolve函数，失败时调用reject函数 例如： 12345678910111213141516171819const fs=require('fs')// 异步读取文件内容let promise=new Promise((resolve,reject)=&gt;&#123; fs.readFile('test.js','utf8',(err,contents)=&gt;&#123; if(err) &#123; reject(err); &#125; else &#123; resolve(contents); &#125; &#125;)&#125;)promise.then(contents=&gt;&#123; console.log(contents); // test&#125;,err=&gt;&#123; console.log(err);&#125;) 通过Promise构造函数创建了一个promise对象，之后便会执行执行器函数，同时异步操作开始。当异步操作结束后，会调用异步操作中的回调函数，如果操作成功那么将成功获得的数据作为参数传递给resolved函数，如果失败那么将失败信息传递给rejected函数。 promise对象调用then()方法和catch()方法时，会创建一个新任务放入一个任务队列中，只有监听到promise被解决后才会被执行 then()与catch()then() 方法返回一个 Promise 。它最多需要有两个参数：Promise 的成功和失败情况的回调函数。 catch() 方法返回一个 Promise 。它接受一个参数：失败情况的回调函数。 then()方法和catch()方法一起使用才更加方便和清晰地处理异步操作结果 例如： 1234567891011121314151617181920const fs=require('fs')let promise=new Promise((resolve,reject)=&gt;&#123; fs.readFile('test.js','utf8',(err,contents)=&gt;&#123; if(err) &#123; reject(err); &#125; else &#123; resolve(contents); &#125; &#125;)&#125;)promise.then(contents=&gt;&#123; console.log(contents);&#125;)promise.catch(err=&gt;&#123; console.log(err);&#125;) Promise.resolve()和Promise.reject()创建已处理的promise我们可以使用Promise.resolve()来创建已处理的成功完成的promise Promise.resolve(value)方法返回一个以给定值解析后的Promise 对象。如果该值为promise，返回这个promise；如果这个值是thenable（即带有”then” 方法)），返回的promise会“跟随”这个thenable的对象，采用它的最终状态；否则返回的promise将以此值完成。此函数将类promise对象的多层嵌套展平。 我们也可以使用Promise.reject()来创建已处理的拒绝态的promise 例如： 12345678// 返回给定的promise对象let promise=Promise.resolve(new Promise((resolve,reject)=&gt;&#123; resolve(1);&#125;))promise.then(v=&gt;&#123; console.log(v); // 1&#125;) 执行器错误如果执行器函数内部发生错误，那么promise的拒绝处理程序就会被调用。 例如： 1234567let promise=new Promise((resolve,reject)=&gt;&#123; throw new Error('err');&#125;)promise.catch(err=&gt;&#123; console.log(err); // 'err'&#125;) 因为，每个执行器函数中都隐含着一个try…catch块，所以所有的错误都会被捕获并传入拒绝处理程序,以上示例相当于： 1234567891011let promise=new Promise((resolve,reject)=&gt;&#123; try &#123; throw new Error('err'); &#125; catch (err) &#123; reject(err); &#125;&#125;)promise.catch(err=&gt;&#123; console.log(err); // 'err'&#125;) 串联Promise前面提到过每次调用then()方法或者catch()方法都会创建并返回了另一个Promise，只有当第一个promise完成或被拒绝后才会去解决之后的promise 调用then()方法返回的promise按照以下规则被创建：当一个Promise完成（fulfilled）或者失败（rejected），返回函数将被异步调用（由当前的线程循环来调度完成）。具体的返回值依据以下规则返回： 如果then中的回调函数返回一个值，那么then返回的Promise将会成为接受状态，并且将返回的值作为接受状态的回调函数的参数值。 如果then中的回调函数没有返回值，那么then返回的Promise将会成为接受状态，并且该接受状态的回调函数的参数值为 undefined。 如果then中的回调函数抛出一个错误，那么then返回的Promise将会成为拒绝状态，并且将抛出的错误作为拒绝状态的回调函数的参数值。 如果then中的回调函数返回一个已经是接受状态的Promise，那么then返回的Promise也会成为接受状态，并且将那个Promise的接受状态的回调函数的参数值作为该被返回的Promise的接受状态回调函数的参数值。 如果then中的回调函数返回一个已经是拒绝状态的Promise，那么then返回的Promise也会成为拒绝状态，并且将那个Promise的拒绝状态的回调函数的参数值作为该被返回的Promise的拒绝状态回调函数的参数值。 如果then中的回调函数返回一个未定状态（pending）的Promise，那么then返回Promise的状态也是未定的，并且它的终态与那个Promise的终态相同；同时，它变为终态时调用的回调函数参数与那个Promise变为终态时的回调函数的参数是相同的。 调用catch()方法返回的是一个带有错误原因的promise 例如： 123456789101112131415161718192021222324// 创建一个已处理的promiselet promise=Promise.resolve(1);// 不返回任何值promise.then(v=&gt;&#123; console.log(v); // 1&#125;).then(v=&gt;&#123; console.log(v); // undefined&#125;)// 返回一个值promise.then(v=&gt;&#123; console.log(v); // 1 return 2;&#125;).then(v=&gt;&#123; console.log(v); // 2&#125;)// 抛出错误在promise链的下一个拒绝处理程序中捕获promise.then(v=&gt;&#123; throw new Error('err');&#125;).catch(v=&gt;&#123; console.log(v); // err&#125;) 就像上述的第三个例子，在已完成处理程序中抛出了错误，我们可以使用then…catch来捕获错误。因此，在实际编程时，为了防止某些未知的错误而造成程序崩溃，我们要使用then…catch来捕获未知错误 promise链中传递数据在上面提过，在调用then()方法和catch()方法的处理程序中，如果return某些值，是会作为返回的promise对象的执行函数的参数值，因此，我们可以在promise链中往下游传递数据 例如： 12345678let promise=Promise.resolve(1);promise.then(v=&gt;&#123; console.log(v); // 1 return v+1; // 返回一个值&#125;).then(v=&gt;&#123; // 接收到这个值 console.log(v); // 2&#125;) 在处理程序中return一个promise 如果then中的回调函数返回一个已经是接受状态的Promise，那么then返回的Promise也会成为接受状态，并且将那个Promise的接受状态的回调函数的参数值作为该被返回的Promise的接受状态回调函数的参数值。 如果then中的回调函数返回一个已经是拒绝状态的Promise，那么then返回的Promise也会成为拒绝状态，并且将那个Promise的拒绝状态的回调函数的参数值作为该被返回的Promise的拒绝状态回调函数的参数值。 如果then中的回调函数返回一个未定状态（pending）的Promise，那么then返回Promise的状态也是未定的，并且它的终态与那个Promise的终态相同；同时，它变为终态时调用的回调函数参数与那个Promise变为终态时的回调函数的参数是相同的。 例如： 123456789let p1=Promise.resolve(1);let p2=Promise.reject('err');p1.then(v=&gt;&#123; console.log(v); // 1 return p2; // 返回一个拒绝态的promise&#125;).catch(v=&gt;&#123; // 接收到拒绝态promise传过来的错误原因 console.log(v); // 'err'&#125;) 响应多个PromisePromise.all()Promise.all()方法接受一个参数并返回一个promise，该参数是一个含有多个受监视Promise的可迭代对象（例如，一个数组），只有可迭代对象中的所有promise被成功解决(resolved态)后返回的promise才会被解决 注意： 如果传入的可迭代对象为空，Promise.all 会同步地返回一个已完成（resolved）状态的promise。 在任何情况下，Promise.all 返回的 promise 的完成状态的结果都是一个数组，它包含所有的传入迭代参数对象的值（也包括非 promise 值）。 例如： 123456let p1=Promise.resolve(1);let p2=Promise.resolve(2);Promise.all([p1,p2]).then(v=&gt;&#123; console.log(v); // [1,2]&#125;) 当然，只要所有传入的promise对象中有一个被拒绝，那么Promise.all()方法返回的promise对象就会被立刻拒绝 拒绝处理程序总是接受一个值而非数组，该值来自于被拒绝promise的拒绝值 例如： 12345678910111213let p1=Promise.resolve(1);let p2=Promise.resolve(2);// 拒绝态promiselet p3=Promise.reject(3);let p4=Promise.resolve(4);let set=new Set([p1,p2,p3,p4]);Promise.all(set).then(v=&gt;&#123; console.log(v);&#125;).catch(err=&gt;&#123; console.log(err); // 3&#125;) Promise.race()Promise.race()同样也是接受一个包含多个promise的可迭代对象，但是，一旦迭代器中的某个promise解决或拒绝，返回的 promise就会解决或拒绝。 一个待定的 Promise 只要给定的迭代中的一个promise解决或拒绝，返回的promise就采用第一个promise的值作为它的值，从而异步地解析或拒绝 例如： 123456789101112131415161718// p1在2000毫秒后成为已成功处理的promiselet p1=new Promise((resolve,reject)=&gt;&#123; setTimeout(()=&gt;&#123; resolve(1); &#125;,2000)&#125;)// 创建已完成拒绝态promiselet p2=Promise.reject(2);// 创建已完成resolved态promiselet p3=Promise.resolve(3);Promise.race([p1,p2,p3]).then(v=&gt;&#123; consoel.log(v);&#125;).catch(err=&gt;&#123; console.log(err); // 2&#125;) 因为，p1在2000毫秒后才会成为已成功处理的promise,p2,p3都是已完成处理程序，但是p2先于p3被添加到处理队列中 需要注意的是，可迭代对象中promise的顺序也可能会对结果产生影响 例如： 123456789101112131415let p1=new Promise((resolve,reject)=&gt;&#123; setTimeout(()=&gt;&#123; resolve(1); &#125;,2000)&#125;)let p2=Promise.reject(2);let p3=Promise.resolve(3);// 调换p2,p3的先后顺序Promise.race([p1,p3,p2]).then(v=&gt;&#123; console.log(v); // 3&#125;).catch(err=&gt;&#123; console.log(err);&#125;) async/await async function 用来定义一个返回 AsyncFunction 对象的异步函数。异步函数是指通过事件循环异步执行的函数，它会通过一个隐式的 Promise 返回其结果。 await 操作符用于等待一个Promise 对象。它只能在异步函数 async function 中使用。 async 函数返回一个 Promise 对象 async 函数内部 return 返回的值。会成为 then 方法回调函数的参数。 例如： 1234567891011async function f() &#123; return await new Promise((resolve,reject)=&gt;&#123; resolve(1); &#125;)&#125;f().then(v=&gt;&#123; console.log(v); // 1&#125;).catch(err=&gt;&#123; console.log(err);&#125;);]]></content>
      <categories>
        <category>ES6</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[数组创建的改进]]></title>
    <url>%2F2019%2F09%2F09%2F%E6%95%B0%E7%BB%84%E5%88%9B%E5%BB%BA%E7%9A%84%E6%94%B9%E8%BF%9B%2F</url>
    <content type="text"><![CDATA[ES6之前数组创建的一些问题在ES6之前，数组的创建具有以下的一些问题 通过Array构造函数创建数组时具有一些怪异的行为 没有现成的方法可以将类数组对象（具有数值型索引和length属性的对象）和可迭代对象转化为数组 Array构造函数的一些怪异行为Array构造函数具有以下怪异行为 如果给Array构造函数传入一个数值型的值，此时，并不是创建一个包含该数值的数组，而是创建一个数组，将该数组的length属性设置为该值。那么显然数组内的所有元素都会是undefined 123let arr=new Array(2);console.log(arr); // [undefined,undefined]console.log(arr.length); // 2 相对于上一点，如果传入一个非数值类型的值，那么就符合常规的想法，会创建一个包含该值的数组 123let arr=new Array('man');console.log(arr); // ['man']console.log(arr.length); // 1 最后，如果传入了多个值，那么不管这些值中是否有数值类型，所有的值都会变为创建的数组的元素 123let arr=new Array(2,'man');console.log(arr); // [2,'man']console.log(arr.length); // 2 因为Array构造函数具有以上的一些怪异特性，因此ES6通过引入Array.of()方法来解决这个问题 ES5实现将类数组对象转化为数组对象对于类数组对象，在ES5中我们可以采用以下的方式来将其转化为数组对象 12345678910111213141516let a=&#123; 0:1, 1:2, length:2&#125;function getArray(obj) &#123; let ans=[]; // 类数组对象具有数值型索引和length属性 for(let i=0;i&lt;obj.length;i++) &#123; ans.push(obj[i]); &#125; return ans;&#125;console.log(getArray(a)); // [1,2] 除此之外，我们还可以利用数组方法slice()的一个特性： slice 方法可以用来将一个类数组（Array-like）对象/集合转换成一个新数组。 1234567891011let a=&#123; 0:1, 1:2, length:2&#125;function getArray(obj) &#123; return Array.prototype.slice.call(obj);&#125;console.log(getArray(a)); // [1,2] ES6对于数组创建的改进Array.of()方法对于Array构造函数的改进ES6通过引入Array.of()方法来解决Array构造函数出现的一些怪异行为 概述Array.of() 方法创建一个具有可变数量参数的新数组实例，而不考虑参数的数量或类型。 Array.of() 和 Array 构造函数之间的区别在于处理整数参数：Array.of(7) 创建一个具有单个元素 7 的数组，而 Array(7) 创建一个长度为7的空数组（注意：这是指一个有7个空位(empty)的数组，而不是由7个undefined组成的数组）。 语法 Array.of(element0[, element1[, …[, elementN]]]) 参数 elementN:任意个参数，将按顺序成为返回数组中的元素。 返回值 新的 Array 实例。 例子123456789// 使用Array构造函数并传入一个数值类型值let arr=new Array(2);console.log(arr); // [undefined,undefined]console.log(arr.length); // 2// 使用Array.of()方法并传入一个数值类型值let array=Array.of(2);console.log(array); // [2]console.log(array.length); // 1 Array.from()方法将非数组对象转化为数组对象概述Array.from() 方法从一个类似数组或可迭代对象中创建一个新的，浅拷贝的数组实例。 语法 Array.from(arrayLike[, mapFn[, thisArg]]) 参数 arrayLike 想要转换成数组的伪数组对象或可迭代对象。 mapFn (可选参数) 如果指定了该参数，新数组中的每个元素会执行该回调函数。 thisArg (可选参数) 可选参数，执行回调函数 mapFn 时 this 对象。 返回值 一个新的数组实例 例子使用Array.from()方法将类数组对象转化为数组对象 12345678910let a=&#123; 0:1, 1:2, length:2&#125;// 使用Array.from()方法将类数组对象转化为数组对象let arr=Array.from(a);console.log(arr); // [1,2] 使用Array.from()方法将可迭代对象转化为数组对象 12345678910111213141516171819202122// 将字符串转化为数组let str='hello';console.log(Array.from(str)); // ['h','e','l','l','o']// 将Set集合转化为数组console.log(Array.from(new Set([1,2,3]))); // [1,2,3]// 将Map集合转化为数组console.log(Array.from(new Map([['a',1],['b',2],['c',3]]))); // [['a',1],['b',2],['c',3]]// 将普通自定义对象利用生成器转化为可迭代对象之后再转化为数组let test=&#123; a:'a', c:'c', *[Symbol.iterator]() &#123; for(let i in test) &#123; yield test[i]; &#125; &#125;&#125;console.log(Array.from(test)); // ['a','c'] 映射转化：使用Array.from()的第二个参数将被转化对象的每一个值转化为其他形式 1234567891011let test=&#123; a:'a', c:'c', *[Symbol.iterator]() &#123; for(let i in test) &#123; yield test[i]; &#125; &#125;&#125;console.log(Array.from(test,(v)=&gt;'hello '+v)); // ['hello a','hello c']]]></content>
      <categories>
        <category>ES6</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[leetcode-263 丑数]]></title>
    <url>%2F2019%2F09%2F09%2Fleetcode-263%2F</url>
    <content type="text"><![CDATA[丑数题目描述编写一个程序判断给定的数是否为丑数。 丑数就是只包含质因数 2, 3, 5 的正整数。 示例 1: 输入: 6输出: true解释: 6 = 2 × 3 示例 2: 输入: 8输出: true解释: 8 = 2 × 2 × 2 示例 3: 输入: 14输出: false 解释: 14 不是丑数，因为它包含了另外一个质因数 7。 说明： 1是丑数。 输入不会超过 32 位有符号整数的范围: [−231, 231 − 1]。 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/ugly-number著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。核心思路概述题目说明只包含质因数2,3,5的整数位丑数（且1为丑数）。那么，我们先排除掉小于等于0的数。那么对于正整数来说，如果该数只包含质因数2,3,5；那么我们只要将该数不断地除以2（如果可以整除），不断地除以3（如果可以整除），不断地除以5（如果可以整除）；如果最后的结果为1的话，那么该数就是丑数 解题步骤 如果给定数小于等于0，返回false 如果该数可以整除2，那么不断将该数除以2 如果该数可以整除3，那么不断将该数除以3 如果该数可以整除5，那么不断将该数除以5 执行完2,3,4步骤后如果结果为1，那么该数为丑数，返回true；否则返回false Coding实现123456789101112131415161718/** * @param &#123;number&#125; num * @return &#123;boolean&#125; */var isUgly = function(num) &#123; if(num&lt;=0) return false; while(num%2===0) &#123; num=num/2; &#125; while(num%3===0) &#123; num=num/3; &#125; while(num%5===0) &#123; num=num/5; &#125; if(num===1) return true; else return false;&#125;;]]></content>
      <categories>
        <category>leetcode题解与算法</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[类语法不得不知的几点]]></title>
    <url>%2F2019%2F09%2F08%2F%E7%B1%BB%E8%AF%AD%E6%B3%95%E4%B8%8D%E5%BE%97%E4%B8%8D%E7%9F%A5%E7%9A%84%E5%87%A0%E7%82%B9%2F</url>
    <content type="text"><![CDATA[ES5实现模拟类ES5是通过构造函数和原型来是模拟实现类的 1234567891011function Test(item) &#123; this.item=item;&#125;Test.prototype.getItem=function ()&#123; return this.item;&#125;let test=new Test(123);console.log(test); // &#123;item:123&#125;console.log(test.getItem()); // 123 ES6类的声明基本类声明语法要声明一个类，可以按照如下的方法 123456789101112131415class Test&#123; constructor(item) &#123; this.item=item; &#125; getItem() &#123; return this.item; &#125;&#125;let test=new Test(123);console.log(test); // &#123;item:123&#125;console.log(test.getItem()); // 123// 查看test实例原型上的属性console.log(Object.getOwnPropertyNames(Object.getPrototypeOf(test))); // [ 'constructor', 'getItem' ] 其中，constructor方法用来定义构造函数，除此之外的所有方法就是定义在原型上的方法 另外，类声明其实是基于已有自定义类型声明的语法糖。如果使用typeof Test最终返回的结果会是’function’，因此，类其实就是创建了一个具有构造函数方法行为的函数 1234567class Test&#123; constructor(item) &#123; this.item=item; &#125;&#125;console.log(typeof Test); // function 类表达式语法类和函数一样(类实质上就是一个函数)，它在声明的时候也具有表达式语法 12345678910111213// 使用匿名类赋值给Testlet Test=class&#123; constructor(item) &#123; this.item=item; &#125;&#125;// 使用命名类赋值给Testlet Test=class A&#123; constructor(item) &#123; this.item=item; &#125;&#125; 类的一些特性类声明具有的一些特性 虽然类实质上是函数，函数声明可以被提升，但是类声明却是与let声明类似不能被提升 因为类实质上是函数，因此类可以作为参数传递给函数，也可以作为值赋给变量 123456789class Test&#123; constructor(item) &#123; this.item=item; &#125;&#125;let M=Test;let m=new M(1);console.log(m); // &#123;item:1&#125; 类方法与函数一样同样支持使用可计算属性名 12345678910111213let a='get Item';class Test&#123; constructor(item) &#123; this.item=item; &#125; [a]() &#123; return this.item; &#125;&#125;let M=Test;let m=new M(1);console.log(m[a]()); // 1 类是个函数，那么它也就是个对象，因此，我们可以在类中定义生成器方法 1234567891011121314151617181920class Test&#123; constructor(...item) &#123; this.a=item[0]; this.b=item[1]; this.c=item[2]; &#125; // 建立生成器方法 *[Symbol.iterator]() &#123; for(let i in this) &#123; yield this[i]; &#125; &#125;&#125;let test=new Test(3,4,5);// 可以用for...of进行迭代for(let v of test) &#123; console.log(v); // 3,4,5&#125; 静态成员静态成员通过static关键字来声明，它会作为类的一个方法属性。无法被类的实例调用，只能通过类本身被调用 例如： 1234567891011121314151617let Test=class&#123; constructor(item) &#123; this.item=item; &#125; static getValue() &#123; return 1; &#125;&#125;let test=new Test(1);console.log(test);// 通过类本身来调用静态成员console.log(Test.getValue()); // 1// 无法通过类的实例来调用，因为静态成员不会出现在构造函数的原型对象上，所以实例无法访问到该方法console.log(test.getValue()); // 报错：test.getValue is not a function 那么，静态成员一般用来做什么呢？他们通常是一些实用程序方法，例如创建或克隆对象 123456789101112let Test=class&#123; constructor(item) &#123; this.item=item; &#125; // 实用静态成员来创建对象 static create(item) &#123; return new Test(item); &#125;&#125;// 实用静态成员来创建对象let test=Test.create(1);console.log(test); // &#123;item:1&#125; 静态成员的继承如果基类有静态成员，那么这些静态成员在派生类中也可以被使用 例如： 123456789101112131415161718let Person=class&#123; constructor(item) &#123; this.item=item; &#125; // 实用静态成员来创建对象 static create(item) &#123; return new Person(item); &#125;&#125;class Man extends Person&#123; constructor(item) &#123; super(item); &#125;&#125;let man=Man.create('man');console.log(man); // &#123;item:'man'&#125; 继承与派生类ES5模拟实现继承ES5模拟实现继承主要是通过利用原型链 12345678910111213141516171819function Person(item) &#123; this.item=item;&#125;Person.prototype.sayPerson=function() &#123; console.log('person');&#125;// 利用call来继承父类的构造函数function Man(item) &#123; Person.call(this,item);&#125;// 原型对象的继承Man.prototype=new Person();let man=new Man('man');console.log(man); // &#123;item:'man'&#125;man.sayPerson(); // 'person' ES6的继承ES6使用extends关键字来指定类继承的函数，并且通过super()方法即可访问基类的构造函数 123456789101112131415161718class Person&#123; constructor(item) &#123; this.item=item; &#125; getItem() &#123; return this.item; &#125;&#125;class Man extends Person&#123; constructor(item) &#123; super(item); &#125;&#125;let man=new Man('man');console.log(man); // &#123;item:'man'&#125;console.log(man.getItem()); // 'man' 继承自其它类的类被称为派生类，因此，对于上述代码，Person类被称为基类（父类），Man类被称为派生类（子类） 注意： 如果在派生类中指定了构造函数，那么在构造函数中就必须要调用super()方法，如果不这样做程序就会报错；当然，你也可以不指定构造函数，那么派生类就会默认执行构造函数并调用super()方法并传入所有参数 例如: 1234567891011class Man extends Person&#123; // 没有构造函数&#125;// 等价于class Man extends Person&#123; constructor(...items)&#123; super(...items); &#125;&#125; 为了避免一些参数传入引起的问题，我们最好是手动建立构造函数 super()的一些注意点super()方法有一些注意点 我们只能在派生类的构造函数中使用super()方法，如果尝试在非派生类（不适用extends声明的类）或函数中使用就会导致程序抛出错误 在构造函数中访问this前一定要调用super()，它负责初始化this 类方法的遮蔽派生类的同名方法会覆盖基类中的同名方法，因为继承的本质就是原型链来实现的；而原型链的查找是从底端向上查找的，如果找到了一个符合要求的便不会再向上查找 例如： 123456789101112131415161718192021class Person&#123; constructor(item) &#123; this.item=item; &#125; sayHello() &#123; console.log('Person say hello'); &#125;&#125;class Man extends Person&#123; constructor(item) &#123; super(item); &#125; sayHello() &#123; console.log('Man say hello'); &#125;&#125;let man=new Man('man');console.log(man); // &#123;item:'man'&#125;man.sayHello(); // 'Man say hello' 继承自表达式的类只要表达式可以被解析为一个函数并且具有[[construct]]属性（箭头函数不具有该属性）和原型，那么就可以用extends进行派生 例如： 12345678910111213141516171819// 该函数为构造函数function Person(item) &#123; this.item=item;&#125;Person.prototype.sayHello=function() &#123; console.log('hello');&#125;// 继承自构造函数而非基本类class Man extends Person&#123; constructor(item) &#123; super(item); &#125;&#125;let man=new Man('man');console.log(man); // &#123;item:'man'&#125;man.sayHello(); // 'hello']]></content>
      <categories>
        <category>ES6</category>
      </categories>
      <tags>
        <tag>基础语法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[leetcode-258 各位相加]]></title>
    <url>%2F2019%2F09%2F08%2Fleetcode-258%2F</url>
    <content type="text"><![CDATA[各位相加题目描述给定一个非负整数 num，反复将各个位上的数字相加，直到结果为一位数。 示例: 输入: 38输出: 2 解释: 各位相加的过程为：3 + 8 = 11, 1 + 1 = 2。 由于 2 是一位数，所以返回 2。 进阶:你可以不使用循环或者递归，且在 O(1) 时间复杂度内解决这个问题吗？ 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/add-digits著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 核心思路概述 如果不考虑进阶的要求的话，那么第一直觉就会是使用循环或者递归，将数的各位和一直相加，直到和为个位数 如果需要满足进阶的要求的话，那么我们需要一些数学的技巧。对于一个数abc,它等于a*100+b*10+c。将它求和的话，就会变为a+b+c,也就是求和之后减少了99*a+9*b=9*(11*a+b);因此，每次求和这个数就会减少9的倍数的值；也就是相当于，原数-9*未知值=和；这个式子可以转化为：原数%9=和；因此，若结果为 0 则考虑num本身是否为 0，若本身不为不为 0，则返回 9；此外，返回结果 解题步骤Coding实现循环版 123456789101112/** * @param &#123;number&#125; num * @return &#123;number&#125; */var addDigits = function(num) &#123; while(num&gt;=10) &#123; num=num.toString().split('').reduce((pre,value)=&gt;&#123; return pre+parseInt(value); &#125;,0) &#125; return num;&#125;; 数学推断版 12345678910111213/** * @param &#123;number&#125; num * @return &#123;number&#125; */var addDigits = function(num) &#123; if(num&gt;9) &#123; if(num%9) &#123; return num%9; &#125; else return 9; &#125; else return num;&#125;;]]></content>
      <categories>
        <category>leetcode题解与算法</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[迭代器与生成器]]></title>
    <url>%2F2019%2F09%2F07%2F%E8%BF%AD%E4%BB%A3%E5%99%A8%E4%B8%8E%E7%94%9F%E6%88%90%E5%99%A8%2F</url>
    <content type="text"><![CDATA[什么是迭代器首先，迭代器是一个对象，一个专门为迭代过程设计的对象。所有的迭代器对象都会具有一个next()方法，用来返回一个结果对象（该结果对象包括两个属性，一个是下一个要返回的值，一个是done属性。在返回最后一个值及之前时，done值为false，否则为true）。 使用ES5模拟一个迭代器1234567891011121314151617181920212223242526272829303132// 利用闭包的特性，使得next()方法一直保存着index的变量值function createIterator(items) &#123; let index=-1; return &#123; next : function () &#123; index++; return &#123; value:items[index], done:index&lt;=items.length-1?false:true &#125; &#125; &#125;&#125;let iterator=createIterator([3,4,5]);console.log(iterator.next());console.log(iterator.next());console.log(iterator.next());console.log(iterator.next());console.log(iterator.next());/** 输出结果*//*&#123; value: 3, done: false &#125;&#123; value: 4, done: false &#125;&#123; value: 5, done: false &#125;&#123; value: undefined, done: true &#125;&#123; value: undefined, done: true &#125;*/ 什么是生成器生成器是一个可以返回迭代器对象的函数，通过*关键字来表示该函数为生成器函数。 在生成器函数中，我们一般需要使用yield关键字来指定调用迭代器的next()方法的返回值和返回顺序。 yield关键字可以返回任何值或者表达式 例如： 12345678910111213141516171819202122232425// 使用生成器函数来返回一个迭代器，其中的yield关键字来指定调用此迭代器中的next()方法的返回值与返回顺序function *createIterator(items) &#123; for(let i=0;i&lt;items.length;i++) &#123; yield items[i]; &#125;&#125;let iterator=createIterator([3,4,5]);console.log(iterator.next());console.log(iterator.next());console.log(iterator.next());console.log(iterator.next());console.log(iterator.next());/** 输出结果*//*&#123; value: 3, done: false &#125;&#123; value: 4, done: false &#125;&#123; value: 5, done: false &#125;&#123; value: undefined, done: true &#125;&#123; value: undefined, done: true &#125;*/ 对于生成器函数中的yield，每当执行完一个yield语句后，该函数就会自动停止执行，直到再次调用返回的迭代器的next()方法 生成器函数表达式上面的例子是使用函数声明的方式来创建生成器，同样我们也可以使用函数表达式的方式来创建生成器。此时，我们只需要在function关键字和小括号中间添加*号即可 例如： 12345678910111213// 匿名函数let createIterator=function *() &#123; yield 3; yield 4; yield 5;&#125;// 非匿名函数let createIterator=function *test() &#123; yield 3; yield 4; yield 5;&#125; 生成器函数作为一个对象的方法由于生成器本身就是一个函数，因此我们可以将生成器作为一个对象的方法。 这样，我们可以使用ES6对象的简写方法来创建生成器，只需要在方法名前加上*即可 例如： 1234567let test=&#123; *createIterator() &#123; yield 3; yield 4; yield 5; &#125;&#125; 可迭代对象与for…of循环什么是可迭代对象可迭代对象都会有Symbol.iterator属性。该属性可以通过指定的函数来返回一个迭代器。 在ES6中，所有的集合对象（数组，Set集合，Map集合）和字符串都是可迭代对象。这些对象都有默认的迭代器。 而我们自己创建的对象一般都不是可迭代对象，当然我们可以将他们转变为可迭代对象 注意：由于生成器默认会为Symbol.iterator属性赋值，因此所有通过生成器创建的迭代器都会是可迭代对象。因此，我们可以这一特性将不可迭代对象转化为可迭代对象 判断一个对象是否为可迭代对象因为可迭代对象都会有Symbol.iterator方法属性，所以我们可以判断某对象中是否具有该方法来判断是否为可迭代对象 123456789function isIterable(object) &#123; return typeof object[Symbol.iterator] === 'function'&#125; console.log(isIterable([1,2,3])); // trueconsole.log(isIterable(new Set([1,2,3]))); // trueconsole.log(isIterable(new Map([[1,1],[2,2]]))); //trueconsole.log(isIterable('hello')); // trueconsole.log(isIterable(&#123;a:1,b:2&#125;)); // false for…of循环for…of循环只能循环可迭代对象。 其实质上是会调用可迭代对象的Symbol.iterator的属性方法来获取到一个迭代器，然后不断调用迭代器的next()方法直到done属性值为true时退出 例如： 1234567891011121314let test=[3,4,5];for(let v of test) &#123; console.log(v);&#125;/** 输出结果*//*345*/ 访问默认迭代器每个可迭代对象都会有一个Symbol.iterator的方法属性，该方法被调用后可以返回一个迭代器。 因此，我们可以通过该属性去访问一个可迭代对象的默认迭代器 例如： 123456789101112131415161718192021let test=[3,4,5];// 获得数组对象的默认迭代器let iterator=test[Symbol.iterator]();console.log(iterator.next());console.log(iterator.next());console.log(iterator.next());console.log(iterator.next());console.log(iterator.next());/** 输出结果*//*&#123; value: 3, done: false &#125;&#123; value: 4, done: false &#125;&#123; value: 5, done: false &#125;&#123; value: undefined, done: true &#125;&#123; value: undefined, done: true &#125;*/ 将不可迭代对象转化为可迭代对象通过添加Symbol.iterator属性因为一个对象是否可迭代是根据是否有Symbol.iterator属性的，因此，我们可以手动添加该生成器 1234567891011121314151617181920let test=&#123; a:1, b:2&#125;// 自建对象一般都是不可迭代的console.log(test[Symbol.iterator]); // undefined// 为不可迭代对象创建Symbol.iterator并赋予一个生成器,使其成为一个可迭代对象test[Symbol.iterator]=function *() &#123; // this指向test对象 for(let i in this) &#123; yield this[i]; &#125;&#125;// 验证是否成为了一个可迭代对象for(let v of test) &#123; console.log(v); // 1 2&#125; 通过生成器函数在前文提到过，由于生成器默认会为传入的对象Symbol.iterator属性赋值，因此，我们只需向生成器函数传入不可迭代对象即可 例如： 123456789101112131415function *createIterator(object) &#123; for(let i in object) &#123; yield object[i]; &#125;&#125;let test=&#123; a:1, b:2&#125;let iterator=createIterator(test);for(let v of iterator) &#123; console.log(v); // 1,2&#125;]]></content>
      <categories>
        <category>ES6</category>
      </categories>
      <tags>
        <tag>基础语法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[leetcode-257 二叉树的所有路径]]></title>
    <url>%2F2019%2F09%2F07%2Fleetcode-257%2F</url>
    <content type="text"><![CDATA[二叉树的所有路径题目描述给定一个二叉树，返回所有从根节点到叶子节点的路径。 说明: 叶子节点是指没有子节点的节点。 示例: 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/binary-tree-paths著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 核心思路概述二叉树的路径是根节点到叶子节点上的路径。因此，我们可以传入一个数组，在递归的时候存储每个节点当前的路径，如果遇到叶子节点，就将叶子节点上的路径加入到ans数组 解题步骤 设立一个ans数组，用来存放二叉树的路径 先序遍历二叉树，同时传入一个数组，用来保存当前节点的路径 如果遇到叶子节点，则将数组存入ans数组中，并return 访问其左子树和右子树 递归2,3,4步骤，直到二叉树遍历完毕 利用map()方法和join()方法将输出满足题目要求 Coding实现1234567891011121314151617181920212223242526272829303132/** * Definition for a binary tree node. * function TreeNode(val) &#123; * this.val = val; * this.left = this.right = null; * &#125; *//** * @param &#123;TreeNode&#125; root * @return &#123;string[]&#125; */var binaryTreePaths = function(root) &#123; let ans=[]; (function getPath(root,arr) &#123; if(root===null) return; else &#123; arr.push(root.val); let arrLeft=arr.concat(); let arrRight=arr.concat(); if(!root.left&amp;&amp;!root.right) &#123; ans.push(arr); return; &#125; getPath(root.left,arrLeft); getPath(root.right,arrRight); &#125; &#125;)(root,[]) ans=ans.map(v=&gt;&#123; return v.join('-&gt;'); &#125;) return ans;&#125;;]]></content>
      <categories>
        <category>leetcode题解与算法</category>
      </categories>
      <tags>
        <tag>树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[leetcode-242 有效的字母异位词]]></title>
    <url>%2F2019%2F09%2F05%2Fleetcode-242%2F</url>
    <content type="text"><![CDATA[有效的字母异位词题目描述给定两个字符串 s 和 t ，编写一个函数来判断 t 是否是 s 的字母异位词。 示例 1: 输入: s = “anagram”, t = “nagaram”输出: true 示例 2: 输入: s = “rat”, t = “car”输出: false 说明:你可以假设字符串只包含小写字母。 进阶:如果输入字符串包含 unicode 字符怎么办？你能否调整你的解法来应对这种情况？ 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/valid-anagram著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 核心思路概述判断两个字符串互相是不是字母异位词，这也就意味着，两个字符串内的每个字符数量都是相同的。因此，我们只需要设定一个map集合来存储每个字符的数量即可 解题步骤 如果两字符的长度不一样则返回false 如果两字符相等，返回true 设定map集合，遍历其中一个字符串，以字符和字符个数为键值对存入哈希表中 遍历另一个字符串，如果出现哈希表中没有的字符，则返回false；如果是哈希表中已有的字符，那么将该键值减一 遍历哈希表，如果所有的键值都为0，那么返回true；否则返回false Coding实现1234567891011121314151617181920212223242526272829303132/** * @param &#123;string&#125; s * @param &#123;string&#125; t * @return &#123;boolean&#125; */var isAnagram = function(s, t) &#123; if(s.length!==t.length) return false; if(s===t) return true; let map=new Map(); let flag=1; for(let v of s) &#123; if(map.has(v)) &#123; map.set(v,map.get(v)+1); &#125; else &#123; map.set(v,1); &#125; &#125; for(let v of t) &#123; if(map.has(v)) &#123; map.set(v,map.get(v)-1); &#125; else &#123; return false; &#125; &#125; map.forEach(v=&gt;&#123; if(v!==0) flag=0; &#125;) return Boolean(flag);&#125;;]]></content>
      <categories>
        <category>leetcode题解与算法</category>
      </categories>
      <tags>
        <tag>哈希表</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[set集合与map集合]]></title>
    <url>%2F2019%2F09%2F05%2Fset%E9%9B%86%E5%90%88%E4%B8%8Emap%E9%9B%86%E5%90%88%2F</url>
    <content type="text"><![CDATA[Set集合Set集合的使用语法 new Set([iterable]); 参数 iterable 如果传递一个可迭代对象，它的所有元素将不重复地被添加到新的 Set中。如果不指定此参数或其值为null，则新的 Set为空。 返回值 一个新的Set对象 set的一些基本操作Set对象的一些基本方法 add() 向集合添加一个元素 delete() 向集合删除某个指定元素 clear() 清除集合内所有元素 has() 检查集合内是否有指定元素 Set对象的一些属性 size 集合大小 1234567let set=new Set();set.add(1);set.add('1');console.log(set.size); // 2set.delete('1'); console.log(set); // Set &#123; 1 &#125; Set的特性在set集合内，存入元素的时候不会对值进行任何强制的类型转换，这也意味着，5和’5’在set集合内是两个不同的独立的元素 另外,如果往set集合内多次传入同一数据，那么后面的操作就会被忽略。因此，set集合内的元素是不重复的 利用Set特性来实现数组去重因为展开运算符可以将诸如set集合的可迭代对象转化为数组 因此，我们可以将数组传入set集合内，利用set内元素不能重复的特性实现去重。之后利用展开运算符，将set集合转化回数组、 1234let test=[1,2,3,3,4,1,3,2]; // 创建一个具有重复元素的数组let set=new Set(test);console.log([...set]); // [1,2,3,4] Set集合的遍历set集合使用forEach()方法来实现遍历 该方法的回调函数接受三个参数 元素的值 元素的键名 自身set集合 因为set集合存储的是单个元素而不是键值对，但是为了大多数方法中回调参数的统一，该回调函数的参数也按照键值的形式传参。 但，值得注意的是，元素的键名与键值相同 12345678let set=new Set([3,4,5]);set.forEach((value,key,ownerSet)=&gt;&#123; console.log(value,key,ownerSet);&#125;);// 3,3,&#123;3,4,5&#125;// 4,4,&#123;3,4,5&#125;// 5,5,&#123;3,4,5&#125; WeakSet集合什么是WeakSet集合WeakSet 集合是一个弱引用Set集合，里面只能存储的弱引用，而不能存储基本类型值 为什么要使用WeakSet如果往set集合内加入某个引用类型值，那么set集合中的该元素也有了某个对象的引用。那么，就算在set集合外部释放了该对象（令该对象的值为null），set集合内部的那个元素仍然保持着那个对象的引用。因此，这会很容易造成内存泄漏 1234567891011121314let a=&#123; item:1&#125;// 往set内传入a对象let set=new Set([a]);// 将a对象置为空对象a=null;// 但是set集合中的元素仍然保持着该对象的引用console.log([...set][0]); // &#123; item: 1 &#125;console.log(a); // null 对于上述程序，显然我们可以看到，我们在set集合外部想要释放对象a，但是set集合引用着该对象，因此该对象的内存无法被释放 WeakSet的使用WeakSet 对象中存储的对象值都是被弱引用的, 如果没有其他的变量或属性引用这个对象值, 则这个对象值会被当成垃圾回收掉. 正因为这样, WeakSet 对象是无法被枚举的, 没有办法拿到它包含的所有元素. 1234567891011let a=&#123; item:1&#125;// 往weakSet内传入a对象let set=new WeakSet([a]);// 将a对象置为空对象a=null;console.log(a); // null 当WeakSet集合外部的引用被释放后，该引用就会被真正地完全释放 weakSet集合的一些注意点weakSet只支持3个方法 add() has() delete weakSet集合不可迭代和枚举，因此其不支持 for…of循环 …展开运算符 forEach()方法 size属性 Map集合Map类型是一种存储着许多键值对的有序列表，其中的键名和键值支持所有的数据类型。 键名的等价性判断是通过Object.is()方法来进行判断的，所以数字5和字符串’5’会被判定为两种类型，可以分IE作为独立的两个键名来存储在Map结合内 1234let map=new Map();map.set('1',1);map.set(1,1);console.log(map); // Map &#123; '1' =&gt; 1, 1 =&gt; 1 &#125; Map集合的使用语法 new Map([iterable]) 参数 iterable Iterable 可以是一个数组或者其他 iterable 对象，其元素为键值对(两个元素的数组，例如: [[ 1, ‘one’ ],[ 2, ‘two’ ]])。 每个键值对都会添加到新的 Map。null 会被当做 undefined。 Map的一些基本方法Map集合具有以下一些基本方法 set() 传入键名和键值来设定一个键值对 delete() 删除指定键值对 clear() 删除全部键值对 has() 判断某个键值对是否存在 get() 传入键名来获取键值 Map集合具有以下一些属性 size Map集合的大小 1234567let map=new Map();map.set('a','a');map.set('b','b');console.log(map.get('a')); // 'a'map.delete('a');console.log(map.size); // 1console.log(map.has('a')); // false Map集合的遍历Map集合也是使用forEach()方法来进行遍历 其回调函数接受三个参数 value 键值 key 键名3，ownerMap 自身map集合 1234567let map=new Map([[1,1],['1','1']]);map.forEach((value,key,ownerMap)=&gt;&#123; console.log(value,key,ownerMap);&#125;); // 1 1 Map &#123; 1 =&gt; 1, '1' =&gt; '1' &#125;// '1' '1' Map &#123; 1 =&gt; 1, '1' =&gt; '1' &#125; WeakMap集合类似于WeakSet集合，WeakMap是弱引用Map集合。其中，它的键名必须是非null类型的对象，键值则可以使任意类型的值 WeakMap集合中保存的是键名弱引用着的引用对象，如果在弱引用之外不再有任何其他强引用，那么垃圾回收机制就会自动回收这个对象 只有集合的键名遵守以上规则，如果键值是一个对象，那么该引用是强引用，不会触发垃圾回收机制]]></content>
      <categories>
        <category>ES6</category>
      </categories>
      <tags>
        <tag>基础语法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[解构]]></title>
    <url>%2F2019%2F09%2F04%2F%E8%A7%A3%E6%9E%84%2F</url>
    <content type="text"><![CDATA[为什么需要解构在Es6之前，当我们需要从一个对象中取出某个属性的值时，我们通常会这么做： 123456789let test=&#123; a:1, b:2, c:3&#125;console.log(test.a); // 1console.log(test.b); // 2console.log(test.c); // 3 显然我们可以看到，我们重复写了很多同样的代码；况且这只是仅仅只有一层，如果其中还包含更多的嵌套解构的话，那么我们就需要编写更长更多的代码 然而，Es6的解构就很好地解决了这些问题 对象解构对象解构的语法形式是在一个赋值操作符左边放置一个对象字面量,那么左边对象字面量中的变量就可以获得右边对象中的同名变量的属性值 例如： 123456789let test=&#123; a:1, b:2, c:3&#125;// 变量声明的时候，解构对象获得对应属性值let &#123;a,b,c&#125;=test;console.log(a,b,c); // 1,2,3 注意：只要使用了解构来声明变量，那么就必须要给该表达式初始化（即提供等号右侧的值） 解构赋值不同于上面的那段程序，是在变量声明的时候就解构对象来得到相应的属性值。解构赋值，是在变量已经声明结束后，在普通赋值表达式的时候进行解构 但此时，一定要记住，需要用一对小括号来包裹解构赋值表达式； 因为，在之前提过，JavaScritp将一对花括号之间的区域视为一个代码块，但是代码块语句不允许出现在赋值表达式左侧。因此，我们通过在解构赋值语句外包裹一对小括号来讲该块语句转化为一个表达式 例如： 123456789let test=&#123; a:1, b:2, c:3&#125;let a,b,c;(&#123;a,b,c&#125;=test);console.log(a,b,c); 给函数传递参数的同时解构只要你想获得对象中某些参数的值，无论是在哪里你都可以利用解构，比如在函数传参的环节 例： 123456789101112let test=&#123; a:1, b:2, c:3&#125;function getValue(value) &#123; return value;&#125;console.log(getValue(&#123;a,b,c&#125;=test)); // &#123; a: 1, b: 2, c: 3 &#125;console.log(a,b,c); // 1,2,3 因为JavaScript表达式的结果会是等号右边的值，因此实参的表达式 {a,b,c}=test的结果会是test对象，因此传递给getValue函数的是test对象，但是在此表达式的执行过程中，也进行了解构操作，因此也得到了a,b,c的值 解构赋值也可以使用默认值在使用解构赋值表达式的时候，如果指定的局部变量名称在对象中并没有该属性，那么该变量会被赋予undefined 例如： 12345678let test=&#123; a:1, b:2, c:3&#125;let &#123;a,b,c,d,e&#125;=test;console.log(a,b,c,d,e); // 1,2,3,undefined,undefined 但其实，类似于之前提到过的默认参数（当形参没有获得实参时，那些提前被赋予默认值的参数就可以使用默认值），在解构赋值时也可以使用默认值 例如： 12345678let test=&#123; a:1, b:2, c:3&#125;let &#123;a='aaa',b='bbb',c='ccc',d='ddd',e='eee'&#125;=test;console.log(a,b,c,d,e); // 1,2,3,'ddd','eee' 当指定的属性不存在时，我们变量就会获得预先设定的默认值 为非同名局部变量赋值有些时候，我们只想取得某个对象中的属性值而不是命名与属性名相同的变量名，也就是为非同名局部变量解构赋值 12345678910let test=&#123; a:1, b:2, c:3&#125;// 使用冒号语法来为非同名变量赋值let &#123;a:itemA,b:itemB,c:itemC&#125;=test;console.log(itemA,itemB,itemC); // 1,2,3console.log(a,b,c); // 报错：a is not defined 嵌套对象解构无论嵌套多少层，我们只需要记住将赋值操作符左边的解构对象看作是一个对象字面量，这个对象字面量等于右边给定的对象，那么我们就可以很容易对比两个对象得到需要的属性值 例如： 1234567891011121314let test=&#123; a:1, b:2, c:&#123; a:'a', b:'b', c:'c' &#125;&#125;// 解构嵌套对象时，我们只能获得当前解构对象内的最深层变量赋值let &#123;c:&#123;b&#125;&#125;=test;console.log(b); // 'b'console.log(c); // 报错 c is not defined 数组解构数组解构使用的数组字面量，且解构操作全部在数组内完成 在数组解构语法中，我们是通过值在数组中的位置来进行获取数组元素值的 例如： 1234let test=[1,2,&#123;item:3&#125;];let [a,b,c]=test;console.log(a,b,c); // 1,2,&#123; item: 3 &#125;console.log(c===test[2]); // true 当然我们也可以只取得其中的几项，未显示声明的元素都会被忽略（通过设置空白占位符） 例如： 123let test=[1,2,&#123;item:3&#125;];let [a, ,c]=test;console.log(a,c); // 1,&#123;item:3&#125; 数组解构赋值数组解构不像对象解构，因为数组使用[]包裹的，而不是对象字面量的{}，因此，数组的解构赋值会被当做一个表达式 12345let test=[1,2,&#123;item:3&#125;];let a,b,c; // 声明a,b,c[a,b,c]=test;console.log(a,b,c); // 1,2,&#123;item:3&#125; 交换变量数组解构赋值语法有一个独特的用例，可以用来交换两个变量的值 123let a=1,b=2;[a,b]=[b,a];console.log(a,b); // 2,1 对于上述代码，在表达式赋值之前，我们会先求得表达式左右两侧的值之后在进行赋值。右侧根据a,b生成一个数组对象，因此，这就符合了数组解构赋值的语法 因为在数组解构语法中，我们是通过值在数组中的位置来进行获取数组元素值的，而不是像对象解构是根据同名变量来的，因此，在这里，局部变量a会获得数组[b,a]的第一个元素也就是2，局部变量b会获得数组[b,a]的第二个元素也就是1 上述代码可以转化为 12345let a=1,b=2;let arr=[b,a];console.log(arr); // [2,1][a,b]=arr;console.log(a,b); // 2,1 数组解构赋值中的默认值类似于对象解构赋值我们可以使用默认值，在数组解构赋值中我们同样也可以使用默认值 123let test=[1,2,&#123;item:3&#125;];let [a='aaa',b='bbb',c='ccc',d='ddd',e='eee']=test;console.log(a,b,c,d,e); // 1,2,&#123;item:3&#125;,ddd,eee 嵌套数组解构类似于对象的嵌套解构 123let test=[1,2,[3,4,5]];let [a, ,[ , ,c]]=test;console.log(a,c); // 1,5 不定元素在数组中，我们可以通过…语法将数组中的其余元素都赋值给一个特定的变量。我们把这称之为不定元素 注意：在被解构的数组中，不定元素必须为最后一个条目，在不定元素后面继续添加都好会导致程序抛出语法错误 123let test=[1,2,&#123;item:3&#125;,[4,5,6]];let [a, , ,[...d]]=test;console.log(a,d); // 1,[4,5,6] 混合解构顾名思义，就是在任何混杂真对象和数组的数据解构得到某些值 1234567891011121314let test=&#123; a:1, b:2, c:&#123; a:1, b:&#123; b:2 &#125;, c:[1,2,3] &#125;&#125;let &#123;c:&#123;b,c:[ , ,d]&#125;&#125;=test;console.log(b,d); // &#123;b:2&#125;,3 在上述代码中的冒号前的变量代表对象的属性，并不是声明的局部变量 解构参数解构可以用在函数参数的传递过程中，我们可以使用对象或数组解构模式来替代命名参数 例如： 1234567891011function getValue(&#123;a,b,c&#125;) &#123; console.log(a,b,c); // 1,2,3&#125;let test=&#123; a:1, b:2, c:3&#125;getValue(test); 注意，解构参数必须传值，对于上述代码，我们就不能穿一个null空对象或者undefined，不然就会使程序抛出语法错误]]></content>
      <categories>
        <category>ES6</category>
      </categories>
      <tags>
        <tag>基础语法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[leetcode-235 二叉搜索树的最近公共祖先]]></title>
    <url>%2F2019%2F09%2F04%2Fleetcode-235%2F</url>
    <content type="text"><![CDATA[二叉搜索树的最近公共祖先题目描述给定一个二叉搜索树, 找到该树中两个指定节点的最近公共祖先。 百度百科中最近公共祖先的定义为：“对于有根树 T 的两个结点 p、q，最近公共祖先表示为一个结点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（一个节点也可以是它自己的祖先）。” 例如，给定如下二叉搜索树: root = [6,2,8,0,4,7,9,null,null,3,5] 示例 1: 输入: root = [6,2,8,0,4,7,9,null,null,3,5], p = 2, q = 8输出: 6解释: 节点 2 和节点 8 的最近公共祖先是 6。示例 2: 输入: root = [6,2,8,0,4,7,9,null,null,3,5], p = 2, q = 4输出: 2解释: 节点 2 和节点 4 的最近公共祖先是 2, 因为根据定义最近公共祖先节点可以为节点本身。 说明: 所有节点的值都是唯一的。p、q 为不同节点且均存在于给定的二叉搜索树中。 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/lowest-common-ancestor-of-a-binary-search-tree著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 核心思路概述因为该树为二叉搜索树，因此，每个节点的左子树均小于等于它的值；每个节点的右子树均大于等于它的值；那么，如果当给定的节点分别位于某节点的两侧时，则该节点为给定两节点的最近公共祖先 解题步骤 先序遍历该二叉搜索树，如果给定两节点的值均小于该节点，那么遍历该节点的左子树 如果给定两节点的值均大于该节点，那么遍历该节点的右子树 如果该节点的值小于某节点的值又大于另一节点的值，那么返回该节点 Coding实现123456789101112131415161718192021222324252627/** * Definition for a binary tree node. * function TreeNode(val) &#123; * this.val = val; * this.left = this.right = null; * &#125; *//** * @param &#123;TreeNode&#125; root * @param &#123;TreeNode&#125; p * @param &#123;TreeNode&#125; q * @return &#123;TreeNode&#125; */var lowestCommonAncestor = function(root, p, q) &#123; if(root===null) return; else &#123; if(p.val&gt;root.val&amp;&amp;q.val&gt;root.val) &#123; return lowestCommonAncestor(root.right,p,q); &#125; else if(p.val&lt;root.val&amp;&amp;q.val&lt;root.val) &#123; return lowestCommonAncestor(root.left,p,q); &#125; else &#123; return root; &#125; &#125;&#125;;]]></content>
      <categories>
        <category>leetcode题解与算法</category>
      </categories>
      <tags>
        <tag>树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[原型对象的设置与访问]]></title>
    <url>%2F2019%2F09%2F03%2F%E5%8E%9F%E5%9E%8B%E5%AF%B9%E8%B1%A1%E7%9A%84%E8%AE%BE%E7%BD%AE%E4%B8%8E%E8%AE%BF%E9%97%AE%2F</url>
    <content type="text"><![CDATA[原型对象的访问__proto__proto属性是Object.prototype 一个简单的访问器属性，其中包含了get（获取）和set（设置）的方法 proto的读取器(getter)暴露了一个对象的内部 [[Prototype]] 。对于使用对象字面量创建的对象，这个值是 Object.prototype。对于使用数组字面量创建的对象，这个值是 Array.prototype。对于functions，这个值是Function.prototype。 proto 的设置器(setter)允许对象的 [[Prototype]]被变更。要变更的值必须是一个object或null，提供其它值将不起任何作用。 12345678910111213function Test(item) &#123; this.item=item;&#125;Test.prototype.sayHello=function() &#123; console.log('hello');&#125;let test=new Test();// 使用__proto__属性访问原型console.log(test.__proto__); // Test &#123; sayHello: [Function] &#125;test.sayHello(); // 'hello' Object.getPrototypeOf()概述Object.getPrototypeOf() 方法返回指定对象的原型（内部[[Prototype]]属性的值）。 语法 Object.getPrototypeOf(object) 参数：obj: 要返回的对象的原型 例子12345678910111213function Test(item) &#123; this.item=item;&#125;Test.prototype.sayHello=function() &#123; console.log('hello');&#125;let test=new Test();// 使用Object.getPrototypeOf()方法访问原型let proto=Object.getPrototypeOf(test);console.log(proto); // Test &#123; sayHello: [Function] &#125; 原型对象的设置Object.setPrototypeOf()概述Object.setPrototypeOf() 方法设置一个指定的对象的原型 ( 即, 内部[[Prototype]]属性）到另一个对象或 null。 语法 Object.setPrototypeOf(obj, prototype) 参数：obj: 要设置其原型的对象 prototype: 该对象的新原型（一个对象或null） 例子1234567891011121314151617181920function Test(item) &#123; this.item=item;&#125;Test.prototype.sayHello=function() &#123; console.log('hello');&#125;let test=new Test();// 使用Object.setPrototypeOf()方法修改对象的原型let a=&#123; sayHello() &#123; console.log('say hello'); &#125;&#125;Object.setPrototypeOf(test,a);console.log(Object.getPrototypeOf(test)===a); // truetest.sayHello(); // 'say hello' Object.create()概述Object.create()方法创建一个新对象，使用现有的对象来提供新创建的对象的proto。 语法 Object.create(proto[, propertiesObject]) 参数：proto 新创建对象的原型对象。 propertiesObject 可选。如果没有指定为 undefined，则是要添加到新创建对象的可枚举属性（即其自身定义的属性，而不是其原型链上的枚举属性）对象的属性描述符以及相应的属性名称。这些属性对应Object.defineProperties()的第二个参数。 返回值 一个新对象，带着指定的原型对象和属性。 例子12345678910111213141516function Test(item) &#123; this.item=item;&#125;Test.prototype.sayHello=function() &#123; console.log('hello');&#125;// 使用Object.create创建一个新对象，该新对象的原型对象为给定值let test=Object.create(Test.prototype);Test.call(test,1);console.log(Object.getPrototypeOf(test)===Test.prototype); // truetest.sayHello(); // 'hello'console.log(test.item); // 1console.log(test); // Test &#123; item: 1 &#125; __proto__例子1234567891011121314151617function Test(item) &#123; this.item=item;&#125;Test.prototype.sayHello=function() &#123; console.log('hello');&#125;// 使用__Proto__属性来设置原型let test=&#123;&#125;;test.__proto__=Test.prototype;Test.call(test,1);console.log(Object.getPrototypeOf(test)===Test.prototype); // truetest.sayHello(); // 'hello'console.log(test.item); // 1console.log(test); // Test &#123; item: 1 &#125;]]></content>
      <categories>
        <category>javaScript基础</category>
      </categories>
      <tags>
        <tag>基础语法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[获取对象属性名的几种方法]]></title>
    <url>%2F2019%2F09%2F03%2F%E8%8E%B7%E5%8F%96%E5%AF%B9%E8%B1%A1%E5%B1%9E%E6%80%A7%E5%90%8D%E7%9A%84%E5%87%A0%E7%A7%8D%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[什么是可枚举属性和不可枚举属性可枚举属性是指那些内部 “可枚举” 标志（[[ Enumerable]]）设置为 true 的属性。 对于通过直接的赋值和属性初始化的属性，该标识值默认为即为 true; 对于通过 Object.defineProperty 等定义的属性，该标识值默认为 false（当然该方法也可以设置 enumerable的值为true，使其变为可枚举属性）。 Object.keys() –只返回自身对象的可枚举属性Object.keys() 方法会返回一个由一个给定对象的自身可枚举属性组成的数组，数组中属性名的排列顺序和使用 for…in 循环遍历该对象时返回的顺序一致 。如果对象的键-值都不可枚举，那么将返回由键组成的数组。 1234567891011121314151617181920212223242526let a=&#123; item:1&#125;let b=&#123; b:2, c() &#123; return this.b; &#125;&#125;// 设置a对象的不可枚举属性Object.defineProperty(a,'_item',&#123; get:function() &#123; return this.item; &#125;, set:function(item) &#123; this.item=item; &#125;&#125;)// 设置b对象为a的原型对象Object.setPrototypeOf(a,b);// 只会返回当前对象的所有可枚举属性，而不会返回其原型对象上的可枚举属性console.log(Object.keys(a)); // ['item'] for…in –返回整条原型链上的可枚举属性for…in语句以任意顺序遍历一个对象的除Symbol以外的可枚举属性。 循环将遍历对象本身的所有可枚举属性，以及对象从其构造函数原型中继承的属性（更接近原型链中对象的属性覆盖原型属性）。 123456789101112131415161718192021222324252627282930let a=&#123; item:1&#125;let b=&#123; b:2, c() &#123; return this.b; &#125;&#125;// 设置a对象的不可枚举属性Object.defineProperty(a,'_item',&#123; get:function() &#123; return this.item; &#125;, set:function(item) &#123; this.item=item; &#125;&#125;)// 设置b对象为a对象的原型对象Object.setPrototypeOf(a,b);// 会返回其自身的所有可枚举属性以及其原型链上的所有可枚举属性(包括其原型对象，其原型对象的原型对象一直到除Object,prototype的顶端原型对象)let ans=[];for(let i in a) &#123; ans.push(i);&#125;console.log(ans); // ['item','b','c'] getOwnPropertyNames() –返回自身对象的所有属性（包括不可枚举但不包括Symbol值）Object.getOwnPropertyNames()方法返回一个由指定对象的所有自身属性的属性名（包括不可枚举属性但不包括Symbol值作为名称的属性）组成的数组。 它与上述两种方法的不同之处在于其可以返回不可枚举属性 1234567891011121314151617181920212223242526let a=&#123; item:1&#125;let b=&#123; b:2, c() &#123; return this.b; &#125;&#125;// 设置a对象的不可枚举属性Object.defineProperty(a,'_item',&#123; get:function() &#123; return this.item; &#125;, set:function(item) &#123; this.item=item; &#125;&#125;)// 设置b对象为a对象的原型对象Object.setPrototypeOf(a,b);// 返回自身对象的所有属性，包括可枚举属性和不可枚举属性console.log(Object.getOwnpropertyNames(a)); //['item','_item']]]></content>
      <categories>
        <category>javaScript基础</category>
      </categories>
      <tags>
        <tag>基础语法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[leetcode-234 回文链表]]></title>
    <url>%2F2019%2F09%2F03%2Fleetcode-234%2F</url>
    <content type="text"><![CDATA[回文链表题目描述请判断一个链表是否为回文链表。 示例 1: 输入: 1-&gt;2输出: false 示例 2: 输入: 1-&gt;2-&gt;2-&gt;1输出: true 进阶：你能否用 O(n) 时间复杂度和 O(1) 空间复杂度解决此题？ 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/palindrome-linked-list著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 核心思路概述一个简单的想法就是，将该链表的所有节点值都取出来，然后判断是否回文。但是，题目要求为O(1)的空间复杂度，因此不能使用数组来存储。因此，我们可以使用哈希表来存储，以链表节点的下标为键名，节点值为键值来存入哈希表 之后利用双指针来判断是否回文 解题步骤 建立哈希表 遍历该链表，以链表节点的下标为键名，节点值为键值来存入哈希表 设置前后双指针，如果指针未相遇时，前后指针在哈希表中的键值不相同的话那么返回false 否则，返回true Coding实现1234567891011121314151617181920212223242526272829/** * Definition for singly-linked list. * function ListNode(val) &#123; * this.val = val; * this.next = null; * &#125; *//** * @param &#123;ListNode&#125; head * @return &#123;boolean&#125; */var isPalindrome = function(head) &#123; let cur=head; let map=new Map(); let index=0; while(cur) &#123; map.set(index,cur.val); index++; cur=cur.next; &#125; let left=0; let right=index-1; while(left&lt;right) &#123; if(map.get(left)!==map.get(right)) return false; left++; right--; &#125; return true;&#125;;]]></content>
      <categories>
        <category>leetcode题解与算法</category>
      </categories>
      <tags>
        <tag>链表</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[浅拷贝与深拷贝]]></title>
    <url>%2F2019%2F09%2F02%2F%E6%B5%85%E6%8B%B7%E8%B4%9D%E4%B8%8E%E6%B7%B1%E6%8B%B7%E8%B4%9D%2F</url>
    <content type="text"><![CDATA[什么是浅拷贝与深拷贝 浅拷贝与深拷贝是只针对Object和Array这样的引用数据类型的 浅拷贝指的是在复制对象的时候，对第一层键值进行独立的复制。若键值为基本类型值，则复制该基本类型值；若键值为引用类型值，则复制该引用类型值的引用 深拷贝则会创造另一个对象，只是这个对象与被拷贝的对象一模一样，但是并没有占用同一块内存 赋值操作是浅拷贝吗在将一个对象赋值给另一个对象的时候，其实是将该对象的引用地址复制给了它。因此两个对象占用同一个内存 但是，浅拷贝是在复制对象的时候，对第一层键值进行独立的复制。因此，新旧对象并不占用同一个内存，所以，原对象在浅拷贝之后做的任何操作都不会影响浅拷贝得到的对象 例如： 12345678910111213141516171819let a=&#123; item:1&#125;// 使用赋值操作得到的对象let b=a;console.log(b); // &#123;item:1&#125;console.log(b===a); // true// 使用浅拷贝得到的对象let c=&#123;&#125;;Object.assign(c,a);console.log(c); // &#123;item:1&#125;console.log(c===a); // false// 修改原对象a.item=2;console.log(b.item); // 2console.log(c.item); // 1 显然，赋值得到的对象与原对象占用同一个内存；而浅拷贝得到的对象与原对象并没有占有同一个内存，因此，原对象做出的任何修改都不会影响浅拷贝得到的对象 实现浅拷贝的几种方法Object.assign()概述Object.assign() 方法用于将所有可枚举属性的值从一个或多个源对象复制到目标对象。它将返回目标对象。 如果目标对象中的属性具有相同的键，则属性将被源对象中的属性覆盖。后面的源对象的属性将类似地覆盖前面的源对象的属性。 语法 Object.assign(target, …sources) 参数：target: 拷贝得到的对象sources: 被拷贝的对象，可以是多个 Object.assign()方法主要做的工作就是，遍历要拷贝对象的属性，如果该属性值为基本类型值，那么就复制该属性值；如果，该属性值为引用类型值，那么就复制该引用类型值的引用。 因此，该方法只拷贝对象的第一层属性 例子1234567891011121314151617181920let a=&#123; item:1, tree:&#123; k:2 &#125;&#125;// 使用浅拷贝得到的对象let c=&#123;&#125;;Object.assign(c,a);console.log(c); // &#123;item:1,tree:&#123;k:2&#125;&#125;console.log(c===a); // false// 修改原对象的第一层基本类型值a.item=2;console.log(c.item); // 1// 修改原对象的第二层基本类型值a.tree.k=3;console.log(c.tree.k); // 3 因此，使用浅拷贝得到的对象，如果其第一层属性值为基本类型值，那么原对象修改后，不会影响浅拷贝得到的对象； 如果其第一层属性值为引用类型值，那么原对象修改后会影响拷贝得到的对象 实现Object.assign()方法知道浅拷贝的思想之后，那么实现Object.assign()方法就很容易了 1234567function shallowCopy(receiver=&#123;&#125;,supplier) &#123; let keys=Object.keys(supplier); keys.forEach(v=&gt;&#123; receiver[v]=supplier[v]; &#125;) return receiver;&#125; 使用展开运算符展开运算符在构造字面量对象时，可以进行克隆或者属性拷贝（ECMAScript 2018规范新增特性）： let objClone = { …obj }; 其行为是, 将已有对象的所有可枚举(enumerable)属性拷贝到新构造的对象中. 浅拷贝(Shallow-cloning, 不包含 prototype) 和对象合并, 可以使用更简短的展开语法。而不必再使用 Object.assign() 方式. 12345678910111213141516let a=&#123; item:1, tree:&#123; item:2 &#125;&#125;let b=&#123;...a&#125;;console.log(b); // &#123;item:1,tree:&#123;item:2&#125;&#125;console.log(b===a); // falsea.item=2;console.log(b.item); // 1a.tree.item=3;console.log(b.tree.item); // 3 当然，使用展开运算符也可以拷贝多个对象。它像Object.assign方法一样，可以接受任意数量的原对象，并按指定顺序将属性复制到接受对象中。所以，如果多个原对象具有相同的属性名，那么排位靠后的原对象的属性值会覆盖排位靠前的 12345678910111213let a=&#123; item:1, tree:&#123; item:2 &#125;&#125;let b=&#123; item:2&#125;let c=&#123;...a,...b&#125;;console.log(c); // &#123; item: 2, tree: &#123; item: 2 &#125; &#125; 对于数组对象对于数组对象，可以使用以下方法 Array.prototype.concat() Array.prototype.slice() Array.of()结合不定参数 12345678910111213141516171819202122232425262728293031let test=[1,&#123;item:1&#125;]// 使用concat()方法let arr1=test.concat();console.log(arr1); // [1,&#123;item:1&#125;]console.log(arr1===test); // falseconsole.log(arr1[1]===test[1]); // true// 使用slice()方法let arr2=test.concat();console.log(arr2); // [1,&#123;item:1&#125;]console.log(arr2===test); // falseconsole.log(arr2[1]===test[1]); // true// 使用new Array()方法let arr3=new Array(...arr1);console.log(arr3); // [1,&#123;item:1&#125;]console.log(arr3===test); // falseconsole.log(arr3[1]===test[1]); // true// 修改数组中引用类型元素的值test[1].item=2;console.log(`$&#123;arr1[1].item&#125;$&#123;arr2[1].item&#125; $&#123;arr3[1].item&#125;`);// 2// 2// 2 数组对象的浅拷贝实质上就是，遍历整个数组将数组元素复制到另一个新的数组对象中去； 因此，当数组元素为基本类型值时，复制的就是基本类型值，原数组改变该值不会影响新数组 但是当数组元素为引用类型值时，复制的就是引用类型值的引用，那么原数组修改该值就会影响新的数组 实现深拷贝的几种方法利用JSON我们可以使用JSON.stringify将对象转成JSON字符串，再用JSON.parse()把字符串解析成对象。此时生成的对象与原对象会是完全不同的对象，里面的任何属性都不会占用同一个内存 12345678910111213141516171819let a=&#123; item:1, tree:&#123; item:2, tree:&#123; item:3 &#125; &#125;&#125;// 使用JSON方法深拷贝let b=JSON.parse(JSON.stringify(a));console.log(b); // &#123; item: 1, tree: &#123; item: 2, tree: &#123; item: 3 &#125; &#125; &#125;console.log(a===b); // falseconsole.log(a.tree===b.tree); // false// 修改原对象的引用类型属性a.tree.tree.item=4；console.log(b.tree.tree.item); // 3 这种方法虽然简便，但还是有一些缺点，比如 会忽略undefined 不能序列化函数 这是因为JSON.stringify() 方法是将一个JavaScript值(对象或者数组)转换为一个 JSON字符串，不能接受函数 无法拷贝Symbol 递归拷贝在深拷贝一个对象时，我们需要考虑要拷贝的这个对象时常规键值对对象还是数组对象。因为，遇到前者我们需要生成一个新的空对象{}，而遇到后者时我们需要生成一个新的空数组对象[] 那么，我们需要通过什么方法来检测，某个对象究竟是数组对象还是常规对象呢?可以采用如下方式： 123456function check(target) &#123; return Object.prototype.toString.call(target).slice(8,-1);&#125;console.log(check(new Object())); // Objectconsole.log(check(new Array())); // Array 因此，深拷贝完整代码如下： 123456789101112131415161718192021222324function deepClone(target) &#123; let ans; if(check(target)==='Array') ans=[]; else if(check(target)==='Object') ans=&#123;&#125;; else return target; for(let i in target) &#123; if(check(target[i])==='Array'||check(target[i])==='Object') &#123; ans[i]=deepClone(target[i]); &#125; else &#123; ans[i]=target[i]; &#125; &#125; return ans;&#125;function check(obj) &#123; return Object.prototype.toString.call(obj).slice(8,-1);&#125;let target=&#123;item:1,a:[1,2,&#123;item:2&#125;],tree:&#123;tree:&#123;item:3&#125;&#125;&#125;;let rev=deepClone(target);console.log(rev); // &#123; item: 1, a: [ 1, 2, &#123; item: 2 &#125; ], tree: &#123; tree: &#123; item: 3 &#125; &#125; &#125;console.log(rev.a===target.a); // false]]></content>
      <categories>
        <category>javaScript基础</category>
      </categories>
      <tags>
        <tag>基础语法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ES6中对于对象作出了哪些扩展]]></title>
    <url>%2F2019%2F09%2F02%2FES6%E4%B8%AD%E5%AF%B9%E4%BA%8E%E5%AF%B9%E8%B1%A1%E4%BD%9C%E5%87%BA%E4%BA%86%E5%93%AA%E4%BA%9B%E6%89%A9%E5%B1%95%2F</url>
    <content type="text"><![CDATA[对象字面量语法的扩展属性初始值的简写在ES6之前，当我们声明一个对象时，可能该对象的属性名与该对象可访问到的作用链上的某变量同名。那么显然此时会发生一些重复 例如: 123456function Person(name,age) &#123; return &#123; name:name, age:age &#125;&#125; 为了消除这种属性名称与局部变量之间的重复书写。在ES6中，当一个对象的属性与本地变量同名时，不必再写冒号和值，简单地只写属性名即可。 这也意味着，当在声明属性时，如果采用这种简写语法，只要保证能够访问到以该属性名为变量名的变量即可。（也就是，该变量所在的活动对象需在当前对象的所能访问到的作用链上） 例如： 12345// 同一个作用域内声明对象let a=1;let b=2;console.log(&#123;a,b&#125;); // &#123;a:1,b:2&#125; 123456789101112// 变量处在同一作用域链上时声明对象let a=1;let b=2;function test() &#123; return &#123; a, b &#125;&#125;console.log(test()); // &#123;a:1,b:2&#125; 123456789101112131415// 变量不处在同一作用域上声明对象&#123; let a=1; let b=2;&#125;function test() &#123; return &#123; a, b &#125;&#125;console.log(test()); // 报错：ReferenceError: a is not defined 当对象字面量中只有一个属性的名称时，JavaScript引擎会在可访问作用域中查找其同名变量；如果找到，则该变量的值被赋给对象字面量里的同名属性 对象方法的简写语法在ES6中，通过对象字面量法创建对象时，如果为对象添加方法，可以不再使用键值对来声明方法 例如： 1234567let a=&#123; test()&#123; console.log('test'); &#125;&#125;a.test(); // 'test' 可计算属性名点记法与方括号法当想访问一个对象的属性时，可以采用点记法和方括号法 例如： 12345678910111213let a=&#123; name:'ming', age:18&#125;console.log(a.name); // 'ming'// 方括号内为字符串console.log(a['age']); // 18// 方括号内可以表示为字符串的变量let age='age';console.log(a[age]); // 18 注意，当使用方括号语法时，方括号内必须是字符串或者表示字符串的变量 当然，该字符串可以不是一个合法的标识符；它可以是任意值 例如: 1234let a=&#123;&#125;;let firstName='first name';a[firstName]='ming';console.log(a); // &#123; 'first name': 'ming' &#125; 另外,使用点表示法时，点的后面必须是一个有效的 JavaScript 标识符，例如，一串字母数字字符，也包括下划线及美元符号，但不能以数字作为开头。比如，object.$1是合法的，而 object.1是无效不合法的。但是可以通过方括号表示法来解决这个问题 例如： 1234567let item=1;let a=&#123; [item]:123&#125;console.log(a); // &#123; '1': 123 &#125;// 将1转化为一个字符串console.log(a['1']); //123 在对象字面量中使用可计算属性名在对象字面量中使用方括号语法表示该属性名是可以被计算的。也就是说方括号内如果是一个变量，那么这个变量将会被求值并转化为一个字符串；如果方括号内是一个字符串，那么就使用这个字符串 12345678910// 方括号内为一个变量，该变量表示一个字符串//变量会被求值得到字符串let item='itemA';let a=&#123; [item]:1&#125;console.log(a); // &#123; itemA: 1 &#125;console.log(a[item]); // 1console.log(a.itemA); // 1 12345678// 方括号内为字符串，那么就使用这个字符串let a=&#123; ['itemA']:1&#125;console.log(a); // &#123; itemA: 1 &#125;console.log(a['itemA']); // 1console.log(a.itemA); // 1 1234567891011// 方括号内为一个变量，该变量表示的不是一个字符串// 变量会通过String()转型函数被转化为字符串，因此undefined和null也可以let item=1;let test=undefined;let a=&#123; [item]:123, [test]:987&#125;console.log(a); // &#123; '1': 123, undefined: 987 &#125;console.log(a.undefined); // 987 当然，可计算属性名也可以计算表达式 123456let first='first 'let a=&#123; [first+'name']:'ming'&#125;console.log(a); // &#123; 'first name': 'ming' &#125;console.log(a['first name']); // ming]]></content>
      <categories>
        <category>ES6</category>
      </categories>
      <tags>
        <tag>基础语法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[leetcode-232 用栈实现队列]]></title>
    <url>%2F2019%2F09%2F02%2Fleetcode-232%2F</url>
    <content type="text"><![CDATA[用栈实现队列题目描述使用栈实现队列的下列操作： push(x) -- 将一个元素放入队列的尾部。 pop() -- 从队列首部移除元素。 peek() -- 返回队列首部的元素。 empty() -- 返回队列是否为空。示例: MyQueue queue = new MyQueue(); queue.push(1); queue.push(2); queue.peek(); // 返回 1 queue.pop(); // 返回 1 queue.empty(); // 返回 false说明: 你只能使用标准的栈操作 – 也就是只有 push to top, peek/pop from top, size, 和 is empty 操作是合法的。 你所使用的语言也许不支持栈。你可以使用 list 或者 deque（双端队列）来模拟一个栈，只要是标准的栈操作即可。 假设所有操作都是有效的 （例如，一个空的队列不会调用 pop 或者 peek 操作）。 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/implement-queue-using-stacks著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 核心思路概述队列与栈不一样的地方就在于，栈是先进后出，而队列是先进先出；因此，在利用栈实现队列，只有出队列方法不一样而已； 解题步骤 在实现出队列的方法时，需要准备一个备用栈，来存储出栈的元素。 当需要出队列时，将栈内所有元素出栈并以此存入到备用栈中； 将备用栈的栈顶元素出栈并保存到一个变量ans中； 将备用栈的所有元素出栈并以此存入回基本栈中 返回ans Coding实现1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556/** * Initialize your data structure here. */var MyQueue = function() &#123; this.stack=[];&#125;;/** * Push element x to the back of queue. * @param &#123;number&#125; x * @return &#123;void&#125; */MyQueue.prototype.push = function(x) &#123; this.stack.push(x);&#125;;/** * Removes the element from in front of queue and returns that element. * @return &#123;number&#125; */MyQueue.prototype.pop = function() &#123; let anotherStack=[]; while(this.stack.length) &#123; anotherStack.push(this.stack.pop()); &#125; let ans=anotherStack.pop(); while(anotherStack.length) &#123; this.stack.push(anotherStack.pop()); &#125; return ans;&#125;;/** * Get the front element. * @return &#123;number&#125; */MyQueue.prototype.peek = function() &#123; return this.stack[0];&#125;;/** * Returns whether the queue is empty. * @return &#123;boolean&#125; */MyQueue.prototype.empty = function() &#123; return this.stack.length===0;&#125;;/** * Your MyQueue object will be instantiated and called as such: * var obj = new MyQueue() * obj.push(x) * var param_2 = obj.pop() * var param_3 = obj.peek() * var param_4 = obj.empty() */]]></content>
      <categories>
        <category>leetcode题解与算法</category>
      </categories>
      <tags>
        <tag>栈</tag>
        <tag>队列</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[leetcode-113 路径总和 II]]></title>
    <url>%2F2019%2F09%2F01%2Fleetcode-113%2F</url>
    <content type="text"><![CDATA[路径总和 II题目描述给定一个二叉树和一个目标和，找到所有从根节点到叶子节点路径总和等于给定目标和的路径。 说明: 叶子节点是指没有子节点的节点。 示例:给定如下二叉树，以及目标和 sum = 22， 返回: 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/path-sum-ii著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 核心思路概述不同于上题，这次还要记录路径和为给定值的路径上的所有值。那么我们可以用数组来进行记录，每次传入一个新的数组（包括该条路径上当前记录的所有的值）。 采用先序遍历，当遍历到叶子节点时，判断路径和是否为给定值，如果是，那么将该数组插入到ans数组中；否则，return； 解题步骤 创建ans数组 创建遍历函数(传入的参数为当前节点，当前路径和，当前已经被记录的节点值的数组)，如果节点为空，那么return 否则，将该节点的值记录到传入的数组中；如果当前节点为叶子节点，那么判断此时的路径和是否为给定值，如果是，那么将此时的数组push入ans数组中；如果不是，则return，接着遍历直到整棵树遍历完毕 Coding实现123456789101112131415161718192021222324252627282930313233/** * Definition for a binary tree node. * function TreeNode(val) &#123; * this.val = val; * this.left = this.right = null; * &#125; *//** * @param &#123;TreeNode&#125; root * @param &#123;number&#125; sum * @return &#123;number[][]&#125; */var pathSum = function(root, sum) &#123; let ans=[]; (function path(root,s,array) &#123; if(root===null) return; else &#123; array.push(root.val); let arrayCloneLeft=array.slice(0); let arrayCloneRight=array.slice(0); s+=root.val; if(!root.left&amp;&amp;!root.right) &#123; if(s===sum) &#123; ans.push(array); &#125; return; &#125; path(root.left,s,arrayCloneLeft); path(root.right,s,arrayCloneRight); &#125; &#125;)(root,0,[]) return ans;&#125;;]]></content>
      <categories>
        <category>leetcode题解与算法</category>
      </categories>
      <tags>
        <tag>树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[getter与setter函数]]></title>
    <url>%2F2019%2F08%2F31%2Fgetter%E4%B8%8Esetter%E5%87%BD%E6%95%B0%2F</url>
    <content type="text"><![CDATA[访问器属性对象属性分为数据属性与访问器属性。访问器属性不包含数据值，它们包含一对getter与setter函数。在读取访问器属性时，会调用getter函数，这个函数负责返回有效的值；在写入访问器属性时，会调用setter函数并传入新值 什么是getter/setter getter是获得属性值的方法，setter是设置属性值的方法 get与set并不是对象的属性，可以说是伪属性，特性只有内部才用，一般利用Object.getOwnPropertyDescriptor()方法来查询属性的特性；利用Object.defineProperty来定义和修改属性的特性 怎么定义getter与setterget与set语法get/set语法会将对象属性绑定到查询/调用的函数 例： 12345678910111213let a=&#123; item:1, get getItem() &#123; return this.item; &#125;, set setItem(item) &#123; this.item=item; &#125;&#125;console.log(a); // &#123; item: 1, getItem: [Getter], setItem: [Setter] &#125;console.log(a.getItem); // 1a.setItem=2;console.log(a.getItem); // 2 get与set绑定的函数名可以是一样的 12345678910111213let a=&#123; item:1, get _item() &#123; return this.item; &#125;, set _item(item) &#123; this.item=item; &#125;&#125;console.log(a); // &#123; item: 1, _item: [Getter/Setter] &#125;console.log(a._item); // 1a._item=2;console.log(a._item); // 2 当然,get与set也可以绑定多个函数名 1234567891011121314151617181920212223let a=&#123; item:1, name:'ming', get _item() &#123; return this.item; &#125;, set _item(item) &#123; this.item=item; &#125;, get _name() &#123; return this.name; &#125;, set _name(name) &#123; this.name=name; &#125;&#125;console.log(a); // &#123;item: 1,name: 'ming',_item: [Getter/Setter],_name: [Getter/Setter]&#125;console.log(a._item); // 1a._item=2;console.log(a._item); // 2console.log(a._name); // minga._name='xiao ming';console.log(a._name); // xioa ming defineProperty()方法Object.defineProperty() 方法会直接在一个对象上定义一个新属性，或者修改一个对象的现有属性， 并返回这个对象。 语法： Object.defineProperty(obj, prop, descriptor) 参数 obj 要在其上定义属性的对象。 prop 要定义或修改的属性的名称。 descriptor 将被定义或修改的属性描述符 例： 12345678910111213let a=&#123;item:1&#125;;Object.defineProperty(a,'_item',&#123; get: function () &#123; return this.item; &#125;, set: function (item) &#123; this.item=item; &#125;&#125;)console.log(a._item); // 1a._item=2;console.log(a._item); // 2 getter与setter的作用getter与setter的作用我觉得是可以在对赋值和取值之前做一层封装，拦截这些操作，定义一些其他操作（在赋值与取值之前进行一些额外的操作） 1234567891011121314151617let a=&#123;item:1&#125;;Object.defineProperty(a,'_item',&#123; get: function () &#123; return this.item; &#125;, set: function (item) &#123; let date=new Date(); console.log(`a.item的值在$&#123;date.toLocaleString()&#125;被修改`); this.item=item; &#125;&#125;)console.log(a._item); // 1a._item=2;console.log(a._item);// a.item的值在2019-8-31 20:50:59被修改// 2 在上述代码中,我在setter函数赋值后，输出属性值被修改的时间。从而可以监测到值何时被修改。 这就是拦截了赋值操作,先进行了额外定义的检测值被修改的方法]]></content>
      <categories>
        <category>javaScript基础</category>
      </categories>
      <tags>
        <tag>基础语法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Es6一些新的函数参数知识]]></title>
    <url>%2F2019%2F08%2F31%2FEs6%E4%B8%80%E4%BA%9B%E6%96%B0%E7%9A%84%E5%87%BD%E6%95%B0%E5%8F%82%E6%95%B0%E7%9F%A5%E8%AF%86%2F</url>
    <content type="text"><![CDATA[arguments对象每个函数都会有一个arguments对象(类数组对象)，它引用着函数的实参而非形参。 因此，Js函数有一个十分特别的特性，即无论形参有几个，都可以传入任意个实参值，并且由arguments对象引用着 例： 12345function test(a,b) &#123; console.log(arguments); // [Arguments] &#123; '0': 1, '1': 2, '2': 3 &#125;&#125;test(1,2,3); 函数参数的默认值因为在函数定义中声明了多少形参，都可以传入任意数量的参数。那么，如果，传入的参数要比形参少时，我们能否给没有得到传值的形参赋予默认值呢？ Es5模拟默认参数值如果一个参数没有传入值，那么那个形参就会是已声明但未定义，因此，形参就会被默认赋予undefined 如： 12345function test(a,b) &#123; console.log(b); // undefined&#125;test(1); 那么，我们可以在函数体中检测该形参值是否为undefined来判断是否来赋予形参默认值 123456789function test(a,b) &#123; a=((typeof a)!=='undefined')?a:1; b=((typeof b)!=='undefined')?b:2; console.log(a,b);&#125;test(0,0); // 0,0test(0); // 0,2test(); // 1,2 Es6中的默认参数值Es6简化了像Es5模拟默认参数值进行检测形参值是否为undefined的操作，它可以在形参后赋予一个初始值，当没有实参传入时，则使用那个初始值 例如： 12345function test(a,b=1,c) &#123; console.log(a,b,c); // undefined,1,undefined&#125;test(); 如上所示，test函数调用时没有传入任何参数，因此没有赋予初始值的a,c会输出undefined，而赋予初始值的形参在没有获得实参传入时就会获得该初始值 但是，其实质上也是像Es5一样检测了形参值是否为undefined；因此，当你显示地传入undefined值时，它还是会获得被赋予的初始值； 注意，null是一个空对象指针，它不等于undefined 123456function test(a,b=1,c) &#123; console.log(a,b,c); // undefined,1,undefined&#125;test(undefined,undefined,undefined);test(null,null,null); // null,null,null 默认参数值对arguments对象的影响没有使用默认参数值在Es5非严格模式下，当形参值发生变化时，arguments对象也会做出相应的改变；即，命名参数的变化会同步更新到arguments对象中 例： 123456789101112function test(a,b) &#123; console.log(a,b,arguments); // 1 2 [Arguments] &#123; '0': 1, '1': 2 &#125; a=++a; b=++b; console.log(a,b,arguments); // 2 3 [Arguments] &#123; '0': 2, '1': 3 &#125; // arguments对象发生了变化&#125;test(1,2); 使用默认参数值在Es6中，如果函数使用了默认参数值（哪怕所有形参都被传入了实参值），那么所有形参值的变化都不会影响arguments对象，即，默认参数值的存在使得arguments对象保持与命名参数的分离 例： 123456789101112function test(a=3,b=4) &#123; console.log(a,b,arguments); // 1 2 [Arguments] &#123; '0': 1, '1': 2 &#125; a=++a; b=++b; console.log(a,b,arguments); // 2 3 [Arguments] &#123; '0': 1, '1': 2 &#125; // arguments对象没有发生变化&#125;test(1,2); 默认参数表达式默认参数初始值的赋予可以通过函数来进行 例： 123456789function getB() &#123; return 3;&#125;function test(a,b=getB()) &#123; console.log(a,b); // undefined 3&#125;test(); 对于上面的test函数，初次解析函数声明的时候并不会执行getB方法，只有放该函数被调用且没有传入b的实参时才会被执行 因此，默认参数值的赋予是在函数调用时进行的，所以，我们就可以使用先定义的参数来作为后定义的参数的初始值 1234567function test(a,b=a) &#123; console.log(a,b); // 1,1 // b形参没有传入实现值，因此会赋予形参a的值，此时a传入了实参值1，因此b也被赋予为1&#125;test(1); 但是，如果先定义的参数使用后定义的参数来作为初始值，就会发生错误 123456function test(a=b,b) &#123; console.log(a,b); // 报错： ReferenceError: Cannot access 'b' before initialization&#125;test(undefined,1); 具体原因，类似于let与const声明会具有的临时死区(TDZ) 默认参数的临时死区与let和const声明类似，默认参数也具有临时死区，在临时死区内的参数不可访问。 在参数被定义时，在预编译阶段，这些参数会被放入临时死区内，如果在运行到这些参数声明语句之前就访问这些参数，那么就会导致程序抛出错误 例： 123456function test(a=b,b) &#123; console.log(a,b); // 报错： ReferenceError: Cannot access 'b' before initialization&#125;test(undefined,1); 上述参数赋值阶段的行为类似于以下 123let a=undefined;a=b; // 此时b还在临时死区内，无法被访问let b=1; 不定参数当传入的实参数量小于形参数量时，我们可以使用默认参数值； 那么，如果，当传入的实参数量大于形参数量，我们一般会想到使用arguments对象来表示这些实参；而Es6给我们引入了不定参数的特性，来方便地表示传入的实参 概念在函数的命名参数前添加三个点（…）就表明这是一个不定参数，该参数为一个数组，包含着自它之后传入的所有实参，通过这个数组名可以逐一访问到里面的参数 例如： 12345function test(a,...arr) &#123; console.log(a,arr); // 1,[2,3,4]&#125;test(1,2,3,4); 注意： 每个函数最多只能声明一个不定参数，并且该不定参数一定要放在所有的参数的末尾 不定参数不能用于对象字面量的setter函数中,因为，setter函数的参数有且只能有一个。因此不能传入不定参数，哪怕即使只是传入一个值 1234567891011let a=&#123; item:1, set _item(...item)&#123; this.item=item[0]; &#125;&#125;a._item=3;// 赋值时会报错// Setter function argument must not be a rest parameterconsole.log(a.item); 怎么判断函数是被new还是被普通调用JavaScript函数有两个内部方法：[[Call]]和[[Construct]]。当通过new关键字调用函数时，执行的是[[Construct]]；而当为普通调用时，执行的时[[Call]]函数。 具有[[construct]]方法的函数被称为构造函数，但不是所有的函数都有[[Construct]]方法，比如箭头函数，因此箭头函数不能被new关键字调用 元素性 new.target为了解决判断函数是否通过new关键字调用的问题，Es6引入了new.target元属性。 当调用[[Construct]]方法，即使用new关键字调用函数时，new.target被赋值为当前构造函数；如果是普通调用，那么new.target值为undefined 例如： 12345678function Test(item) &#123; console.log(new.target); this.item=item;&#125;let test=new Test(1); // [Function Test]Test(1); // undefinedconsole.log(test); // &#123;item:1&#125; 注意：在函数外面使用new.target会造成语法错误 123456function test() &#123; // ...&#125;console.log(new.target);// SyntaxError: new.target only allowed within functions 尾调用优化]]></content>
      <categories>
        <category>ES6</category>
      </categories>
      <tags>
        <tag>基础语法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[leetcode-231 2的幂]]></title>
    <url>%2F2019%2F08%2F31%2Fleetcode-231%2F</url>
    <content type="text"><![CDATA[2的幂题目描述给定一个整数，编写一个函数来判断它是否是 2 的幂次方。 示例 1: 输入: 1输出: true解释: 20 = 1 示例 2: 输入: 16输出: true解释: 24 = 16 示例 3: 输入: 218输出: false 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/power-of-two著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 核心思路概述题目给定要求的是整数，那么也就是自然数，因为2的幂次方大于0，因此我们只要考虑大于等于1的整数即可。 对于，这些整数，我们可以将该数不断除以2，如果得到的结果不是整数，那么该数就不是2的幂次方；如果，最终得到的结果为1，那么该数就是2的幂次方 解题步骤 如果输入为0，返回false; 如果该数为1，返回true 否则，将该数除以2，如果结果不为整数，返回false；如果为整数，那么重复该步骤直到结果为1或者返回fase Coding实现1234567891011121314/** * @param &#123;number&#125; n * @return &#123;boolean&#125; */var isPowerOfTwo = function(n) &#123; if(n===0) return false; while(n) &#123; if(n===1) return true; else &#123; if(n/2!==Math.floor(n/2)) return false; &#125; n=n/2; &#125;&#125;;]]></content>
      <categories>
        <category>leetcode题解与算法</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[模板字面量]]></title>
    <url>%2F2019%2F08%2F30%2F%E6%A8%A1%E6%9D%BF%E5%AD%97%E9%9D%A2%E9%87%8F%2F</url>
    <content type="text"><![CDATA[什么是模板字面量模板字面量 是允许嵌入表达式的字符串字面量。你可以使用多行字符串和字符串插值功能。它们在ES2015规范的先前版本中被称为“模板字符串”。 基础语法12345678`string text` // 相当于普通字符串`string text line 1 string text line 2` // 多行字符串 `string text $&#123;expression&#125; string text` // 带有占位符tag `string text $&#123;expression&#125; string text` 模板字符串使用反引号 () 来代替普通字符串中的用双引号和单引号。模板字符串可以包含特定语法（${expression}）的占位符。占位符中的表达式和周围的文本会一起传递给一个默认函数，该函数负责将所有的部分连接起来，如果一个模板字符串由表达式开头，则该字符串被称为带标签的模板字符串，该表达式通常是一个函数，它会在模板字符串处理后被调用，在输出最终结果前，你都可以通过该函数来对模板字符串进行操作处理。在模版字符串内使用反引号（`）时，需要在它前面加转义符（\）。 在模板字符串中，不需要转义单双引号 多行字符串123456console.log(`abc def`); // 输出结果：abcdef 注意： 在两个反引号之间的所有空白字符串都是有效的，都属于字符串的一部分。 123456console.log(`abc def`);// 输出结果abc def 因此我们可以考虑使用第一行留白的方法来对齐缩进文本 12345678console.log(` abc def`);// 输出结果 abc def 当然我们也可以使用\n在模板字符串中显示换行 12345console.log(`abc\ndef`);// 输出结果abcdef 字符串占位符在一个模板字面量中，你可以任何合法的JavaScript表达式嵌入到占位符中并将其作为字符串中的一部分输出到结果中去 占位符由${}组成，中间可以包含任意的表达式 例： 12let name='ming';console.log(`My name is $&#123;name&#125;`); // My name is ming 除了变量，占位符还可以嵌入其他表达式，包括运算式、函数调用等等 1234567function getName()&#123; return `ming`;&#125;console.log(`My name is $&#123;getName()&#125;`); // My name is mingconsole.log(`My name is $&#123;'xiao'+'ming'&#125;`); // My name is xiaoming 嵌套模板模板字面量本身也是Js表达式，所以你可以在任意一个模板字面量里嵌入另外一个模板字面量 注意： 是另外一个模板字面量而不是占位符，即：应该是 1`$&#123;`$&#123;&#125;`&#125;` 而不是 1`&amp;&#123;&amp;&#123;&#125;&#125;` // 会报错 1console.log(`$&#123;2&gt;1?`$&#123;2&gt;1?'yes':'no'&#125;`:'no'`) // 'yes' 标签模板更高级的形式的模板字符串是带标签的模板字符串。标签使您可以用函数解析模板字符串。标签函数的第一个参数包含一个字符串值的数组。其余的参数与表达式相关。最后，你的函数可以返回处理好的的字符串（或者它可以返回完全不同的东西，）。用于该标签的函数的名称可以被命名为任何名字。 定义标签标签可以是一个函数，其函数名可以任意（符合变量命名规则） 标签函数语法： 123function tag(literals,...substitutions)&#123; // 返回一个字符串&#125; 参数解释 literals: 该参数是一个字符串数组，其包括模板字面量中占位符之前，之后，以及之间的字符串 例如，对于模板字符串${girlName},my name is ${boyName}则，其数组为[‘’,’,my name is ‘,’’] substitutions:该参数是模板字符串中所有占位符结果的值，例如以上模板字符串，则数组应该为${girlName}的值和${boyName}的值 注意 不难发现,literals数组的长度永远比substitutions数组长度多1 标签模板例子1234567891011121314151617function tag(literals,...sub)&#123; console.log(literals,sub); let ans=''; for(let i in sub) &#123; ans+=literals[i]; ans+=sub[i]; &#125; ans+=literals[literals.length-1]; return ans;&#125;let name='ming';let mes=tag`my name is $&#123;name&#125;`;console.log(mes);// 输出结果[ 'my name is ', '' ] [ 'ming' ]my name is ming]]></content>
      <categories>
        <category>ES6</category>
      </categories>
      <tags>
        <tag>基础语法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[leetcode-226 翻转二叉树]]></title>
    <url>%2F2019%2F08%2F30%2Fleetcode-226%2F</url>
    <content type="text"><![CDATA[翻转二叉树题目描述翻转一棵二叉树。 示例： 输入： 输出： 备注:这个问题是受到 Max Howell 的 原问题 启发的 ： 谷歌：我们90％的工程师使用您编写的软件(Homebrew)，但是您却无法在面试时在白板上写出翻转二叉树这道题，这太糟糕了。 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/invert-binary-tree著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 核心思路概述翻转二叉树，可以利用深度优先遍历，对于二叉树来说也就是先序遍历；在遍历的同时交换其左右子树 解题步骤 如果节点为空，那么返回null 否则，交换其左右子树 递归遍历左右子树 重复1,2,3步骤直到整颗二叉树遍历完毕 Coding实现12345678910111213141516171819202122/** * Definition for a binary tree node. * function TreeNode(val) &#123; * this.val = val; * this.left = this.right = null; * &#125; *//** * @param &#123;TreeNode&#125; root * @return &#123;TreeNode&#125; */var invertTree = function(root) &#123; if(root===null) return null; else &#123; let empty=root.left; root.left=root.right; root.right=empty; invertTree(root.left); invertTree(root.right); &#125; return root;&#125;;]]></content>
      <categories>
        <category>leetcode题解与算法</category>
      </categories>
      <tags>
        <tag>树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数组扁平化]]></title>
    <url>%2F2019%2F08%2F29%2F%E6%95%B0%E7%BB%84%E6%89%81%E5%B9%B3%E5%8C%96%2F</url>
    <content type="text"><![CDATA[数组扁平化数组的扁平化，就是将一个嵌套多层的数组按照给定深度转化为原本深度减去给定深度的数组 例如： 12let arr=[1,2,[3,4]];console.log(arr.flat()); // [1,2,3,4] flat()方法概述flat() 方法会按照一个可指定的深度递归遍历数组，并将所有元素与遍历到的子数组中的元素合并为一个新数组返回。 语法 var newArray = arr.flat(depth) 参数depth(可选) 指定要提取嵌套数组的结构深度，默认值为1 返回值一个包含数组与子数组所有元素的新数组 实现数组扁平化flat()方法利用递归实现思路根据给定深度遍历，那么我们需要知道每一层数组的深度。当遍历每一层数组时，若遇到了内一层的数组，那么对该数组再执行Flat函数，也就是进行递归；若不是，则放入ans数组 代码实现12345678910111213141516171819202122function Flat(arr,num) &#123; return (function f(arr,dep)&#123; let ans=[]; arr.forEach(v=&gt;&#123; if(dep&lt;num) &#123; if(!Array.isArray(v)) &#123; ans.push(v); &#125; else &#123; ans.push(...f(v,dep+1)); &#125; &#125; else ans.push(v); &#125;) return ans; &#125;)(arr,0)&#125;console.log(Flat([1,2, ,[3,4,[5,6]],[7,8,[9,10,[11,12]]]],2))// 输出结果[ 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, [ 11, 12 ] ] 利用reduce方法实现reduce方法就是遍历原数组，将每个元素利用concat方法进行拼接。因为concat方法进行拼接时会将被拼接的数组的最外层数组去掉，只取得内部的元素 12345678910111213141516171819function Flat(arr,depth)&#123; return (function flat(arr,dep) &#123; dep++; return arr.reduce((pre,cur)=&gt;&#123; if(dep&gt;=depth) &#123; return pre.concat(cur); &#125; else &#123; return Array.isArray(cur)?pre.concat(flat(cur,dep)):pre.concat(cur); &#125; &#125;,[]) &#125;)(arr,0)&#125;console.log(Flat([1,2,[3,4,[5,6,[7,8]]]],2))// 输出结果[ 1, 2, 3, 4, 5, 6, [ 7, 8 ] ] 利用toString()方法实现使用toString()方法我目前能想到的好像只能将数组完全扁平化到一维数组，而不能根据给定深度来扁平化 12345678function Flat(arr) &#123; return arr.toString().split(',').map(value=&gt;parseInt(value));&#125;console.log(Flat([1,2,[3,4,[5,6]]]));// 输出结果[ 1, 2, 3, 4, 5, 6 ] 使用展开运算符…类似于使用reduce配合concat,但是还是离不开递归]]></content>
      <categories>
        <category>javaScript基础</category>
      </categories>
      <tags>
        <tag>基础语法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[leetcode-566 重塑矩阵]]></title>
    <url>%2F2019%2F08%2F29%2Fleetcode-566%2F</url>
    <content type="text"><![CDATA[重塑矩阵题目描述在MATLAB中，有一个非常有用的函数 reshape，它可以将一个矩阵重塑为另一个大小不同的新矩阵，但保留其原始数据。 给出一个由二维数组表示的矩阵，以及两个正整数r和c，分别表示想要的重构的矩阵的行数和列数。 重构后的矩阵需要将原始矩阵的所有元素以相同的行遍历顺序填充。 如果具有给定参数的reshape操作是可行且合理的，则输出新的重塑矩阵；否则，输出原始矩阵。 示例 1: 输入:\nums = [[1,2], [3,4]]r = 1, c = 4输出: [[1,2,3,4]]解释:行遍历nums的结果是 [1,2,3,4]。新的矩阵是 1 * 4 矩阵, 用之前的元素值一行一行填充新矩阵。 示例 2: 输入: nums = [[1,2], [3,4]]r = 2, c = 4输出: [[1,2], [3,4]]解释:没有办法将 2 * 2 矩阵转化为 2 * 4 矩阵。 所以输出原矩阵。 注意： 给定矩阵的宽和高范围在 [1, 100]。 给定的 r 和 c 都是正数。 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/reshape-the-matrix著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 核心思路概述重塑矩阵，意思也就是将原先的nm矩阵转化为题目要求的rc矩阵；一种思路是我们在遍历数组的所有元素的时候就插入到rc新矩阵中；另一种思路是，将整个二维数组扁平化为一维数组，然后再转化为新的rc矩阵 解题步骤 将数组扁平化 转化为r*c矩阵 Coding实现1234567891011121314151617181920/** * @param &#123;number[][]&#125; nums * @param &#123;number&#125; r * @param &#123;number&#125; c * @return &#123;number[][]&#125; */var matrixReshape = function(nums, r, c) &#123; let ans=[]; let numsFlat=nums.flat(); if(r*c!==numsFlat.length) return nums; else &#123; for(let i=0;i&lt;r;i++) &#123; ans[i]=[]; for(let k=0;k&lt;c;k++) &#123; ans[i].push(numsFlat.shift()); &#125; &#125; &#125; return ans;&#125;;]]></content>
      <categories>
        <category>leetcode题解与算法</category>
      </categories>
      <tags>
        <tag>数组</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Javascript与简单正则表达式]]></title>
    <url>%2F2019%2F08%2F28%2FJavascript%E4%B8%8E%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[正则表达式正则表达式(regular expression)描述了一种字符串匹配的模式（pattern），可以用来检查一个串是否含有某种子串、将匹配的子串替换或者从某个串中取出符合某个条件的子串等。 Js怎么支持正则表达式Es是通过RegExp类型来支持正则表达式。 怎么创建正则表达式使用正则表达式字面量语法 let pat=/pattern/flags 其中,pattern部分是正则表达式，而flags部分是标志，可以是0或多个，其中标志包括下列三种： g: 表示全局模式，即模式将被应用到所有的字符串，而非在发现第一个匹配项时就立刻停止；若没有该标志，则表示该模式时在发现第一个匹配项时就立刻停止 i: 表示不区分大小写模式，即在确定匹配项时忽略模式与字符串的大小写 m: 表示多行模式，即在到达一行文本末尾时还会继续查找下一行中是否存在于模式匹配的项 使用RegExp构造函数创建语法 let re=new RegExp(“pattern”,”flags”); 其中，pattern与flags意义同上 正则表达式的一些相关重要方法exec()方法exec()方法是专门为捕获组而设计的。exec()接受一个参数，即要应用模式的字符串，然后返回包括第一个匹配项信息的数组；或者在没有匹配的情况下返回null 例： 123let pattern=/.at/g;let str='cat pat hat';console.oog(pattern.exec(str)); // [ 'cat', index: 0, input: 'cat pat hat', groups: undefined ] test()方法test()方法接受一个字符串参数。在模式与该参数匹配的情况下返回true;否则，返回false。经常被用于if判断语句 只要在字符串中存在某字符串能够匹配正则表达式的模式，那么就会返回true 例： 123let pattern=/.at/g;let str='cat pat hat';console.log(pattern.test(str)); // true String.match()方法match() 方法检索返回一个字符串匹配正则表达式的的结果。 语法： str.match(regexp); 参数： regexp:一个正则表达式对象。如果传入的是一个非正则表达式对象，则会隐式地使用new RegExp(obj)将其转化为一个正则表达式对象。如果没有给定任何参数，那么则会返回一个空数组 返回值： 如果使用g标志，那么则返回所有与正则表达式匹配的结果(Array)，但不会返回捕获组；或者没有匹配项返回null 如果不使用g标志，那么则返回第一个完整匹配及相关的捕获组。 例： 123let pattern=/.at/g;let str='cat pat hat';console.log(str.match(pattern)); // ['cat','pat','hat'] 元字符元字符是正则表达式的基本组成元素。 具体元字符如下： 元字符 描述 . 匹配除了换行符以外的任意字符 [] 匹配方括号中的任意一个字符,可以使用连字符’-‘来表示范围，例如 [a,b,c]可以表示为[a-c] [^] 上一个的反状态，即匹配除了括号内的任意一个字符 {n,m} 匹配前面的字符[n,m]次，即至少n次，但是不超过m次 (xyz) 相当于四则运算中常用的小括号，解释为按照确切的顺序来匹配字符xyz | 分支结构，匹配符号之前的字符或后面的字符 \ 转义符，它可以还原元字符原来的含义，允许你匹配保留元字符 * 匹配前面的子表达式0次或多次 + 匹配前面的子表达式一次或多次 ? 匹配前面的子表达式0次或一次，或指定一个非贪婪限定符 ^ 匹配行的开始 $ 匹配行的结束 \d 表示[0-9]，即1位数字 \D 表示除数字外的任意字符 \w 表示[0-9a-zA-z_]，即数字、大小写字母或下划线 \W 表示非单词字符，\w的对立 \s 表示空白符，包括空格、水平制表符、垂直制表符、换行符、回车符、换页符 \S 非空白符 如果想要匹配任意字符，根据以上元字符可以使用 \d|\D 或 [\d\D] \w|\W 或 [\w\W] \s|\S 或 [\s\S] [^] 元字符详解与例子元字符 .元字符.可以用来匹配除了换行符之外的所有单个字符 123let pattern=/.at/g;let str='cat pat hat';console.log(str.match(pattern)); // ['cat','pat','hat'] 元字符 []元字符 []用来匹配方括号内的任意一个字符 123let pattern=/[cph]at/g;let str='cat pat hat';console.log(str.match(pattern)); // ['cat','pat','hat'] 元字符 [^]元字符 [^]用来匹配除了方括号内字符的任意一个字符 123let pattern=/[^cph]at/g;let str='cat pat hat';console.log(str.match(pattern)); // null 元字符 {n,m}元字符 {n,m}用来匹配该元字符的前一个字符[n,m]次（即至少n次但不超过m次） 123let pattern=/.a&#123;1,2&#125;t/g;let str='cat paat haaat';console.log(str.match(pattern)); // ['cat','paat','aaat'] 元字符 (xyz)元字符 (xyz)我觉得其实相当于四则运算中的小括号，先执行小括号内的部分 123let pattern=/.(a|b|c)t/g;let str='cat pbt hct';console.log(str.match(pattern)); // ['cat','pbt','hct'] 元字符 |元字符 | 用来定义分支结构，分支结构就是相当于或运算。即要么执行元字符之前的字符要么执行之后的字符或者都不； 注意： 该元字符类似于或运算具有短路操作 123let pattern=/.(a|b|c)t/g;let str='cat pbt hct';console.log(str.match(pattern)); // ['cat','pbt','hct'] 1234567let pattern=/good|goodbye/g;let str='good goodbye';console.log(str.match(pattern)); // ['good','good']// 元字符 | 类似或运算具有短路操作，当前面的字符成立时就不会执行元字符之后的字符。// 上面的代码中，str字符串中的第一个'good'字符串满足正则表达式模式中的'good'，而后一个'goodbye'字符串虽然也满足'goodbye'，但是它先满足元字符之前的字符'good'，因此该运算被短路了，所以只返回了'good' 123let pattern=/goodbye|good/g;let str='good goodbye';console.log(str.match(pattern)); // ['good','goodbye'] 元字符 \元字符 \用来转义它的下一个字符。这将允许你使用保留字符来作为匹配元字符 123let pattern=/.at\./g;let str='cat\ pat/ hat.';console.log(str.match(pattern)); // ['hat.'] 元字符 *元字符 *用来匹配上一个匹配规则的0次或多次 123let pattern=/zk*/g;let str='zk z zkkk';console.log(str.match(pattern)); // [ 'zk', 'z', 'zkkk' ] 元字符 +元字符 +用来匹配上一个字符的一次或多次 123let pattern=/zk+/g;let str='zk z zkkk';console.log(str.match(pattern)); // [ 'zk','zkkk' ] 元字符 ?元字符 ?用来匹配前一个字符的0次或一次 123let pattern=/zk?/g;let str='zk z zkkk';console.log(str.match(pattern)); // [ 'zk','z','zk' ] 元字符 ^元字符 ^用来检查匹配字符是否是输入字符串的第一个字符 123let pattern=/(T|t)he/g;let str='The the';console.log(str.match(pattern)); // ['The','the'] 123let pattern=/^(T|t)he/g;let str='The the';console.log(str.match(pattern)); // ['The'] 元字符 $元字符 $用来检查匹配字符是否是输入字符串的最后一个字符 123let pattern=/.he/g;let str='The the';console.log(str.match(pattern)); // ['The','the'] 123let pattern=/.he$/g;let str='The the';console.log(str.match(pattern)); // ['the']]]></content>
      <categories>
        <category>javaScript基础</category>
      </categories>
      <tags>
        <tag>正则表达式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[leetcode-190 颠倒二进制位]]></title>
    <url>%2F2019%2F08%2F28%2Fleetcode-190%2F</url>
    <content type="text"><![CDATA[颠倒二进制位题目描述颠倒给定的 32 位无符号整数的二进制位。 示例 1： 输入: 00000010100101000001111010011100输出: 00111001011110000010100101000000解释: 输入的二进制串 00000010100101000001111010011100 表示无符号整数 43261596， 因此返回 964176192，其二进制表示形式为 00111001011110000010100101000000。 示例 2： 输入：11111111111111111111111111111101输出：10111111111111111111111111111111解释：输入的二进制串 11111111111111111111111111111101 表示无符号整数 4294967293， 因此返回 3221225471 其二进制表示形式为 10101111110010110010011101101001。 提示： 请注意，在某些语言（如 Java）中，没有无符号整数类型。在这种情况下，输入和输出都将被指定为有符号整数类型，并且不应影响您的实现，因为无论整数是有符号的还是无符号的，其内部的二进制表示形式都是相同的。 在 Java 中，编译器使用二进制补码记法来表示有符号整数。因此，在上面的 示例 2 中，输入表示有符号整数 -3，输出表示有符号整数 -1073741825。 进阶:如果多次调用这个函数，你将如何优化你的算法？ 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/reverse-bits著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 核心思路概述输入的会是一个无符号整数可以转化为32位二进制表示；要求输出的是反转该32位二进制并转化为整数输出 解题步骤 利用模二取余法得到32位二进制数 将32位二进制数反转后转化为整数并返回 Coding实现1234567891011121314151617/** * @param &#123;number&#125; n - a positive integer * @return &#123;number&#125; - a positive integer */var reverseBits = function(n) &#123; let s=[]; while(n) &#123; s.unshift(n%2); n=Math.floor(n/2); &#125; while(s.length&lt;32) &#123; s.unshift(0); &#125; return s.reduce((pre,cur,curIndex)=&gt;&#123; return pre+cur*Math.pow(2,curIndex); &#125;,0)&#125;;]]></content>
      <categories>
        <category>leetcode题解与算法</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[全局变量的声明以及如何避免声明全局变量]]></title>
    <url>%2F2019%2F08%2F27%2F%E5%85%A8%E5%B1%80%E5%8F%98%E9%87%8F%E7%9A%84%E5%A3%B0%E6%98%8E%E4%BB%A5%E5%8F%8A%E5%A6%82%E4%BD%95%E9%81%BF%E5%85%8D%E5%A3%B0%E6%98%8E%E5%85%A8%E5%B1%80%E5%8F%98%E9%87%8F%2F</url>
    <content type="text"><![CDATA[全局变量的声明 全局变量会成为全局对象的属性 那种方式的变量声明会形成全局变量呢？ Javascript运行环境分为浏览器环境和非浏览器环境（比如Node.js） 在浏览器环境中,有三种方式可以声明全局变量 使用var关键字在全局作用域下显示声明 不适用任何声明关键字(var,let,const)直接给变量赋值，这属于隐式声明 使用全局对象作为其属性来声明 浏览器环境中（全局对象为window对象） 123456a=1;var b=2;window.c=3;console.log(a===window.a); // trueconsole.log(b===window.b); // trueconsole.log(c); // 3 但是，在Node.js中，上述方法中的方法2就不成立 Node.js环境（全局对象为global对象) 123456a=1;var b=2;global.c=3;console.log(a===global.a); // trueconsole.log(b===global.b); // falseconsole.log(c===global.c); // 3 如何避免声明全局变量使用let与const声明关键字 如果你在全局作用域中使用let或const来声明变量，那么会在全局作用域下创建一个新的绑定，但该绑定不会添加为全局对象的属性。 换句话说，用let或const不能覆盖全局变量，而只能遮蔽它 浏览器环境中 12345678910window.a=1;var a=2;console.log(a); // 2 全局对象的属性a被var声明修改了console.log(a===window.a); // truewindow.b=1;let b=2;console.log(b); // 2console.log(b===window.b); // false// b不是全局变量，因为使用let声明的b没有成为全局对象的属性 总结如果不想为全局变量创建属性或修改全局变量的属性，那么使用let和const要安全的多]]></content>
      <categories>
        <category>javaScript基础</category>
      </categories>
      <tags>
        <tag>基础语法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Js中的字符与Unicode编码操作]]></title>
    <url>%2F2019%2F08%2F27%2FJs%E4%B8%AD%E7%9A%84%E5%AD%97%E7%AC%A6%E4%B8%8EUnicode%E7%BC%96%E7%A0%81%E6%93%8D%E4%BD%9C%2F</url>
    <content type="text"><![CDATA[字符转化为Unicode编码charAt()概述charAt() 方法从一个字符串中返回指定的字符。 语法 str.charAt(index) 参数： index: 一个介于0和字符转长度减1之间的整数。即0~str.length-1。如果没有提供索引值，那么index默认为0，即第一位 返回值： 返回值是一个根据给定索引的指定字符；如果，给定值超过了上述的要求范围（0~str.length-1），那么该方法返回一个空字符串 例子12345let str='abc'console.log(str.charAt()); // 'a'console.log(str.charAt(1)); // 'b'console.log(str.charAt(2)); // 'c'console.log(str.charAt(7)); // '' charCodeAt()概述charCodeAt()方法 返回给定索引处（String中index索引处）字符的 UTF-16 代码单元值的数字 语法 str.charCodeAt(index) 参数 index:一个大于等于0，小于字符串长度的整数。如果不是一个数值，则默认为0 返回值 返回值是一表示给定索引处（String中index索引处）字符的 UTF-16 代码单元值的数字；如果索引超出范围，则返回 NaN。 例子123456let str1='a';console.log(str1.charCodeAt()); // 97let str2='abc';console.log(str2.charCodeAt(0)); // 97console.log(str2.charCodeAt(1)); // 98console.log(str2.charCodeAt(7)); // NaN Unicode编码转化为字符String.fromCharCode()概述静态 String.fromCharCode() 方法返回由指定的UTF-16代码单元序列创建的字符串。 语法 String.fromCharCode(num1, …, numN) 参数 num1, …, numN一系列UTF-16代码单元的数字。 范围介于0到65535（0xFFFF）之间。 大于0xFFFF的数字将被截断。 不进行有效性检查。 返回值 一个长度为N的字符串，由N个指定的UTF-16代码单元组成；如果不给定参数，那么则返回空字符串 例子123console.log(String.fromCharCode(97)); 'a'console.log(String.fromCharCode(97,98,99)) // 'abc'console.log(String.fromCharCode()); // '']]></content>
      <categories>
        <category>javaScript基础</category>
      </categories>
      <tags>
        <tag>基础语法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[leetcode-168 Excel表列名称]]></title>
    <url>%2F2019%2F08%2F27%2Fleetcode-168%2F</url>
    <content type="text"><![CDATA[Excel表列名称题目描述给定一个正整数，返回它在 Excel 表中相对应的列名称。 例如， 1 -&gt; A 2 -&gt; B 3 -&gt; C ... 26 -&gt; Z 27 -&gt; AA 28 -&gt; AB ...示例 1: 输入: 1输出: “A” 示例 2: 输入: 28输出: “AB” 示例 3: 输入: 701输出: “ZY” 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/excel-sheet-column-title著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 核心思路概述题目要求的是1~26对应的是A~Z，然而如果使用进制来表示的话，我们一般习惯使用0开始的。因此，我们可以用0~25来表示A~Z；这样，我们之后在利用类似二进制中的模二取余法时就可以避免遇到余数0没有对应值的问题。 那么，对于输入值，每次取余时我们就应该讲值减去一之后再进行取余。这样就可以将0~25对应到输入值 解题步骤 建立哈希表，将025作为键，对应到AZ的键值 使用类似二进制的模二取余法，将给定值取余；每次取余先将值减一；取得的余数放入unshift入队列数组中 遍历队列数组，从哈希表中取出对应的键值，添加到字符串ans中 返回ans Coding实现123456789101112131415161718192021/** * @param &#123;number&#125; n * @return &#123;string&#125; */var convertToTitle = function(n) &#123; let map=new Map(); let queue=[]; let ans=''; for(let i=0;i&lt;26;i++) &#123; map.set(i,String.fromCharCode(65+i)); &#125; while(n) &#123; n--; queue.unshift(n%26); n=Math.floor(n/26); &#125; queue.forEach(value=&gt;&#123; ans+=map.get(value); &#125;) return ans;&#125;;]]></content>
      <categories>
        <category>leetcode题解与算法</category>
      </categories>
      <tags>
        <tag>哈希表</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[leetcode-811 子域名访问计数]]></title>
    <url>%2F2019%2F08%2F26%2Fleetcode-811%2F</url>
    <content type="text"><![CDATA[子域名访问计数题目描述一个网站域名，如”discuss.leetcode.com”，包含了多个子域名。作为顶级域名，常用的有”com”，下一级则有”leetcode.com”，最低的一级为”discuss.leetcode.com”。当我们访问域名”discuss.leetcode.com”时，也同时访问了其父域名”leetcode.com”以及顶级域名 “com”。 给定一个带访问次数和域名的组合，要求分别计算每个域名被访问的次数。其格式为访问次数+空格+地址，例如：”9001 discuss.leetcode.com”。 接下来会给出一组访问次数和域名组合的列表cpdomains 。要求解析出所有域名的访问次数，输出格式和输入格式相同，不限定先后顺序。 示例 1: 输入: [“9001 discuss.leetcode.com”]输出: [“9001 discuss.leetcode.com”, “9001 leetcode.com”, “9001 com”]说明: 例子中仅包含一个网站域名：”discuss.leetcode.com”。按照前文假设，子域名”leetcode.com”和”com”都会被访问，所以它们都被访问了9001次。 示例 2 输入: [“900 google.mail.com”, “50 yahoo.com”, “1 intel.mail.com”, “5 wiki.org”]输出: [“901 mail.com”,”50 yahoo.com”,”900 google.mail.com”,”5 wiki.org”,”5 org”,”1 intel.mail.com”,”951 com”]说明: 按照假设，会访问”google.mail.com” 900次，”yahoo.com” 50次，”intel.mail.com” 1次，”wiki.org” 5次。而对于父域名，会访问”mail.com” 900+1 = 901次，”com” 900 + 50 + 1 = 951次，和 “org” 5 次。 注意事项： cpdomains 的长度小于 100。 每个域名的长度小于100。 每个域名地址包含一个或两个”.”符号。 输入中任意一个域名的访问次数都小于10000。 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/subdomain-visit-count著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 核心思路概述题目给定包含一系列域名和访问次数的字符串数组。对于每个域名字符串，我们可以从后往前遍历该字符串，当遇到’.’或者到达最前端时，将’.’之后部分或全部字符串放入哈希表中并存放次数；当遇到，哈希表中已经存在该键时，则更新该键值 解题步骤 建立哈希表以及ans数组 遍历字符串数组，取当前字符串赋为s 将s分为次数count和域名domains两部分 遍历domains字符串。当遇到’.’或者到达最前端时，将’.’之后部分或全部字符串放入哈希表中并存放次数；当遇到，哈希表中已经存在该键时，则更新该键值 重复3、4直到字符串数组遍历完毕 遍历哈希表，将键值和键名合成字符串放入ans数组中 返回ans Coding实现1234567891011121314151617181920212223242526272829303132333435/** * @param &#123;string[]&#125; cpdomains * @return &#123;string[]&#125; */var subdomainVisits = function(cpdomains) &#123; if(cpdomains.length===0) return []; let map=new Map(); let ans=[]; for(let i=0;i&lt;cpdomains.length;i++) &#123; let s=cpdomains[i]; let count=s.split(' ')[0]; let domains=s.split(' ')[1]; let k=domains.length-1; while(k&gt;=0) &#123; if(domains[k]==='.'||k===0) &#123; let domain; if(k===0) &#123; domain=domains.slice(k); &#125; else domain=domains.slice(k+1); if(!map.has(domain)) &#123; map.set(domain,parseInt(count)); &#125; else &#123; map.set(domain,map.get(domain)+parseInt(count)); &#125; &#125; k--; &#125; &#125; map.forEach((value,key)=&gt;&#123; ans.push(value+' '+key); &#125;) return ans;&#125;;]]></content>
      <categories>
        <category>leetcode题解与算法</category>
      </categories>
      <tags>
        <tag>哈希表</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[leetcode-160 相交链表]]></title>
    <url>%2F2019%2F08%2F25%2Fleetcode-160%2F</url>
    <content type="text"><![CDATA[相交链表题目描述编写一个程序，找到两个单链表相交的起始节点。 如下面的两个链表： 在节点 c1 开始相交。 示例 1： 输入：intersectVal = 8, listA = [4,1,8,4,5], listB = [5,0,1,8,4,5], skipA = 2, skipB = 3输出：Reference of the node with value = 8输入解释：相交节点的值为 8 （注意，如果两个列表相交则不能为 0）。从各自的表头开始算起，链表 A 为 [4,1,8,4,5]，链表 B 为 [5,0,1,8,4,5]。在 A 中，相交节点前有 2 个节点；在 B 中，相交节点前有 3 个节点。 示例 2： 输入：intersectVal = 2, listA = [0,9,1,2,4], listB = [3,2,4], skipA = 3, skipB = 1输出：Reference of the node with value = 2输入解释：相交节点的值为 2 （注意，如果两个列表相交则不能为 0）。从各自的表头开始算起，链表 A 为 [0,9,1,2,4]，链表 B 为 [3,2,4]。在 A 中，相交节点前有 3 个节点；在 B 中，相交节点前有 1 个节点。 示例 3： 输入：intersectVal = 0, listA = [2,6,4], listB = [1,5], skipA = 3, skipB = 2输出：null输入解释：从各自的表头开始算起，链表 A 为 [2,6,4]，链表 B 为 [1,5]。由于这两个链表不相交，所以 intersectVal 必须为 0，而 skipA 和 skipB 可以是任意值。解释：这两个链表不相交，因此返回 null。 注意： 如果两个链表没有交点，返回 null. 在返回结果后，两个链表仍须保持原有的结构。 可假定整个链表结构中没有循环。 程序尽量满足 O(n) 时间复杂度，且仅用 O(1) 内存。 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/intersection-of-two-linked-lists著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 核心思路因为题目要求使用O(1)内存，那么显然就不能使用多余的数组。并且程序尽量满足O(n)时间复杂度。因此，解法有二： 哈希表法 哈希表的内存占用为O(1)，遍历第一条链表，将链表内的所有节点存入哈希表中。再遍历第二条链表，如果遇到某节点存在于哈希表中，那么就将结果返回 双指针 创建两个指针 pA 和 pB，分别初始化为链表 A 和 B 的头结点。然后让它们向后逐结点遍历。当 pA 到达链表的尾部时，将它重定位到链表 B 的头结点 (你没看错，就是链表 B); 类似的，当 pB 到达链表的尾部时，将它重定位到链表 A 的头结点。若在某一时刻 pApA 和 pBpB 相遇，则 pApA/pBpB 为相交结点。（原因如下，若两链表相交，那么相交部分加上两链表之前未相交部分的和是一定的。那么若能相交，这样子移动指针必能相遇） 解题步骤coding实现哈希表法 123456789101112131415161718192021222324252627/** * Definition for singly-linked list. * function ListNode(val) &#123; * this.val = val; * this.next = null; * &#125; *//** * @param &#123;ListNode&#125; headA * @param &#123;ListNode&#125; headB * @return &#123;ListNode&#125; */var getIntersectionNode = function(headA, headB) &#123; let map=new Map(); let cur=headA; while(cur) &#123; map.set(cur,1); cur=cur.next; &#125; cur=headB; while(cur) &#123; if(map.has(cur)) return cur; cur=cur.next; &#125; return null;&#125;; 双指针法 123456789101112131415161718192021222324252627282930313233343536/** * Definition for singly-linked list. * function ListNode(val) &#123; * this.val = val; * this.next = null; * &#125; *//** * @param &#123;ListNode&#125; headA * @param &#123;ListNode&#125; headB * @return &#123;ListNode&#125; */var getIntersectionNode = function(headA, headB) &#123; let top=headA; let down=headB; let bool=false; while(top&amp;&amp;down) &#123; if(top===down) return top; if(top.next===null) &#123; top=headB; bool=!bool; if(bool===false) return null; &#125; else &#123; top=top.next; &#125; if(down.next===null) &#123; down=headA; &#125; else &#123; down=down.next; &#125; &#125; return null;&#125;;]]></content>
      <categories>
        <category>leetcode题解与算法</category>
      </categories>
      <tags>
        <tag>链表</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[leetcode-268 缺失数字]]></title>
    <url>%2F2019%2F08%2F24%2Fleetcode-268%2F</url>
    <content type="text"><![CDATA[缺失数字题目描述给定一个包含 0, 1, 2, …, n 中 n 个数的序列，找出 0 .. n 中没有出现在序列中的那个数。 示例 1: 输入: [3,0,1]输出: 2 示例 2: 输入: [9,6,4,2,3,5,7,0,1]输出: 8 说明:你的算法应具有线性时间复杂度。你能否仅使用额外常数空间来实现? 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/missing-number著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 核心思路概述 第一种方法是将数组排序后再遍历，如果某个数与下标不相同的话，那么那个下标就是缺失的数 第二种方法是利用哈希表，在第一次遍历数组时将值记录在哈希表中。然后从0遍历到n，查看每个数是否在哈希表中，若无，则是缺失的数 第三种方法，是将0~n的和减去数组的和就是缺失的数 第四种方法，利用位运算（待补充） 解题步骤步骤易懂，直接贴代码 Coding实现第一种方法：排序遍历 12345678910/** * @param &#123;number[]&#125; nums * @return &#123;number&#125; */var missingNumber = function(nums) &#123; nums.sort((a,b)=&gt;a-b); for(let i=0;i&lt;=nums.length;i++) &#123; if(i!==nums[i]) return i; &#125;&#125;; 第二种方法：哈希表存值 12345678910111213/** * @param &#123;number[]&#125; nums * @return &#123;number&#125; */var missingNumber = function(nums) &#123; let map=new Map(); for(let i=0;i&lt;nums.length;i++) &#123; map.set(nums[i],1); &#125; for(let i=0;i&lt;=nums.length;i++) &#123; if(!map.has(i)) return i; &#125; &#125;; 第三种方法：数组求和 12345678910/** * @param &#123;number[]&#125; nums * @return &#123;number&#125; */var missingNumber = function(nums) &#123; let sum=nums.reduce((pre,value)=&gt;&#123; return pre+value; &#125;,0) return ((0+nums.length)*(nums.length+1)/2)-sum;&#125;; 第四种方法：位运算 12]]></content>
      <categories>
        <category>leetcode题解与算法</category>
      </categories>
      <tags>
        <tag>数组</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[leetcode-121 买卖股票的最佳时机]]></title>
    <url>%2F2019%2F08%2F23%2Fleetcode-121%2F</url>
    <content type="text"><![CDATA[买卖股票的最佳时机题目描述给定一个数组，它的第 i 个元素是一支给定股票第 i 天的价格。 如果你最多只允许完成一笔交易（即买入和卖出一支股票），设计一个算法来计算你所能获取的最大利润。 注意你不能在买入股票前卖出股票。 示例 1: 输入: [7,1,5,3,6,4]输出: 5解释: 在第 2 天（股票价格 = 1）的时候买入，在第 5 天（股票价格 = 6）的时候卖出，最大利润 = 6-1 = 5 。注意利润不能是 7-1 = 6, 因为卖出价格需要大于买入价格。 示例 2: 输入: [7,6,4,3,1]输出: 0解释: 在这种情况下, 没有交易完成, 所以最大利润为 0。 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 核心思路如果使用暴力解法，对每一天作为买入天进行遍历，再遍历每一天的后面的几天，找到差值最大的天数，这样就会有O(n^2)的时间复杂度。那么，一次遍历可以解决吗？ 当然，我们换一种思路，加入第一次遍历不把它当做买入天，而是当做卖出天。那么，我们只要找到当前天之前的那几天中价格最小的即可。而这最小价格，我们可以设定一个min，在遍历中不断改变。 解题步骤 设定min为第一天价格，最大差值max=0 从第二天开始遍历，因为卖出天需要在买入天之后，如果当前天的股票价格大于min，那么求得差价与max比较，赋予max较大值；若小于min，那么将当日股票价格赋予min 循环结束，返回max coding实现123456789101112131415/** * @param &#123;number[]&#125; prices * @return &#123;number&#125; */var maxProfit = function(prices) &#123; let min=prices[0]; let max=0; for(let i=1;i&lt;prices.length;i++)&#123; if(prices[i]&gt;min) &#123; max=max&gt;prices[i]-min?max:prices[i]-min; &#125; else min=prices[i]; &#125; return max;&#125;;]]></content>
      <categories>
        <category>leetcode题解与算法</category>
      </categories>
      <tags>
        <tag>数组</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[leetcode-119]]></title>
    <url>%2F2019%2F08%2F22%2Fleetcode-119%2F</url>
    <content type="text"><![CDATA[题目类似与leetcode-118 杨辉三角 不解释，直接上代码 123456789101112131415/** * @param &#123;number&#125; rowIndex * @return &#123;number[]&#125; */var getRow = function(rowIndex) &#123; let arr=[[1]]; for(let i=1;i&lt;=rowIndex;i++) &#123; arr[i]=[]; arr[i][0]=arr[i][i]=1; for(let k=1;k&lt;i;k++) &#123; arr[i][k]=arr[i-1][k-1]+arr[i-1][k]; &#125; &#125; return arr[rowIndex];&#125;;]]></content>
      <categories>
        <category>leetcode题解与算法</category>
      </categories>
      <tags>
        <tag>数组</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[闭包]]></title>
    <url>%2F2019%2F08%2F22%2F%E9%97%AD%E5%8C%85%2F</url>
    <content type="text"><![CDATA[什么是闭包闭包，实际上也是个函数，只不过他的外部被另外一个函数包围。因此，在一个函数内部创建另一个函数，就会产生闭包。 红宝书是这么定义的： 闭包是指有权访问另一个函数作用域中的变量的函数 那么这段话又该如何理解？ 执行环境分为全局执行环境和局部执行环境。全局执行环境永远存在于某条作用域链的最末端。那么，局部执行环境呢？当进入某个函数时，该函数的局部执行环境就会被压入环境栈，同时会生成一个存储当前环境所有变量、函数的活动对象。 因此，在一个函数中创建了另外一个函数，那么内部那个函数的作用域链上就包含了外部函数的活动对象，而该活动对象又具有其作用域中的所有的变量 来看一个例子： 12345678function test()&#123; let a=1; return function ()&#123; console.log(a); &#125;&#125;test()(); // 1console.log(a); // ReferenceError: a is not defined 我们首先在全局作用域下创建了一个test函数，在当前作用域中定义了a变量为1；然后在内部定义了一个新的匿名函数并返回； 从输出上，我们很容易就能验证闭包的特性。闭包的作用域链包含着自己的作用域，以及外部函数的作用域直到全局作用域 定时器与闭包我们经常可以看到这样的例子 123456for(var i=0;i&lt;10;i++)&#123; setTimeout(function ()&#123; console.log(i); // 10个10 后输出 &#125;,1000)&#125;console.log('i',i); // i 10 先输出 初学者们一般都会以为会按照0~9的顺序依次输出，然而并不是，它会打印出10个10. 那么，这又是为什么呢？ 定时器的作用是当定时器到期时，会执行传入定时器的函数； 我们往该函数中传入了一个新的匿名函数去打印i；那么对于该段代码，定时器中的匿名函数会在全局作用中被执行。因袭该匿名函数的作用域链会是其自身的作用域以及全局作用域 我们需要注意的是，在定时器开始启动之前，这10次循环已经结束了，相当于已经创建了10个还未执行的定时器，于此同时i已经变为了10 在执行定时器时，也就是每1000毫秒要去执行一次匿名函数。匿名函数就会顺着作用域去寻找i，那么，显然它会在全局作用域中找到i为10，所以也就会输出10个10了 那么如果我们顺着作用域链查找的思路稍微修改一下代码 1234567for(var i=0;i&lt;10;i++)&#123; setTimeout(function ()&#123; i=1; console.log(i); // 10个1 后输出 &#125;,1000)&#125;console.log('i',i); // i 10 先输出 显然，查找作用域链时在自身作用域中就找到了i，因此不会再向上查找位于全局作用域的i 定时器函数的优化我们已经发现了以上那个函数并不能达到想要的效果。本质上是因为作用域链的缘故。 那么使用es6的let就可以解决这个问题 let会将当前变量的作用域限制在当前代码块内，因此，上面的10次循环就会形成10个作用域，每一个函数都能够查找到正确的i 12345678910111213for(let i=0;i&lt;10;i++)&#123; setTimeout(function ()&#123; console.log(i); // 0~9 &#125;,1000)&#125;// 执行以上代码会是如下情形&#123;i=0;setTimeout();&#125;...&#123;i=9;setTimeout();&#125; 如果，此时在全局作用域下去执行console.log(i)；会报出错误i为定义。因为，全局作用下并没有定义i 闭包的应用私有变量闭包的主要应用是设计私有变量 任何在函数中定义的变量，都可以被认为是私有变量，因为不能在函数外部访问这些变量。 私有变量包括函数的参数，局部变量和在函数内部定义的其他函数 然而，闭包可以通过自身的作用域链访问到这些私有变量。因此我们经常利用闭包来创建用于访问私有变量的共有方法，又被称之为特权方法。 例如： 1234567891011121314function Person(name) &#123; // 私有变量 let rigion='Hang Zhou' // 特权方法 this.get=function ()&#123; return rigion; &#125;&#125;let ming=new Person('ming');console.log(ming); // Person &#123; get: [Function] &#125;console.log(ming.get()); // Hang Zhouconsoel.log(ming.rigion); // undefined 这个Person构造函数不同于一般的构造函数，一般的构造函数会像下例一样声明属性与方法 12345678910function Person(name) &#123; // 公有属性 this.rigion='Hang Zhou'&#125;let ming=new Person('ming');console.log(ming.rigion); // 'Hang Zhou'ming.rigion='Shang Hai';console.log(ming.rigion); // 'Shang Hai'// 此时rigion属性是公有属性，实例化之后可以直接访问和修改 而该构造函数创建的实例并不会直接添加私有变量到实例的属性上，而是需要通过get()方法去访问。此时get()方法是一个闭包，其作用链上拥有外部构造函数的作用域，因此可以访问到私有变量 模块模式模块模式是用来为单例创建私有变量和特权方法的。所谓单例，指的就是只有一个实例的对象 12345678910111213141516function Person()&#123; // 私有变量和私有函数 let rigion='Hang Zhou'; let get=function ()&#123; return rigion; &#125; // 特权方法和属性 return &#123; get:get &#125;&#125;let ming=new Person();console.log(ming); // &#123; get: [Function: get] &#125;console.log(ming.get()); // 'Hang Zhou' 闭包的缺陷一般来说，一个函数执行完毕后，会销毁其作用域及其变量对象；但是，在创建了一个闭包以后，这个函数的的作用域会一直保存到闭包不存在（手动令这个闭包函数为null）为止。 在javascript中，如果一个对象不再被引用，那么这个对象就会被垃圾回收机制回收； 如果两个对象互相引用，而不再被第3者所引用，那么这两个互相引用的对象也会被回收。有些闭包可能会被返回到全局作用域被执行 因此，闭包会携带包含它的函数的作用域，从而会占用比其他函数更多的内存。过得使用闭包会导致内存占用过多。]]></content>
      <categories>
        <category>javaScript基础</category>
      </categories>
      <tags>
        <tag>基础语法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[滑动窗口]]></title>
    <url>%2F2019%2F08%2F21%2F%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%2F</url>
    <content type="text"><![CDATA[什么是滑动窗口算法滑动窗口可以看做是一个区间。但是，这个区间是可以动态变化的。可以左右移动，也可以变大或变小 例如，假如有一个字符串为’abcabcbb’，那么对于大小为5的滑动窗口在该字符串上滑动，则有 1234abcab bcabc cabcb abcbb 滑动窗口，在我理解看来无非是一种用来大幅降低时间复杂度的算法。在某一个字符串或者一个数组中，要找到某个子字符串或者子数组来满足某些条件，那么利用滑动窗口便可以将时间复杂度降低到O(n) 用什么来实现滑动窗口leetcode题目引入题目引入：leetcode-3 无重复字符的最长子串给定一个字符串，请你找出其中不含有重复字符的 最长子串 的长度。 示例 1:输入: “abcabcbb”输出: 3 解释: 因为无重复字符的最长子串是 “abc”，所以其长度为 3。 示例 2:输入: “bbbbb”输出: 1解释: 因为无重复字符的最长子串是 “b”，所以其长度为 1。 示例 3:输入: “pwwkew”输出: 3解释: 因为无重复字符的最长子串是 “wke”，所以其长度为 3。 请注意，你的答案必须是 子串 的长度，”pwke” 是一个子序列，不是子串。 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/longest-substring-without-repeating-characters著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 解决思路如果使用常规的暴力解法。因为要找到一个字符串没有任何重复字符且是最长的。那么，很容易想到，找到以该字符串的每个字符为开头的最长无重复字符的字符串，然后比较那个字符串更长返回即可。思路很简单，但是，稍加考虑就会发现这样的时间复杂度会达到O(n^2)，很可能无法通过题目要求的时间限制 那么，滑动窗口呢。照着暴力解法的思路，在外循环遍历每一个字符时，如果遇到了与子串中已经重复的字符那么就会停止内循环遍历下去（因为这会是以当前字符为开头的最长子串）。按照暴力的思路，接下来我们会以外循环中的下一个字符来开始内循环。那么，我们很容易就会发现一个问题，倘若那个重复字符并不是外循环中立即接下去的那一个呢，那么遇到那个重复字符，我们依然要停下来。因此，我们可以直接滑动窗口到那个重复字符的后一位，再接着遍历后面的字符 队列来实现滑动窗口我们很容易可以想到利用队列来实现滑动窗口，当该窗口向右移动时，左边不需要的元素只要shift()移除队列即可 对于上题的队列实现滑动窗口解法 1234567891011121314151617181920/** * @param &#123;string&#125; s * @return &#123;number&#125; */var lengthOfLongestSubstring = function(s) &#123; if(s.length===0) return s.length; let maxLength=0; let queue=[]; for(let v of s)&#123; if(queue.includes(v)) &#123; while(queue[0]!==v) &#123; queue.shift() &#125; queue.shift(); &#125; queue.push(v); maxLength=queue.length&gt;maxLength?queue.length:maxLength; &#125; return maxLength;&#125;; 双指针来实现滑动窗口滑动窗口不过就是个动态的区间，那么使用双指针来表示区间也是不错的选择。而且对于队列滑动只能一格一格滑动，而双指针可以直接滑动多格 使用双指针来实现核心就是，要找到该次滑动的终点位置 123456789101112131415161718192021/** * @param &#123;string&#125; s * @return &#123;number&#125; */var lengthOfLongestSubstring = function(s) &#123; if(s.length===0) return s.length; let maxLength=0; let left=0; let right=0; let arr=[]; for(let v of s) &#123; if(arr.includes(v)) &#123; let index=s.indexOf(v,left); left=index+1; &#125; right++; arr=s.slice(left,right); maxLength=arr.length&gt;maxLength?arr.length:maxLength; &#125; return maxLength;&#125;; 双指针实现的优化：利用哈希表map来使字符搜索时间复杂度降至为O(1)上面的解法中，找到重复字符的位置，利用了indexOf()函数，实际上该函数的时间复杂度为O(n)，但是，如果在遍历的同时将字符下标不断更新的话，那么查找起来时间复杂度就会变为O(1) 这也是常用的以空间换时间的策略 1234567891011121314151617181920212223/** * @param &#123;string&#125; s * @return &#123;number&#125; */var lengthOfLongestSubstring = function(s) &#123; if(s.length===0) return s.length; let maxLength=0; let left=0; let right=0; let arr=[]; let map=new Map(); for(let i=0;i&lt;s.length;i++) &#123; if(arr.includes(s[i])) &#123; let index=map.get(s[i]); left=index+1; &#125; map.set(s[i],i) right++; arr=s.slice(left,right); maxLength=arr.length&gt;maxLength?arr.length:maxLength; &#125; return maxLength;&#125;; 当然，对于队列也可以像这样进行优化]]></content>
      <categories>
        <category>算法笔记</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[leetcode-112 路径总和]]></title>
    <url>%2F2019%2F08%2F21%2Fleetcode-112%2F</url>
    <content type="text"><![CDATA[路径总和题目描述给定一个二叉树和一个目标和，判断该树中是否存在根节点到叶子节点的路径，这条路径上所有节点值相加等于目标和。 说明: 叶子节点是指没有子节点的节点。 示例:给定如下二叉树，以及目标和 sum = 22， 5 / \ 4 8 / / \ 11 13 4 / \ \ 7 2 1返回 true, 因为存在目标和为 22 的根节点到叶子节点的路径 5-&gt;4-&gt;11-&gt;2。 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/path-sum著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 核心思路概述求根节点到叶子节点上的路径和，利用深度优先搜索（DFS）即可做到。当遍历到某节点时，若该节点不为空就加上该节点的值，如果遇到是叶子节点，那么就说明一条路径已经出现。比较该路径和与给定sum,若相同则返回true;否则返回false 解题步骤递归 递归式 return test(root.left,count)||test(root.right,count); 或运算是短路运算 递归终止条件： 该节点为null，返回false 该节点为叶子节点，如果路径和等于给定sum返回true,否则返回false Coding实现1234567891011121314151617181920212223/** * Definition for a binary tree node. * function TreeNode(val) &#123; * this.val = val; * this.left = this.right = null; * &#125; *//** * @param &#123;TreeNode&#125; root * @param &#123;number&#125; sum * @return &#123;boolean&#125; */var hasPathSum = function(root, sum) &#123; return (function test(root,count) &#123; if(root===null) return false; count+=root.val; if(root.left===null&amp;&amp;root.right===null) &#123; if(count===sum) return true; else return false; &#125; return test(root.left,count)||test(root.right,count); &#125;)(root,0)&#125;;]]></content>
      <categories>
        <category>leetcode题解与算法</category>
      </categories>
      <tags>
        <tag>树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[leetcode-111]]></title>
    <url>%2F2019%2F08%2F20%2Fleetcode-111%2F</url>
    <content type="text"><![CDATA[二叉树的层次遍历 II题目描述给定一个二叉树，找出其最小深度。 最小深度是从根节点到最近叶子节点的最短路径上的节点数量。 说明: 叶子节点是指没有子节点的节点。 示例: 给定二叉树 [3,9,20,null,null,15,7], 返回它的最小深度 2. 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/minimum-depth-of-binary-tree著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 核心思路概述关于二叉树的最小深度，我们可以考虑利用广度优先搜索，在这里即层序遍历的思想。当遍历到第一个叶子节点时，返回其深度即可。因为，层序遍历是从定至下，从左至右遍历的，所以遍历到的第一个叶子节点的深度必定是二叉树的最小深度 解题步骤 利用队列queue来实现层序遍历，为根节点设置属性depth=0； 判断当前节点是否有左右子树，若有，则左右子树的根节点的属性depth=当前节点的属性depth值+1；并且将子树入队列； 若没有，则返回该节点的深度 重复2,3步骤 Coding实现123456789101112131415161718192021222324252627282930/** * Definition for a binary tree node. * function TreeNode(val) &#123; * this.val = val; * this.left = this.right = null; * &#125; *//** * @param &#123;TreeNode&#125; root * @return &#123;number&#125; */var minDepth = function(root) &#123; if(root===null) return 0; else &#123; let queue=[root]; root.depth=1; while(queue.length!==0) &#123; let key=queue.shift(); if(!key.left&amp;&amp;!key.right) return key.depth; if(key.left) &#123; key.left.depth=key.depth+1; queue.push(key.left); &#125; if(key.right) &#123; key.right.depth=key.depth+1; queue.push(key.right); &#125; &#125; &#125;&#125;;]]></content>
      <categories>
        <category>leetcode题解与算法</category>
      </categories>
      <tags>
        <tag>树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[leetcode-107 二叉树的层次遍历 II]]></title>
    <url>%2F2019%2F08%2F19%2Fleetcode-107%2F</url>
    <content type="text"><![CDATA[二叉树的层次遍历 II题目描述给定一个二叉树，返回其节点值自底向上的层次遍历。 （即按从叶子节点所在层到根节点所在的层，逐层从左向右遍历） 例如： 给定二叉树 [3,9,20,null,null,15,7], 返回其自底向上的层次遍历为： [ [15,7], [9,20], [3]] 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/binary-tree-level-order-traversal-ii著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 核心思路概述返回节点值自底部向上的遍历，也就是相当于节点值自顶部向下的遍历的倒转；那么，利用队列将二叉树进行层序遍历的同时，为节点添加depth属性（表示这为第几层）；根据depth值，添加到对应的二维数组ans中;最后，返回ans数组的倒序 解题步骤 利用队列queue来实现层序遍历，为根节点设置属性depth=0； 判断ans数组的key.depth项是否为数组，若是则直接将该值加入数组；若不是，则创建数组[key] 判断当前节点是否有左右子树，若有，则左右子树的根节点的属性depth=当前节点的属性depth值+1；并且将子树入队列； 重复2,3步骤直到queue为空 返回ans.reverse() Coding实现1234567891011121314151617181920212223242526272829303132333435363738/** * Definition for a binary tree node. * function TreeNode(val) &#123; * this.val = val; * this.left = this.right = null; * &#125; *//** * @param &#123;TreeNode&#125; root * @return &#123;number[][]&#125; */var levelOrderBottom = function(root) &#123; let ans=[]; if(root===null) return ans; else &#123; let queue=[]; queue.push(root); root.depth=0; while(queue.length!==0) &#123; let key=queue.shift(); if(Array.isArray(ans[key.depth])) &#123; ans[key.depth].push(key.val); &#125; else &#123; ans[key.depth]=[key.val]; &#125; if(key.left) &#123; key.left.depth=key.depth+1; queue.push(key.left); &#125; if(key.right) &#123; key.right.depth=key.depth+1; queue.push(key.right); &#125; &#125; &#125; return ans.reverse();&#125;;]]></content>
      <categories>
        <category>leetcode题解与算法</category>
      </categories>
      <tags>
        <tag>树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[leetcode-104 二叉树的最大深度]]></title>
    <url>%2F2019%2F08%2F18%2Fleetcode-104%2F</url>
    <content type="text"><![CDATA[二叉树的最大深度题目描述给定一个二叉树，找出其最大深度。 二叉树的深度为根节点到最远叶子节点的最长路径上的节点数。 说明: 叶子节点是指没有子节点的节点。 示例： 给定二叉树 [3,9,20,null,null,15,7]， 返回它的最大深度 3 。 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/maximum-depth-of-binary-tree著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 核心思路概述获取一棵树的二叉树地最大深度，也就是需要获得该树的层数。那么，很自然可以想到利用层序遍历来获取到层数 解题步骤 利用队列来实现层序遍历，为根节点设置属性depth=1；并使最大层数max=1; 判断当前节点是否有左右子树，若有，则左右子树的根节点的属性depth=当前节点的属性depth值+1；并且将子树入队列 每个节点depth值与max值进行比较，将max赋予较大值 返回max Coding实现12345678910111213141516171819202122232425262728293031323334/** * Definition for a binary tree node. * function TreeNode(val) &#123; * this.val = val; * this.left = this.right = null; * &#125; *//** * @param &#123;TreeNode&#125; root * @return &#123;number&#125; */var maxDepth = function(root) &#123; let max=0; if(root===null) return max; else &#123; let queue=[]; queue.push(root); max=root.depth=1; while(queue.length!==0)&#123; let key=queue.shift(); if(key.left!==null) &#123; key.left.depth=key.depth+1; if(key.left.depth&gt;max) max=key.left.depth; queue.push(key.left) &#125;; if(key.right!==null) &#123; key.right.depth=key.depth+1; if(key.right.depth&gt;max) max=key.right.depth; queue.push(key.right) &#125; &#125; return max; &#125;&#125;;]]></content>
      <categories>
        <category>leetcode题解与算法</category>
      </categories>
      <tags>
        <tag>树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[leetcode-101 对称二叉树]]></title>
    <url>%2F2019%2F08%2F18%2Fleetcode-101%2F</url>
    <content type="text"><![CDATA[对称二叉树题目描述给定一个二叉树，检查它是否是镜像对称的。 例如，二叉树 [1,2,2,3,4,4,3] 是对称的。 但是下面这个 [1,2,2,null,3,null,3] 则不是镜像对称的: 说明: 如果你可以运用递归和迭代两种方法解决这个问题，会很加分。 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/symmetric-tree著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 核心思路概述对于对称二叉树，我们只需要判断根节点的左子树和右子树是否是镜像对称的。那么，我们只需要将其中一个子树的所有节点的子树对换位置，再与另一个子树比较是否是相同的树（树结构相同，节点值也一样，参考leetcode100-相同的树） 那么按照这个思路，我们可以直接比较根节点的左子树中的每一个节点的左右子树是否都与右子树中的每一个节点的左右子树镜像对称，也就是leftTree.left===rightTree.right&amp;&amp;leftTree.right===rightTree.left对于每个节点是否成立 解题步骤 如果树为空，那么该树为对称数组，直接返回true 如果该树非空，那么遍历根节点的左右子树的每一个节点，如果他们的左右子树都相同那么返回true，否则返回false Coding实现1234567891011121314151617181920212223/** * Definition for a binary tree node. * function TreeNode(val) &#123; * this.val = val; * this.left = this.right = null; * &#125; *//** * @param &#123;TreeNode&#125; root * @return &#123;boolean&#125; */var isSymmetric = function(root) &#123; if(root===null) return true; let rightTree=root.right; let leftTree=root.left; function isSame(leftTree,rightTree)&#123; if(leftTree==null&amp;&amp;rightTree==null) return true; if(leftTree==null||rightTree==null) return false; if(leftTree.val!==rightTree.val) return false; return isSame(leftTree.left,rightTree.right)&amp;&amp;isSame(leftTree.right,rightTree.left); &#125; return isSame(root.left,root.right);&#125;;]]></content>
      <categories>
        <category>leetcode题解与算法</category>
      </categories>
      <tags>
        <tag>树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[leetcode-100 相同的树]]></title>
    <url>%2F2019%2F08%2F16%2Fleetcode-100%2F</url>
    <content type="text"><![CDATA[相同的树题目描述给定两个二叉树，编写一个函数来检验它们是否相同。 如果两个树在结构上相同，并且节点具有相同的值，则认为它们是相同的。 示例 1: 示例 2: 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/same-tree著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 核心思路概述想要确定两棵树是否结构相同，并且节点的值也相同。那么从两树的根节点开始遍历每棵树的每个节点，如果值都相同，那么两棵树就是相同的 解题步骤以下是递归终止条件 遍历节点，如果两树的节点不同，那么返回false 如果两树的节点都为null那么返回true 如果两树的节点一个为null，另一个不为null，那么返回false Coding实现123456789101112131415161718192021/** * Definition for a binary tree node. * function TreeNode(val) &#123; * this.val = val; * this.left = this.right = null; * &#125; *//** * @param &#123;TreeNode&#125; p * @param &#123;TreeNode&#125; q * @return &#123;boolean&#125; */var isSameTree = function(p, q) &#123; if(p == null &amp;&amp; q == null) return true; if(p == null || q == null) return false; if(p.val != q.val) return false; return isSameTree(p.left, q.left) &amp;&amp; isSameTree(p.right, q.right);&#125;;]]></content>
      <categories>
        <category>leetcode题解与算法</category>
      </categories>
      <tags>
        <tag>树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[leetcode-38 报数]]></title>
    <url>%2F2019%2F08%2F15%2Fleetcode-38%2F</url>
    <content type="text"><![CDATA[报数题目描述报数序列是一个整数序列，按照其中的整数的顺序进行报数，得到下一个数。其前五项如下： 1. 1 2. 11 3. 21 4. 1211 5. 1112211 被读作 “one 1” (“一个一”) , 即 11。11 被读作 “two 1s” (“两个一”）, 即 21。21 被读作 “one 2”, “one 1” （”一个二” , “一个一”) , 即 1211。 给定一个正整数 n（1 ≤ n ≤ 30），输出报数序列的第 n 项。 注意：整数顺序将表示为一个字符串。 示例 1: 输入: 1输出: “1” 示例 2: 输入: 4输出: “1211” 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/count-and-say著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 核心思路概述报数，指报的是前一个数。当前一个数有连续个同样地数比如’111’，那么把这个念作（3个1），因此会输出31；又比如’123’，因为这三个数都不同，我们会报数为（1个1；1个2；1个3），因此会输出111213 解题步骤不想多说，直接上代码 Coding实现12345678910111213141516171819202122/** * @param &#123;number&#125; n * @return &#123;string&#125; */var countAndSay = function(n) &#123; let ans=[]; ans[0]='1'; for(let i=1;i&lt;n;i++)&#123; let sum=1; ans[i]=''; for(let k=0;k&lt;ans[i-1].length;k++)&#123; if(ans[i-1][k]!==ans[i-1][k+1])&#123; ans[i]+=sum.toString()+ans[i-1][k]; sum=1; &#125; else &#123; sum++; &#125; &#125; &#125; return ans[n-1];&#125;;]]></content>
      <categories>
        <category>leetcode题解与算法</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[二叉树与二叉搜索树]]></title>
    <url>%2F2019%2F08%2F15%2F%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%8E%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%2F</url>
    <content type="text"><![CDATA[二叉树的定义二叉树的递归定义 要么二叉树没有根节点，是一棵空树 要么二叉树是由根节点、左子树、右子树组成，且左子树和右子树都是二叉树 简单来说，就是二叉树要么是一棵空树，要么这棵树的每一个节点最多只有两个节点，并且左右子树是严格区分的 二叉搜索树（BST）定义二叉搜索树（Binary Search Tree）是一种特殊的二叉树，又称为排序二叉树，二叉查找树、二叉排序树。 二叉搜索树的递归定义 要么二叉搜索树是一棵空树 要么二叉搜索树是由根节点、左子树、右子树组成，其中左子树和右子树都是二叉搜索树，且左子树上所有节点的数据域均小于根节点的数据域，右子树上所有节点的数据域均大于或等于根节点的数据域 简单来说，二叉搜索树是二叉树的一种，但是它只允许你在左侧节点存储比父节点小的值；在右侧节点存储比父节点大或等于的值 二叉搜索树的插入如果要插入的树为空树，那么就将要插入的节点作为这颗二叉搜索树的根节点； 如果不是，那么就根据二叉搜索树的特性，判断它与根节点的大小关系不断递归直到找到它的位置 二叉搜索树的插入实现 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162class Node&#123; // 节点类 constructor(key)&#123; this.key=key; this.left=null; this.right=null; &#125;&#125;class BinarySearchTree&#123; // 二叉搜索树类 constructor(root)&#123; this.root=root; &#125; insert(node)&#123; // 二叉搜索树的插入方法 if(this.root===null)&#123; this.root=node; &#125; else &#123; this.insertNode(this.root,node); &#125; &#125; insertNode(root,node)&#123; // insertNode方法（用来找到合适的位置进行插入） if(node.key&lt;root.key)&#123; if(root.left===null) &#123; root.left=node; return; &#125; else &#123; this.insertNode(root.left,node); &#125; &#125; else &#123; if(root.right===null) &#123; root.right=node; return; &#125; else &#123; this.insertNode(root.right,node); &#125; &#125; &#125;&#125;let A=new Node(10);let B=new Node(15);let C=new Node(13);let D=new Node(7);let root=new BinarySearchTree(A);root.insert(B);root.insert(C);root.insert(D);console.log(root);/** 输出结果*//*BinarySearchTree &#123; root: Node &#123; key: 10, left: Node &#123; key: 7, left: null, right: null &#125;, right: Node &#123; key: 15, left: [Node], right: null &#125; &#125;&#125;*/ 二叉搜索树的性质因为二叉搜索树的所有节点的左子树会小于它，右子树会大于它，因此，对二叉搜索树使用中序遍历会得到一个有序序列 二叉树（二叉搜索树）的四种遍历因为二叉搜索树是特殊的二叉树，因此讲清楚二叉树地遍历即可 先序遍历对于先序遍历来说，总是先访问根节点，然后才去访问左子树和右子树，因此先序遍历的遍历顺序是根节点-&gt;左子树-&gt;右子树 先序遍历的代码实现 12345678function preOrder(root)&#123; if(root===null) return; else &#123; console.log(root); preOrder(root.left); preOrder(root.right); &#125;&#125; 中序遍历和后序遍历的代码实现与先序遍历类似，就不再展开 层序遍历层序遍历是指按照层次的顺序从根节点向下逐层进行遍历，且对同一层次的节点为从左到右遍历 层序遍历的实现步骤对于层序遍历，我们需要一层一层的访问，因此像之前的三种遍历方式使用递归我们无法做到，因此我们可以考虑使用队列来实现 将根节点tree.root加入队列queue 取出队首节点，访问它 如果该节点有左孩子，将左孩子入队 如果该节点有右孩子，将右孩子入队 返回2，直到队列为空 1234567891011121314151617function layerOrder(tree)&#123; if(tree.root===null) return; else &#123; let queue=[]; queue.push(tree.root); while(queue.length!==0)&#123; let key=queue.shift(); console.log(key); if(key.left!==null)&#123; queue.push(key.left); &#125; if(key.right!==null)&#123; queue.push(key.right); &#125; &#125; &#125;&#125; 根据遍历序列重建二叉树中序序列可以与先序序列、后序序列、层序序列中的任意一个来构建唯一的二叉树，而后三者两两搭配或是三个一起上都无法构建唯一的二叉树 原因是先序、后序、层序均是提供根节点。然而只有中序序列才能区分出左右子树 给定二叉树的先序遍历和中序遍历来重建二叉树的步骤 通过先序遍历来确定根节点，一开始会是数组的第一项 通过中序遍历来确定这棵树根节点的左子树和右子树，左子树会是数组中根节点项的前面那所有项；右子树会是数组中根节点项的后面的所有值 通过步骤2确定的中序遍历中的左子树数组和右子树数组来确定先序遍历中的左子树数组和右子树数组 递归左子树数组和右子树数组，重复步骤1,2,3直到数组为空 代码实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354class Node&#123; constructor(key)&#123; this.key=key; this.left=null; this.right=null; &#125;&#125;let A=new Node('A');let B=new Node('B');let C=new Node('C');let D=new Node('D');let E=new Node('E');let F=new Node('F');let G=new Node('G');// 给定二叉树的先序遍历和中序遍历重建二叉树函数function createTree(m,n)&#123; if(m.length===0) &#123;return;&#125;; let root=m[0]; let rootIndex=n.indexOf(root); let leftNTree=n.slice(0,rootIndex); let rightNTree=n.slice(rootIndex+1); let leftMTree=m.slice(1,leftNTree.length+1); let rightMTree=m.slice(rootIndex+1); if(leftMTree[0])&#123;root.left=leftMTree[0];&#125; if(rightMTree[0])&#123;root.right=rightMTree[0];&#125; createTree(leftMTree,leftNTree); createTree(rightMTree,rightNTree);&#125;createTree([A,B,C,D,E,F,G],[B,D,C,A,F,E,G]);console.log(A);/** 输出结果*//*Node &#123; key: 'A', left: Node &#123; key: 'B', left: null, right: Node &#123; key: 'C', left: [Node], right: null &#125; &#125;, right: Node &#123; key: 'E', left: Node &#123; key: 'F', left: null, right: null &#125;, right: Node &#123; key: 'G', left: null, right: null &#125; &#125;&#125;*/]]></content>
      <categories>
        <category>算法笔记</category>
      </categories>
      <tags>
        <tag>排序</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[leetcode-118 杨辉三角]]></title>
    <url>%2F2019%2F08%2F14%2Fleetcode-118%2F</url>
    <content type="text"><![CDATA[杨辉三角题目描述给定一个非负整数 numRows，生成杨辉三角的前 numRows 行。 在杨辉三角中，每个数是它左上方和右上方的数的和。 示例: 输入: 5输出:[ [1], [1,1], [1,2,1], [1,3,3,1], [1,4,6,4,1]] 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/pascals-triangle著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 核心思路杨辉三角的每一行，除了首尾都是为1外，每一项都是前一行的两项之和 解题步骤 设置一个数组 建立numRows行二维数组，每一行除了首尾都是为1外，每一项都是前一行的两项之和 返回数组 coding实现12345678910111213141516/** * @param &#123;number&#125; numRows * @return &#123;number[][]&#125; */var generate = function(numRows) &#123; let ans=[]; for(let i=0;i&lt;numRows;i++)&#123; ans[i]=[]; ans[i][0]=1; ans[i][i]=1; for(let k=1;k&lt;i;k++)&#123; ans[i][k]=ans[i-1][k-1]+ans[i-1][k]; &#125; &#125; return ans;&#125;;]]></content>
      <categories>
        <category>leetcode题解与算法</category>
      </categories>
      <tags>
        <tag>数组</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[操作符new到底做了哪些事]]></title>
    <url>%2F2019%2F08%2F13%2F%E6%93%8D%E4%BD%9C%E7%AC%A6new%E5%88%B0%E5%BA%95%E5%81%9A%E4%BA%86%E5%93%AA%E4%BA%9B%E4%BA%8B%2F</url>
    <content type="text"><![CDATA[new操作符的作用new操作符可以快速创建构造函数的实例，如： 12345678910111213function Person(name,age,job)&#123; this.name=name; this.age=age; this.job=job;&#125;Person.prototype.sayHello=function ()&#123; console.log('hello');&#125;let man=new Person('zjb','18','frontEnd');console.log(man); // Object &#123; name: "zjb", age: "18", job: "frontEnd" &#125;man.sayHello(); // 'hello' 那么，使用new操作符来创建某构造函数的实例会经历以下四个步骤： 内部创建一个新对象 将构造函数的作用域赋给新对象（因此this就指向了这个新对象） 执行构造函数中的代码 返回新对象 自己实现一个new操作符既然new操作符的作用是创建一个构造函数的实例，那么new操作无非就是创建一个新的对象，将这个新对象的proto属性指向其构造函数的原型对象，然后该新对象绑定到构造函数上并获得传入的值，从而执行代码获得自身的对象属性 new操作符的代码实现 1234567891011function New(obj,...arr)&#123; let ans=&#123;&#125;; ans.__proto__=obj.prototype; // 连接原型对象 //Object.setPrototypeOf(ans, obj.prototype) 也可以，或许更高效 // 或者使用 let ans=Object.create(obj.prototype); （以obj.rototype为原型对象创建一个新对象） let result=obj.apply(ans,arr); // 获得构造函数的返回值 return ans===Object?ans:result; //用来判断构造函数的返回值是否与创建的实例不同&#125;]]></content>
      <categories>
        <category>javaScript基础</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[如何优雅地使用箭头函数]]></title>
    <url>%2F2019%2F08%2F13%2F%E5%A6%82%E4%BD%95%E4%BC%98%E9%9B%85%E5%9C%B0%E4%BD%BF%E7%94%A8%E7%AE%AD%E5%A4%B4%E5%87%BD%E6%95%B0%2F</url>
    <content type="text"><![CDATA[什么是箭头函数箭头函数是ES6新增语法特性，它是一种使用箭头（=&gt;）定义函数的新语法，但是，他与传统的函数有些许的不同，主要集中在以下方面： 没有this,super,arguments和new.target绑定 箭头函数中的this,supper,arguments及new.target这些值由外围最近一层非箭头函数决定 不能通过new关键字调用 箭头函数没有[ [Constuct]]方法，所以不能被作为构造函数 没有原型 箭头函数不存在prototype这个属性 不可以改变this的绑定 箭头函数语法当函数右侧的表达式只有一个时，可以没有显式的返回语句 12const test=a=&gt;a+1;console.log(test(1)); // 2 如果函数没有参数，则要在声明的时候写一组没有内容的小括号 12const test=()=&gt;'hello';console.log(test()); // 'hello' 如果想要返回一个对象字面量，则需要将该字面量包裹在小括号里 12const test=()=&gt;(&#123;item:1&#125;);console.log(test()); // &#123;item:1&#125; 没有this绑定箭头函数中没有this绑定，必须通过查找作用域链来确定this的值。 箭头函数的this在定义时就确定了，是由其外层代码的this决定 对于其外层代码的this指向我们可以参考另一篇博文《Js中的this到底指向哪》 简单来说，假设外层代码里有一句输出语句console.log(this); 那么输出的对象即为this的指向 被全局环境中定义的函数包含 123(function test()&#123; console.log((()=&gt;this)()); // window&#125;)() 被对象中定义的方法包含 12345678const obj=&#123; a()&#123; return ()=&gt;&#123; console.log(this); &#125; &#125;&#125;obj.a()(); // obj &#123; a: a() &#125; 全局环境下定义 12const a=()=&gt;this;console.log(a()); // window 被另一个箭头函数包含 12345678910111213const obj=&#123; a()&#123; return ()=&gt;&#123; console.log('outter'); console.log(this); // Object &#123; a: a() &#125; (()=&gt;&#123; console.log('inner'); console.log(this); // Object &#123; a: a() &#125; &#125;)() &#125; &#125;&#125;obj.a()(); 最后，因为箭头函数没有 this，所以也不能用 call()、apply()、bind() 这些方法改变 this 的指向 123const test=()=&gt;this;const obj=&#123;&#125;console.log(test.apply(obj)); // window 创建立即执行表达式立即执行表达式，即可以定义一个匿名函数并调用，自始至终不保存对该函数的引用 123(()=&gt;&#123; console.log('hello'); // 'hello'&#125;)(); 没有arguments绑定箭头函数没有自己的arguments对象，且未来无论函数在哪个上下文中执行，箭头函数始终可以访问到外围函数的arguments对象 123456(function a()&#123; console.log(arguments[0]); // 5 ((m)=&gt;&#123; console.log(arguments[0]); // 5 &#125;)(1)&#125;)(5)]]></content>
      <categories>
        <category>ES6</category>
      </categories>
      <tags>
        <tag>基础语法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Js中的this到底指向哪]]></title>
    <url>%2F2019%2F08%2F13%2FJs%E4%B8%AD%E7%9A%84this%E5%88%B0%E5%BA%95%E6%8C%87%E5%90%91%E5%93%AA%2F</url>
    <content type="text"><![CDATA[什么是this对于this,我们可以下一个定义 this是在执行上下文创建时确定的一个在执行过程中不可更改的变量。 简单来说,this应当是当前执行代码的环境对象 在函数中使用this函数调用一般会有以下四种情境： 在全局环境或是普通函数中直接调用 作为对象的方法 使用apply和call 作为构造函数 在全局环境或是普通函数中直接调用ps：全文均在浏览器环境下执行 在全局环境中直接调用1234567console.log(this===window); // truevar a=1;function test()&#123; var a=2; console.log(this.a);&#125;test(); // 1 在函数中直接调用123456789var a=1;function test()&#123; let a=2; function m()&#123; console.log(this.a); // 1 &#125; m();&#125;test(); 从这两个例子中，我们很容易可以得到：当函数在全局环境下或在某个函数中被直接调用时，那么其中的this会指向全局对象（window） 函数作为对象的方法被调用先说结论，当函数作为对象的方法被调用时，this就会指向该对象 如： 12345678var a=1;let obj=&#123; a:2, func()&#123; console.log(this.a); // 2 &#125;&#125;obj.func(); 由于func函数被作为obj的对象调用，那么this就会指向obj 然而，我们经常会遇到这样的陷阱： 123456789var a=1;let obj=&#123; a:2, func()&#123; console.log(this.a); // 1 &#125;&#125;const func=obj.func;func(); 此时，fnc函数被赋值给了全局作用域下的func变量。因为我们知道，函数名只是一个指向函数对象的指针，因此，此时全局作用域下定义的func域obj对象中的func一样指向了同一个函数对象；然后，这个函数在全局作用域下被直接调用，所以this指向了window 使用apply,call,bind apply() 方法调用一个具有给定this值的函数，以及作为一个数组（或类似数组对象）提供的参数。 call() 方法使用一个指定的 this 值和单独给出的一个或多个参数来调用一个函数。 注意：该方法的语法和作用与 apply() 方法类似，只有一个区别，就是 call() 方法接受的是一个参数列表，而 apply() 方法接受的是一个包含多个参数的数组。 bind()方法创建一个新的函数，在bind()被调用时，这个新函数的this被bind的第一个参数指定，其余的参数将作为新函数的参数供调用时使用。 其中，apply和call方法返回的是调用有指定this值和参数的函数的结果。 而bind方法是返回构建的新的函数 apply与call的使用例子123456789var a=1;function test()&#123; console.log(this.a);&#125;function func()&#123; console.log(this===window); // true test.apply(this); // 1&#125;func(); 执行func函数，因为func函数被直接调用，因此func函数内部的this指向全局对象，在浏览器中即为window。然后，test函数通过apply方法被调用，因此test函数被传入的this值也是指向window的。 另一个例子： 1234567891011var name='bjz'function test()&#123; let name='fairy' console.log(this.name);&#125;var obj=&#123; name:'angel'&#125;test.apply(obj); // 'angel' 与上个例子同理，test函数通过apply方法传入的this指向的是obj对象。 因为call方法与apply方法的作用是一样的，只是参数传递的形式有区别，因此，call的例子将会在下面列出 apply与call方法的参数传递区别1234567891011function sum(num1,num2)&#123; this.sum=num1+num2; console.log(this); // &#123; sum: 3, callSum: callSum() &#125;&#125;var obj=&#123; sum:0, callSum()&#123; sum.call(this,1,2)// 或者是sum.apply(this,[1,2]) &#125;&#125;obj.callSum(); callSum函数被作为obj的对象被调用，因此callSum函数内部的this指向obj对象。因此，sum函数通过call方法被传入的this对象也指向obj对象 bind的使用例子mdn上的解释 bind() 最简单的用法是创建一个函数，不论怎么调用，这个函数都有同样的 this 值。JavaScript新手经常犯的一个错误是将一个方法从对象中拿出来，然后再调用，期望方法中的 this 是原来的对象（比如在回调中传入这个方法）。如果不做特殊处理的话，一般会丢失原来的对象。基于这个函数，用原始的对象创建一个绑定函数，巧妙地解决了这个问题： 官方例子： 12345678910111213141516this.x = 9; // 在浏览器中，this指向全局的 "window" 对象var module = &#123; x: 81, getX: function() &#123; return this.x; &#125;&#125;;module.getX(); // 81var retrieveX = module.getX;retrieveX(); // 返回9 - 因为函数是在全局作用域中调用的// 创建一个新函数，把 'this' 绑定到 module 对象// 新手可能会将全局变量 x 与 module 的属性 x 混淆var boundGetX = retrieveX.bind(module);boundGetX(); // 81 一个简单的小例子： 1234567function test()&#123; console.log(this);&#125;var obj=&#123; item:1&#125;test.bind(obj)() //&#123;item:1&#125; 由此可以看出，bind方法的返回值是一个新创建的函数，函数内部的this指向为传入的this值 函数作为构造函数被调用何为构造函数？所谓构造函数就是用来new对象的函数，像Function、Object、Array、Date等都是全局定义的构造函数。 来看例子： 12345function Test()&#123; this.item=1;&#125;let b=new Test();console.log(b.item); // 1 如果函数作为构造函数用，那么其中的this就代表它即将new出来的对象。 箭头函数参考另一篇博文 如何优雅地使用箭头函数]]></content>
      <categories>
        <category>javaScript基础</category>
      </categories>
      <tags>
        <tag>基础语法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[leetcode-867 转置矩阵]]></title>
    <url>%2F2019%2F08%2F13%2Fleetcode-867%2F</url>
    <content type="text"><![CDATA[转置矩阵题目描述给定一个矩阵 A， 返回 A 的转置矩阵。 矩阵的转置是指将矩阵的主对角线翻转，交换矩阵的行索引与列索引。 示例 1： 输入：[[1,2,3],[4,5,6],[7,8,9]]输出：[[1,4,7],[2,5,8],[3,6,9]] 示例 2： 输入：[[1,2,3],[4,5,6]]输出：[[1,4],[2,5],[3,6]] 提示： 1&lt;= A.length &lt;= 1000 1&lt;= A[0].length &lt;= 1000 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/transpose-matrix著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 核心思路概述对于转置矩阵的特点，我们很容易得到，对于原数组A，ans[k][i]=A[i][k] 解题步骤 根据矩阵列数来创建ans二维数组的行数 由ans[k][i]=A[i][k]循环得到ans数组并返回 Coding实现1234567891011121314/** * @param &#123;number[][]&#125; A * @return &#123;number[][]&#125; */var transpose = function(A) &#123; let ans=[]; for(let i=0;i&lt;A[0].length;i++)&#123; ans[i]=[]; for(let k=0;k&lt;A.length;k++)&#123; ans[i][k]=A[k][i]; &#125; &#125; return ans;&#125;;]]></content>
      <categories>
        <category>leetcode题解与算法</category>
      </categories>
      <tags>
        <tag>数组</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[对象的属性类型与特性]]></title>
    <url>%2F2019%2F08%2F12%2F%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%B1%9E%E6%80%A7%E7%B1%BB%E5%9E%8B%E4%B8%8E%E7%89%B9%E6%80%A7%2F</url>
    <content type="text"><![CDATA[对象的属性类型对象包括两种属性类型，分别是 数据属性 访问器属性 数据属性定义及特性数据属性相对于访问器属性来说，它拥有数据值 数据属性有4个描述其行为的特性，分别是 configurable：可配置。（具体来说指的是，1.能否通过delete删除属性从而重新定义属性； 2.能否修改属性的特性；3.能否把属性修改为访问器属性；默认为true） enumerable：可枚举。（表示是否可以通过for-in循环来返回属性；对于直接在对象上定义的属性，这个特性值默认为true） writable：可写。（表示能否修改属性的值；默认为true） 以上三个属性取值为true或false。 value：属性值。 我们可以通过Object.getOwnPropertyDescriptor()这个方法来查看对象属性的特性 此方法可得到对象的数据属性，传入两个参数：第一个是要查找的对象名；第二个是要查找的属性名。 如下： 12345let test=&#123; item:1&#125;console.log(Object.getOwnPropertyDescriptor(test,'item')) //&#123; value: 1, writable: true, enumerable: true, configurable: true &#125; Object.defineProperty()要修改属性的默认特性，我们可以使用Object.defineProperty()来进行修改。当然我们也可以使用该方法来新建属性并同时制定它的属性特性 注意： 在调用该方法创建新的属性时，如果不指定，默认会将除value外的特性值置为false;如果调用该方法只是修改已有属性，则无此限制 这个方法接收三个参数：属性所在的对象、属性的名字(字符串类型),一个描述符对象。其中描述符对象的属性必须是数据属性四个特性中的一或多个 12345678910111213141516171819202122232425let test=&#123; item:1, name:2&#125;Object.defineProperty(test,'item',&#123; enumerable:false // 该属性无法被枚举&#125;)for(let i in test)&#123; console.log(i) // name&#125;Object.defineProperty(test,'item',&#123; configurable:false //让该属性不能被配置，具体指无法被删除，无法修改属性特性，无法修改为访问器属性&#125;)delete test.item // 该属性无法被删除console.log(test); // &#123;item:1&#125;Object.defineProperty(test,'item',&#123; value:2 // 修改该属性的值为2&#125;)console.log(test); // &#123;item:2&#125;Object.defineProperty(test,'item',&#123; writable:false // 该属性的值无法被修改&#125;)test.item=3;console.log(test); // &#123;item:2&#125; 访问器属性访问器属性不包含数据值；他们包含一对儿getter和setter函数；在读取访问器属性时，会调用getter函数，这个函数负责返回有效的值；在写入访问器属性时，会调用setter函数并传入新值，这个函数负责决定如何处理数据 访问器属性有4个描述其行为的特性，分别是 configurable：可配置。（具体来说指的是，1.能否通过delete删除属性从而重新定义属性； 2.能否修改属性的特性；3.能否把属性修改为访问器属性；默认为true） enumerable：可枚举。（表示是否可以通过for-in循环来返回属性；对于直接在对象上定义的属性，这个特性值默认为true） get：在读取属性时调用的函数。默认值为undefined set：在写入属性时调用的函数。默认值为undefined 访问器属性不像数据属性一样可以直接被定义，它只能通过Object.defineProperty()来定义。如果通过这种方式来进行定义的话，那么[[Enumerable]]可枚举属性会默认为false,当然我们可以在定义的时候将其设置为true 如下： 12345678910111213141516let test=&#123; _item:1&#125;Object.defineProperty(test,'item',&#123; get:function()&#123; return this._item; &#125;, set:function(num)&#123; if(num&gt;10)&#123; this._item++; &#125; &#125;&#125;)test.item=15;console.log(test.item); // 2 除此之外，我们也可以通过在对象上直接定义访问器属性使得其可枚举 12345678910111213141516171819202122let test=&#123; _item:1, get item() &#123; return this._item; &#125;, set item(num) &#123; if(num&gt;10) &#123; this._item++; &#125; &#125;&#125;console.log(Object.getPropertyDescriptor(test,item));/* &#123; get: [Function: get item], set: [Function: set item], enumerable: true, configurable: true&#125; */for(let i in test) &#123; console.log(i); // '_item','item'&#125; 访问器属性的意义 修改访问器属性动态修改相关联的数据属性 监听访问器属性的修改去操作其它业务逻辑]]></content>
      <categories>
        <category>javaScript基础</category>
      </categories>
      <tags>
        <tag>基础语法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[leetcode-509 斐波那契数]]></title>
    <url>%2F2019%2F08%2F12%2Fleetcode-509%2F</url>
    <content type="text"><![CDATA[斐波那契数题目描述斐波那契数，通常用 F(n) 表示，形成的序列称为斐波那契数列。该数列由 0 和 1 开始，后面的每一项数字都是前面两项数字的和。也就是： F(0) = 0, F(1) = 1F(N) = F(N - 1) + F(N - 2), 其中 N &gt; 1.给定 N，计算 F(N)。 示例 1： 输入：2输出：1解释：F(2) = F(1) + F(0) = 1 + 0 = 1. 示例 2： 输入：3输出：2解释：F(3) = F(2) + F(1) = 1 + 1 = 2. 示例 3： 输入：4输出：3解释：F(4) = F(3) + F(2) = 2 + 1 = 3. 提示： 0 ≤ N ≤ 30 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/fibonacci-number著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 核心思路概述一开始会很容易想到用递归的方式来解决，但是递归会很容易超出时间限制。因此，利用动态规划就很容易解决这个问题 解题步骤 建立一个数组，数组的第一项和第二项分别为0,1 从第三项开始一直到第N项，每一项等于前两项的和，并存放到数组中 返回数组第N项存储的值 Coding实现1234567891011/** * @param &#123;number&#125; N * @return &#123;number&#125; */var fib = function(N) &#123; let arr=[0,1]; for(let i=2;i&lt;=N;i++)&#123; arr[i]=arr[i-1]+arr[i-2]; &#125; return arr[N];&#125;;]]></content>
      <categories>
        <category>leetcode题解与算法</category>
      </categories>
      <tags>
        <tag>数组</tag>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[leetcode-561 数组拆分 I]]></title>
    <url>%2F2019%2F08%2F09%2Fleetcode-561%2F</url>
    <content type="text"><![CDATA[数组拆分 I题目描述给定长度为 2n 的数组, 你的任务是将这些数分成 n 对, 例如 (a1, b1), (a2, b2), …, (an, bn) ，使得从1 到 n 的 min(ai, bi) 总和最大。 示例 1: 输入: [1,4,3,2]输出: 4解释: n 等于 2, 最大总和为 4 = min(1, 2) + min(3, 4). 提示: n 是正整数,范围在 [1, 10000]. 数组中的元素范围在 [-10000, 10000]. 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/array-partition-i著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 核心思路概述当将整个数组排序后，第一个数必定为最小的数也是必须参加和运算的数假设为a。那么假如与这个最小的数a配对的数n并不是这个数组排序后a的后一个数b，那么b此时成为了剩下的数中最小的数因此必定也要参加和运算；但显然的是，此时a+b所组成的和运算中必定不是最大的和了 解题步骤 将原数组按从小到大进行排序 将数组中所有下标为偶数的数组元素相加得到的和返回 Coding实现1234567891011121314/** * @param &#123;number[]&#125; nums * @return &#123;number&#125; */var arrayPairSum = function(nums) &#123; let ans=0; nums.sort((a,b)=&gt;&#123; return a-b; &#125;); for(let i=0;i&lt;nums.length;i=i+2)&#123; ans+=nums[i]; &#125; return ans;&#125;;]]></content>
      <categories>
        <category>leetcode题解与算法</category>
      </categories>
      <tags>
        <tag>数组</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[leetcode-905 按奇偶排序数组]]></title>
    <url>%2F2019%2F08%2F08%2Fleetcode-905%2F</url>
    <content type="text"><![CDATA[按奇偶排序数组题目描述给定一个非负整数数组 A，返回一个数组，在该数组中， A 的所有偶数元素之后跟着所有奇数元素。 你可以返回满足此条件的任何数组作为答案。 示例： 输入：[3,1,2,4]输出：[2,4,3,1]输出 [4,2,3,1]，[2,4,1,3] 和 [4,2,1,3] 也会被接受。 提示： 1&lt;= A.length &lt;= 5000 0&lt;= A[i] &lt;= 5000 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/sort-array-by-parity著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 核心思路概述 数组 遍历原数组，将奇数放到奇数数组，偶数放到偶数数组，concat后返回 双指针 left指针从前往后遍历,right指针从后往前遍历，如果left指针指向奇数而right指针指向偶数，那么两数交换，直到left&gt;=right 解题步骤数组 设定奇数数组、偶数数组 遍历原数组，将奇数放到奇数数组，偶数放到偶数数组 返回 奇数数组concat偶数数组 双指针 设定left=0,right=A.length-1 left指针从前往后遍历,right指针从后往前遍历，如果left指针指向奇数而right指针指向偶数，那么两数交换，直到left&gt;=right 返回ACoding实现数组实现1234567891011121314151617/** * @param &#123;number[]&#125; A * @return &#123;number[]&#125; */var sortArrayByParity = function(A) &#123; let odd=[]; let even=[]; A.forEach(value=&gt;&#123; if(value%2===0)&#123; even.push(value); &#125; else &#123; odd.push(value); &#125; &#125;) return even.concat(odd);&#125;; 双指针实现12345678910111213141516171819202122/** * @param &#123;number[]&#125; A * @return &#123;number[]&#125; */var sortArrayByParity = function(A) &#123; let left=0; let right=A.length-1; while(left&lt;right)&#123; if(A[left]%2===0)&#123; left++; continue; &#125; if(A[right]%2!==0)&#123; right--; continue; &#125; let temp=A[left]; A[left]=A[right]; A[right]=temp; &#125; return A;&#125;;]]></content>
      <categories>
        <category>leetcode题解与算法</category>
      </categories>
      <tags>
        <tag>数组</tag>
        <tag>双指针</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[引用类型]]></title>
    <url>%2F2019%2F08%2F07%2F%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B%2F</url>
    <content type="text"><![CDATA[引言 新对象的创建可以通过new操作符后跟一个构造函数来创建 例： 1let a=new Object() Object类型创建Object实例的两个方法new操作符1let a=new Object() 对象字面量法1let a=&#123;item:1&#125; 在使用对象字面量语法时，属性名也可以使用字符串和可计算属性名 字符串属性名 1234let a=&#123; 'item':1&#125;console.log(a.item); // 1 可计算属性名(方括号语法：使用变量来访问属性) 12345let n=123;let a=&#123; [n+'abc']:'hello'&#125;console.log(a['123abc']); // hello Array类型创建数组的几种方式 Array构造函数 12let a=new Array(1,2,3);console.log(a); // [1,2,3] 数组字面量法 12let a=[1,2,3];console.log(a); //[1,2,3] 数组的length属性设置值的索引下标超过数组长度当设置值的索引下标超过数组长度时，那么数组的长度会自动加到该索引值加一的长度，并且中间未设置的元素还是undefined 1234let a=[1,2,3];a[8]=1;console.log(a); //[ 1, 2, 3, &lt;5 empty items&gt;, 1 ]console.log(a[5]); //undefined 利用数组的length属性来移除数组项和添加项当将数组的length值设置为小于原数组的length时，则会将原数组后面的几项移除掉 123let a=[1,2,3];a.length=1;console.log(a); //[1] 常用的数组方法栈方法 方法名 作用 返回值 push() 接受任意参数并添加到数组末尾 修改后的数组长度 pop() 从数组末尾移除最后一项 被移除的项 队列方法 方法名 作用 返回值 shift() 移除数组的第一个项 被移除的项 unshift() 接受任意参数并添加到数组前端 修改后的数组长度 重排序方法 方法名 作用 返回值 reverse() 翻转数组项的顺序 修改后的数组 sort() 默认是将数组元素转化为字符串进行比较并按升序排列，但可以添加比较函数 修改后的数组 操作方法 方法名 作用 返回值 concat() 该方法会先创建当前数组的一个副本，然后将接收到的参数添加到这个副本的末尾，最后返回构建的数组 新数组 slice() 返回给定起始位置和结束位置之间的项（左开右闭）（该方法不会影响原始数组） 新数组 splice() 1.删除（删除的第一项的位置和要删除的项数） 2.插入（插入的第一项的位置，0，要插入的元素） 3.替换（替换的第一项位置，要替换的项数，要插入的项数） 从原始数组中删除的项（如果没有删除任何项，则返回一个空数组） 位置方法 方法名 作用 返回值 indexOf() 从数组开头查找第一个全等于给定参数的数组项的下标，若没找到则返回-1 要查找的项在数组中的位置或-1 lastIndexOf() 从数组末尾查找第一个全等于给定参数的数组项的下标，若没找到则返回-1 要查找的项在数组中的位置或-1 迭代方法 方法名 作用 返回值 every() 对数组中的每一项运行给定函数，如果该函数对每一项都返回true，则返回true true或false some() 对数组中的每一项运行给定函数，如果该函数对任一项返回true，则返回true true或false filter() 过滤得到满足给定函数的项的组成的数组 新数组 forEach() 对数组中的每一项运行给定函数 undefined map() 对数组中的每一项运行给定函数，返回每次函数调用的结果组成的数组 新数组 归并方法 方法名 作用 返回值 reduce() 从数组第一项开始，向后对数组中的每个元素执行一个由您提供的reducer函数(升序执行)，将其结果汇总为单个返回值。 新数组 reduceRight() 从数组最后一项开始，向前对数组中的每个元素执行一个由您提供的reducer函数(升序执行)，将其结果汇总为单个返回值。 新数组 方法参数：这两个方法都接收两个参数：一个在每一项上调用的reucer函数和（可选的）作为归并基础的初始值 reducer函数参数：接收四个参数：前一个值、当前值、项的索引和数组对象。这个函数的返回的任何值都后悔作为第一个参数自动传给下一项 Date类型创建日期对象 12let date=new Date();console.log(date.toLocaleString()); RegExp类型Function类型函数实际上是对象。因此函数名实际上也是一个指向函数对象的指针，并不会与某个函数绑定 因此使用不带圆括号的函数名是访问函数指针，而非调用函数 语法 函数声明式语法 （整体提升） 123function test()&#123; console.log(1);&#125; 函数表达式语法 （变量提升，给变量赋值为undefined）123const test=function()&#123; console.log(1);&#125; 作为值的函数因为函数名只是一个指向函数对象的指针，因此函数也可以作为参数的值进行传递 123456789function test()&#123; console.log(1);&#125;function a(test)&#123; test();&#125;a(test); //1 基本包装类型组成 Boolean Number String 定义每当读取一个基本类型值的时候，后台就会自动创建一个对应的基本包装类型的对象。 处理步骤：\ 创建基本包装类型的一个实例 在实例上调用制定的方法 销毁这个实例 生命周期：自动创建的基本包装类型的对象，只存在于一行代码的执行瞬间，然后立即被销毁，这意味着我们不能在运行时为基本类型值添加属性和方法 123let a='hello';a.test=4;console.log(a.test); // undefined Boolean类型Number类型String类型String类型的每个实例都有一个length属性，表示字符串中包含多少个字符 123let a='hello';a.length=1; // 创建a的基本包装类型对象，修改掉length之后，被立即销毁console.log(a.length); // 5 创建a的基本包装类型对象，并返回length属性值 字符方法charAt()与charCodeAt() 字符串操作方法 concat() slice() substr() substring() indexOf() lastIndexOf() toLowerCase() toUpperCase() split() 单体内置对象Global对象Math对象]]></content>
      <categories>
        <category>javaScript基础</category>
      </categories>
      <tags>
        <tag>基础语法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[leetcode-1051 高度检查器]]></title>
    <url>%2F2019%2F08%2F07%2Fleetcode-1051%2F</url>
    <content type="text"><![CDATA[高度检查器题目描述学校在拍年度纪念照时，一般要求学生按照 非递减 的高度顺序排列。 请你返回至少有多少个学生没有站在正确位置数量。该人数指的是：能让所有学生以 非递减 高度排列的必要移动人数。 示例： 输入：[1,1,4,2,1,3]输出：3解释：高度为 4、3 和最后一个 1 的学生，没有站在正确的位置。 提示： 1&lt;= heights.length &lt;= 100 1&lt;= heights[i] &lt;= 100 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/height-checker著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 核心思路概述只需比较原数组和排序后的数组的每个位置上的元素有几个不一样即可 解题步骤 复制原数组，并排序 比较原数组和排序后的数组的各个位置上的元素，若不同则ans++ 返回ans Coding实现12345678910111213141516/** * @param &#123;number[]&#125; heights * @return &#123;number&#125; */var heightChecker = function(heights) &#123; let heightsSort=(new Array(...heights)).sort((a,b)=&gt;&#123; return a-b; &#125;); let ans=0; for(let i in heights)&#123; if(heights[i]!==heightsSort[i])&#123; ans++; &#125; &#125; return ans;&#125;;]]></content>
      <categories>
        <category>leetcode题解与算法</category>
      </categories>
      <tags>
        <tag>数组</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[leetcode-832 翻转图像]]></title>
    <url>%2F2019%2F08%2F06%2Fleetcode-832%2F</url>
    <content type="text"><![CDATA[翻转图像题目描述 给定一个二进制矩阵 A，我们想先水平翻转图像，然后反转图像并返回结果。 水平翻转图片就是将图片的每一行都进行翻转，即逆序。例如，水平翻转 [1, 1, 0] 的结果是 [0, 1, 1]。 反转图片的意思是图片中的 0 全部被 1 替换， 1 全部被 0 替换。例如，反转 [0, 1, 1] 的结果是 [1, 0, 0]。 示例 1: 输入: [[1,1,0],[1,0,1],[0,0,0]]输出: [[1,0,0],[0,1,0],[1,1,1]]解释: 首先翻转每一行: [[0,1,1],[1,0,1],[0,0,0]]； 然后反转图片: [[1,0,0],[0,1,0],[1,1,1]] 示例 2: 输入: [[1,1,0,0],[1,0,0,1],[0,1,1,1],[1,0,1,0]]输出: [[1,1,0,0],[0,1,1,0],[0,0,0,1],[1,0,1,0]]解释: 首先翻转每一行: [[0,0,1,1],[1,0,0,1],[1,1,1,0],[0,1,0,1]]； 然后反转图片: [[1,1,0,0],[0,1,1,0],[0,0,0,1],[1,0,1,0]] 说明: 1&lt;= A.length = A[0].length &lt;= 20 0&lt;= A[i][j] &lt;= 1 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/flipping-an-image著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 核心思路概述利用es6数组方法map()快速地修改数组元素 解题步骤 因为是二维数组，遍历该二维数组将一维数组倒序，并且1变成0,0变成1 Coding实现12345678910111213141516/** * @param &#123;number[][]&#125; A * @return &#123;number[][]&#125; */var flipAndInvertImage = function(A) &#123; return A.map(value=&gt;&#123; value.reverse(); return value.map(value1=&gt;&#123; if(value1===0)&#123; value1=1; &#125; else value1=0; return value1; &#125;); &#125;)&#125;;]]></content>
      <categories>
        <category>leetcode题解与算法</category>
      </categories>
      <tags>
        <tag>数组</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[leetcode-345 反转字符串中的元音字母]]></title>
    <url>%2F2019%2F08%2F05%2Fleetcode-345%2F</url>
    <content type="text"><![CDATA[反转字符串中的元音字母题目描述编写一个函数，以字符串作为输入，反转该字符串中的元音字母。 示例 1: 输入: “hello”输出: “holle” 示例 2: 输入: “leetcode”输出: “leotcede” 说明:元音字母不包含字母”y”。 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/reverse-vowels-of-a-string著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 核心思路概述元音字母一共有5个，分别为’a’,’e’,’i’,’o’,’u’; 当然该题要注意元音字母对应的大写形式也算 因此，使用双指针，一个在首，一个在尾，当两指针未相遇时，如果两个指针指的都是元音字母或其大写形式，那么就交换两个字母；如果不是，那么就左指针向后，右指针往前 解题步骤 建立left,right双指针；将字符串s转换为字符串数组 left与right双指针，一个在首，一个在尾，当两指针未相遇时，如果两个指针指的都是元音字母或其大写形式，那么就交换两个字母；如果不是，那么就左指针向后，右指针往前 Coding实现123456789101112131415161718192021222324/** * @param &#123;string&#125; s * @return &#123;string&#125; */var reverseVowels = function(s) &#123; s=s.split(''); let left=0; let yuan=['a','e','i','o','u']; let right=s.length-1; while(left&lt;right)&#123; if(yuan.includes(s[left].toLowerCase())&amp;&amp;yuan.includes(s[right].toLowerCase()))&#123; [s[left],s[right]]=[s[right],s[left]]; left++; right--; &#125; if(!yuan.includes(s[left].toLowerCase())) &#123; left++; &#125; if(!yuan.includes(s[right].toLowerCase())) &#123; right--; &#125; &#125; return s.join('');&#125;;]]></content>
      <categories>
        <category>leetcode题解与算法</category>
      </categories>
      <tags>
        <tag>双指针</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[leetcode-933 最近的请求次数]]></title>
    <url>%2F2019%2F08%2F04%2Fleetcode-933%2F</url>
    <content type="text"><![CDATA[最近的请求次数题目描述写一个 RecentCounter 类来计算最近的请求。 它只有一个方法：ping(int t)，其中 t 代表以毫秒为单位的某个时间。 返回从 3000 毫秒前到现在的 ping 数。 任何处于 [t - 3000, t] 时间范围之内的 ping 都将会被计算在内，包括当前（指 t 时刻）的 ping。 保证每次对 ping 的调用都使用比之前更大的 t 值。 示例： 输入：inputs = [“RecentCounter”,”ping”,”ping”,”ping”,”ping”], inputs = [[],[1],[100],[3001],[3002]]输出：[null,1,2,3,3] 提示： 每个测试用例最多调用 10000 次 ping。 每个测试用例会使用严格递增的 t 值来调用 ping。 每次调用 ping 都有 1 &lt;= t &lt;= 10^9。 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/number-of-recent-calls著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 核心思路概述该题目的意思就是计算在当前时刻往前3000毫秒到此时（即[t - 3000, t]）的所有Ping的数量 解题步骤 在RecentCounter构造函数中设置一个队列queue用来保存按时间顺序到来的ping的时间 利用出队列来删去当前队列中小于当前时间-3000毫秒的队列项 返回队列长度 Coding实现1234567891011121314151617181920212223242526var RecentCounter = function() &#123; this.queue=[];&#125;;/** * @param &#123;number&#125; t * @return &#123;number&#125; */RecentCounter.prototype.ping = function(t) &#123; let queue=this.queue; if(t===null) return null; else&#123; queue.push(t); while(queue[0]&lt;t-3000)&#123; queue.shift(); &#125; return queue.length; &#125;&#125;;/** * Your RecentCounter object will be instantiated and called as such: * var obj = new RecentCounter() * var param_1 = obj.ping(t) */]]></content>
      <categories>
        <category>leetcode题解与算法</category>
      </categories>
      <tags>
        <tag>队列</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[变量、作用域和内存问题]]></title>
    <url>%2F2019%2F08%2F04%2F%E5%8F%98%E9%87%8F%E3%80%81%E4%BD%9C%E7%94%A8%E5%9F%9F%E5%92%8C%E5%86%85%E5%AD%98%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[基本类型值和引用类型值的存储与复制变量类型与内存的关系栈内存基本数据类型保存在栈内存中，因为基本数据类型占用空间小、大小固定，通过按值来访问，属于被频繁使用的数据 堆内存引用数据类型存储在堆内存中，因为引用数据类型占据空间大、大小不固定。 如果存储在栈中，将会影响程序运行的性能； 引用数据类型在栈中存储了指针，该指针指向堆中该实体的起始地址。 当解释器寻找引用值时，会首先检索其在栈中的地址，取得地址后从堆中获得实体 变量复制基本类型值的变量复制如果从一个变量向另一个变量复制基本类型的值，那么就会在变量对象（每个执行环境都有一个与之相关联的变量对象，当前环境中的所有变量和函数都会保存在这个对象中）上创建一个新的值，然后把该值复制到为新变量分配的位置上。 基本类型变量复制完毕后，两个变量是相互独立的。因为两个变量占据的是不同的栈内存空间。 12345const a=20;let b=a;console.log(a,b); // 20,20b=30;console.log(a,b); // 20,30 引用数据类型值的变量复制当从一个变量向另一个变量复制引用类型的值时，同样也会将存储在变量对象中的值复制一份放到位新变量分配的空间中。不同的是，这个值的副本实际上是一个指针，而这个指针指向存储在堆中的一个对象。 两个变量实际上引用的是同一个对象，因此改变其中一个变量，就会影响另一个变量。 123let m=&#123;a:10,b:20&#125;;let n=m;console.log(n); //&#123;a:10,b:20&#125; 函数的参数传递相当于变量复制es中所有函数的参数传递都是按值传递的。 基本类型值的参数传递就相当于基本类型值的变量复制，即创建了一个新的局部变量，值为传过来的参数值。 1234567let a=1;function test(n)&#123; console.log(n); //1 n++;&#125;test(a);console.log(a); // 1 引用类型值的参数传递也相当于引用类型值的变量传递，即创建了一个新的局部变量，保存的是传过来的参数的指针地址，两个变量在栈内存中有着不同的内存空间，但是指向堆内存中的同一个对象。 函数内部变量有变化时（指的是不改变该变量的指针指向地址）也会影响函数外部对象 而当该变量的指针指向地址改变后，两个变量就不在指向了同一个变量，因此之后函数内部变量的变化不会体现在函数外部 123456let a=&#123;item:1&#125;;function test(n)&#123; console.log(a===n); //true n=&#123;&#125;; console.log(a===n);&#125; 执行环境及作用域执行环境(执行上下文)执行环境可能有三种情况 全局执行环境(浏览器中的window对象和node环境中的global对象) —— 代码第一次执行的默认环境 函数执行环境 —— 执行流进入函数体 当执行流进入一个函数时，函数的执行环境会被推入一个环境中。当该函数执行完毕后，栈将其环境弹出，把控制权返回给之前的执行环境 Eval code（Eval code）——代码在eval函数内部执行 每个执行环境中都有一个与之关联的变量对象，用来存储在该环境中定义的变量和函数(但是我们无法访问到这个变量对象，是解析器在后台处理数据时会使用到) 作用域对于作用域，我的理解是它在某种程度上相当于执行环境，每个作用域都有当前作用域的变量和对象。但是作用域之间的变量和函数时相互隔离的，也就说不同作用域下的同名变量不会产生冲突 作用域链当代码在一个环境中执行时，会创建变量对象的一个作用域链。 作用域链的用途：是用来保证对执行环境有权访问的所有变量和函数的有序访问。 作用域的前端，始终都是当前的执行环境的变量对象。如果这个环境是函数，那么将其环境对象作为变量对象。作用链中的下一个对象是包含当前执行环境的执行环境的变量对象。这样，一直延续到全局执行环境。全局执行环境的变量对象始终都是作用域链的最后一个对象 12345678910function a()&#123; let m=1; function b()&#123; let m=2; console.log(m); // 2 &#125; b(); console.log(m); // 1&#125;a(); 延长作用域链有两种方式可以延长作用域链 try-catch语句的catch块 with语句 这两个语句都会在当前作用域链的前端添加一个变量对象。 对with语句来说，会将指定的对象添加到作用域链中。 对catch语句来说，会创建一个新的变量对象，其中包含的是被抛出的错误对象的声明 垃圾收集JavaScript 具有自动垃圾收集机制（GC：Garbage Collecation），也就是说，执行环境会负责管理代码执行过程中使用的内存。 标记清除JavaScript中最常用的垃圾收集方式就是标记清除，当变量进入环境后，就将这个变量标记为“进入环境”；而当变量离开环境时，就将其标记为“离开环境”。从而垃圾回收器完成垃圾回收工作 管理内存优化内存占用的最佳方式，就是为执行中的代码只保存必要的数据。一旦数据不再有用，最好将其值设置为null来释放其引用————这个做法叫做解除引用。 局部变量在离开执行环境是会自动被解除引用。 因此我们通常来解除全局执行环境中的引用]]></content>
      <categories>
        <category>javaScript基础</category>
      </categories>
      <tags>
        <tag>基础语法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[leetcode-237 删除链表中的节点]]></title>
    <url>%2F2019%2F08%2F03%2Fleetcode-237%2F</url>
    <content type="text"><![CDATA[删除链表中的节点题目描述请编写一个函数，使其可以删除某个链表中给定的（非末尾）节点，你将只被给定要求被删除的节点。 现有一个链表 – head = [4,5,1,9]，它可以表示为: 示例 1: 输入: head = [4,5,1,9], node = 5输出: [4,1,9]解释: 给定你链表中值为 5 的第二个节点，那么在调用了你的函数之后，该链表应变为 4 -&gt; 1 -&gt; 9. 示例 2: 输入: head = [4,5,1,9], node = 1输出: [4,5,9]解释: 给定你链表中值为 1 的第三个节点，那么在调用了你的函数之后，该链表应变为 4 -&gt; 5 -&gt; 9. 说明: 链表至少包含两个节点。 链表中所有节点的值都是唯一的。 给定的节点为非末尾节点并且一定是链表中的一个有效节点。 不要从你的函数中返回任何结果。 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/delete-node-in-a-linked-list著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 核心思路概述一开始看到这个题目也是傻了一下，为什么只是传入一个要删除的节点，而不传入整个链表。后来一想，题目给定的初始链表中，每个节点的next存在的指向关系是一定的。那么我们就可以不需要考虑要删除节点之前的节点，只需要将要删除的节点的val值和next指向改变就可以了 解题步骤 改变要删除节点的val值为其下一个节点的val值 改变要删除节点的next指向为其下一个节点的下一个节点 Coding实现123456789101112131415/** * Definition for singly-linked list. * function ListNode(val) &#123; * this.val = val; * this.next = null; * &#125; *//** * @param &#123;ListNode&#125; node * @return &#123;void&#125; Do not return anything, modify node in-place instead. */var deleteNode = function(node) &#123; node.val=node.next.val; node.next=node.next.next;&#125;;]]></content>
      <categories>
        <category>leetcode题解与算法</category>
      </categories>
      <tags>
        <tag>链表</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[arguments与模拟函数重载]]></title>
    <url>%2F2019%2F08%2F03%2Farguments%E4%B8%8E%E6%A8%A1%E6%8B%9F%E5%87%BD%E6%95%B0%E9%87%8D%E8%BD%BD%2F</url>
    <content type="text"><![CDATA[argumentsarguments对象是所有（非箭头）函数中都可用的局部变量。 通过该对象可以访问参数数组。因为此对象包含传递给函数的每个参数，第一个参数在索引0处。 12345function a()&#123; console.log(arguments); //Arguments &#123; 0: 1, 1: 2, 2: 3, … &#125; console.log(arguments[0]); //1&#125;a(1,2,3); 由此可以看到，arguments对象并不是Array的实例，它是类数组对象。因此，可以通过方括号语法访问它的每一个元素 arguments对象内的属性值永远与对应命名参数的值保持同步 123456function a(num)&#123; console.log(arguments[0]); //1 num=11; console.log(arguments[0]); //11&#125;a(1,2,3); 模拟函数重载重载的概念在Java语言中，函数或者方法有相同的名称，但是参数的类型或数量不同，这样的同名不同参数的函数或者方法之间，互相称之为重载函数。 为什么js没有重载然而，js中并没有重载的概念，因为： 1234567function a(num)&#123; console.log(1);&#125;function a(num1,num2)&#123; console.log(2);&#125;a(); // 2 如果定义了多个同名函数，那么该名字只属于后定义的函数，所以js中不能像Java一样有传统意义上的重载 js模拟函数重载其实，通过arguments,我们就可以通过检查传入函数中的参数类型和数量来做出不同的反应，从而模拟方法的重载 12345678910function a()&#123; if(arguments.length===0)&#123; console.log(0); &#125; else if(arguments.length===1)&#123; console.log(1); &#125;&#125;a(); // 0a(1); // 1]]></content>
      <categories>
        <category>javaScript基础</category>
      </categories>
      <tags>
        <tag>基础语法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[循环 (for...of与for...in)]]></title>
    <url>%2F2019%2F08%2F03%2F%E5%BE%AA%E7%8E%AF%2F</url>
    <content type="text"><![CDATA[循环语句类型 for 语句 do…while 语句 while 语句 labeled 语句 break 语句 continue 语句 for…in 语句 for…of 语句 for…infor…in 语句循环一个指定的变量来循环一个对象所有可枚举的属性。JavaScript 会为每一个不同的属性执行指定的语句。 123456789const items=&#123; item1:1, item2:2, item3:3&#125;for(let a in items)&#123; console.log(a); // item1,item2,item3 console.log(items[a]); //1,2,3&#125; for…offor…of语句在可迭代的对象(在es6中，所有的集合对象(数组、Set集合及Map集合)和字符串都是可迭代对象)上创建了一个循环 ，对值的每一个独特的属性调用一个将被执行的自定义的和语句挂钩的迭代。 for…of循环每执行一次都会调用可迭代对象的next()方法，并将迭代器返回的结果对象的value属性存储在一个变量中，循环将持续执行这一过程直到返回对象的done属性的值为true 与 for…in 循环遍历的结果是数组元素的下标不同的是， for…of 遍历的结果是元素的值： 1234567891011121314151617181920let arr=[4,5,6];let str='string';let set=new Set([1,'a',3]);let map=new Map([['a',1],['b',2]]);//遍历数组for(let a of arr)&#123; console.log(a); //4,5,6&#125;//遍历字符串for(let s of str)&#123; console.log(s); //s,t,r,i,n,g&#125;//遍历set集合for(let k of set)&#123; console.log(k); //1,'a',3&#125;//遍历map集合for(let m of map)&#123; console.log(m); //[ 'a', 1 ],[ 'b', 2 ]&#125; 总结 倘若是遍历普通对象(非迭代对象)，那么使用for…in最佳，遍历得到属性名 倘若是遍历可迭代对象，那么根据需求来，如果不需要一些下标信息（例如set集合，字符串）那么使用for…of最佳 如果是数组和map，那么使用forEach会更加方便]]></content>
      <categories>
        <category>javaScript基础</category>
      </categories>
      <tags>
        <tag>基础语法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[null与{}其实不相等]]></title>
    <url>%2F2019%2F08%2F03%2F%E7%A9%BA%E5%AF%B9%E8%B1%A1%2F</url>
    <content type="text"><![CDATA[引言{}与null相等吗？看一下下面的例子： 1console.log(&#123;&#125;===null); //false 显然，{}与null是不相等的 关于{}与null当我们在浏览器环境下，输入以下代码会发现： 1console.log(&#123;&#125;); // Object &#123; &#125; 作为比较，当需要输出null时会发现： 1console.log(null); // null 关于是否是空对象，我们可以采用instanceof的方法来检测 1console.log(&#123;&#125; instanceof Object); //true 那么，{}这个对象的原型链顶部会是Object，那么{}是一个不完全空的对象，只不过他没有任何属性罢了 1console.log(null instanceof Object); //false 而null的原型链上都找不到Object，那么null就是一个完完全全的空对象指针]]></content>
      <categories>
        <category>javaScript基础</category>
      </categories>
      <tags>
        <tag>基础语法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[布尔操作符(1&&2和1||2)]]></title>
    <url>%2F2019%2F08%2F03%2F%E5%B8%83%E5%B0%94%E6%93%8D%E4%BD%9C%E7%AC%A6%2F</url>
    <content type="text"><![CDATA[mdn总结 运算符 语法 说明 逻辑与，AND（&amp;&amp;） expr1 &amp;&amp; expr2 若 expr1 可转换为 true，则返回 expr2；否则，返回 expr1。 逻辑或，OR（||） expr1 || expr2 若 expr1 可转换为 true，则返回 expr1；否则，返回 expr2。 逻辑非，NOT（!） !expr 若 expr 可转换为 true，则返回 false；否则，返回 true。 逻辑非 – !逻辑非操作符首先会将它的操作数转换为一个布尔值，然后再对其求反 123456console.log(!123); //falseconsole.log(!''); //trueconsole.log(!undefined); //trueconsole.log(!null); //trueconsole.log(!new String('1')); //falseconsole.log(!false); //true 逻辑与 – &amp;&amp;注意：逻辑与(&amp;&amp;)操作可以应用于任何类型的操纵数，而不仅仅是布尔值。 在有一个操作数不是布尔值的情况下，逻辑与操作就不一定返回布尔值；因此若要显示返回布尔值，则可以使用Boolean转型函数显示返回 逻辑与操作属于短路操作，即如果第一个操作数能够决定结果，那么就不会再对第二个操作数求值。 1234console.log(1&amp;&amp;2); //2console.log(0&amp;&amp;1); //0console.log(123&amp;&amp;'qwe'); //'qwe'console.log(&#123;&#125;&amp;&amp;null); //null 因为&#123;&#125;并不等于null，&#123;&#125;是一个不完全为空的对象，所以&#123;&#125;转换为逻辑值会是true 逻辑或 – ||与逻辑与操作类似，逻辑或操作也是短路操作。也就是说，如果第一个操作数的求值结果为true,就不会对第二个操作数求值了 1234console.log(1||2); //1console.log(0||1); //1console.log(123||'qwe'); //123console.log(&#123;&#125;||null); //&#123;&#125;]]></content>
      <categories>
        <category>javaScript基础</category>
      </categories>
      <tags>
        <tag>基础语法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[leetcode-283 移动零]]></title>
    <url>%2F2019%2F08%2F02%2Fleetcode-283%2F</url>
    <content type="text"><![CDATA[移动零题目描述给定一个数组 nums，编写一个函数将所有 0 移动到数组的末尾，同时保持非零元素的相对顺序。 示例: 输入: [0,1,0,3,12]输出: [1,3,12,0,0] 说明: 必须在原数组上操作，不能拷贝额外的数组。 尽量减少操作次数。 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/move-zeroes著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 核心思路概述利用双指针，一个left指针用来寻找为0的元素，当找到后，该元素后面的所有元素前移，并将第二个指向数组末尾的指针right的元素值赋为0；如此循环直到left&gt;right 解题步骤 设置left指针指向数组第一个元素，设置right指针指向数组的最后一个元素 移动Left寻找数组中为0元素，当找到后，该元素后面的所有元素前移，并将第二个指向数组末尾的指针right的元素值赋为0；如此循环直到left&gt;right Coding实现123456789101112131415161718192021/** * @param &#123;number[]&#125; nums * @return &#123;void&#125; Do not return anything, modify nums in-place instead. */var moveZeroes = function(nums) &#123; let left=0; let right=nums.length-1; while(left&lt;right)&#123; if(nums[left]===0)&#123; for(let i=left;i&lt;right;i++)&#123; nums[i]=nums[i+1]; &#125; nums[right]=0; right--; &#125; else &#123; left++; &#125; &#125; return nums;&#125;;]]></content>
      <categories>
        <category>leetcode题解与算法</category>
      </categories>
      <tags>
        <tag>双指针</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据类型]]></title>
    <url>%2F2019%2F08%2F01%2F%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%2F</url>
    <content type="text"><![CDATA[数据类型简单数据类型 Null (null值本质上是一个空对象指针) Undefined String Number Boolean Symbol 复杂数据类型 Object(包括Array、Function、Date、RegExp、Error、Arguments等更为具体的引用类型) 数据类型的检测判断typeof typeof 常用于判断基本数据类型 一些注意点 typeof返回的是一个字符串,因此 typeof typeof 1 //(任意数据类型)都会返回string null是一个空对象指针，因此typeof null会返回object 对于函数function的判断，tpeof function会返回function而不是对象object 从技术角度讲，函数在es中是对象，而不是一种数据类型。然而，函数也确实有一些特殊的属性，因此通过typeof操作符来区分函数和其他对象是有必要的 对于除function外的复杂数据类型，例如数组，set,map都会返回对象object 1234567891011121314151617181920212223typeof 123 // "number"typeof "abc" // "string" typeof (new String()) //objecttypeof true // "boolean" typeof &#123;a: 1&#125; // "object" typeof null //objecttypeof function foo() &#123;&#125; // "function" typeof undefined // "undefined" typeof Symbol('foo') // "symbol"typeof (new Set()) //"object"typeof (new Map()) //"object"typeof typeof 1 //"string" typeof的不足使用 typeof 方法来检测数据类型，基本类型大部分都能被准确检测并返回正确的字符串（除了 Null 类型，其返回 object 字符串），而引用类型大部分都不能够被准确检测（除了 Function 类型能够准确返回 function 字符串外，其它的都返回了 object 字符串）。 instanceofinstanceof用于判断引用类型 instanceof 运算符用于测试构造函数的prototype属性是否出现在对象的原型链中的任何位置 12let str=new String();console.log(str instanceof String); //true 123456function Person()&#123;&#125;;function Student()&#123;&#125;;let person=new Person();Student.prototype=person;let student=new Student();console.log(student instanceof Person) //true 语法 object instanceof constructor 因此当使用instanceof判断基本数据类型时就会返回false,与此同时,instanceof 右端也必须是某个构造函数 12'a' instanceof String //false123 instanceof Number //false null instanceof object那么基本数据类型中的null呢，既然typeof null===object;那么null instanceof object呢？很不幸,返回的会是false 简单来说，null并不是以Object为原型创建出来的 1null instanceof object //false 函数模拟instanceof知道instaceof的原理是判断构造函数的prototype属性是否出现在对象的原型链中的任何位置时，那么就不难模拟一个函数来实现instanceof 12345678910function instance(a,b)&#123; let bPro=b.prototype; //取b的显示原型 let aPro=a.__proto__; //取a的隐式原型 //或者使用Object.getPrototypeOf(a)取得a的隐式原型 while(true)&#123; if(aPro===bPro) return true; if(aPro===Object.prototype) return false; aPro=aPro.__proto__; &#125;&#125; Object.prototype.toString()一个完善的类型检测方案 每个对象都有一个toString()方法，当该对象被表示为一个文本值时，或者一个对象以预期的字符串方式引用时自动调用。默认情况下，toString()方法被每个Object对象继承。如果此方法在自定义对象中未被覆盖，toString() 返回 “[object type]”，其中type是对象的类型 可以通过toString() 来获取每个对象的类型。为了每个对象都能通过 Object.prototype.toString() 来检测，需要以 Function.prototype.call() 或者 Function.prototype.apply() 的形式来调用，传递要检查的对象作为第一个参数，称为thisArg。 123456789101112var toString=Object.prototype.toString;console.log(toString.call(undefined)); // [object Undefined]console.log(toString.call(null)); // [object Null]console.log(toString.call(true)); // [object Boolean]console.log(toString.call(123)); // [object Number]console.log(toString.call('a')); // [object String]console.log(toString.call(new Object()); // [object Object]console.log(toString.call([1,2,3])); // [object Array]console.log(toString.call(function a()&#123;&#125;)); // [object Function]console.log(toString.call(new Date())); // [object Date] 数组判断isArray() Array.isArray() 用于确定传递的值是否是一个 Array。 12345678Array.isArray([1, 2, 3]); // trueArray.isArray(&#123;foo: 123&#125;); // falseArray.isArray("foobar"); // falseArray.isArray(undefined); // false instanceof12let a=[1,2,3];console.log(a instanceof Array); // true 综述一个较好的解决方案应该是检测基本数据类型时使用typeof，当然null除外；检测复杂数据类型时使用Object.prototype.toString() Undefined类型undefined指那些被声明但未被初始化的值 Null类型null值表示一个空对象指针，因此typeof null === object Boolean类型及相应转换规则转型函数Boolean()12let str='hello';console.log(Boolean(str)); //true Boolean自动转换规则 数据类型 转换为true值 转换为false值 Number 任何非0数值 0和NaN String 非空字符串 空字符串（””） Bollean true false Object 任何object(包括{}，因为{}是一个不完全空的对象) null Undefined 无 undefined Number类型为什么0.1+0.2!==0.3 NaNNaN,指的是非数值，用来表示一个本来要返回数值的操作数未返回数值的情况，例如： 1console.log('a'-1); //NaN 任何设置NaN的操作都会返回NaN,甚至NaN与任何值都不相等包括其本身，包括但不限于： 12console.log(NaN-1); //NaNconsole.log(NaN===NaN); //false isNaN函数 isNaN() 函数用来确定一个值是否为NaN 。注：isNaN函数内包含一些非常有趣的规则；你也可以使用 ECMAScript 2015 中定义的 Number.isNaN() 来判断。 下一个版本的ECMAScript (ES2015)包含Number.isNaN()函数。通过Number.isNaN(x)来检测变量x是否是一个NaN将会是一种可靠的做法。然而，在缺少Number.isNaN函数的情况下, 通过表达式(x != x) 来检测变量x是否是NaN会更加可靠。 一个isNaN的 polyfill 可以理解为（这个polyfill利用了NaN自身永不相等于自身这一特征 ）： 1234var isNaN = function(value) &#123; var n = Number(value); //利用Number()函数进行数值转换 return n !== n;&#125;; 例子12345678910111213141516171819202122isNaN(NaN); // trueisNaN(undefined); // trueisNaN(&#123;&#125;); // trueisNaN(true); // falseisNaN(null); // falseisNaN(37); // false// stringsisNaN("37"); // false: 可以被转换成数值37isNaN("37.37"); // false: 可以被转换成数值37.37isNaN("37,5"); // trueisNaN('123ABC'); // true: parseInt("123ABC")的结果是 123, 但是Number("123ABC")结果是 NaNisNaN(""); // false: 空字符串被转换成0isNaN(" "); // false: 包含空格的字符串被转换成0// datesisNaN(new Date()); // falseisNaN(new Date().toString()); // trueisNaN("blabla") // true: "blabla"不能转换成数值 // 转换成数值失败， 返回NaN 数值转换 Number() parseInt() parseFloat() String类型toString()方法作用：返回值的字符串表现数值，布尔值，对象和字符串都有该方法但是undefined和null没有该方法 1234console.log(123.toString()); //'123'console.log(true.toString()); //'true'let a=&#123;item:1&#125;;console.log(a.toString()); //'[object Object]' String()转型函数该函数不同于toString不能转换null和undefined;该方法可以转换任何类型的值 转换规则如下： 如果该类型有toString()方法，那么就调用该方法 如果为null，则返回”null” 如果为undefined，则返回”undefined” Object类型Object类型是所有对象的基础，也就是所有对象都是继承与Object的 123456let a=new Object();let str=new String();let date=new Date();console.log(a instanceof Object); //trueconsole.log(str instanceof Object); //trueconsole.log(date instanceof Object); //true 对象可以通过执行new操作符后跟要创建的对象类型的名称来创建，例 123let a=new Object();let str=new String();let date=new Date(); Object实例的一些属性与方法 constructor: 指向构造函数 isPrototypeOf(object)：用于检查传入的对象是否是当前对象的原型 toString()：返回对象的字符串表示 valueOf(): 返回对象的字符串、数值或布尔值表示。通常与toString()方法返回值相同]]></content>
      <categories>
        <category>javaScript基础</category>
      </categories>
      <tags>
        <tag>基础语法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[leetcode-1021 删除最外层的括号]]></title>
    <url>%2F2019%2F07%2F31%2Fleetcode-1021%2F</url>
    <content type="text"><![CDATA[删除最外层的括号题目描述有效括号字符串为空 (“”)、”(“ + A + “)” 或 A + B，其中 A 和 B 都是有效的括号字符串，+ 代表字符串的连接。例如，””，”()”，”(())()” 和 “(()(()))” 都是有效的括号字符串。 如果有效字符串 S 非空，且不存在将其拆分为 S = A+B 的方法，我们称其为原语（primitive），其中 A 和 B 都是非空有效括号字符串。 给出一个非空有效字符串 S，考虑将其进行原语化分解，使得：S = P_1 + P_2 + … + P_k，其中 P_i 是有效括号字符串原语。 对 S 进行原语化分解，删除分解中每个原语字符串的最外层括号，返回 S 。 示例 1： 输入：”(()())(())”输出：”()()()”解释：输入字符串为 “(()())(())”，原语化分解得到 “(()())” + “(())”，删除每个部分中的最外层括号后得到 “()()” + “()” = “()()()”。 示例 2： 输入：”(()())(())(()(()))”输出：”()()()()(())”解释：输入字符串为 “(()())(())(()(()))”，原语化分解得到 “(()())” + “(())” + “(()(()))”，删除每隔部分中的最外层括号后得到 “()()” + “()” + “()(())” = “()()()()(())”。 示例 3： 输入：”()()”输出：””解释：输入字符串为 “()()”，原语化分解得到 “()” + “()”，删除每个部分中的最外层括号后得到 “” + “” = “”。 提示： S.length &lt;= 10000 S[i] 为 “(“ 或 “)” S 是一个有效括号字符串 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/remove-outermost-parentheses著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 核心思路概述关于括号匹配问题，很容易想到用栈来解决。 遇到 ‘ ( ‘ 入栈，遇到 ‘ ) ‘ 则出栈。则当该栈为空时，则代表之前的括号都已匹配。那么就可以将先前的括号去掉最外层的括号 解题步骤 设定一个数组stack用来表示栈操作，并预先压入第一个元素’(‘ 设定一个数组temp用来存放已经匹配完成的括号，并预先设定第一个元素’(‘ 从第二个元素开始遍历，遇到 ‘ ( ‘ 入栈，遇到 ‘ ) ‘ 则出栈。则当该栈为空时，则代表之前的括号都已匹配。那么就可以将先前的括号去掉最外层的括号,并压入结果数组ans 返回ans Coding实现123456789101112131415161718192021222324/** * @param &#123;string&#125; S * @return &#123;string&#125; */var removeOuterParentheses = function(S) &#123; let stack=['(']; let temp=['(']; let ans=[]; S=S.split(''); for(let i=1;i&lt;S.length;i++)&#123; temp.push(S[i]); if(S[i]===')')&#123; stack.pop(); if(stack.length===0)&#123; temp.pop(); temp.shift(); ans.push(...temp); temp=[]; &#125; &#125; else stack.push(S[i]); &#125; return ans.join('');&#125;;]]></content>
      <categories>
        <category>leetcode题解与算法</category>
      </categories>
      <tags>
        <tag>栈</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[leetcode-1122 数组的相对排序]]></title>
    <url>%2F2019%2F07%2F30%2Fleetcode-1122%2F</url>
    <content type="text"><![CDATA[数组的相对排序题目描述给你两个数组，arr1 和 arr2， arr2 中的元素各不相同 arr2 中的每个元素都出现在 arr1 中 对 arr1 中的元素进行排序，使 arr1 中项的相对顺序和 arr2 中的相对顺序相同。未在 arr2 中出现过的元素需要按照升序放在 arr1 的末尾。 示例： 输入：arr1 = [2,3,1,3,2,4,6,7,9,2,19], arr2 = [2,1,4,3,9,6]输出：[2,2,2,1,4,3,3,9,6,7,19] 提示： arr1.length, arr2.length &lt;= 1000 0 &lt;= arr1[i], arr2[i] &lt;= 1000 arr2 中的元素 arr2[i] 各不相同 arr2 中的每个元素 arr2[i] 都出现在 arr1 中 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/relative-sort-array著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 核心思路概述目前觉得暴力解法最简单 解题步骤双循环，时间复杂度为O(n*m) Coding实现1234567891011121314151617181920212223/** * @param &#123;number[]&#125; arr1 * @param &#123;number[]&#125; arr2 * @return &#123;number[]&#125; */var relativeSortArray = function(arr1, arr2) &#123; let ans=[]; let el=[]; arr1.forEach(value=&gt;&#123; if(!arr2.includes(value))&#123; el.push(value); &#125; &#125;) arr2.forEach(value2=&gt;&#123; arr1.forEach(value1=&gt;&#123; if(value1===value2)&#123; ans.push(value2); &#125; &#125;) &#125;) el.sort((a,b)=&gt;&#123;return a-b;&#125;) return ans.concat(el);&#125;;]]></content>
      <categories>
        <category>leetcode题解与算法</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[leetcode-344 反转字符串]]></title>
    <url>%2F2019%2F07%2F30%2Fleetcode-344%2F</url>
    <content type="text"><![CDATA[反转字符串题目描述编写一个函数，其作用是将输入的字符串反转过来。输入字符串以字符数组 char[] 的形式给出。 不要给另外的数组分配额外的空间，你必须原地修改输入数组、使用 O(1) 的额外空间解决这一问题。 你可以假设数组中的所有字符都是 ASCII 码表中的可打印字符。 示例 1： 输入：[“h”,”e”,”l”,”l”,”o”]输出：[“o”,”l”,”l”,”e”,”h”] 示例 2： 输入：[“H”,”a”,”n”,”n”,”a”,”h”]输出：[“h”,”a”,”n”,”n”,”a”,”H”] 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/reverse-string著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 核心思路概述题目要求是原地修改数组，并且只能使用O(1)的额外空间。因此，不能创建新的数组来存放数组元素，此时可以考虑使用双指针，一个置首，一个置尾。首向后，尾向前，交换两个指针的值即可。 解题步骤 建立left,right双指针 当left&lt;=right时，交换两指针元素 Coding实现1234567891011121314/** * @param &#123;character[]&#125; s * @return &#123;void&#125; Do not return anything, modify s in-place instead. */var reverseString = function(s) &#123; let left=0; let right=s.length-1; while(left&lt;=right)&#123; [s[left],s[right]]=[s[right],s[left]]; left++; right--; &#125; return s;&#125;;]]></content>
      <categories>
        <category>leetcode题解与算法</category>
      </categories>
      <tags>
        <tag>双指针</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[leetcode-977 有序数组的平方]]></title>
    <url>%2F2019%2F07%2F29%2Fleetcode-977%2F</url>
    <content type="text"><![CDATA[有序数组的平方题目描述给定一个按非递减顺序排序的整数数组 A，返回每个数字的平方组成的新数组，要求也按非递减顺序排序。 示例 1： 输入：[-4,-1,0,3,10]输出：[0,1,9,16,100] 示例 2： 输入：[-7,-3,2,3,11]输出：[4,9,9,49,121] 提示： 1&lt;= A.length &lt;= 10000 -10000 &lt;= A[i] &lt;= 10000 A 已按非递减顺序排序。 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/squares-of-a-sorted-array著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 核心思路概述将该数组的每一个元素平方后在将该数组排序并返回 解题步骤 将该数组的每一个元素平方 排序该数组并返回 Coding实现123456789/** * @param &#123;number[]&#125; A * @return &#123;number[]&#125; */var sortedSquares = function(A) &#123; return A.map(value=&gt;&#123; return value*value; &#125;).sort((a,b)=&gt;&#123;return a-b;&#125;)&#125;;]]></content>
      <categories>
        <category>leetcode题解与算法</category>
      </categories>
      <tags>
        <tag>数组</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[leetcode-350 两个数组的交集 II]]></title>
    <url>%2F2019%2F07%2F28%2Fleetcode-350%2F</url>
    <content type="text"><![CDATA[两个数组的交集 II题目描述给定两个数组，编写一个函数来计算它们的交集。 示例 1: 输入: nums1 = [1,2,2,1], nums2 = [2,2]输出: [2,2] 示例 2: 输入: nums1 = [4,9,5], nums2 = [9,4,9,8,4]输出: [4,9] 说明： 输出结果中每个元素出现的次数，应与元素在两个数组中出现的次数一致。我们可以不考虑输出结果的顺序。 进阶: 如果给定的数组已经排好序呢？你将如何优化你的算法？ 如果 nums1 的大小比 nums2 小很多，哪种方法更优？ 如果 nums2 的元素存储在磁盘上，磁盘内存是有限的，并且你不能一次加载所有的元素到内存中，你该怎么办？ 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/intersection-of-two-arrays-ii著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 核心思路概述该题可以考虑用双指针方法和哈希表去解决。双指针主要循环比较两个数是否相等；哈希表主要是记录每个数组中每个元素出现的次数 解题步骤双指针 将两个数组进行排序 设定两个指针，分别指向两个数组的第一个元素 如果两个指针指向的元素相等，那么就把该元素push入ans数组；并且两个指针向后移动 如果不等，那么指向较小元素的那个指针向后移动 哈希表 建立两个哈希表，分别存储每个数组中的每个元素存储的个数 遍历其中一个哈希表，如果另一个哈希表中也存在该键，比较两个键值大小，按照小的那个键值循环则将该键push入ans数组； Coding实现双指针解法代码12345678910111213141516171819202122232425262728/** * @param &#123;number[]&#125; nums1 * @param &#123;number[]&#125; nums2 * @return &#123;number[]&#125; */var intersect = function(nums1, nums2) &#123; let nums1Index=0; let nums2Index=0; let ans=[]; nums1.sort((a,b)=&gt;&#123;return a-b;&#125;); nums2.sort((a,b)=&gt;&#123;return a-b;&#125;); while(nums1Index&lt;nums1.length&amp;&amp;nums2Index&lt;nums2.length)&#123; let num1=nums1[nums1Index]; let num2=nums2[nums2Index]; if(num1===num2)&#123; ans.push(num1); nums1Index++; nums2Index++; &#125; else if(num1&lt;num2)&#123; nums1Index++; &#125; else&#123; nums2Index++; &#125; &#125; return ans;&#125;; 哈希表解法代码12345678910111213141516171819202122232425262728293031/** * @param &#123;number[]&#125; nums1 * @param &#123;number[]&#125; nums2 * @return &#123;number[]&#125; */var intersect = function(nums1, nums2) &#123; let map1=new Map(); let map2=new Map(); let ans=[]; function count(nums,map)&#123; nums.forEach(value=&gt;&#123; if(!map.has(value))&#123; map.set(value,1); &#125; else &#123; map.set(value,map.get(value)+1); &#125; &#125;) &#125; count(nums1,map1); count(nums2,map2); map1.forEach((value,key)=&gt;&#123; if(map2.has(key))&#123; let num=value&gt;map2.get(key)?map2.get(key):value; for(let i=0;i&lt;num;i++)&#123; ans.push(key); &#125; &#125; &#125;) return ans;&#125;;]]></content>
      <categories>
        <category>leetcode题解与算法</category>
      </categories>
      <tags>
        <tag>哈希表</tag>
        <tag>双指针</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[二分查找]]></title>
    <url>%2F2019%2F07%2F27%2F%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE%2F</url>
    <content type="text"><![CDATA[二分查找概述 二分查找的高效之处在于，每一步都可以去除当前区间中的一半元素，因此时间复杂度为O(logn) 严格递增序列的二分查找 输入：[1,2,3,7,9,11] , 3返回: 2 输入：[1,2,3,7,9,11] , 8返回：false 1234567891011121314151617function F(n,m)&#123; let left=0; let right=n.length-1; while(left&lt;=right)&#123; let mid=Math.floor((left+right)/2); if(m===n[mid])&#123; return mid; &#125; if(m&lt;n[mid])&#123; right=mid-1; &#125; else&#123; left=mid+1; &#125; &#125; return false;&#125; 在整体递增，局部重复的序列中二分查找第一个符合要求的元素位置 输入：[1,2,3,3,3,7,9,11],3返回: 2 输入：[1,2,3,3,3,7,9,11],8返回：false 123456789101112131415function F(n,m)&#123; let left=0; let right=n.length; while(left&lt;right)&#123; let mid=Math.floor((left+right)/2); //floor()函数，不大于当前数的最大数 if(m&lt;=n[mid])&#123; right=mid; &#125; else&#123; left=mid+1; &#125; &#125; if(n[left]===m) return left; else return false;&#125; 在整体递增，局部重复的序列中二分查找第一个大于给定元素的元素位置 输入：[1,2,3,3,3,7,9,11],3返回：5 输入：[1,2,3,3,3,7,9,11],4返回: ‘给定元素不存在’ 1234567891011121314151617function F(n,m)&#123; let left=0; let right=n.length-1; while(left&lt;right)&#123; let mid=Math.ceil((left+right)/2); //ceil()函数，不小于当前数的最小整数 if(m&gt;=n[mid])&#123; left=mid; &#125; else&#123; right=mid-1; &#125; &#125; if(n[right]===m) return right+1; else &#123; return ('给定元素不存在'); &#125;&#125; 求根号2的近似值 输入：0.00001 //精确度返回：(1.4142074584960938,1.414215087890625) 123456789101112131415function F(x)&#123; let left=1; let right=2; let num=Math.sqrt(2); while(right-left&gt;x)&#123; let mid=(left+right)/2; if(num&lt;mid)&#123; right=mid; &#125; if(num&gt;mid)&#123; left=mid; &#125; &#125; return `($&#123;left&#125;,$&#123;right&#125;)`&#125; 快速幂用于求解高次幂的快速求法比如2^10 基于二分的思想，又被称之为二分幂 快速幂基于以下原理： 如果b是奇数，那么有a^b=a*a^(b-1) 如果b是偶数，那么有a^b=(a^(b/2))*(a^(b/2)) 因此可以利用递归来求解快速幂 输入 2,10返回: 1024 123456789function F(a,n)&#123; if(n===0) return 1; if(n%2===1)&#123; return F(a,n-1)*a; &#125; else &#123; return F(a,n/2)*F(a,n/2); &#125;&#125;]]></content>
      <categories>
        <category>算法笔记</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[leetcode-852 山脉数组的峰顶索引]]></title>
    <url>%2F2019%2F07%2F27%2Fleetcode-852%2F</url>
    <content type="text"><![CDATA[山脉数组的峰顶索引题目描述我们把符合下列属性的数组 A 称作山脉： A.length &gt;= 3 存在 0 &lt; i &lt; A.length - 1 使得A[0] &lt; A[1] &lt; … A[i-1] &lt; A[i] &gt; A[i+1] &gt; … &gt; A[A.length - 1] 给定一个确定为山脉的数组，返回任何满足 A[0] &lt; A[1] &lt; … A[i-1] &lt; A[i] &gt; A[i+1] &gt; … &gt; A[A.length - 1] 的 i 的值。 示例 1： 输入：[0,1,0]输出：1 示例 2： 输入：[0,2,1,0]输出：1 提示： 3&lt;= A.length &lt;= 10000 0&lt;= A[i] &lt;= 10^6 A是如上定义的山脉 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/peak-index-in-a-mountain-array著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 核心思路概述要找某个特定的值，都可以使用二分查找来提高效率 解题步骤 二分法查找山脉的下标 一开始设定left为0，right为A.length-1,mid为Math.floor((left+right)/2) 如果A[mid]&gt;A[mid+1]&amp;&amp;A[mid]&gt;A[mid-1],那么此时mid就是山脉的下标 如果A[mid]&lt;A[mid+1]，那么就说明山脉应该在mid的右边区间，故left=mid+1 如果A[mid]&gt;A[mid+1]，那么就说明山脉应该在mid的右边区间，故right=mid-1 Coding实现1234567891011121314151617181920/** * @param &#123;number[]&#125; A * @return &#123;number&#125; */var peakIndexInMountainArray = function(A) &#123; let left=0; let right=A.length-1; while(left&lt;=right)&#123; let mid=Math.floor((left+right)/2); if(A[mid]&gt;A[mid+1]&amp;&amp;A[mid]&gt;A[mid-1])&#123; return mid; &#125; else if(A[mid]&lt;A[mid+1])&#123; left=mid+1; &#125; else&#123; right=mid-1; &#125; &#125;&#125;; 时间复杂度时间复杂度为O(log2N);]]></content>
      <categories>
        <category>leetcode题解与算法</category>
      </categories>
      <tags>
        <tag>二分查找</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[leetcode-944 删列造序]]></title>
    <url>%2F2019%2F07%2F26%2Fleetcode-944%2F</url>
    <content type="text"><![CDATA[删列造序题目描述给定由 N 个小写字母字符串组成的数组 A，其中每个字符串长度相等。 删除 操作的定义是：选出一组要删掉的列，删去 A 中对应列中的所有字符，形式上，第 n 列为 [A[0][n], A[1][n], …, A[A.length-1][n]]）。 比如，有 A = [“abcdef”, “uvwxyz”]， 要删掉的列为 {0, 2, 3}，删除后 A 为[“bef”, “vyz”]， A 的列分别为[“b”,”v”], [“e”,”y”], [“f”,”z”]。 你需要选出一组要删掉的列 D，对 A 执行删除操作，使 A 中剩余的每一列都是 非降序 排列的，然后请你返回 D.length 的最小可能值。 示例 1： 输入：[“cba”, “daf”, “ghi”]输出：1解释：当选择 D = {1}，删除后 A 的列为：[“c”,”d”,”g”] 和 [“a”,”f”,”i”]，均为非降序排列。若选择 D = {}，那么 A 的列 [“b”,”a”,”h”] 就不是非降序排列了。 示例 2： 输入：[“a”, “b”]输出：0解释：D = {} 示例 3： 输入：[“zyx”, “wvu”, “tsr”]输出：3解释：D = {0, 1, 2} 提示： 1&lt;= A.length &lt;= 100 1&lt;= A[i].length &lt;= 1000 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/delete-columns-to-make-sorted著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 核心思路概述题目要求得到删去列数的最小值来使剩余的每一列都是非降序的，那么对于贪心思想，只要找到某些列存在降序的删除即可，而无需删除那些已经是非降序的列 解题步骤 根据数组第一个字符串元素长度来确认列数 根据列数，遍历每一个字符串中的那一列 如果某一列存在降序则将ans加1 返回ans Coding实现12345678910111213141516/** * @param &#123;string[]&#125; A * @return &#123;number&#125; */var minDeletionSize = function(A) &#123; let ans=0; for(let i=0;i&lt;A[0].length;i++)&#123; for(let k=0;k&lt;A.length-1;k++)&#123; if(A[k+1][i].charCodeAt()-A[k][i].charCodeAt()&lt;0)&#123; ans++; break; &#125; &#125; &#125; return ans; &#125;;]]></content>
      <categories>
        <category>leetcode题解与算法</category>
      </categories>
      <tags>
        <tag>贪心</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[贪心]]></title>
    <url>%2F2019%2F07%2F26%2F%E8%B4%AA%E5%BF%83%2F</url>
    <content type="text"><![CDATA[##简单贪心 贪心法是求解一类最优化问题的方法，它总是考虑在当前状态下局部最优（或较优）的策略，来使全局的结果达到最优（或较优） 简单来说，也就是，在对问题求解时，总是做出在当前看来是最好的选择。 贪心算法的基本思路 将求解的问题分成若干子问题 对于每一个子问题，考虑得到该子问题的局部最优解 把所有子问题的局部最优解合成一个原问题的解 贪心算法的适用前提和问题 局部最优解能够影响全局最优解 贪心算法得到的不一定就是问题的最优解 贪心算法题目设有n个正整数，将它们连接成一排，组成一个最大的多位整数。 例如：n=3时，3个整数13，312，343，连成的最大整数为34331213。又如：n=4时，4个整数7，13，4，246，连成的最大整数为7424613。 输入：nN个数输出：连成的多位数 思路因为要得到最大的正整数，那么高位数据越大则值越大。因此，使用贪心算法，每次选值的时候优先选择最高位最大的，如若相同，则比较次高位，直到选出较优值 因此，通过这个思路，比较高位可以利用字符串UniCode码来比较，比如’7’&gt;’432’ js的sort()函数可以完美解决，利用sort函数对输入值由高到低进行排序，最后转化为数值进行返回 Coding实现123function F(n)&#123; return parseInt(n.sort().reverse().join(''));&#125; 区间贪心]]></content>
      <categories>
        <category>算法笔记</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[排序]]></title>
    <url>%2F2019%2F07%2F25%2F%E6%8E%92%E5%BA%8F%2F</url>
    <content type="text"><![CDATA[选择排序定义选择排列是指，对一个序列A中的元素，令i从0到n-1枚举，进行n趟操作，每趟从待排序部分（i+1,n）中选择最小的元素，令其与待排序部分的第一个元素A[i]进行交换，这样在n趟操作后，所有元素都会是有序的 动图演示 Coding实现1234567891011121314function selectSort(n)&#123; for(let i=0;i&lt;n.length-1;i++)&#123; let min=i; for(let k=i;k&lt;n.length;k++)&#123; if(n[k]&lt;n[min])&#123; min=k; &#125; &#125; let temp=n[min]; n[min]=n[i]; n[i]=temp; &#125; return n;&#125; 插入排序直接插入排序定义直接插入排序是指，对序列A的n个元素A[0]到A[n-1],令n从1到n-1枚举，进行n-1趟操作。每一趟排序时，该待排列元素之前的所有元素已经是有序的，则在该有序队列中寻找一个位置进行插入，使得该序列依旧有序 动图演示 Coding实现1234567891011function insertionSort(n)&#123; for(let i=1;i&lt;n.length;i++)&#123; let num=n[i]; while(num&lt;n[i-1])&#123; n[i]=n[i-1]; i--; &#125; n[i]=num; &#125; return n;&#125; 折半插入排序定义 有一组数据待排序，排序区间为Array[0] ~ Array[n-1]。将数据分为有序数据和无序数据，第一次排序时默认Array[0]为有序数据，Array[1]~Array[n-1]为无序数据。有序数据分区的第一个元素位置为low，最后一个元素的位置为high。 遍历无序区间的所有元素，每次取无序区间的第一个元素Array[i]，因为0 ~ i-1是有序排列的，所以用中点m将其平分为两部分，然后将待排序数据同中间位置为m的数据进行比较，若待排序数据较大，则low ~ m-1分区的数据都比待排序数据小，反之，若待排序数据较小，则m+1 ~ high分区的数据都比 待排序数据大，此时将low或high重新定义为新的合适分区的边界，对新的小分区重复上面操作。直到low和high 的前后顺序改变，此时high+1所处位置为待排序数据的合适位置。 作者：weixin_42245157来源：CSDN原文：https://blog.csdn.net/weixin_42245157/article/details/80458542版权声明：本文为博主原创文章，转载请附上博文链接！ Coding实现123456789101112131415161718192021function BinaryInsertSortup(n)&#123; for(let i=1;i&lt;n.length;i++)&#123; let low=0; let high=i-1; let num=n[i]; while(low&lt;=high)&#123; let mid=Math.floor((low+high)/2); if(num&lt;n[mid])&#123; high=mid-1; &#125; else&#123; low=mid+1; &#125; &#125; for(k=i;k&gt;low;k--)&#123; n[k]=n[k-1]; &#125; n[k]=num; &#125; return n;&#125; 冒泡排序定义冒泡排序旨在每次冒泡一个最大或最小的元素到顶端，因此需遍历n次。（若冒泡较大元素）则每次遍历，比较相邻两个元素大小，若底部元素（数组下标较小）大于其相邻顶部元素，则两元素交换位置，直至最大的元素冒泡到最顶端 动图演示 Coding实现12345678910111213141516function bubbleSort(n)&#123; let flag; do&#123; flag=0; for(let i=0;i&lt;n.length;i++)&#123; let temp; if(n[i]&gt;n[i+1])&#123; temp=n[i]; n[i]=n[i+1]; n[i+1]=temp; flag=1; &#125; &#125; &#125;while(flag===1) return n;&#125; 归并排序定义归并排序是一种基于归并思想的排序方法。 实现思路： 将序列分成Math.ceil(n/2)个组，组内单独排序 将这些组两两归并，这样就会变成Math.ceil(n/4)个组，组内再单独排序 以此类推，直到最后只剩下一个组为止 Coding实现1234567891011121314151617181920212223242526272829303132333435363738394041function mergeSort(arr) &#123; const length = arr.length; if (length === 1) &#123; //递归算法的停止条件，即为判断数组长度是否为1 return arr; &#125; const mid = Math.floor(length / 2); const left = arr.slice(0, mid); const right = arr.slice(mid, length); return merge(mergeSort(left), mergeSort(right)); //要将原始数组分割直至只有一个元素时，才开始归并&#125;function merge(left, right) &#123; const result = []; let il = 0; let ir = 0; //left, right本身肯定都是从小到大排好序的 while( il &lt; left.length &amp;&amp; ir &lt; right.length) &#123; if (left[il] &lt; right[ir]) &#123; result.push(left[il]); il++; &#125; else &#123; result.push(right[ir]); ir++; &#125; &#125; //不可能同时存在left和right都有剩余项的情况, 要么left要么right有剩余项, 把剩余项加进来即可 while (il &lt; left.length) &#123; result.push(left[il]); il++; &#125; while(ir &lt; right.length) &#123; result.push(right[ir]); ir++; &#125; return result;&#125; 快速排序定义快速排序是排序算法中平均时间复杂度为O(logn)的一种算法。 其主要步骤为 调整序列中的元素，使得当前序列的第一个元素在调整后所处的位置的左侧元素都小于它，在右侧的位置都大于它 对该元素的左侧和右侧区间分别递归进行1的调整，直到当前调整区间的长度不大于1 Coding实现123456789101112131415function F(n)&#123; if(n.length&lt;2) return n; let first=n[0]; let small=[]; let large=[]; for(let i=1;i&lt;n.length;i++)&#123; if(n[i]&lt;first)&#123; small.push(n[i]); &#125; else&#123; large.push(n[i]); &#125; &#125; return F(small).concat([first],F(large));&#125;]]></content>
      <categories>
        <category>算法笔记</category>
      </categories>
      <tags>
        <tag>排序</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[leetcode-1002 查找常用字符]]></title>
    <url>%2F2019%2F07%2F24%2Fleetcode-1002%2F</url>
    <content type="text"><![CDATA[查找常用字符题目描述给定仅有小写字母组成的字符串数组 A，返回列表中的每个字符串中都显示的全部字符（包括重复字符）组成的列表。例如，如果一个字符在每个字符串中出现 3 次，但不是 4 次，则需要在最终答案中包含该字符 3 次。 你可以按任意顺序返回答案。 示例 1： 输入：[“bella”,”label”,”roller”]输出：[“e”,”l”,”l”] 示例 2： 输入：[“cool”,”lock”,”cook”]输出：[“c”,”o”] 提示： 1&lt;= A.length &lt;= 100 1&lt;= A[i].length &lt;= 100 A[i][j] 是小写字母 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/find-common-characters著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 核心思路概述统计每个字符串中字符的出现个数，返回出现相同字符的最少个数字符 解题步骤 建立哈希表A，存储第一个字符串个字符的出现次数 遍历后面的字符串，在每个循环中建立新的哈希表，存储该字符串中第一个字符串所有字符的个数；比较新哈希表与步骤1建立的哈希表A，更新A哈希表中的键值为两者较小值 遍历A哈希表，存储value次key到ans数组并返回 Coding实现12345678910111213141516171819202122232425262728293031323334353637383940/** * @param &#123;string[]&#125; A * @return &#123;string[]&#125; */var commonChars = function(A) &#123; let map=new Map(); let ans=[]; for(let i=0;i&lt;A[0].length;i++)&#123; if(!map.has(A[0][i]))&#123; map.set(A[0][i],1); &#125; else &#123; map.set(A[0][i],map.get(A[0][i])+1); &#125; &#125; for(let i=1;i&lt;A.length;i++)&#123; let mapEve=new Map(); map.forEach((value,key)=&gt;&#123; mapEve.set(key,0); &#125;) for(let k=0;k&lt;A[i].length;k++)&#123; if(map.has(A[i][k]))&#123; mapEve.set(A[i][k],mapEve.get(A[i][k])+1); &#125; &#125; map.forEach((value,key)=&gt;&#123; if(value&gt;mapEve.get(key))&#123; map.set(key,mapEve.get(key)); &#125; &#125;) &#125; map.forEach((value,key)=&gt;&#123; if(value&gt;0)&#123; for(let i=0;i&lt;value;i++)&#123; ans.push(key); &#125; &#125; &#125;); return ans;&#125;;]]></content>
      <categories>
        <category>leetcode题解与算法</category>
      </categories>
      <tags>
        <tag>哈希表</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[递归与分治]]></title>
    <url>%2F2019%2F07%2F24%2F%E9%80%92%E5%BD%92%E4%B8%8E%E5%88%86%E6%B2%BB%2F</url>
    <content type="text"><![CDATA[分治分治的全称为“分而治之”。分治法将原问题划分为若干个规模较小而结构与原问题相同或类似的子问题，然后分别解决这些子问题，最后合并子问题的解，即可得到原问题的解 减治、分治 一般把子问题个数为1的情况称为减治（例如对n!的求解） 123456function F(n)&#123; if(n===1) return 1; else &#123; return F(n-1)*n; &#125;&#125; 子问题个数大于1的情况称为分治（例如对Fibonacci数列的求解） 1234function F(n)&#123; if(n===1||n===0) return 1; else return F(n-1)+F(n-2);&#125; 递归 递归适合用来实现分治思想 递归的两个核心概念 递归边界 递归式（递归调用） 对于n!的求解，可以很容易的到F(n)=F(n-1)*n ;这就是递归式而F(1)=1; 这是递归的边界 分治思想的应用全排列n皇后问题]]></content>
      <categories>
        <category>算法笔记</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[leetcode-349 两个数组的交集]]></title>
    <url>%2F2019%2F07%2F23%2Fleetcode-349%2F</url>
    <content type="text"><![CDATA[两个数组的交集题目描述给定两个数组，编写一个函数来计算它们的交集。 示例 1: 输入: nums1 = [1,2,2,1], nums2 = [2,2]输出: [2] 示例 2: 输入: nums1 = [4,9,5], nums2 = [9,4,9,8,4]输出: [9,4] 说明: 输出结果中的每个元素一定是唯一的。我们可以不考虑输出结果的顺序。 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/intersection-of-two-arrays著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 核心思路概述将两个数组都去重后，比较另一个数组是否包含这个数组的某些元素，返回即可 解题步骤 使用set将两个数组去重 比较去重后的两个数组的大小，遍历较小的那个数组，查看另一个数组是否includes这个数组中的某些元素，有则添加到ans数组返回 Coding实现12345678910111213141516171819/** * @param &#123;number[]&#125; nums1 * @param &#123;number[]&#125; nums2 * @return &#123;number[]&#125; */var intersection = function(nums1, nums2) &#123; let ans=[]; nums1=[...new Set(nums1)]; nums2=[...new Set(nums2)]; function inter(nums1,nums2)&#123; nums1.forEach(value=&gt;&#123; if(nums2.includes(value))&#123; ans.push(value); &#125; &#125;) &#125; nums1.length&gt;nums2.length?inter(nums2,nums1):inter(nums1,nums2); return ans;&#125;;]]></content>
      <categories>
        <category>leetcode题解与算法</category>
      </categories>
      <tags>
        <tag>数组</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[leetcode-961 重复 N 次的元素]]></title>
    <url>%2F2019%2F07%2F23%2Fleetcode-961%2F</url>
    <content type="text"><![CDATA[重复 N 次的元素题目描述在大小为 2N 的数组 A 中有 N+1 个不同的元素，其中有一个元素重复了 N 次。 返回重复了 N 次的那个元素。 示例 1： 输入：[1,2,3,3]输出：3 示例 2： 输入：[2,1,2,5,3,2]输出：2 示例 3： 输入：[5,1,5,2,5,3,5,4]输出：5 提示： 4 &lt;= A.length &lt;= 100000 &lt;= A[i] &lt; 10000A.length 为偶数 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/n-repeated-element-in-size-2n-array著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 核心思路概述因为该数组大小为2N，其中由N+1个不同的元素，并且有一个元素重复了N次，那么剩余的N个数都是不同的 所以题目可转化为返回有重复的那个数 解题步骤 建立哈希表 遍历给定数组，若哈希表中没有该键名，则加入哈希表；若有，则直接返回该数组元素 Coding实现123456789101112131415/** * @param &#123;number[]&#125; A * @return &#123;number&#125; */var repeatedNTimes = function(A) &#123; let map=new Map(); for(let i=0;i&lt;A.length;i++)&#123; if(!map.has(A[i]))&#123; map.set(A[i],0); &#125; else&#123; return A[i]; &#125; &#125;&#125;;]]></content>
      <categories>
        <category>leetcode题解与算法</category>
      </categories>
      <tags>
        <tag>哈希表</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[leetcode-500 键盘行]]></title>
    <url>%2F2019%2F07%2F23%2Fleetcode-500%2F</url>
    <content type="text"><![CDATA[键盘行题目描述 给定一个单词列表，只返回可以使用在键盘同一行的字母打印出来的单词。键盘如下图所示。 示例： 输入: [“Hello”, “Alaska”, “Dad”, “Peace”]输出: [“Alaska”, “Dad”] 注意： 你可以重复使用键盘上同一字符。你可以假设输入的字符串将只包含字母。 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/keyboard-row著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 核心思路概述利用哈希表,分别即字母为键名，字母所在行号为键值建立哈希表。遍历给定字符串，若字符串的所有字符的所在哈希表的键值都一样，则说明该字符串的字符都在同一行上 解题步骤 建立哈希表以及键盘字符数组 将每个字符以字符为键名，字符所在行号为键值建立哈希表。 遍历题目给定字符串数组，若每个字符串中的字符在哈希表中的键值都一样，则将该字符串加入到要返回的数组中 遍历字符串方法：先得到字符串的第一个字符的所在行号，接着循环得到后面的字符的行号，若不一样则直接退出该循环 注意 将所有字符都转换为小写形式再去得到字符的键值 Coding实现123456789101112131415161718192021222324252627282930313233/** * @param &#123;string&#125; J * @param &#123;string&#125; S * @return &#123;number&#125; *//** * @param &#123;string[]&#125; words * @return &#123;string[]&#125; */var findWords = function(words) &#123; const str=['qwertyuiop','asdfghjkl','zxcvbnm']; let ans=[]; let map=new Map(); str.forEach((value,index)=&gt;&#123; for(let i=0;i&lt;value.length;i++)&#123; map.set(value[i],index+1); &#125; &#125;); words.forEach(value=&gt;&#123; let flag=0; let first=map.get(value[0].toLowerCase()); for(let i=1;i&lt;value.length;i++)&#123; if(map.get(value[i].toLowerCase())!=first)&#123; flag=1; break; &#125; &#125; if(flag===0)&#123; ans.push(value); &#125; &#125;) return ans;&#125;;]]></content>
      <categories>
        <category>leetcode题解与算法</category>
      </categories>
      <tags>
        <tag>哈希表</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[散列]]></title>
    <url>%2F2019%2F07%2F22%2F%E6%95%A3%E5%88%97%2F</url>
    <content type="text"><![CDATA[散列的定义 简单来说：就是将某个元素通过一个函数转换为整数，使得该整数可以尽量唯一地代表这个元素 常用的散列函数 直接定址法 直接把key值作为哈希表的下标 平方取中法 取key的平方的中间若干位作为哈希表的下标 除留余数法（常用） 指把key除以一个数得到的余数作为hash值的方法 冲突处理 线性探查法 如果该hash值已经被占用，那么就不断检查下一个位置，直到找到没被占用的。如果检查过程中超过了表长，则返回到哈希表的首位继续循环查找，或是发现所有的位置都被占用 该方法容易造成扎堆现象，即表中的若干个连续位置都被使用 平方探查法 按照下列的顺序进行探查： H(key)+1^2,H(key)-1^2, H(key)+2^2,H(key)-2^2, H(key)+3^2,H(key)-3^2, … … 如果，检查过程中H(key)+k^2超过了表长Tsize，那么就把(H(key)+k^2) % Tsize 作为hash值 链地址法 链地址法不计算新的hash值，而是把所有H(key)相同的key连接成一条单链表 字符串hash字符串hash是指将字符串S映射为一个整数，使得该整数尽可能唯一地代表该字符串 假设字符串只由AZ构成，那么可以将AZ映射为0~25；比如，ABC则就可以看作是012。显然，与二进制类似，我们可以把其看作为26进制，再将其转化为10进制，即可得到该字符串唯一地hash映射。 代码 1234567const hashFunc(str,length)&#123; let hash=0; for(let i=0;i&lt;length;i++)&#123; hash=hash*26+str[i].charCodeAt()-'A'.charCodeAt(); &#125; return hash;&#125; 如果外加有小写字母，则就是52进制转换若还有数字，则就是62进制转换 一些散列表算法题散列表相关算法题]]></content>
      <categories>
        <category>算法笔记</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[leetcode-771 宝石与石头]]></title>
    <url>%2F2019%2F07%2F22%2Fleetcode-771%2F</url>
    <content type="text"><![CDATA[宝石与石头题目描述 给定字符串J 代表石头中宝石的类型，和字符串 S代表你拥有的石头。 S 中每个字符代表了一种你拥有的石头的类型，你想知道你拥有的石头中有多少是宝石。 J 中的字母不重复，J 和 S中的所有字符都是字母。字母区分大小写，因此”a”和”A”是不同类型的石头。 示例 1: 输入: J = “aA”, S = “aAAbbbb”输出: 3 示例 2: 输入: J = “z”, S = “ZZ”输出: 0 注意: S 和 J 最多含有50个字母。 J 中的字符不重复。 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/jewels-and-stones著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 核心思路概述利用哈希表，遍历宝石类型字符串，建立以宝石类型为键名，宝石数量为值的哈希表。哈希表中的所有键值之和就是所拥有的宝石的数量。 解题步骤 建立哈希表，声明所拥有的宝石数量为ans=0 遍历J字符串，以字符为键名，0为键值建立哈希表 遍历S字符串，若哈希表中存在该键名，则ans++ 返回ans Coding实现123456789101112131415161718/** * @param &#123;string&#125; J * @param &#123;string&#125; S * @return &#123;number&#125; */var numJewelsInStones = function(J, S) &#123; let map=new Map(); let ans=0; for(let i=0;i&lt;J.length;i++)&#123; map.set(J[i],0); &#125;; for(let i=0;i&lt;S.length;i++)&#123; if(map.has(S[i]))&#123; ans++; &#125; &#125; return ans;&#125;;]]></content>
      <categories>
        <category>leetcode题解与算法</category>
      </categories>
      <tags>
        <tag>哈希表</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[leetcode-219 存在重复元素 II]]></title>
    <url>%2F2019%2F07%2F21%2Fleetcode-219%2F</url>
    <content type="text"><![CDATA[存在重复元素 II题目描述给定一个整数数组和一个整数 k，判断数组中是否存在两个不同的索引 i 和 j，使得 nums [i] = nums [j]，并且 i 和 j 的差的绝对值最大为 k。 示例 1: 输入: nums = [1,2,3,1], k = 3输出: true 示例 2: 输入: nums = [1,0,1,1], k = 1输出: true 示例 3: 输入: nums = [1,2,3,1,2,3], k = 2输出: false 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/contains-duplicate-ii著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 核心思路概述利用哈希表，存储以值为键，下标为键值的哈希表。当某个键值需要更新时，比较当前下标与键值的差值是否小于题目给定值，若是则返回true; 解题步骤 建立哈希表 当以当前数组元素的值为键名的键不存在时，则以值为键，下标为键值添加到哈希表中。若存在，则比较当前下标与键值的差值是否小于题目给定值，若是则返回true; Coding实现1234567891011121314151617181920/** * @param &#123;number[]&#125; nums * @param &#123;number&#125; k * @return &#123;boolean&#125; */var containsNearbyDuplicate = function(nums, k) &#123; let map = new Map(); return nums.some((value, index) =&gt; &#123; if (!map.has(value)) &#123; map.set(value, index); &#125; else &#123; if (index - map.get(value) &lt;= k) &#123; return true; &#125; else &#123; map.set(value, index); &#125; &#125; return false; &#125;);&#125;;]]></content>
      <categories>
        <category>leetcode题解与算法</category>
      </categories>
      <tags>
        <tag>哈希表</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[leetcode-217 存在重复元素]]></title>
    <url>%2F2019%2F07%2F20%2Fleetcode-217%2F</url>
    <content type="text"><![CDATA[存在重复元素题目描述给定一个整数数组，判断是否存在重复元素。 如果任何值在数组中出现至少两次，函数返回 true。如果数组中每个元素都不相同，则返回 false。 示例 1: 输入: [1,2,3,1]输出: true 示例 2: 输入: [1,2,3,4]输出: false 示例 3: 输入: [1,1,1,3,3,4,3,2,4,2]输出: true 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/contains-duplicate著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 核心思路概述将该数组去重之后的元素个数与原数组长度进行比较，不一样则有重复； 解题步骤 建立set集合，用于数组去重 将set集合的size与数组长度进行比较 不相同则有重复,返回true;反之,false Coding实现123456789/** * @param &#123;number[]&#125; nums * @return &#123;boolean&#125; */var containsDuplicate = function(nums) &#123; let set=new Set(nums); if(set.size===nums.length) return false; else return true;&#125;;]]></content>
      <categories>
        <category>leetcode题解与算法</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Java解决算法题一些记录(杂)]]></title>
    <url>%2F2019%2F07%2F20%2FJava%E8%A7%A3%E5%86%B3%E7%AE%97%E6%B3%95%E9%A2%98%2F</url>
    <content type="text"><![CDATA[ArrayListArrayList的一些方法 方法 描述 add() 在list的末尾添加一个元素 add(index: int, o: E) 在指定的index处插入元素 clear() 从list中删除所有元素 contains(o: Object) 如果list含有元素o，返回true get(index: int) 返回指定index处的元素 indexOf(o: Object) 返回list中第一个匹配元素的index isEmpty() 如果list不含元素，返回true lastIndexOf(o: Object) 返回list中最后一个匹配元素的index remove(o: Object) 删除list中的第一个元素o，如果元素被删除，返回true size() 返回list中元素个数 remove(index: int) 删除指定index处的元素，如果元素被删除，返回true set(index: int, o: E) 设置指定index处的元素为o]]></content>
      <categories>
        <category>Java</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[leetcode-206 反转链表]]></title>
    <url>%2F2019%2F07%2F19%2Fleetcode-206%2F</url>
    <content type="text"><![CDATA[反转链表题目描述反转一个单链表。 示例: 输入: 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL输出: 5-&gt;4-&gt;3-&gt;2-&gt;1-&gt;NULL 进阶:你可以迭代或递归地反转链表。你能否用两种方法解决这道题？ 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/reverse-linked-list著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 核心思路概述将链表所有的元素取出并倒序放到数组，按照数组元素创建新链表并返回 解题步骤 遍历链表，并将数组元素unshift入数组 按照数组元素添加节点到新创建的链表上 Coding实现12345678910111213141516171819202122232425/** * Definition for singly-linked list. * function ListNode(val) &#123; * this.val = val; * this.next = null; * &#125; *//** * @param &#123;ListNode&#125; head * @return &#123;ListNode&#125; */var reverseList = function(head) &#123; let newList=new ListNode(0); let newHead=newList; let numArray=[]; while(head)&#123; numArray.unshift(head.val); head=head.next; &#125; numArray.forEach(value=&gt;&#123; newHead.next=new ListNode(value); newHead=newHead.next; &#125;) return newList.next;&#125;;]]></content>
      <categories>
        <category>leetcode题解与算法</category>
      </categories>
      <tags>
        <tag>链表</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[leetcode-205 同构字符串]]></title>
    <url>%2F2019%2F07%2F18%2Fleetcode-205%2F</url>
    <content type="text"><![CDATA[同构字符串题目描述给定两个字符串 s 和 t，判断它们是否是同构的。 如果 s 中的字符可以被替换得到 t ，那么这两个字符串是同构的。 所有出现的字符都必须用另一个字符替换，同时保留字符的顺序。两个字符不能映射到同一个字符上，但字符可以映射自己本身。 示例 1: 输入: s = “egg”, t = “add”输出: true 示例 2: 输入: s = “foo”, t = “bar”输出: false 示例 3: 输入: s = “paper”, t = “title”输出: true 说明:你可以假设 s 和 t 具有相同的长度。 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/isomorphic-strings著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 核心思路概述解法1利用哈希表进行映射，两个字符串相互映射 解法2对比两个字符串对应位置的字符在字符串内第一次出现的位置，若不同则返回false 解题步骤解法1 建立哈希映射函数，若哈希表中没有该键值对，则插入表中；若有，则比较值是否相同，不同则返回fasle 两个字符串依次使用哈希映射函数进行比较 解法2 同时遍历两字符串，若当前字符的第一次出现的位置不相同则返回false Coding实现解法1123456789101112131415161718192021222324252627/** * @param &#123;string&#125; s * @param &#123;string&#125; t * @return &#123;boolean&#125; */function match(map,s,t)&#123; for(let i=0;i&lt;s.length;i++)&#123; if(!map.has(s[i]))&#123; map.set(s[i],t[i]); &#125; else&#123; if(map.get(s[i])!=t[i])&#123; return false; &#125; &#125; &#125; return true;&#125;var isIsomorphic = function(s, t) &#123; s=s.split(''); t=t.split(''); let map=new Map(); if(!match(map,s,t)) return false; map.clear(); return match(map,t,s);&#125;; 解法2123456789101112/** * @param &#123;string&#125; s * @param &#123;string&#125; t * @return &#123;boolean&#125; */var isIsomorphic = function(s, t) &#123; for (let i = 0; i &lt; s.length; i++) &#123; if (s.indexOf(s[i]) !== t.indexOf(t[i])) return false; &#125; return true;&#125;]]></content>
      <categories>
        <category>leetcode题解与算法</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[leetcode-204 计数质数]]></title>
    <url>%2F2019%2F07%2F17%2Fleetcode-204%2F</url>
    <content type="text"><![CDATA[计数质数题目描述统计所有小于非负整数 n 的质数的数量。 示例: 输入: 10输出: 4解释: 小于 10 的质数一共有 4 个, 它们是 2, 3, 5, 7 。 核心思路概述质数的定义 质数又称素数。一个大于1的自然数，除了1和它自身外，不能被其他自然数整除的数叫做质数；否则称为合数。 此题的基本解法即为遍历给定数之前的数，若为质数则计数加一 解题步骤 建立一个函数用来判断当前数是否为质数 对于1中的函数质数判断条件，若在1~开根号n的左开右闭的区间内无法被整除，那么该数即为质数。 遍历给定数之前的数，若为质数则计数加一 Coding实现1234567891011121314151617181920212223/** * @param &#123;number&#125; n * @return &#123;number&#125; */const checkPrimes=function(n)&#123; if(n===2) return true; if(n===1) return false; if(n%2===1)&#123; for(let i=1;i&lt;=Math.sqrt(n);i=i+2)&#123; if(n%i===0&amp;&amp;i!==1) return false; &#125; return true; &#125;&#125;var countPrimes = function(n) &#123; let count=0; for(let i=2;i&lt;n;i++)&#123; if(checkPrimes(i))&#123; count++; &#125; &#125; return count;&#125;;]]></content>
      <categories>
        <category>leetcode题解与算法</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[leetcode-203 移除链表元素]]></title>
    <url>%2F2019%2F07%2F16%2Fleetcode-203%2F</url>
    <content type="text"><![CDATA[移除链表元素题目描述删除链表中等于给定值 val 的所有节点。 示例: 输入: 1-&gt;2-&gt;6-&gt;3-&gt;4-&gt;5-&gt;6, val = 6输出: 1-&gt;2-&gt;3-&gt;4-&gt;5 核心思路概述此题为单链表删除指定元素 解题步骤单独考虑头节点（因为头节点之前没有节点） 考虑头节点即为指定需删除元素，那么应当将头指针指向下一个元素。循环检验，当头节点不是指定需删除元素时则退出循环 若步骤1之后，该链表为空链表则直接返回该空链表 1、2步骤之后，当前链表则为头节点不为指定需删除元素的非空链表。遍历当前链表，设置pre和cur指针方便删除链表节点。 设置虚拟头节点（指向头节点的节点） 创建新节点指向当前头节点 遍历该链表，删除指定元素 返回以创建的新节点的下一个节点为头节点所在的链表 Coding实现单独处理头节点的Coding1234567891011121314151617181920212223242526272829/** * Definition for singly-linked list. * function ListNode(val) &#123; * this.val = val; * this.next = null; * &#125; *//** * @param &#123;ListNode&#125; head * @param &#123;number&#125; val * @return &#123;ListNode&#125; */var removeElements = function(head, val) &#123; while(head&amp;&amp;head.val===val)&#123; head=head.next &#125; if(head===null) return head; let cur=head; let pre=head; while(cur.next)&#123; pre=cur; cur=cur.next; if(cur.val===val)&#123; pre.next=cur.next; cur=pre; &#125; &#125; return head;&#125;; 设置指向头节点的指针节点的Coding12345678910111213141516171819202122232425/** * Definition for singly-linked list. * function ListNode(val) &#123; * this.val = val; * this.next = null; * &#125; *//** * @param &#123;ListNode&#125; head * @param &#123;number&#125; val * @return &#123;ListNode&#125; */var removeElements = function(head, val) &#123; let listNode=new ListNode(val-1); listNode.next=head; let list=listNode; while(list.next)&#123; if(list.next.val===val)&#123; list.next=list.next.next; continue; &#125; list=list.next; &#125; return listNode.next;&#125;;]]></content>
      <categories>
        <category>leetcode题解与算法</category>
      </categories>
      <tags>
        <tag>链表</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[leetcode-202 快乐数]]></title>
    <url>%2F2019%2F07%2F15%2Fleetcode-202%2F</url>
    <content type="text"><![CDATA[快乐数题目描述编写一个算法来判断一个数是不是“快乐数”。 一个“快乐数”定义为：对于一个正整数，每一次将该数替换为它每个位置上的数字的平方和，然后重复这个过程直到这个数变为 1，也可能是无限循环但始终变不到 1。如果可以变为 1，那么这个数就是快乐数。 示例: 输入: 19输出: true解释: 12 + 92 = 8282 + 22 = 6862 + 82 = 10012 + 02 + 02 = 1 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/happy-number著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 核心思路概述 正面解题，寻找快乐数。当重复过程变为1则为快乐数，若当循环过程中得到的数与之前出现过的数相重复，则表示之后会在这两数之间无限循环，此时即可返回false. 快慢指针解法：使用快慢指针来判断该循环是否为无限死循环。 解题步骤正面解题法(遇到重复数字则退出) 若输入为1，则直接返回true 设置set集合用来存储循环过程中得到的数 进入do-while循环，将参数转化为数组，利用reduce函数进行平方和累加，判断该得到的数是否存在于set集合中，若存在则返回false，否则则将该数放入set集合中。同时,若该数为1则返回true退出函数快慢指针法 设置两个指针，一个指针移动较快，一个指针移动较慢，若两指针相遇，则代表该循环中存在死循环，则应退出该函数。Coding实现正面解题的Coding12345678910111213141516var isHappy = function(n) &#123; if(n===1) return true; let arr; let set=new Set([n]); do&#123; arr=n.toString().split(''); n=arr.reduce((pre,value)=&gt;&#123; return pre+Math.pow(parseInt(value),2) &#125;,0); if(set.has(n))&#123; return false; &#125; set.add(n); &#125;while(n!=1) return true;&#125;; 递归法的Coding12]]></content>
      <categories>
        <category>leetcode题解与算法</category>
      </categories>
      <tags>
        <tag>快慢指针</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[var、let与const的比较以及作用域]]></title>
    <url>%2F2019%2F07%2F15%2Fvar%E3%80%81let%E4%B8%8Econst%2F</url>
    <content type="text"><![CDATA[var、let与const的比较以及作用域 var、let与const的比较 \ var let const 变量提升机制 有 无 无 重声明 允许 在同个作用域下禁止,不同作用域下允许 同let 能否更改 允许 允许 不允许 初始化 可以不用 可以不用 必须 const的一些注意点 const不允许修改基本类型值，但是允许修改对象的属性值（没有修改对象的绑定）；123456789101112(function test()&#123; const person = &#123; a:1 &#125; console.log(person.a); // 1 person.a=2; console.log(person.a); // 2 person=&#123; a:3 &#125; console.log(person.a); // 报错： 不允许修改使用const声明的对象的绑定&#125;)() 预编译与词法分析预编译 JS引擎会在正式执行代码之前进行一次”预编译“，预编译简单理解就是在内存中开辟一些空间，存放一些变量和函数。 具体步骤 页面创建全局对象（Global Object）对象（window对象）。 加载第一个脚本文件 脚本加载完毕后，进行语法分析。 开始预编译 查找函数声明，作为GO属性，值赋予函数体（函数声明优先） 查找变量声明（除了函数内部的），作为GO属性，值赋予undefined 若函数声明与变量声明同名，则函数声明会优先于变量声明。具体来说即是1. 函数声明替换变量声明 2. 后面的函数声明替换前面的函数声明 3. 后面的变量声明无效 例如 1234567console.log(a); //[function: a]a(); //hellofunction a()&#123; console.log('hello');&#125;var a=1;console.log(a); //1 词法分析 创建AO活动对象（Active Object 每个执行环境都有一个与之对应的活动对象） 查找形参和变量声明，值赋予undefined 实参值赋给形参 查找函数声明，值赋给函数体 解释执行函数中的代码 提升机制对于用var定义的变量会被提升到当前作用域的顶端并赋值为undefined123console.log(a); //undefinedvar a='hello';console.log(a); //hello 函数声明整体提升1234a(); //hellofunction a()&#123; console.log('hello');&#125; 123456console.log(a); //undefineda(); //报错：a is not a functionvar a=function()&#123; /*遇见var a= 会直接将a当作一个变量提升并赋值为undefined;*/console.log('hello');&#125; 123456console.log(a); /*报错：Cannot access 'a' before initialization*/a(); let a=function()&#123; /*这里为let a= ,不会有变量提升机制*/console.log('hello');&#125; 块级声明与块级作用域块级作用域存在于： 1.函数内部2.块中（{ }之间的区域） 注意： 只有使用let和const声明（const与let都是块级标识符），块语句（{ } 比如for循环语句和if判断语句）才会将快语句中声明的变量限制在该块级作用域；而使用var声明则不会 例如 12345678910111213(function test()&#123; console.log(a); // undefined if(true)&#123; var a=1; &#125;&#125;)()(function test()&#123; console.log(a); //报错：a is not defined if(true)&#123; let a=1; &#125;&#125;)() let声明不会被提升 用let声明变量，会将变量的作用域限制在当前代码块中（即块级作用域）;因此块级作用域外部无法访问 禁止重声明同一作用域中不能使用let来重复定义已经存在的标识符 1234(function test()&#123; var a=1; let a=2; // Identifier 'a' has already been declared&#125;)() 但是在不同作用域下声明同名变量是没有问题的，因为不同作用域之间的变量是没有关系的。内部作用域的变量会遮蔽外部作用域的同名变量 12345678(function test()&#123; let a=1; &#123; let a=2; console.log(a); // 2 &#125; console.log(a); // 1&#125;)() 临时死区 javascript引擎在预编译阶段时，要么将变量提升至作用域顶部（遇到var声明）,要么就将其放到TDZ（临时死区中，遇到let或const声明）。访问临时死区的变量会触发运行错误，即使是相对安全的typeof操作也会报错 我对于临时死区的理解是，相当于临时死区内部的代码在预编译阶段时被放进了一个黑匣子内（暂时从代码块中移除）。这些声明在预编译阶段不会进行任何操作；只有当运行代码块到这些声明时，这些代码才会被执行声明 例如 12console.log(typeof a); //报错: Cannot access 'a' before initializationlet a=1; 为什么typeof是相对安全的？ 如果某个变量未声明就被调用，那么一般其他操作就会报错，然而typeof只会返回undefined而不报错 12console.log(typeof a); // undefinedconsole.log(a); // 报错 a未定义 for循环中的块级作用域使用var声明变量的一些偏离预想的问题来看一段代码 12345678let funcs=[];for(var i=0;i&lt;10;i++) &#123; funcs.push(function ()&#123; console.log(i); &#125;)&#125;console.log('i',i); // 10funcs.forEach(value=&gt;value()); // 输出10个10 为什么不是我们想要的结果0~9，而是输出10个10 因为，使用var声明的变量在预编译阶段会被提升到当前作用域顶部；因此，当函数执行前i已经变为了10 那么，我们该怎么解决这个问题呢？ 使用IIFE（立即执行函数）来解决使用立即执行函数，说的更加明确一点，应该是利用闭包的特性，将当时的变量保存在闭包的作用域链上 12345678910let funcs=[];for(var i=0;i&lt;10;i++) &#123; funcs.push((function (value)&#123; return function ()&#123; console.log(value); &#125; &#125;)(i))&#125;console.log('i',i); // 10funcs.forEach(value=&gt;value()); // 0~9 使用let声明来解决12345678let funcs=[];for(let i=0;i&lt;10;i++) &#123; funcs.push(function ()&#123; console.log(i); &#125;)&#125;funcs.forEach(value=&gt;value()); // 0~9console.log('i',i); // 报错 i未定义 每次迭代循环都会创建一个块级作用域，而使用let声明则可以将变量绑定在当前作用域，因此每个作用域中的同名变量不会相互影响，并且会是0~9 循环中的const声明在不改变const定义的值得情况下，const声明在循环中的作用和表现与let一样 12345678910111213let obj=&#123; a:1, b:2&#125;let funcs=[];for(const key in obj) &#123; funcs.push(function ()&#123; console.log(key); &#125;)&#125;funcs.forEach(value=&gt;value()); // 'a' 'b' 但是，如果在某个作用内企图改变const定义的变量就会报错 1234567891011121314let obj=&#123; a:1, b:2&#125;let funcs=[];for(const key in obj) &#123; funcs.push(function ()&#123; key='c'; // 试图修改const定义的变量key console.log(key); &#125;)&#125;funcs.forEach(value=&gt;value()); // 报错]]></content>
      <categories>
        <category>javaScript基础</category>
      </categories>
      <tags>
        <tag>基础语法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[leetcode-172 阶乘后的零]]></title>
    <url>%2F2019%2F07%2F14%2Fleetcode-172%2F</url>
    <content type="text"><![CDATA[阶乘后的零题目描述给定一个整数 n，返回 n! 结果尾数中零的数量。 示例 1: 输入: 3输出: 0解释: 3! = 6, 尾数中没有零。 示例 2: 输入: 5输出: 1解释: 5! = 120, 尾数中有 1 个零. 说明: 你算法的时间复杂度应为 O(log n) 。 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/factorial-trailing-zeroes著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 核心思路概述一开始看到题目时的第一反应就是求解出n!的值，再遍历得到0的个数。然后提交之后，报错提示：超出最大堆栈大小（RangeError: Maximum call stack size exceeded）。因此，看题解之后得到提示，开始寻找规律。 若要某个数中有某位为0,那么他必定是10的倍数。而10=2 * 5；因此，该阶乘中有几对2 * 5，则该数就有几个0；又因为该阶乘为递减，则5的个数必定小于2的个数，则题目即可转化为求出5的个数即可。 解题步骤 归纳得： n 式子 5的个数 5的总个数 5 1*5 1 1 10 2*5 1 2 15 3*5 1 3 20 4*5 1 4 25 5*5 2 6 因此，可以通过 1234while (n &gt;= 5) &#123; n = Math.floor(n / 5); total += n;&#125; 得到5的个数 Coding实现一开始使用递归报错的coding1234567891011121314151617var trailingZeroes = function(n) &#123; let sum=(function circle(n)&#123; if(n!=1)&#123; return circle(n-1)*n; &#125; return 1; &#125;)(n) console.log(sum); sum=sum.toString().split(''); let count=0; sum.forEach(value=&gt;&#123; if(value==0)&#123; count++; &#125; &#125;); return count;&#125;; 优化过的coding12345678const trailingZeroes = n =&gt; &#123; let total = 0; while (n &gt;= 5) &#123; n = Math.floor(n / 5); total += n; &#125; return total;&#125;;]]></content>
      <categories>
        <category>leetcode题解与算法</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[leetcode-171 Excel表列序号]]></title>
    <url>%2F2019%2F07%2F13%2Fleetcode-171%2F</url>
    <content type="text"><![CDATA[Excel表列序号题目描述给定一个Excel表格中的列名称，返回其相应的列序号。 例如， A -&gt; 1 B -&gt; 2 C -&gt; 3 ... Z -&gt; 26 AA -&gt; 27 AB -&gt; 28 ...示例 1: 输入: “A” 输出: 1 示例 2: 输入: “AB” 输出: 28 示例 3: 输入: “ZY”输出: 701 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/excel-sheet-column-number著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 核心思路概述通过观察，不难发现其实这类似于二进制之类的表示形式。只不过对于该题可以把其称之为26进制。再按照二进制转化为十进制方法将其转化为对应的表示数 A的Unicode编码为65，在该题目中对应的是1.因此可以通过letter.charCodeAt()函数得到的Unicode编码值减去64即可得到对应的单个字母对应值。 解题步骤 将字符串转化为数组从而可以进行遍历 将转化得到的数组反转(reverse()) 【类似于二进制转化为十进制的方法，因此，反转后的数组的下标index就是他们在累加时的26幂的次方】 利用reduce()函数进行累加 Coding实现我一开始的coding12345678910var titleToNumber = function(s) &#123; const sArray=s.split(''); let length=sArray.length-1; let sum=0; sArray.forEach(value=&gt;&#123; sum+=(value.charCodeAt()%'A'.charCodeAt()+1)*Math.pow(26,length); length--; &#125;); return sum;&#125;; 优化过的coding123456var titleToNumber = function(s) &#123; const sArray=s.split('').reverse(); return (sArray.reduce((pre,cur,index)=&gt;&#123; return pre+(cur.charCodeAt()-64)*Math.pow(26,index); &#125;,0))&#125;;]]></content>
      <categories>
        <category>leetcode题解与算法</category>
      </categories>
      <tags>
        <tag>数组</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Vue项目代码与命名规范]]></title>
    <url>%2F2019%2F07%2F11%2FVue%E9%A1%B9%E7%9B%AE%E4%BB%A3%E7%A0%81%E4%B8%8E%E5%91%BD%E5%90%8D%E8%A7%84%E8%8C%83%2F</url>
    <content type="text"><![CDATA[Vue项目代码与命名规范 项目结构文件命名 单文件组件命名规范 组件名为多个单词 组件名应该始终是多个单词的，根组件 App 以及 &lt; transition &gt;、&lt; component &gt; 之类的 Vue 内置组件除外。 这样做可以避免跟现有的以及未来的 HTML 元素相冲突，因为所有的 HTML 元素名称都是单个单词的。 MyComponent.vue 语义化及单词顺序 SearchButtonRun.vue 文件名以单词大写开头 MyComponent.vue 组件名应该倾向于完整单词而不是缩写 UserProfileOptions.vue 文件夹命名规范 属于components文件夹下的子文件夹，使用大写字母开头的PascalBase风格 所有组件放在components文件夹下，对于各个页面应当新建立业务页面组件文件夹。 一些通用组件可以建立common文件夹放在components文件夹下 应当建立api文件夹，统一定义管理接口请求 建立router文件夹，进行路由管理 建立store文件夹，进行vuex状态管理]]></content>
      <categories>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>命名规范</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Vue项目的快速搭建]]></title>
    <url>%2F2019%2F07%2F11%2FVue%E9%A1%B9%E7%9B%AE%E7%9A%84%E5%BF%AB%E9%80%9F%E6%90%AD%E5%BB%BA%2F</url>
    <content type="text"><![CDATA[Vue项目的快速搭建 vue-cli创建项目12vue create &lt;项目名&gt;//选择手动设置特性（Manually select features） 安装必要依赖包括但不限于vue-router,vuex,vue-axios,axios1cnpm install vue-router --save 建立基本路由管理在router.js中配置路由 1234567891011121314151617181920212223242526import Vue from 'vue'import VueRouter from 'vue-router'import RouterView1 from '@/component/RouterView1'//@默认表示src文件夹Vue.use(VueRouter) /*安装 Vue.js 插件。如果插件是一个对象，必须提供 install 方法。如果插件是一个函数，它会被作为 install 方法。install 方法调用时，会将 Vue 作为参数传入。*/export default new VueRouter(&#123; routes:[ &#123; path:'/RouterView1', name:'view1', component:RouterView1 &#125;, &#123; path:'/RouterView2', name:'view2', component:()=&gt;&#123; import('@/component/RouterView2') &#125; /*import() es6函数，动态异步加载模块，返回一个promise*/ &#125; ]&#125;) 在main.js中注册12345new Vue(&#123; router, store, render: h =&gt; h(App)&#125;).$mount("#app"); 使用axios（或vue-axios）引入 第一种方式（main.js直接引入) 1234import axios from 'axios'import VueAxios from 'vue-axios'Vue.use(axios,vue-axios) 第二种方式（在api文件夹中引入） 建立api.js文件用来编写接口函数 建立index.js导出api.js的所有函数 使用 1234567891011Vue.axios.get(api).then((response) =&gt; &#123;console.log(response.data)&#125;)this.axios.get(api).then((response) =&gt; &#123;console.log(response.data)&#125;)this.$http.get(api).then((response) =&gt; &#123;console.log(response.data)&#125;)]]></content>
      <categories>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>Vue Cli</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[leetcode-169 求众数]]></title>
    <url>%2F2019%2F07%2F09%2Fleetcode-169%2F</url>
    <content type="text"><![CDATA[求众数核心方法：哈希表题目描述 给定一个大小为 n 的数组，找到其中的众数。众数是指在数组中出现次数大于 ⌊ n/2 ⌋ 的元素。 你可以假设数组是非空的，并且给定的数组总是存在众数。 示例 1: 输入: [3,2,3]输出: 3 示例 2: 输入: [2,2,1,1,1,2,2]输出: 2 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/majority-element著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 核心思路 利用哈希表这一数据结构来存储每个数的出现次数。元素作为键名，他们所出现的次数作为键值，进行存储。 遍历给定数组，若当前数组元素未在哈希表map中（map.has(key)===false），则以该元素为键名添加该元素，并置键值为1（map.set(value,1)）；若已存在，则更新该键值（键值加1:map.set(value,map.get(value)+1)） 遍历哈希表map，找到键值最大的那个键名并返回 coding实现1234567891011121314151617181920var majorityElement = function(nums) &#123; let maxCount=0; let num=0; let numsMap=new Map() nums.forEach(value=&gt;&#123; if(!numsMap.has(value))&#123; numsMap.set(value,1); &#125; else&#123; numsMap.set(value,numsMap.get(value)+1); &#125; &#125;) numsMap.forEach((value,key)=&gt;&#123; if(value&gt;maxCount)&#123; maxCount=value; num=key; &#125; &#125;) return num;&#125;;]]></content>
      <categories>
        <category>leetcode题解与算法</category>
      </categories>
      <tags>
        <tag>哈希表</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[leetcode-167 两数之和|| - 输入有序数组]]></title>
    <url>%2F2019%2F07%2F08%2Fleetcode-167%2F</url>
    <content type="text"><![CDATA[两数之和|| - 输入有序数组核心方法：双指针题目描述给定一个已按照升序排列 的有序数组，找到两个数使得它们相加之和等于目标数。 函数应该返回这两个下标值 index1 和 index2，其中 index1 必须小于 index2。 说明: 返回的下标值（index1 和 index2）不是从零开始的。 你可以假设每个输入只对应唯一的答案，而且你不可以重复使用相同的元素。 示例: 输入: numbers = [2, 7, 11, 15], target = 9输出: [1,2]解释: 2 与 7 之和等于目标数 9 。因此 index1 = 1, index2 = 2 。 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/two-sum-ii-input-array-is-sorted著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 核心思路题目给定的是有序数组，所以使用双指针方法较为方便。设定min指向第一个数组元素（也就是当前最小数），max指向最后一个数组元素。令sum=numbers[min]+numbers[max] 循环比较sum与target是否相等，若想等则输出。小于target则代表min指向的元素值比输出值要小，则min++;反之，则max–; coding实现1234567891011121314var twoSum = function(numbers, target) &#123; let min=0; let max=numbers.length-1; let sum; while((sum=numbers[min]+numbers[max])!==target)&#123; if(sum&lt;target)&#123; min++; &#125; else&#123; max--; &#125; &#125; return [min+1,max+1];&#125;]]></content>
      <categories>
        <category>leetcode题解与算法</category>
      </categories>
      <tags>
        <tag>双指针</tag>
      </tags>
  </entry>
</search>
