<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[变量、作用域和内存问题]]></title>
    <url>%2F2019%2F08%2F04%2F%E5%8F%98%E9%87%8F%E3%80%81%E4%BD%9C%E7%94%A8%E5%9F%9F%E5%92%8C%E5%86%85%E5%AD%98%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[基本类型值和引用类型值的存储与复制变量类型与内存的关系栈内存基本数据类型保存在栈内存中，因为基本数据类型占用空间小、大小固定，通过按值来访问，属于被频繁使用的数据 堆内存引用数据类型存储在堆内存中，因为引用数据类型占据空间大、大小不固定。 如果存储在栈中，将会影响程序运行的性能； 引用数据类型在栈中存储了指针，该指针指向堆中该实体的起始地址。 当解释器寻找引用值时，会首先检索其在栈中的地址，取得地址后从堆中获得实体 变量复制基本类型值的变量复制如果从一个变量向另一个变量复制基本类型的值，那么就会在变量对象（每个执行环境都有一个与之相关联的变量对象，当前环境中的所有变量和函数都会保存在这个对象中）上创建一个新的值，然后把该值复制到为新变量分配的位置上。 基本类型变量复制完毕后，两个变量是相互独立的。因为两个变量占据的是不同的栈内存空间。 12345const a=20;let b=a;console.log(a,b); // 20,20b=30;console.log(a,b); // 20,30 引用数据类型值的变量复制当从一个变量向另一个变量复制引用类型的值时，同样也会将存储在变量对象中的值复制一份放到位新变量分配的空间中。不同的是，这个值的副本实际上是一个指针，而这个指针指向存储在堆中的一个对象。 两个变量实际上引用的是同一个对象，因此改变其中一个变量，就会影响另一个变量。 123let m=&#123;a:10,b:20&#125;;let n=m;console.log(n); //&#123;a:10,b:20&#125; 函数的参数传递相当于变量复制es中所有函数的参数传递都是按值传递的。 基本类型值的参数传递就相当于基本类型值的变量复制，即创建了一个新的局部变量，值为传过来的参数值。 1234567let a=1;function test(n)&#123; console.log(n); //1 n++;&#125;test(a);console.log(a); // 1 引用类型值的参数传递也相当于引用类型值的变量传递，即创建了一个新的局部变量，保存的是传过来的参数的指针地址，两个变量在栈内存中有着不同的内存空间，但是指向堆内存中的同一个对象。 函数内部变量有变化时（指的是不改变该变量的指针指向地址）也会影响函数外部对象 而当该变量的指针指向地址改变后，两个变量就不在指向了同一个变量，因此之后函数内部变量的变化不会体现在函数外部 123456let a=&#123;item:1&#125;;function test(n)&#123; console.log(a===n); //true n=&#123;&#125;; console.log(a===n);&#125; 执行环境及作用域执行环境(执行上下文)执行环境可能有三种情况 全局执行环境(浏览器中的window对象和node环境中的global对象) —— 代码第一次执行的默认环境 函数执行环境 —— 执行流进入函数体 当执行流进入一个函数时，函数的执行环境会被推入一个环境中。当该函数执行完毕后，栈将其环境弹出，把控制权返回给之前的执行环境 Eval code（Eval code）——代码在eval函数内部执行 每个执行环境中都有一个与之关联的变量对象，用来存储在该环境中定义的变量和函数(但是我们无法访问到这个变量对象，是解析器在后台处理数据时会使用到) 作用域对于作用域，我的理解是它在某种程度上相当于执行环境，每个作用域都有当前作用域的变量和对象。但是作用域之间的变量和函数时相互隔离的，也就说不同作用域下的同名变量不会产生冲突 作用域链当代码在一个环境中执行时，会创建变量对象的一个作用链。 作用域链的用途：是用来保证对执行环境有权访问的所有变量和函数的有序访问。 作用域的前端，始终都是当前的执行环境的变量对象。如果这个环境是函数，那么将其环境对象作为变量对象。作用链中的下一个对象是包含当前执行环境的执行环境的变量对象。这样，一直延续到全局执行环境。全局执行环境的变量对象始终都是作用域链的最后一个对象 12345678910function a()&#123; let m=1; function b()&#123; let m=2; console.log(m); // 2 &#125; b(); console.log(m); // 1&#125;a(); 延长作用域链有两种方式可以延长作用域链 try-catch语句的catch块 with语句 这两个语句都会在当前作用域链的前端添加一个变量对象。 对with语句来说，会将指定的对象添加到作用域链中。 对catch语句来说，会创建一个新的变量对象，其中包含的是被抛出的错误对象的声明 垃圾收集JavaScript 具有自动垃圾收集机制（GC：Garbage Collecation），也就是说，执行环境会负责管理代码执行过程中使用的内存。 标记清除JavaScript中最常用的垃圾收集方式就是标记清除，当变量进入环境后，就将这个变量标记为“进入环境”；而当变量离开环境时，就将其标记为“离开环境”。从而垃圾回收器完成垃圾回收工作 管理内存优化内存占用的最佳方式，就是为执行中的代码只保存必要的数据。一旦数据不再有用，最好将其值设置为null来释放其引用————这个做法叫做解除引用。 局部变量在离开执行环境是会自动被解除引用。 因此我们通常来解除全局执行环境中的引用]]></content>
      <categories>
        <category>javaScript基础</category>
      </categories>
      <tags>
        <tag>基础语法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[leetcode-237 删除链表中的节点]]></title>
    <url>%2F2019%2F08%2F03%2Fleetcode-237%2F</url>
    <content type="text"><![CDATA[删除链表中的节点题目描述请编写一个函数，使其可以删除某个链表中给定的（非末尾）节点，你将只被给定要求被删除的节点。 现有一个链表 – head = [4,5,1,9]，它可以表示为: 示例 1: 输入: head = [4,5,1,9], node = 5输出: [4,1,9]解释: 给定你链表中值为 5 的第二个节点，那么在调用了你的函数之后，该链表应变为 4 -&gt; 1 -&gt; 9. 示例 2: 输入: head = [4,5,1,9], node = 1输出: [4,5,9]解释: 给定你链表中值为 1 的第三个节点，那么在调用了你的函数之后，该链表应变为 4 -&gt; 5 -&gt; 9. 说明: 链表至少包含两个节点。 链表中所有节点的值都是唯一的。 给定的节点为非末尾节点并且一定是链表中的一个有效节点。 不要从你的函数中返回任何结果。 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/delete-node-in-a-linked-list著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 核心思路概述一开始看到这个题目也是傻了一下，为什么只是传入一个要删除的节点，而不传入整个链表。后来一想，题目给定的初始链表中，每个节点的next存在的指向关系是一定的。那么我们就可以不需要考虑要删除节点之前的节点，只需要将要删除的节点的val值和next指向改变就可以了 解题步骤 改变要删除节点的val值为其下一个节点的val值 改变要删除节点的next指向为其下一个节点的下一个节点 Coding实现123456789101112131415/** * Definition for singly-linked list. * function ListNode(val) &#123; * this.val = val; * this.next = null; * &#125; *//** * @param &#123;ListNode&#125; node * @return &#123;void&#125; Do not return anything, modify node in-place instead. */var deleteNode = function(node) &#123; node.val=node.next.val; node.next=node.next.next;&#125;;]]></content>
      <categories>
        <category>leetcode题解与算法</category>
      </categories>
      <tags>
        <tag>链表</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[arguments与模拟函数重载]]></title>
    <url>%2F2019%2F08%2F03%2Farguments%E4%B8%8E%E6%A8%A1%E6%8B%9F%E5%87%BD%E6%95%B0%E9%87%8D%E8%BD%BD%2F</url>
    <content type="text"><![CDATA[argumentsarguments对象是所有（非箭头）函数中都可用的局部变量。 通过该对象可以访问参数数组。因为此对象包含传递给函数的每个参数，第一个参数在索引0处。 12345function a()&#123; console.log(arguments); //Arguments &#123; 0: 1, 1: 2, 2: 3, … &#125; console.log(arguments[0]); //1&#125;a(1,2,3); 由此可以看到，arguments对象并不是Array的实例，它是类数组对象。因此，可以通过方括号语法访问它的每一个元素 arguments对象内的属性值永远与对应命名参数的值保持同步 123456function a(num)&#123; console.log(arguments[0]); //1 num=11; console.log(arguments[0]); //11&#125;a(1,2,3); 模拟函数重载重载的概念在Java语言中，函数或者方法有相同的名称，但是参数的类型或数量不同，这样的同名不同参数的函数或者方法之间，互相称之为重载函数。 为什么js没有重载然而，js中并没有重载的概念，因为： 1234567function a(num)&#123; console.log(1);&#125;function a(num1,num2)&#123; console.log(2);&#125;a(); // 2 如果定义了多个同名函数，那么该名字只属于后定义的函数，所以js中不能像Java一样有传统意义上的重载 js模拟函数重载其实，通过arguments,我们就可以通过检查传入函数中的参数类型和数量来做出不同的反应，从而模拟方法的重载 12345678910function a()&#123; if(arguments.length===0)&#123; console.log(0); &#125; else if(arguments.length===1)&#123; console.log(1); &#125;&#125;a(); // 0a(1); // 1]]></content>
      <categories>
        <category>javaScript基础</category>
      </categories>
      <tags>
        <tag>基础语法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[循环 (for...of与for...in)]]></title>
    <url>%2F2019%2F08%2F03%2F%E5%BE%AA%E7%8E%AF%2F</url>
    <content type="text"><![CDATA[循环语句类型 for 语句 do…while 语句 while 语句 labeled 语句 break 语句 continue 语句 for…in 语句 for…of 语句 for…infor…in 语句循环一个指定的变量来循环一个对象所有可枚举的属性。JavaScript 会为每一个不同的属性执行指定的语句。 123456789const items=&#123; item1:1, item2:2, item3:3&#125;for(let a in items)&#123; console.log(a); // item1,item2,item3 console.log(items[a]); //1,2,3&#125; for…offor…of语句在可迭代的对象(在es6中，所有的集合对象(数组、Set集合及Map集合)和字符串都是可迭代对象)上创建了一个循环 ，对值的每一个独特的属性调用一个将被执行的自定义的和语句挂钩的迭代。 for…of循环每执行一次都会调用可迭代对象的next()方法，并将迭代器返回的结果对象的value属性存储在一个变量中，循环将持续执行这一过程直到返回对象的done属性的值为true 与 for…in 循环遍历的结果是数组元素的下标不同的是， for…of 遍历的结果是元素的值： 1234567891011121314151617181920let arr=[4,5,6];let str='string';let set=new Set([1,'a',3]);let map=new Map([['a',1],['b',2]]);//遍历数组for(let a of arr)&#123; console.log(a); //4,5,6&#125;//遍历字符串for(let s of str)&#123; console.log(s); //s,t,r,i,n,g&#125;//遍历set集合for(let k of set)&#123; console.log(k); //1,'a',3&#125;//遍历map集合for(let m of map)&#123; console.log(m); //[ 'a', 1 ],[ 'b', 2 ]&#125; 总结 倘若是遍历普通对象(非迭代对象)，那么使用for…in最佳，遍历得到属性名 倘若是遍历可迭代对象，那么根据需求来，如果不需要一些下标信息（例如set集合，字符串）那么使用for…of最佳 如果是数组和map，那么使用forEach会更加方便]]></content>
      <categories>
        <category>javaScript基础</category>
      </categories>
      <tags>
        <tag>基础语法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[布尔操作符(1&&2和1||2)]]></title>
    <url>%2F2019%2F08%2F03%2F%E5%B8%83%E5%B0%94%E6%93%8D%E4%BD%9C%E7%AC%A6%2F</url>
    <content type="text"><![CDATA[mdn总结 运算符 语法 说明 逻辑与，AND（&amp;&amp;） expr1 &amp;&amp; expr2 若 expr1 可转换为 true，则返回 expr2；否则，返回 expr1。 逻辑或，OR（||） expr1 || expr2 若 expr1 可转换为 true，则返回 expr1；否则，返回 expr2。 逻辑非，NOT（!） !expr 若 expr 可转换为 true，则返回 false；否则，返回 true。 逻辑非 – !逻辑非操作符首先会将它的操作数转换为一个布尔值，然后再对其求反 123456console.log(!123); //falseconsole.log(!''); //trueconsole.log(!undefined); //trueconsole.log(!null); //trueconsole.log(!new String('1')); //falseconsole.log(!false); //true 逻辑与 – &amp;&amp;注意：逻辑与(&amp;&amp;)操作可以应用于任何类型的操纵数，而不仅仅是布尔值。 在有一个操作数不是布尔值的情况下，逻辑与操作就不一定返回布尔值；因此若要显示返回布尔值，则可以使用Boolean转型函数显示返回 逻辑与操作属于短路操作，即如果第一个操作数能够决定结果，那么就不会再对第二个操作数求值。 1234console.log(1&amp;&amp;2); //2console.log(0&amp;&amp;1); //0console.log(123&amp;&amp;'qwe'); //'qwe'console.log(&#123;&#125;&amp;&amp;null); //null 因为&#123;&#125;并不等于null，&#123;&#125;是一个不完全为空的对象，所以&#123;&#125;转换为逻辑值会是true 逻辑或 – ||与逻辑与操作类似，逻辑或操作也是短路操作。也就是说，如果第一个操作数的求值结果为true,就不会对第二个操作数求值了 1234console.log(1||2); //1console.log(0||1); //1console.log(123||'qwe'); //123console.log(&#123;&#125;||null); //&#123;&#125;]]></content>
      <categories>
        <category>javaScript基础</category>
      </categories>
      <tags>
        <tag>基础语法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[leetcode-283 移动零]]></title>
    <url>%2F2019%2F08%2F02%2Fleetcode-283%2F</url>
    <content type="text"><![CDATA[移动零题目描述给定一个数组 nums，编写一个函数将所有 0 移动到数组的末尾，同时保持非零元素的相对顺序。 示例: 输入: [0,1,0,3,12]输出: [1,3,12,0,0] 说明: 必须在原数组上操作，不能拷贝额外的数组。 尽量减少操作次数。 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/move-zeroes著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 核心思路概述利用双指针，一个left指针用来寻找为0的元素，当找到后，该元素后面的所有元素前移，并将第二个指向数组末尾的指针right的元素值赋为0；如此循环直到left&gt;right 解题步骤 设置left指针指向数组第一个元素，设置right指针指向数组的最后一个元素 移动Left寻找数组中为0元素，当找到后，该元素后面的所有元素前移，并将第二个指向数组末尾的指针right的元素值赋为0；如此循环直到left&gt;right Coding实现123456789101112131415161718192021/** * @param &#123;number[]&#125; nums * @return &#123;void&#125; Do not return anything, modify nums in-place instead. */var moveZeroes = function(nums) &#123; let left=0; let right=nums.length-1; while(left&lt;right)&#123; if(nums[left]===0)&#123; for(let i=left;i&lt;right;i++)&#123; nums[i]=nums[i+1]; &#125; nums[right]=0; right--; &#125; else &#123; left++; &#125; &#125; return nums;&#125;;]]></content>
      <categories>
        <category>leetcode题解与算法</category>
      </categories>
      <tags>
        <tag>双指针</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据类型]]></title>
    <url>%2F2019%2F08%2F01%2F%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%2F</url>
    <content type="text"><![CDATA[数据类型简单数据类型 Null (null值本质上是一个空对象指针) Undefined String Number Boolean Symbol 复杂数据类型 Object(包括Array、Function、Date、RegExp、Error、Arguments等更为具体的引用类型) 数据类型的检测判断typeof typeof 常用于判断基本数据类型 一些注意点 typeof返回的是一个字符串,因此 typeof typeof 1 //(任意数据类型)都会返回string null是一个空对象指针，因此typeof null会返回object 对于函数function的判断，tpeof function会返回function而不是对象object 从技术角度讲，函数在es中是对象，而不是一种数据类型。然而，函数也确实有一些特殊的属性，因此通过typeof操作符来区分函数和其他对象是有必要的 对于除function外的复杂数据类型，例如数组，set,map都会返回对象object 1234567891011121314151617181920212223typeof 123 // "number"typeof "abc" // "string" typeof (new String()) //objecttypeof true // "boolean" typeof &#123;a: 1&#125; // "object" typeof null //objecttypeof function foo() &#123;&#125; // "function" typeof undefined // "undefined" typeof Symbol('foo') // "symbol"typeof (new Set()) //"object"typeof (new Map()) //"object"typeof typeof 1 //"string" typeof的不足使用 typeof 方法来检测数据类型，基本类型大部分都能被准确检测并返回正确的字符串（除了 Null 类型，其返回 object 字符串），而引用类型大部分都不能够被准确检测（除了 Function 类型能够准确返回 function 字符串外，其它的都返回了 object 字符串）。 instanceofinstanceof用于判断引用类型 instanceof 运算符用于测试构造函数的prototype属性是否出现在对象的原型链中的任何位置 12let str=new String();console.log(str instanceof String); //true 123456function Person()&#123;&#125;;function Student()&#123;&#125;;let person=new Person();Student.prototype=person;let student=new Student();console.log(student instanceof Person) //true 语法 object instanceof constructor 因此当使用instanceof判断基本数据类型时就会返回false,与此同时,instanceof 右端也必须是某个构造函数 12'a' instanceof String //false123 instanceof Number //false null instanceof object那么基本数据类型中的null呢，既然typeof null===object;那么null instanceof object呢？很不幸,返回的会是false 简单来说，null并不是以Object为原型创建出来的 1null instanceof object //false 函数模拟instanceof知道instaceof的原理是判断构造函数的prototype属性是否出现在对象的原型链中的任何位置时，那么就不难模拟一个函数来实现instanceof 12345678910function instance(a,b)&#123; let bPro=b.prototype; //取b的显示原型 let aPro=a.__proto__; //取a的隐式原型 //或者使用Object.getPrototypeOf(a)取得a的隐式原型 while(true)&#123; if(aPro===bPro) return true; if(aPro===Object.prototype) return false; aPro=aPro.__proto__; &#125;&#125; Object.prototype.toString()一个完善的类型检测方案 每个对象都有一个toString()方法，当该对象被表示为一个文本值时，或者一个对象以预期的字符串方式引用时自动调用。默认情况下，toString()方法被每个Object对象继承。如果此方法在自定义对象中未被覆盖，toString() 返回 “[object type]”，其中type是对象的类型 可以通过toString() 来获取每个对象的类型。为了每个对象都能通过 Object.prototype.toString() 来检测，需要以 Function.prototype.call() 或者 Function.prototype.apply() 的形式来调用，传递要检查的对象作为第一个参数，称为thisArg。 123456789101112var toString=Object.prototype.toString;console.log(toString.call(undefined)); // [object Undefined]console.log(toString.call(null)); // [object Null]console.log(toString.call(true)); // [object Boolean]console.log(toString.call(123)); // [object Number]console.log(toString.call('a')); // [object String]console.log(toString.call(new Object()); // [object Object]console.log(toString.call([1,2,3])); // [object Array]console.log(toString.call(function a()&#123;&#125;)); // [object Function]console.log(toString.call(new Date())); // [object Date] 数组判断isArray() Array.isArray() 用于确定传递的值是否是一个 Array。 12345678Array.isArray([1, 2, 3]); // trueArray.isArray(&#123;foo: 123&#125;); // falseArray.isArray("foobar"); // falseArray.isArray(undefined); // false 综述一个较好的解决方案应该是检测基本数据类型时使用typeof，当然null除外；检测复杂数据类型时使用Object.prototype.toString() Undefined类型undefined指那些被声明但未被初始化的值 Null类型null值表示一个空对象指针，因此typeof null === object Boolean类型及相应转换规则转型函数Boolean()12let str='hello';console.log(Boolean(str)); //true Boolean自动转换规则 数据类型 转换为true值 转换为false值 Number 任何非0数值 0和NaN String 非空字符串 空字符串（””） Bollean true false Object 任何object(包括{}，因为{}是一个不完全空的对象) null Undefined 无 undefined Number类型为什么0.1+0.2!==0.3 NaNNaN,指的是非数值，用来表示一个本来要返回数值的操作数未返回数值的情况，例如： 1console.log('a'-1); //NaN 任何设置NaN的操作都会返回NaN,甚至NaN与任何值都不相等包括其本身，包括但不限于： 12console.log(NaN-1); //NaNconsole.log(NaN===NaN); //false isNaN函数 isNaN() 函数用来确定一个值是否为NaN 。注：isNaN函数内包含一些非常有趣的规则；你也可以使用 ECMAScript 2015 中定义的 Number.isNaN() 来判断。 下一个版本的ECMAScript (ES2015)包含Number.isNaN()函数。通过Number.isNaN(x)来检测变量x是否是一个NaN将会是一种可靠的做法。然而，在缺少Number.isNaN函数的情况下, 通过表达式(x != x) 来检测变量x是否是NaN会更加可靠。 一个isNaN的 polyfill 可以理解为（这个polyfill利用了NaN自身永不相等于自身这一特征 ）： 1234var isNaN = function(value) &#123; var n = Number(value); //利用Number()函数进行数值转换 return n !== n;&#125;; 例子12345678910111213141516171819202122isNaN(NaN); // trueisNaN(undefined); // trueisNaN(&#123;&#125;); // trueisNaN(true); // falseisNaN(null); // falseisNaN(37); // false// stringsisNaN("37"); // false: 可以被转换成数值37isNaN("37.37"); // false: 可以被转换成数值37.37isNaN("37,5"); // trueisNaN('123ABC'); // true: parseInt("123ABC")的结果是 123, 但是Number("123ABC")结果是 NaNisNaN(""); // false: 空字符串被转换成0isNaN(" "); // false: 包含空格的字符串被转换成0// datesisNaN(new Date()); // falseisNaN(new Date().toString()); // trueisNaN("blabla") // true: "blabla"不能转换成数值 // 转换成数值失败， 返回NaN 数值转换 Number() parseInt() parseFloat() String类型toString()方法作用：返回值的字符串表现数值，布尔值，对象和字符串都有该方法但是undefined和null没有该方法 1234console.log(123.toString()); //'123'console.log(true.toString()); //'true'let a=&#123;item:1&#125;;console.log(a.toString()); //'[object Object]' String()转型函数该函数不同于toString不能转换null和undefined;该方法可以转换任何类型的值 转换规则如下： 如果该类型有toString()方法，那么就调用该方法 如果为null，则返回”null” 如果为undefined，则返回”undefined” Object类型Object类型是所有对象的基础，也就是所有对象都是继承与Object的 123456let a=new Object();let str=new String();let date=new Date();console.log(a instanceof Object); //trueconsole.log(str instanceof Object); //trueconsole.log(date instanceof Object); //true 对象可以通过执行new操作符后跟要创建的对象类型的名称来创建，例 123let a=new Object();let str=new String();let date=new Date(); Object实例的一些属性与方法 constructor: 指向构造函数 isPrototypeOf(object)：用于检查传入的对象是否是当前对象的原型 toString()：返回对象的字符串表示 valueOf(): 返回对象的字符串、数值或布尔值表示。通常与toString()方法返回值相同]]></content>
      <categories>
        <category>javaScript基础</category>
      </categories>
      <tags>
        <tag>基础语法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[leetcode-1021 删除最外层的括号]]></title>
    <url>%2F2019%2F07%2F31%2Fleetcode-1021%2F</url>
    <content type="text"><![CDATA[删除最外层的括号题目描述有效括号字符串为空 (“”)、”(“ + A + “)” 或 A + B，其中 A 和 B 都是有效的括号字符串，+ 代表字符串的连接。例如，””，”()”，”(())()” 和 “(()(()))” 都是有效的括号字符串。 如果有效字符串 S 非空，且不存在将其拆分为 S = A+B 的方法，我们称其为原语（primitive），其中 A 和 B 都是非空有效括号字符串。 给出一个非空有效字符串 S，考虑将其进行原语化分解，使得：S = P_1 + P_2 + … + P_k，其中 P_i 是有效括号字符串原语。 对 S 进行原语化分解，删除分解中每个原语字符串的最外层括号，返回 S 。 示例 1： 输入：”(()())(())”输出：”()()()”解释：输入字符串为 “(()())(())”，原语化分解得到 “(()())” + “(())”，删除每个部分中的最外层括号后得到 “()()” + “()” = “()()()”。 示例 2： 输入：”(()())(())(()(()))”输出：”()()()()(())”解释：输入字符串为 “(()())(())(()(()))”，原语化分解得到 “(()())” + “(())” + “(()(()))”，删除每隔部分中的最外层括号后得到 “()()” + “()” + “()(())” = “()()()()(())”。 示例 3： 输入：”()()”输出：””解释：输入字符串为 “()()”，原语化分解得到 “()” + “()”，删除每个部分中的最外层括号后得到 “” + “” = “”。 提示： S.length &lt;= 10000 S[i] 为 “(“ 或 “)” S 是一个有效括号字符串 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/remove-outermost-parentheses著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 核心思路概述关于括号匹配问题，很容易想到用栈来解决。 遇到 ‘ ( ‘ 入栈，遇到 ‘ ) ‘ 则出栈。则当该栈为空时，则代表之前的括号都已匹配。那么就可以将先前的括号去掉最外层的括号 解题步骤 设定一个数组stack用来表示栈操作，并预先压入第一个元素’(‘ 设定一个数组temp用来存放已经匹配完成的括号，并预先设定第一个元素’(‘ 从第二个元素开始遍历，遇到 ‘ ( ‘ 入栈，遇到 ‘ ) ‘ 则出栈。则当该栈为空时，则代表之前的括号都已匹配。那么就可以将先前的括号去掉最外层的括号,并压入结果数组ans 返回ans Coding实现123456789101112131415161718192021222324/** * @param &#123;string&#125; S * @return &#123;string&#125; */var removeOuterParentheses = function(S) &#123; let stack=['(']; let temp=['(']; let ans=[]; S=S.split(''); for(let i=1;i&lt;S.length;i++)&#123; temp.push(S[i]); if(S[i]===')')&#123; stack.pop(); if(stack.length===0)&#123; temp.pop(); temp.shift(); ans.push(...temp); temp=[]; &#125; &#125; else stack.push(S[i]); &#125; return ans.join('');&#125;;]]></content>
      <categories>
        <category>leetcode题解与算法</category>
      </categories>
      <tags>
        <tag>栈</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[leetcode-1122 数组的相对排序]]></title>
    <url>%2F2019%2F07%2F30%2Fleetcode-1122%2F</url>
    <content type="text"><![CDATA[数组的相对排序题目描述给你两个数组，arr1 和 arr2， arr2 中的元素各不相同 arr2 中的每个元素都出现在 arr1 中 对 arr1 中的元素进行排序，使 arr1 中项的相对顺序和 arr2 中的相对顺序相同。未在 arr2 中出现过的元素需要按照升序放在 arr1 的末尾。 示例： 输入：arr1 = [2,3,1,3,2,4,6,7,9,2,19], arr2 = [2,1,4,3,9,6]输出：[2,2,2,1,4,3,3,9,6,7,19] 提示： arr1.length, arr2.length &lt;= 1000 0 &lt;= arr1[i], arr2[i] &lt;= 1000 arr2 中的元素 arr2[i] 各不相同 arr2 中的每个元素 arr2[i] 都出现在 arr1 中 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/relative-sort-array著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 核心思路概述目前觉得暴力解法最简单 解题步骤双循环，时间复杂度为O(n*m) Coding实现1234567891011121314151617181920212223/** * @param &#123;number[]&#125; arr1 * @param &#123;number[]&#125; arr2 * @return &#123;number[]&#125; */var relativeSortArray = function(arr1, arr2) &#123; let ans=[]; let el=[]; arr1.forEach(value=&gt;&#123; if(!arr2.includes(value))&#123; el.push(value); &#125; &#125;) arr2.forEach(value2=&gt;&#123; arr1.forEach(value1=&gt;&#123; if(value1===value2)&#123; ans.push(value2); &#125; &#125;) &#125;) el.sort((a,b)=&gt;&#123;return a-b;&#125;) return ans.concat(el);&#125;;]]></content>
      <categories>
        <category>leetcode题解与算法</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[leetcode-344 反转字符串]]></title>
    <url>%2F2019%2F07%2F30%2Fleetcode-344%2F</url>
    <content type="text"><![CDATA[反转字符串题目描述编写一个函数，其作用是将输入的字符串反转过来。输入字符串以字符数组 char[] 的形式给出。 不要给另外的数组分配额外的空间，你必须原地修改输入数组、使用 O(1) 的额外空间解决这一问题。 你可以假设数组中的所有字符都是 ASCII 码表中的可打印字符。 示例 1： 输入：[“h”,”e”,”l”,”l”,”o”]输出：[“o”,”l”,”l”,”e”,”h”] 示例 2： 输入：[“H”,”a”,”n”,”n”,”a”,”h”]输出：[“h”,”a”,”n”,”n”,”a”,”H”] 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/reverse-string著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 核心思路概述题目要求是原地修改数组，并且只能使用O(1)的额外空间。因此，不能创建新的数组来存放数组元素，此时可以考虑使用双指针，一个置首，一个置尾。首向后，尾向前，交换两个指针的值即可。 解题步骤 建立left,right双指针 当left&lt;=right时，交换两指针元素 Coding实现1234567891011121314/** * @param &#123;character[]&#125; s * @return &#123;void&#125; Do not return anything, modify s in-place instead. */var reverseString = function(s) &#123; let left=0; let right=s.length-1; while(left&lt;=right)&#123; [s[left],s[right]]=[s[right],s[left]]; left++; right--; &#125; return s;&#125;;]]></content>
      <categories>
        <category>leetcode题解与算法</category>
      </categories>
      <tags>
        <tag>双指针</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[leetcode-977 有序数组的平方]]></title>
    <url>%2F2019%2F07%2F29%2Fleetcode-977%2F</url>
    <content type="text"><![CDATA[有序数组的平方题目描述给定一个按非递减顺序排序的整数数组 A，返回每个数字的平方组成的新数组，要求也按非递减顺序排序。 示例 1： 输入：[-4,-1,0,3,10]输出：[0,1,9,16,100] 示例 2： 输入：[-7,-3,2,3,11]输出：[4,9,9,49,121] 提示： 1&lt;= A.length &lt;= 10000 -10000 &lt;= A[i] &lt;= 10000 A 已按非递减顺序排序。 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/squares-of-a-sorted-array著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 核心思路概述将该数组的每一个元素平方后在将该数组排序并返回 解题步骤 将该数组的每一个元素平方 排序该数组并返回 Coding实现123456789/** * @param &#123;number[]&#125; A * @return &#123;number[]&#125; */var sortedSquares = function(A) &#123; return A.map(value=&gt;&#123; return value*value; &#125;).sort((a,b)=&gt;&#123;return a-b;&#125;)&#125;;]]></content>
      <categories>
        <category>leetcode题解与算法</category>
      </categories>
      <tags>
        <tag>数组</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[leetcode-350 两个数组的交集 II]]></title>
    <url>%2F2019%2F07%2F28%2Fleetcode-350%2F</url>
    <content type="text"><![CDATA[两个数组的交集 II题目描述给定两个数组，编写一个函数来计算它们的交集。 示例 1: 输入: nums1 = [1,2,2,1], nums2 = [2,2]输出: [2,2] 示例 2: 输入: nums1 = [4,9,5], nums2 = [9,4,9,8,4]输出: [4,9] 说明： 输出结果中每个元素出现的次数，应与元素在两个数组中出现的次数一致。我们可以不考虑输出结果的顺序。 进阶: 如果给定的数组已经排好序呢？你将如何优化你的算法？ 如果 nums1 的大小比 nums2 小很多，哪种方法更优？ 如果 nums2 的元素存储在磁盘上，磁盘内存是有限的，并且你不能一次加载所有的元素到内存中，你该怎么办？ 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/intersection-of-two-arrays-ii著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 核心思路概述该题可以考虑用双指针方法和哈希表去解决。双指针主要循环比较两个数是否相等；哈希表主要是记录每个数组中每个元素出现的次数 解题步骤双指针 将两个数组进行排序 设定两个指针，分别指向两个数组的第一个元素 如果两个指针指向的元素相等，那么就把该元素push入ans数组；并且两个指针向后移动 如果不等，那么指向较小元素的那个指针向后移动 哈希表 建立两个哈希表，分别存储每个数组中的每个元素存储的个数 遍历其中一个哈希表，如果另一个哈希表中也存在该键，比较两个键值大小，按照小的那个键值循环则将该键push入ans数组； Coding实现双指针解法代码12345678910111213141516171819202122232425262728/** * @param &#123;number[]&#125; nums1 * @param &#123;number[]&#125; nums2 * @return &#123;number[]&#125; */var intersect = function(nums1, nums2) &#123; let nums1Index=0; let nums2Index=0; let ans=[]; nums1.sort((a,b)=&gt;&#123;return a-b;&#125;); nums2.sort((a,b)=&gt;&#123;return a-b;&#125;); while(nums1Index&lt;nums1.length&amp;&amp;nums2Index&lt;nums2.length)&#123; let num1=nums1[nums1Index]; let num2=nums2[nums2Index]; if(num1===num2)&#123; ans.push(num1); nums1Index++; nums2Index++; &#125; else if(num1&lt;num2)&#123; nums1Index++; &#125; else&#123; nums2Index++; &#125; &#125; return ans;&#125;; 哈希表解法代码12345678910111213141516171819202122232425262728293031/** * @param &#123;number[]&#125; nums1 * @param &#123;number[]&#125; nums2 * @return &#123;number[]&#125; */var intersect = function(nums1, nums2) &#123; let map1=new Map(); let map2=new Map(); let ans=[]; function count(nums,map)&#123; nums.forEach(value=&gt;&#123; if(!map.has(value))&#123; map.set(value,1); &#125; else &#123; map.set(value,map.get(value)+1); &#125; &#125;) &#125; count(nums1,map1); count(nums2,map2); map1.forEach((value,key)=&gt;&#123; if(map2.has(key))&#123; let num=value&gt;map2.get(key)?map2.get(key):value; for(let i=0;i&lt;num;i++)&#123; ans.push(key); &#125; &#125; &#125;) return ans;&#125;;]]></content>
      <categories>
        <category>leetcode题解与算法</category>
      </categories>
      <tags>
        <tag>哈希表</tag>
        <tag>双指针</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[二分查找]]></title>
    <url>%2F2019%2F07%2F27%2F%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE%2F</url>
    <content type="text"><![CDATA[二分查找概述 二分查找的高效之处在于，每一步都可以去除当前区间中的一半元素，因此时间复杂度为O(logn) 严格递增序列的二分查找 输入：[1,2,3,7,9,11] , 3返回: 2 输入：[1,2,3,7,9,11] , 8返回：false 1234567891011121314151617function F(n,m)&#123; let left=0; let right=n.length-1; while(left&lt;=right)&#123; let mid=Math.floor((left+right)/2); if(m===n[mid])&#123; return mid; &#125; if(m&lt;n[mid])&#123; right=mid-1; &#125; else&#123; left=mid+1; &#125; &#125; return false;&#125; 在整体递增，局部重复的序列中二分查找第一个符合要求的元素位置 输入：[1,2,3,3,3,7,9,11],3返回: 2 输入：[1,2,3,3,3,7,9,11],8返回：false 123456789101112131415function F(n,m)&#123; let left=0; let right=n.length; while(left&lt;right)&#123; let mid=Math.floor((left+right)/2); //floor()函数，不大于当前数的最大数 if(m&lt;=n[mid])&#123; right=mid; &#125; else&#123; left=mid+1; &#125; &#125; if(n[left]===m) return left; else return false;&#125; 在整体递增，局部重复的序列中二分查找第一个大于给定元素的元素位置 输入：[1,2,3,3,3,7,9,11],3返回：5 输入：[1,2,3,3,3,7,9,11],4返回: ‘给定元素不存在’ 1234567891011121314151617function F(n,m)&#123; let left=0; let right=n.length-1; while(left&lt;right)&#123; let mid=Math.ceil((left+right)/2); //ceil()函数，不小于当前数的最小整数 if(m&gt;=n[mid])&#123; left=mid; &#125; else&#123; right=mid-1; &#125; &#125; if(n[right]===m) return right+1; else &#123; return ('给定元素不存在'); &#125;&#125; 求根号2的近似值 输入：0.00001 //精确度返回：(1.4142074584960938,1.414215087890625) 123456789101112131415function F(x)&#123; let left=1; let right=2; let num=Math.sqrt(2); while(right-left&gt;x)&#123; let mid=(left+right)/2; if(num&lt;mid)&#123; right=mid; &#125; if(num&gt;mid)&#123; left=mid; &#125; &#125; return `($&#123;left&#125;,$&#123;right&#125;)`&#125; 快速幂用于求解高次幂的快速求法比如2^10 基于二分的思想，又被称之为二分幂 快速幂基于以下原理： 如果b是奇数，那么有a^b=a*a^(b-1) 如果b是偶数，那么有a^b=(a^(b/2))*(a^(b/2)) 因此可以利用递归来求解快速幂 输入 2,10返回: 1024 123456789function F(a,n)&#123; if(n===0) return 1; if(n%2===1)&#123; return F(a,n-1)*a; &#125; else &#123; return F(a,n/2)*F(a,n/2); &#125;&#125;]]></content>
      <categories>
        <category>算法笔记</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[leetcode-852 山脉数组的峰顶索引]]></title>
    <url>%2F2019%2F07%2F27%2Fleetcode-852%2F</url>
    <content type="text"><![CDATA[山脉数组的峰顶索引题目描述我们把符合下列属性的数组 A 称作山脉： A.length &gt;= 3 存在 0 &lt; i &lt; A.length - 1 使得A[0] &lt; A[1] &lt; … A[i-1] &lt; A[i] &gt; A[i+1] &gt; … &gt; A[A.length - 1] 给定一个确定为山脉的数组，返回任何满足 A[0] &lt; A[1] &lt; … A[i-1] &lt; A[i] &gt; A[i+1] &gt; … &gt; A[A.length - 1] 的 i 的值。 示例 1： 输入：[0,1,0]输出：1 示例 2： 输入：[0,2,1,0]输出：1 提示： 3&lt;= A.length &lt;= 10000 0&lt;= A[i] &lt;= 10^6 A是如上定义的山脉 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/peak-index-in-a-mountain-array著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 核心思路概述要找某个特定的值，都可以使用二分查找来提高效率 解题步骤 二分法查找山脉的下标 一开始设定left为0，right为A.length-1,mid为Math.floor((left+right)/2) 如果A[mid]&gt;A[mid+1]&amp;&amp;A[mid]&gt;A[mid-1],那么此时mid就是山脉的下标 如果A[mid]&lt;A[mid+1]，那么就说明山脉应该在mid的右边区间，故left=mid+1 如果A[mid]&gt;A[mid+1]，那么就说明山脉应该在mid的右边区间，故right=mid-1 Coding实现1234567891011121314151617181920/** * @param &#123;number[]&#125; A * @return &#123;number&#125; */var peakIndexInMountainArray = function(A) &#123; let left=0; let right=A.length-1; while(left&lt;=right)&#123; let mid=Math.floor((left+right)/2); if(A[mid]&gt;A[mid+1]&amp;&amp;A[mid]&gt;A[mid-1])&#123; return mid; &#125; else if(A[mid]&lt;A[mid+1])&#123; left=mid+1; &#125; else&#123; right=mid-1; &#125; &#125;&#125;; 时间复杂度时间复杂度为O(log2N);]]></content>
      <categories>
        <category>leetcode题解与算法</category>
      </categories>
      <tags>
        <tag>二分查找</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[leetcode-944 删列造序]]></title>
    <url>%2F2019%2F07%2F26%2Fleetcode-944%2F</url>
    <content type="text"><![CDATA[删列造序题目描述给定由 N 个小写字母字符串组成的数组 A，其中每个字符串长度相等。 删除 操作的定义是：选出一组要删掉的列，删去 A 中对应列中的所有字符，形式上，第 n 列为 [A[0][n], A[1][n], …, A[A.length-1][n]]）。 比如，有 A = [“abcdef”, “uvwxyz”]， 要删掉的列为 {0, 2, 3}，删除后 A 为[“bef”, “vyz”]， A 的列分别为[“b”,”v”], [“e”,”y”], [“f”,”z”]。 你需要选出一组要删掉的列 D，对 A 执行删除操作，使 A 中剩余的每一列都是 非降序 排列的，然后请你返回 D.length 的最小可能值。 示例 1： 输入：[“cba”, “daf”, “ghi”]输出：1解释：当选择 D = {1}，删除后 A 的列为：[“c”,”d”,”g”] 和 [“a”,”f”,”i”]，均为非降序排列。若选择 D = {}，那么 A 的列 [“b”,”a”,”h”] 就不是非降序排列了。 示例 2： 输入：[“a”, “b”]输出：0解释：D = {} 示例 3： 输入：[“zyx”, “wvu”, “tsr”]输出：3解释：D = {0, 1, 2} 提示： 1&lt;= A.length &lt;= 100 1&lt;= A[i].length &lt;= 1000 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/delete-columns-to-make-sorted著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 核心思路概述题目要求得到删去列数的最小值来使剩余的每一列都是非降序的，那么对于贪心思想，只要找到某些列存在降序的删除即可，而无需删除那些已经是非降序的列 解题步骤 根据数组第一个字符串元素长度来确认列数 根据列数，遍历每一个字符串中的那一列 如果某一列存在降序则将ans加1 返回ans Coding实现12345678910111213141516/** * @param &#123;string[]&#125; A * @return &#123;number&#125; */var minDeletionSize = function(A) &#123; let ans=0; for(let i=0;i&lt;A[0].length;i++)&#123; for(let k=0;k&lt;A.length-1;k++)&#123; if(A[k+1][i].charCodeAt()-A[k][i].charCodeAt()&lt;0)&#123; ans++; break; &#125; &#125; &#125; return ans; &#125;;]]></content>
      <categories>
        <category>leetcode题解与算法</category>
      </categories>
      <tags>
        <tag>贪心</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[贪心]]></title>
    <url>%2F2019%2F07%2F26%2F%E8%B4%AA%E5%BF%83%2F</url>
    <content type="text"><![CDATA[##简单贪心 贪心法是求解一类最优化问题的方法，它总是考虑在当前状态下局部最优（或较优）的策略，来使全局的结果达到最优（或较优） 简单来说，也就是，在对问题求解时，总是做出在当前看来是最好的选择。 贪心算法的基本思路 将求解的问题分成若干子问题 对于每一个子问题，考虑得到该子问题的局部最优解 把所有子问题的局部最优解合成一个原问题的解 贪心算法的适用前提和问题 局部最优解能够影响全局最优解 贪心算法得到的不一定就是问题的最优解 贪心算法题目设有n个正整数，将它们连接成一排，组成一个最大的多位整数。 例如：n=3时，3个整数13，312，343，连成的最大整数为34331213。又如：n=4时，4个整数7，13，4，246，连成的最大整数为7424613。 输入：nN个数输出：连成的多位数 思路因为要得到最大的正整数，那么高位数据越大则值越大。因此，使用贪心算法，每次选值的时候优先选择最高位最大的，如若相同，则比较次高位，直到选出较优值 因此，通过这个思路，比较高位可以利用字符串UniCode码来比较，比如’7’&gt;’432’ js的sort()函数可以完美解决，利用sort函数对输入值由高到低进行排序，最后转化为数值进行返回 Coding实现123function F(n)&#123; return parseInt(n.sort().reverse().join(''));&#125; 区间贪心]]></content>
  </entry>
  <entry>
    <title><![CDATA[排序]]></title>
    <url>%2F2019%2F07%2F25%2F%E6%8E%92%E5%BA%8F%2F</url>
    <content type="text"><![CDATA[选择排序定义选择排列是指，对一个序列A中的元素，令i从0到n-1枚举，进行n趟操作，每趟从待排序部分（i+1,n）中选择最小的元素，令其与待排序部分的第一个元素A[i]进行交换，这样在n趟操作后，所有元素都会是有序的 动图演示 Coding实现1234567891011121314function selectSort(n)&#123; for(let i=0;i&lt;n.length-1;i++)&#123; let min=i; for(let k=i;k&lt;n.length;k++)&#123; if(n[k]&lt;n[min])&#123; min=k; &#125; &#125; let temp=n[min]; n[min]=n[i]; n[i]=temp; &#125; return n;&#125; 插入排序直接插入排序定义直接插入排序是指，对序列A的n个元素A[0]到A[n-1],令n从1到n-1枚举，进行n-1趟操作。每一趟排序时，该待排列元素之前的所有元素已经是有序的，则在该有序队列中寻找一个位置进行插入，使得该序列依旧有序 动图演示 Coding实现1234567891011function insertionSort(n)&#123; for(let i=1;i&lt;n.length;i++)&#123; let num=n[i]; while(num&lt;n[i-1])&#123; n[i]=n[i-1]; i--; &#125; n[i]=num; &#125; return n;&#125; 折半插入排序定义 有一组数据待排序，排序区间为Array[0] ~ Array[n-1]。将数据分为有序数据和无序数据，第一次排序时默认Array[0]为有序数据，Array[1]~Array[n-1]为无序数据。有序数据分区的第一个元素位置为low，最后一个元素的位置为high。 遍历无序区间的所有元素，每次取无序区间的第一个元素Array[i]，因为0 ~ i-1是有序排列的，所以用中点m将其平分为两部分，然后将待排序数据同中间位置为m的数据进行比较，若待排序数据较大，则low ~ m-1分区的数据都比待排序数据小，反之，若待排序数据较小，则m+1 ~ high分区的数据都比 待排序数据大，此时将low或high重新定义为新的合适分区的边界，对新的小分区重复上面操作。直到low和high 的前后顺序改变，此时high+1所处位置为待排序数据的合适位置。 作者：weixin_42245157来源：CSDN原文：https://blog.csdn.net/weixin_42245157/article/details/80458542版权声明：本文为博主原创文章，转载请附上博文链接！ Coding实现123456789101112131415161718192021function BinaryInsertSortup(n)&#123; for(let i=1;i&lt;n.length;i++)&#123; let low=0; let high=i-1; let num=n[i]; while(low&lt;=high)&#123; let mid=Math.floor((low+high)/2); if(num&lt;n[mid])&#123; high=mid-1; &#125; else&#123; low=mid+1; &#125; &#125; for(k=i;k&gt;low;k--)&#123; n[k]=n[k-1]; &#125; n[k]=num; &#125; return n;&#125; 冒泡排序定义冒泡排序旨在每次冒泡一个最大或最小的元素到顶端，因此需遍历n次。（若冒泡较大元素）则每次遍历，比较相邻两个元素大小，若底部元素（数组下标较小）大于其相邻顶部元素，则两元素交换位置，直至最大的元素冒泡到最顶端 动图演示 Coding实现12345678910111213141516function bubbleSort(n)&#123; let flag; do&#123; flag=0; for(let i=0;i&lt;n.length;i++)&#123; let temp; if(n[i]&gt;n[i+1])&#123; temp=n[i]; n[i]=n[i+1]; n[i+1]=temp; flag=1; &#125; &#125; &#125;while(flag===1) return n;&#125; 归并排序定义归并排序是一种基于归并思想的排序方法。 实现思路： 将序列分成Math.ceil(n/2)个组，组内单独排序 将这些组两两归并，这样就会变成Math.ceil(n/4)个组，组内再单独排序 以此类推，直到最后只剩下一个组为止 Coding实现1234567891011121314151617181920212223242526272829303132333435363738394041function mergeSort(arr) &#123; const length = arr.length; if (length === 1) &#123; //递归算法的停止条件，即为判断数组长度是否为1 return arr; &#125; const mid = Math.floor(length / 2); const left = arr.slice(0, mid); const right = arr.slice(mid, length); return merge(mergeSort(left), mergeSort(right)); //要将原始数组分割直至只有一个元素时，才开始归并&#125;function merge(left, right) &#123; const result = []; let il = 0; let ir = 0; //left, right本身肯定都是从小到大排好序的 while( il &lt; left.length &amp;&amp; ir &lt; right.length) &#123; if (left[il] &lt; right[ir]) &#123; result.push(left[il]); il++; &#125; else &#123; result.push(right[ir]); ir++; &#125; &#125; //不可能同时存在left和right都有剩余项的情况, 要么left要么right有剩余项, 把剩余项加进来即可 while (il &lt; left.length) &#123; result.push(left[il]); il++; &#125; while(ir &lt; right.length) &#123; result.push(right[ir]); ir++; &#125; return result;&#125; 快速排序定义快速排序是排序算法中平均时间复杂度为O(logn)的一种算法。 其主要步骤为 调整序列中的元素，使得当前序列的第一个元素在调整后所处的位置的左侧元素都小于它，在右侧的位置都大于它 对该元素的左侧和右侧区间分别递归进行1的调整，直到当前调整区间的长度不大于1 Coding实现123456789101112131415function F(n)&#123; if(n.length&lt;2) return n; let first=n[0]; let small=[]; let large=[]; for(let i=1;i&lt;n.length;i++)&#123; if(n[i]&lt;first)&#123; small.push(n[i]); &#125; else&#123; large.push(n[i]); &#125; &#125; return F(small).concat([first],F(large));&#125;]]></content>
      <categories>
        <category>算法笔记</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[leetcode-1002 查找常用字符]]></title>
    <url>%2F2019%2F07%2F24%2Fleetcode-1002%2F</url>
    <content type="text"><![CDATA[查找常用字符题目描述给定仅有小写字母组成的字符串数组 A，返回列表中的每个字符串中都显示的全部字符（包括重复字符）组成的列表。例如，如果一个字符在每个字符串中出现 3 次，但不是 4 次，则需要在最终答案中包含该字符 3 次。 你可以按任意顺序返回答案。 示例 1： 输入：[“bella”,”label”,”roller”]输出：[“e”,”l”,”l”] 示例 2： 输入：[“cool”,”lock”,”cook”]输出：[“c”,”o”] 提示： 1&lt;= A.length &lt;= 100 1&lt;= A[i].length &lt;= 100 A[i][j] 是小写字母 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/find-common-characters著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 核心思路概述统计每个字符串中字符的出现个数，返回出现相同字符的最少个数字符 解题步骤 建立哈希表A，存储第一个字符串个字符的出现次数 遍历后面的字符串，在每个循环中建立新的哈希表，存储该字符串中第一个字符串所有字符的个数；比较新哈希表与步骤1建立的哈希表A，更新A哈希表中的键值为两者较小值 遍历A哈希表，存储value次key到ans数组并返回 Coding实现12345678910111213141516171819202122232425262728293031323334353637383940/** * @param &#123;string[]&#125; A * @return &#123;string[]&#125; */var commonChars = function(A) &#123; let map=new Map(); let ans=[]; for(let i=0;i&lt;A[0].length;i++)&#123; if(!map.has(A[0][i]))&#123; map.set(A[0][i],1); &#125; else &#123; map.set(A[0][i],map.get(A[0][i])+1); &#125; &#125; for(let i=1;i&lt;A.length;i++)&#123; let mapEve=new Map(); map.forEach((value,key)=&gt;&#123; mapEve.set(key,0); &#125;) for(let k=0;k&lt;A[i].length;k++)&#123; if(map.has(A[i][k]))&#123; mapEve.set(A[i][k],mapEve.get(A[i][k])+1); &#125; &#125; map.forEach((value,key)=&gt;&#123; if(value&gt;mapEve.get(key))&#123; map.set(key,mapEve.get(key)); &#125; &#125;) &#125; map.forEach((value,key)=&gt;&#123; if(value&gt;0)&#123; for(let i=0;i&lt;value;i++)&#123; ans.push(key); &#125; &#125; &#125;); return ans;&#125;;]]></content>
      <categories>
        <category>leetcode题解与算法</category>
      </categories>
      <tags>
        <tag>哈希表</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[递归与分治]]></title>
    <url>%2F2019%2F07%2F24%2F%E9%80%92%E5%BD%92%E4%B8%8E%E5%88%86%E6%B2%BB%2F</url>
    <content type="text"><![CDATA[分治分治的全称为“分而治之”。分治法将原问题划分为若干个规模较小而结构与原问题相同或类似的子问题，然后分别解决这些子问题，最后合并子问题的解，即可得到原问题的解 减治、分治 一般把子问题个数为1的情况称为减治（例如对n!的求解） 123456function F(n)&#123; if(n===1) return 1; else &#123; return F(n-1)*n; &#125;&#125; 子问题个数大于1的情况称为分治（例如对Fibonacci数列的求解） 1234function F(n)&#123; if(n===1||n===0) return 1; else return F(n-1)+F(n-2);&#125; 递归 递归适合用来实现分治思想 递归的两个核心概念 递归边界 递归式（递归调用） 对于n!的求解，可以很容易的到F(n)=F(n-1)*n ;这就是递归式而F(1)=1; 这是递归的边界 分治思想的应用全排列n皇后问题]]></content>
      <categories>
        <category>算法笔记</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[leetcode-349 两个数组的交集]]></title>
    <url>%2F2019%2F07%2F23%2Fleetcode-349%2F</url>
    <content type="text"><![CDATA[两个数组的交集题目描述给定两个数组，编写一个函数来计算它们的交集。 示例 1: 输入: nums1 = [1,2,2,1], nums2 = [2,2]输出: [2] 示例 2: 输入: nums1 = [4,9,5], nums2 = [9,4,9,8,4]输出: [9,4] 说明: 输出结果中的每个元素一定是唯一的。我们可以不考虑输出结果的顺序。 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/intersection-of-two-arrays著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 核心思路概述将两个数组都去重后，比较另一个数组是否包含这个数组的某些元素，返回即可 解题步骤 使用set将两个数组去重 比较去重后的两个数组的大小，遍历较小的那个数组，查看另一个数组是否includes这个数组中的某些元素，有则添加到ans数组返回 Coding实现12345678910111213141516171819/** * @param &#123;number[]&#125; nums1 * @param &#123;number[]&#125; nums2 * @return &#123;number[]&#125; */var intersection = function(nums1, nums2) &#123; let ans=[]; nums1=[...new Set(nums1)]; nums2=[...new Set(nums2)]; function inter(nums1,nums2)&#123; nums1.forEach(value=&gt;&#123; if(nums2.includes(value))&#123; ans.push(value); &#125; &#125;) &#125; nums1.length&gt;nums2.length?inter(nums2,nums1):inter(nums1,nums2); return ans;&#125;;]]></content>
      <categories>
        <category>leetcode题解与算法</category>
      </categories>
      <tags>
        <tag>数组</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[leetcode-961 重复 N 次的元素]]></title>
    <url>%2F2019%2F07%2F23%2Fleetcode-961%2F</url>
    <content type="text"><![CDATA[重复 N 次的元素题目描述在大小为 2N 的数组 A 中有 N+1 个不同的元素，其中有一个元素重复了 N 次。 返回重复了 N 次的那个元素。 示例 1： 输入：[1,2,3,3]输出：3 示例 2： 输入：[2,1,2,5,3,2]输出：2 示例 3： 输入：[5,1,5,2,5,3,5,4]输出：5 提示： 4 &lt;= A.length &lt;= 100000 &lt;= A[i] &lt; 10000A.length 为偶数 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/n-repeated-element-in-size-2n-array著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 核心思路概述因为该数组大小为2N，其中由N+1个不同的元素，并且有一个元素重复了N次，那么剩余的N个数都是不同的 所以题目可转化为返回有重复的那个数 解题步骤 建立哈希表 遍历给定数组，若哈希表中没有该键名，则加入哈希表；若有，则直接返回该数组元素 Coding实现123456789101112131415/** * @param &#123;number[]&#125; A * @return &#123;number&#125; */var repeatedNTimes = function(A) &#123; let map=new Map(); for(let i=0;i&lt;A.length;i++)&#123; if(!map.has(A[i]))&#123; map.set(A[i],0); &#125; else&#123; return A[i]; &#125; &#125;&#125;;]]></content>
      <categories>
        <category>leetcode题解与算法</category>
      </categories>
      <tags>
        <tag>哈希表</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[leetcode-500 键盘行]]></title>
    <url>%2F2019%2F07%2F23%2Fleetcode-500%2F</url>
    <content type="text"><![CDATA[键盘行题目描述 给定一个单词列表，只返回可以使用在键盘同一行的字母打印出来的单词。键盘如下图所示。 示例： 输入: [“Hello”, “Alaska”, “Dad”, “Peace”]输出: [“Alaska”, “Dad”] 注意： 你可以重复使用键盘上同一字符。你可以假设输入的字符串将只包含字母。 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/keyboard-row著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 核心思路概述利用哈希表,分别即字母为键名，字母所在行号为键值建立哈希表。遍历给定字符串，若字符串的所有字符的所在哈希表的键值都一样，则说明该字符串的字符都在同一行上 解题步骤 建立哈希表以及键盘字符数组 将每个字符以字符为键名，字符所在行号为键值建立哈希表。 遍历题目给定字符串数组，若每个字符串中的字符在哈希表中的键值都一样，则将该字符串加入到要返回的数组中 遍历字符串方法：先得到字符串的第一个字符的所在行号，接着循环得到后面的字符的行号，若不一样则直接退出该循环 注意 将所有字符都转换为小写形式再去得到字符的键值 Coding实现123456789101112131415161718192021222324252627282930313233/** * @param &#123;string&#125; J * @param &#123;string&#125; S * @return &#123;number&#125; *//** * @param &#123;string[]&#125; words * @return &#123;string[]&#125; */var findWords = function(words) &#123; const str=['qwertyuiop','asdfghjkl','zxcvbnm']; let ans=[]; let map=new Map(); str.forEach((value,index)=&gt;&#123; for(let i=0;i&lt;value.length;i++)&#123; map.set(value[i],index+1); &#125; &#125;); words.forEach(value=&gt;&#123; let flag=0; let first=map.get(value[0].toLowerCase()); for(let i=1;i&lt;value.length;i++)&#123; if(map.get(value[i].toLowerCase())!=first)&#123; flag=1; break; &#125; &#125; if(flag===0)&#123; ans.push(value); &#125; &#125;) return ans;&#125;;]]></content>
      <categories>
        <category>leetcode题解与算法</category>
      </categories>
      <tags>
        <tag>哈希表</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[散列]]></title>
    <url>%2F2019%2F07%2F22%2F%E6%95%A3%E5%88%97%2F</url>
    <content type="text"><![CDATA[散列的定义 简单来说：就是将某个元素通过一个函数转换为整数，使得该整数可以尽量唯一地代表这个元素 常用的散列函数 直接定址法 直接把key值作为哈希表的下标 平方取中法 取key的平方的中间若干位作为哈希表的下标 除留余数法（常用） 指把key除以一个数得到的余数作为hash值的方法 冲突处理 线性探查法 如果该hash值已经被占用，那么就不断检查下一个位置，直到找到没被占用的。如果检查过程中超过了表长，则返回到哈希表的首位继续循环查找，或是发现所有的位置都被占用 该方法容易造成扎堆现象，即表中的若干个连续位置都被使用 平方探查法 按照下列的顺序进行探查： H(key)+1^2,H(key)-1^2, H(key)+2^2,H(key)-2^2, H(key)+3^2,H(key)-3^2, … … 如果，检查过程中H(key)+k^2超过了表长Tsize，那么就把(H(key)+k^2) % Tsize 作为hash值 链地址法 链地址法不计算新的hash值，而是把所有H(key)相同的key连接成一条单链表 字符串hash字符串hash是指将字符串S映射为一个整数，使得该整数尽可能唯一地代表该字符串 假设字符串只由AZ构成，那么可以将AZ映射为0~25；比如，ABC则就可以看作是012。显然，与二进制类似，我们可以把其看作为26进制，再将其转化为10进制，即可得到该字符串唯一地hash映射。 代码 1234567const hashFunc(str,length)&#123; let hash=0; for(let i=0;i&lt;length;i++)&#123; hash=hash*26+str[i].charCodeAt()-'A'.charCodeAt(); &#125; return hash;&#125; 如果外加有小写字母，则就是52进制转换若还有数字，则就是62进制转换 一些散列表算法题散列表相关算法题]]></content>
      <categories>
        <category>算法笔记</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[leetcode-771 宝石与石头]]></title>
    <url>%2F2019%2F07%2F22%2Fleetcode-771%2F</url>
    <content type="text"><![CDATA[宝石与石头题目描述 给定字符串J 代表石头中宝石的类型，和字符串 S代表你拥有的石头。 S 中每个字符代表了一种你拥有的石头的类型，你想知道你拥有的石头中有多少是宝石。 J 中的字母不重复，J 和 S中的所有字符都是字母。字母区分大小写，因此”a”和”A”是不同类型的石头。 示例 1: 输入: J = “aA”, S = “aAAbbbb”输出: 3 示例 2: 输入: J = “z”, S = “ZZ”输出: 0 注意: S 和 J 最多含有50个字母。 J 中的字符不重复。 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/jewels-and-stones著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 核心思路概述利用哈希表，遍历宝石类型字符串，建立以宝石类型为键名，宝石数量为值的哈希表。哈希表中的所有键值之和就是所拥有的宝石的数量。 解题步骤 建立哈希表，声明所拥有的宝石数量为ans=0 遍历J字符串，以字符为键名，0为键值建立哈希表 遍历S字符串，若哈希表中存在该键名，则ans++ 返回ans Coding实现123456789101112131415161718/** * @param &#123;string&#125; J * @param &#123;string&#125; S * @return &#123;number&#125; */var numJewelsInStones = function(J, S) &#123; let map=new Map(); let ans=0; for(let i=0;i&lt;J.length;i++)&#123; map.set(J[i],0); &#125;; for(let i=0;i&lt;S.length;i++)&#123; if(map.has(S[i]))&#123; ans++; &#125; &#125; return ans;&#125;;]]></content>
      <categories>
        <category>leetcode题解与算法</category>
      </categories>
      <tags>
        <tag>哈希表</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[leetcode-219 存在重复元素 II]]></title>
    <url>%2F2019%2F07%2F21%2Fleetcode-219%2F</url>
    <content type="text"><![CDATA[存在重复元素 II题目描述给定一个整数数组和一个整数 k，判断数组中是否存在两个不同的索引 i 和 j，使得 nums [i] = nums [j]，并且 i 和 j 的差的绝对值最大为 k。 示例 1: 输入: nums = [1,2,3,1], k = 3输出: true 示例 2: 输入: nums = [1,0,1,1], k = 1输出: true 示例 3: 输入: nums = [1,2,3,1,2,3], k = 2输出: false 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/contains-duplicate-ii著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 核心思路概述利用哈希表，存储以值为键，下标为键值的哈希表。当某个键值需要更新时，比较当前下标与键值的差值是否小于题目给定值，若是则返回true; 解题步骤 建立哈希表 当以当前数组元素的值为键名的键不存在时，则以值为键，下标为键值添加到哈希表中。若存在，则比较当前下标与键值的差值是否小于题目给定值，若是则返回true; Coding实现1234567891011121314151617181920/** * @param &#123;number[]&#125; nums * @param &#123;number&#125; k * @return &#123;boolean&#125; */var containsNearbyDuplicate = function(nums, k) &#123; let map = new Map(); return nums.some((value, index) =&gt; &#123; if (!map.has(value)) &#123; map.set(value, index); &#125; else &#123; if (index - map.get(value) &lt;= k) &#123; return true; &#125; else &#123; map.set(value, index); &#125; &#125; return false; &#125;);&#125;;]]></content>
      <categories>
        <category>leetcode题解与算法</category>
      </categories>
      <tags>
        <tag>哈希表</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[leetcode-217 存在重复元素]]></title>
    <url>%2F2019%2F07%2F20%2Fleetcode-217%2F</url>
    <content type="text"><![CDATA[存在重复元素题目描述给定一个整数数组，判断是否存在重复元素。 如果任何值在数组中出现至少两次，函数返回 true。如果数组中每个元素都不相同，则返回 false。 示例 1: 输入: [1,2,3,1]输出: true 示例 2: 输入: [1,2,3,4]输出: false 示例 3: 输入: [1,1,1,3,3,4,3,2,4,2]输出: true 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/contains-duplicate著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 核心思路概述将该数组去重之后的元素个数与原数组长度进行比较，不一样则有重复； 解题步骤 建立set集合，用于数组去重 将set集合的size与数组长度进行比较 不相同则有重复,返回true;反之,false Coding实现123456789/** * @param &#123;number[]&#125; nums * @return &#123;boolean&#125; */var containsDuplicate = function(nums) &#123; let set=new Set(nums); if(set.size===nums.length) return false; else return true;&#125;;]]></content>
      <categories>
        <category>leetcode题解与算法</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Java解决算法题一些记录(杂)]]></title>
    <url>%2F2019%2F07%2F20%2FJava%E8%A7%A3%E5%86%B3%E7%AE%97%E6%B3%95%E9%A2%98%2F</url>
    <content type="text"><![CDATA[ArrayListArrayList的一些方法 方法 描述 add() 在list的末尾添加一个元素 add(index: int, o: E) 在指定的index处插入元素 clear() 从list中删除所有元素 contains(o: Object) 如果list含有元素o，返回true get(index: int) 返回指定index处的元素 indexOf(o: Object) 返回list中第一个匹配元素的index isEmpty() 如果list不含元素，返回true lastIndexOf(o: Object) 返回list中最后一个匹配元素的index remove(o: Object) 删除list中的第一个元素o，如果元素被删除，返回true size() 返回list中元素个数 remove(index: int) 删除指定index处的元素，如果元素被删除，返回true set(index: int, o: E) 设置指定index处的元素为o]]></content>
      <categories>
        <category>Java</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[leetcode-206 反转链表]]></title>
    <url>%2F2019%2F07%2F19%2Fleetcode-206%2F</url>
    <content type="text"><![CDATA[反转链表题目描述反转一个单链表。 示例: 输入: 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL输出: 5-&gt;4-&gt;3-&gt;2-&gt;1-&gt;NULL 进阶:你可以迭代或递归地反转链表。你能否用两种方法解决这道题？ 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/reverse-linked-list著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 核心思路概述将链表所有的元素取出并倒序放到数组，按照数组元素创建新链表并返回 解题步骤 遍历链表，并将数组元素unshift入数组 按照数组元素添加节点到新创建的链表上 Coding实现12345678910111213141516171819202122232425/** * Definition for singly-linked list. * function ListNode(val) &#123; * this.val = val; * this.next = null; * &#125; *//** * @param &#123;ListNode&#125; head * @return &#123;ListNode&#125; */var reverseList = function(head) &#123; let newList=new ListNode(0); let newHead=newList; let numArray=[]; while(head)&#123; numArray.unshift(head.val); head=head.next; &#125; numArray.forEach(value=&gt;&#123; newHead.next=new ListNode(value); newHead=newHead.next; &#125;) return newList.next;&#125;;]]></content>
      <categories>
        <category>leetcode题解与算法</category>
      </categories>
      <tags>
        <tag>链表</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[leetcode-205 同构字符串]]></title>
    <url>%2F2019%2F07%2F18%2Fleetcode-205%2F</url>
    <content type="text"><![CDATA[同构字符串题目描述给定两个字符串 s 和 t，判断它们是否是同构的。 如果 s 中的字符可以被替换得到 t ，那么这两个字符串是同构的。 所有出现的字符都必须用另一个字符替换，同时保留字符的顺序。两个字符不能映射到同一个字符上，但字符可以映射自己本身。 示例 1: 输入: s = “egg”, t = “add”输出: true 示例 2: 输入: s = “foo”, t = “bar”输出: false 示例 3: 输入: s = “paper”, t = “title”输出: true 说明:你可以假设 s 和 t 具有相同的长度。 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/isomorphic-strings著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 核心思路概述解法1利用哈希表进行映射，两个字符串相互映射 解法2对比两个字符串对应位置的字符在字符串内第一次出现的位置，若不同则返回false 解题步骤解法1 建立哈希映射函数，若哈希表中没有该键值对，则插入表中；若有，则比较值是否相同，不同则返回fasle 两个字符串依次使用哈希映射函数进行比较 解法2 同时遍历两字符串，若当前字符的第一次出现的位置不相同则返回false Coding实现解法1123456789101112131415161718192021222324252627/** * @param &#123;string&#125; s * @param &#123;string&#125; t * @return &#123;boolean&#125; */function match(map,s,t)&#123; for(let i=0;i&lt;s.length;i++)&#123; if(!map.has(s[i]))&#123; map.set(s[i],t[i]); &#125; else&#123; if(map.get(s[i])!=t[i])&#123; return false; &#125; &#125; &#125; return true;&#125;var isIsomorphic = function(s, t) &#123; s=s.split(''); t=t.split(''); let map=new Map(); if(!match(map,s,t)) return false; map.clear(); return match(map,t,s);&#125;; 解法2123456789101112/** * @param &#123;string&#125; s * @param &#123;string&#125; t * @return &#123;boolean&#125; */var isIsomorphic = function(s, t) &#123; for (let i = 0; i &lt; s.length; i++) &#123; if (s.indexOf(s[i]) !== t.indexOf(t[i])) return false; &#125; return true;&#125;]]></content>
      <categories>
        <category>leetcode题解与算法</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[leetcode-204 计数质数]]></title>
    <url>%2F2019%2F07%2F17%2Fleetcode-204%2F</url>
    <content type="text"><![CDATA[计数质数题目描述统计所有小于非负整数 n 的质数的数量。 示例: 输入: 10输出: 4解释: 小于 10 的质数一共有 4 个, 它们是 2, 3, 5, 7 。 核心思路概述质数的定义 质数又称素数。一个大于1的自然数，除了1和它自身外，不能被其他自然数整除的数叫做质数；否则称为合数。 此题的基本解法即为遍历给定数之前的数，若为质数则计数加一 解题步骤 建立一个函数用来判断当前数是否为质数 对于1中的函数质数判断条件，若在1~开根号n的左开右闭的区间内无法被整除，那么该数即为质数。 遍历给定数之前的数，若为质数则计数加一 Coding实现1234567891011121314151617181920212223/** * @param &#123;number&#125; n * @return &#123;number&#125; */const checkPrimes=function(n)&#123; if(n===2) return true; if(n===1) return false; if(n%2===1)&#123; for(let i=1;i&lt;=Math.sqrt(n);i=i+2)&#123; if(n%i===0&amp;&amp;i!==1) return false; &#125; return true; &#125;&#125;var countPrimes = function(n) &#123; let count=0; for(let i=2;i&lt;n;i++)&#123; if(checkPrimes(i))&#123; count++; &#125; &#125; return count;&#125;;]]></content>
      <categories>
        <category>leetcode题解与算法</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[leetcode-203 移除链表元素]]></title>
    <url>%2F2019%2F07%2F16%2Fleetcode-203%2F</url>
    <content type="text"><![CDATA[移除链表元素题目描述删除链表中等于给定值 val 的所有节点。 示例: 输入: 1-&gt;2-&gt;6-&gt;3-&gt;4-&gt;5-&gt;6, val = 6输出: 1-&gt;2-&gt;3-&gt;4-&gt;5 核心思路概述此题为单链表删除指定元素 解题步骤单独考虑头节点（因为头节点之前没有节点） 考虑头节点即为指定需删除元素，那么应当将头指针指向下一个元素。循环检验，当头节点不是指定需删除元素时则退出循环 若步骤1之后，该链表为空链表则直接返回该空链表 1、2步骤之后，当前链表则为头节点不为指定需删除元素的非空链表。遍历当前链表，设置pre和cur指针方便删除链表节点。 设置虚拟头节点（指向头节点的节点） 创建新节点指向当前头节点 遍历该链表，删除指定元素 返回以创建的新节点的下一个节点为头节点所在的链表 Coding实现单独处理头节点的Coding1234567891011121314151617181920212223242526272829/** * Definition for singly-linked list. * function ListNode(val) &#123; * this.val = val; * this.next = null; * &#125; *//** * @param &#123;ListNode&#125; head * @param &#123;number&#125; val * @return &#123;ListNode&#125; */var removeElements = function(head, val) &#123; while(head&amp;&amp;head.val===val)&#123; head=head.next &#125; if(head===null) return head; let cur=head; let pre=head; while(cur.next)&#123; pre=cur; cur=cur.next; if(cur.val===val)&#123; pre.next=cur.next; cur=pre; &#125; &#125; return head;&#125;; 设置指向头节点的指针节点的Coding12345678910111213141516171819202122232425/** * Definition for singly-linked list. * function ListNode(val) &#123; * this.val = val; * this.next = null; * &#125; *//** * @param &#123;ListNode&#125; head * @param &#123;number&#125; val * @return &#123;ListNode&#125; */var removeElements = function(head, val) &#123; let listNode=new ListNode(val-1); listNode.next=head; let list=listNode; while(list.next)&#123; if(list.next.val===val)&#123; list.next=list.next.next; continue; &#125; list=list.next; &#125; return listNode.next;&#125;;]]></content>
      <categories>
        <category>leetcode题解与算法</category>
      </categories>
      <tags>
        <tag>链表</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[leetcode-202 快乐数]]></title>
    <url>%2F2019%2F07%2F15%2Fleetcode-202%2F</url>
    <content type="text"><![CDATA[快乐数题目描述编写一个算法来判断一个数是不是“快乐数”。 一个“快乐数”定义为：对于一个正整数，每一次将该数替换为它每个位置上的数字的平方和，然后重复这个过程直到这个数变为 1，也可能是无限循环但始终变不到 1。如果可以变为 1，那么这个数就是快乐数。 示例: 输入: 19输出: true解释: 12 + 92 = 8282 + 22 = 6862 + 82 = 10012 + 02 + 02 = 1 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/happy-number著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 核心思路概述 正面解题，寻找快乐数。当重复过程变为1则为快乐数，若当循环过程中得到的数与之前出现过的数相重复，则表示之后会在这两数之间无限循环，此时即可返回false. 快慢指针解法：使用快慢指针来判断该循环是否为无限死循环。 解题步骤正面解题法(遇到重复数字则退出) 若输入为1，则直接返回true 设置set集合用来存储循环过程中得到的数 进入do-while循环，将参数转化为数组，利用reduce函数进行平方和累加，判断该得到的数是否存在于set集合中，若存在则返回false，否则则将该数放入set集合中。同时,若该数为1则返回true退出函数快慢指针法 设置两个指针，一个指针移动较快，一个指针移动较慢，若两指针相遇，则代表该循环中存在死循环，则应退出该函数。Coding实现正面解题的Coding12345678910111213141516var isHappy = function(n) &#123; if(n===1) return true; let arr; let set=new Set([n]); do&#123; arr=n.toString().split(''); n=arr.reduce((pre,value)=&gt;&#123; return pre+Math.pow(parseInt(value),2) &#125;,0); if(set.has(n))&#123; return false; &#125; set.add(n); &#125;while(n!=1) return true;&#125;; 递归法的Coding12]]></content>
      <categories>
        <category>leetcode题解与算法</category>
      </categories>
      <tags>
        <tag>快慢指针</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[var、let与const的比较以及作用域]]></title>
    <url>%2F2019%2F07%2F15%2Fvar%E3%80%81let%E4%B8%8Econst%2F</url>
    <content type="text"><![CDATA[var、let与const的比较以及作用域 提升机制对于用var定义的变量会被提升到当前作用域的顶端并赋值为undefined123console.log(a); //undefinedvar a='hello';console.log(a); //hello 函数声明整体提升1234a(); //hellofunction a()&#123; console.log('hello');&#125; 123456console.log(a); //undefineda(); //报错：a is not a functionvar a=function()&#123; /*遇见var a= 会直接将a当作一个变量提升并赋值为undefined;*/console.log('hello');&#125; 123456console.log(a); /*报错：Cannot access 'a' before initialization*/a(); let a=function()&#123; /*这里为let a= ,不会有变量提升机制*/console.log('hello');&#125; 预编译与词法分析预编译 JS引擎会在正式执行代码之前进行一次”预编译“，预编译简单理解就是在内存中开辟一些空间，存放一些变量和函数。 具体步骤 页面创建全局对象（Global Object）对象（window对象）。 加载第一个脚本文件 脚本加载完毕后，进行语法分析。 开始预编译 查找函数声明，作为GO属性，值赋予函数体（函数声明优先） 查找变量声明（除了函数内部的），作为GO属性，值赋予undefined 若函数声明与变量声明同名，则函数声明会优先于变量声明。具体来说即是1. 函数声明替换变量声明 2. 后面的函数声明替换前面的函数声明 3. 后面的变量声明无效 例如 1234567console.log(a); //[function: a]a(); //hellofunction a()&#123; console.log('hello');&#125;var a=1;console.log(a); //1 词法分析 创建AO活动对象（Active Object） 查找形参和变量声明，值赋予undefined 实参值赋给形参 查找函数声明，值赋给函数体 解释执行函数中的代码 块级声明与块级作用域块级作用域存在于： 1.函数内部2.块中（{ }之间的区域） 例如 123456(function test()&#123; console.log(a); //报错：a is not defined if(true)&#123; let a=1; &#125;&#125;)() 用let声明变量，会将变量的作用域限制在当前代码块中（即块级作用域）;因此块级作用域外部无法访问 临时死区 javascript引擎在预编译阶段时，要么将变量提升至作用域顶部（var）,要么就将其放到TDZ（临时死区中）。访问临时死区的变量会触发运行错误。 例如 1234if(true)&#123; console.log(typeof a); //报错 let a=1;&#125; var、let与const的比较 \ var let const 变量提升机制 有 无 无 重声明 允许 在同个作用域下禁止,不同作用域下允许 同let 能否更改 允许 允许 不允许 初始化 可以不用 可以不用 必须]]></content>
      <categories>
        <category>javaScript基础</category>
      </categories>
      <tags>
        <tag>基础语法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[leetcode-172 阶乘后的零]]></title>
    <url>%2F2019%2F07%2F14%2Fleetcode-172%2F</url>
    <content type="text"><![CDATA[阶乘后的零题目描述给定一个整数 n，返回 n! 结果尾数中零的数量。 示例 1: 输入: 3输出: 0解释: 3! = 6, 尾数中没有零。 示例 2: 输入: 5输出: 1解释: 5! = 120, 尾数中有 1 个零. 说明: 你算法的时间复杂度应为 O(log n) 。 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/factorial-trailing-zeroes著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 核心思路概述一开始看到题目时的第一反应就是求解出n!的值，再遍历得到0的个数。然后提交之后，报错提示：超出最大堆栈大小（RangeError: Maximum call stack size exceeded）。因此，看题解之后得到提示，开始寻找规律。 若要某个数中有某位为0,那么他必定是10的倍数。而10=2 * 5；因此，该阶乘中有几对2 * 5，则该数就有几个0；又因为该阶乘为递减，则5的个数必定小于2的个数，则题目即可转化为求出5的个数即可。 解题步骤 归纳得： n 式子 5的个数 5的总个数 5 1*5 1 1 10 2*5 1 2 15 3*5 1 3 20 4*5 1 4 25 5*5 2 6 因此，可以通过 1234while (n &gt;= 5) &#123; n = Math.floor(n / 5); total += n;&#125; 得到5的个数 Coding实现一开始使用递归报错的coding1234567891011121314151617var trailingZeroes = function(n) &#123; let sum=(function circle(n)&#123; if(n!=1)&#123; return circle(n-1)*n; &#125; return 1; &#125;)(n) console.log(sum); sum=sum.toString().split(''); let count=0; sum.forEach(value=&gt;&#123; if(value==0)&#123; count++; &#125; &#125;); return count;&#125;; 优化过的coding12345678const trailingZeroes = n =&gt; &#123; let total = 0; while (n &gt;= 5) &#123; n = Math.floor(n / 5); total += n; &#125; return total;&#125;;]]></content>
      <categories>
        <category>leetcode题解与算法</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[leetcode-171 Excel表列序号]]></title>
    <url>%2F2019%2F07%2F13%2Fleetcode-171%2F</url>
    <content type="text"><![CDATA[Excel表列序号题目描述给定一个Excel表格中的列名称，返回其相应的列序号。 例如， A -&gt; 1 B -&gt; 2 C -&gt; 3 ... Z -&gt; 26 AA -&gt; 27 AB -&gt; 28 ...示例 1: 输入: “A” 输出: 1 示例 2: 输入: “AB” 输出: 28 示例 3: 输入: “ZY”输出: 701 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/excel-sheet-column-number著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 核心思路概述通过观察，不难发现其实这类似于二进制之类的表示形式。只不过对于该题可以把其称之为26进制。再按照二进制转化为十进制方法将其转化为对应的表示数 A的Unicode编码为65，在该题目中对应的是1.因此可以通过letter.charCodeAt()函数得到的Unicode编码值减去64即可得到对应的单个字母对应值。 解题步骤 将字符串转化为数组从而可以进行遍历 将转化得到的数组反转(reverse()) 【类似于二进制转化为十进制的方法，因此，反转后的数组的下标index就是他们在累加时的26幂的次方】 利用reduce()函数进行累加 Coding实现我一开始的coding12345678910var titleToNumber = function(s) &#123; const sArray=s.split(''); let length=sArray.length-1; let sum=0; sArray.forEach(value=&gt;&#123; sum+=(value.charCodeAt()%'A'.charCodeAt()+1)*Math.pow(26,length); length--; &#125;); return sum;&#125;; 优化过的coding123456var titleToNumber = function(s) &#123; const sArray=s.split('').reverse(); return (sArray.reduce((pre,cur,index)=&gt;&#123; return pre+(cur.charCodeAt()-64)*Math.pow(26,index); &#125;,0))&#125;;]]></content>
      <categories>
        <category>leetcode题解与算法</category>
      </categories>
      <tags>
        <tag>数组</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Vue项目代码与命名规范]]></title>
    <url>%2F2019%2F07%2F11%2FVue%E9%A1%B9%E7%9B%AE%E4%BB%A3%E7%A0%81%E4%B8%8E%E5%91%BD%E5%90%8D%E8%A7%84%E8%8C%83%2F</url>
    <content type="text"><![CDATA[Vue项目代码与命名规范 项目结构文件命名 单文件组件命名规范 组件名为多个单词 组件名应该始终是多个单词的，根组件 App 以及 &lt; transition &gt;、&lt; component &gt; 之类的 Vue 内置组件除外。 这样做可以避免跟现有的以及未来的 HTML 元素相冲突，因为所有的 HTML 元素名称都是单个单词的。 MyComponent.vue 语义化及单词顺序 SearchButtonRun.vue 文件名以单词大写开头 MyComponent.vue 组件名应该倾向于完整单词而不是缩写 UserProfileOptions.vue 文件夹命名规范 属于components文件夹下的子文件夹，使用大写字母开头的PascalBase风格 所有组件放在components文件夹下，对于各个页面应当新建立业务页面组件文件夹。 一些通用组件可以建立common文件夹放在components文件夹下 应当建立api文件夹，统一定义管理接口请求 建立router文件夹，进行路由管理 建立store文件夹，进行vuex状态管理]]></content>
      <categories>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>命名规范</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Vue项目的快速搭建]]></title>
    <url>%2F2019%2F07%2F11%2FVue%E9%A1%B9%E7%9B%AE%E7%9A%84%E5%BF%AB%E9%80%9F%E6%90%AD%E5%BB%BA%2F</url>
    <content type="text"><![CDATA[Vue项目的快速搭建 vue-cli创建项目12vue create &lt;项目名&gt;//选择手动设置特性（Manually select features） 安装必要依赖包括但不限于vue-router,vuex,vue-axios,axios1cnpm install vue-router --save 建立基本路由管理在router.js中配置路由 1234567891011121314151617181920212223242526import Vue from 'vue'import VueRouter from 'vue-router'import RouterView1 from '@/component/RouterView1'//@默认表示src文件夹Vue.use(VueRouter) /*安装 Vue.js 插件。如果插件是一个对象，必须提供 install 方法。如果插件是一个函数，它会被作为 install 方法。install 方法调用时，会将 Vue 作为参数传入。*/export default new VueRouter(&#123; routes:[ &#123; path:'/RouterView1', name:'view1', component:RouterView1 &#125;, &#123; path:'/RouterView2', name:'view2', component:()=&gt;&#123; import('@/component/RouterView2') &#125; /*import() es6函数，动态异步加载模块，返回一个promise*/ &#125; ]&#125;) 在main.js中注册12345new Vue(&#123; router, store, render: h =&gt; h(App)&#125;).$mount("#app"); 使用axios（或vue-axios）引入 第一种方式（main.js直接引入) 1234import axios from 'axios'import VueAxios from 'vue-axios'Vue.use(axios,vue-axios) 第二种方式（在api文件夹中引入） 建立api.js文件用来编写接口函数 建立index.js导出api.js的所有函数 使用 1234567891011Vue.axios.get(api).then((response) =&gt; &#123;console.log(response.data)&#125;)this.axios.get(api).then((response) =&gt; &#123;console.log(response.data)&#125;)this.$http.get(api).then((response) =&gt; &#123;console.log(response.data)&#125;)]]></content>
      <categories>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>Vue Cli</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[leetcode-169 求众数]]></title>
    <url>%2F2019%2F07%2F09%2Fleetcode-169%2F</url>
    <content type="text"><![CDATA[求众数核心方法：哈希表题目描述 给定一个大小为 n 的数组，找到其中的众数。众数是指在数组中出现次数大于 ⌊ n/2 ⌋ 的元素。 你可以假设数组是非空的，并且给定的数组总是存在众数。 示例 1: 输入: [3,2,3]输出: 3 示例 2: 输入: [2,2,1,1,1,2,2]输出: 2 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/majority-element著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 核心思路 利用哈希表这一数据结构来存储每个数的出现次数。元素作为键名，他们所出现的次数作为键值，进行存储。 遍历给定数组，若当前数组元素未在哈希表map中（map.has(key)===false），则以该元素为键名添加该元素，并置键值为1（map.set(value,1)）；若已存在，则更新该键值（键值加1:map.set(value,map.get(value)+1)） 遍历哈希表map，找到键值最大的那个键名并返回 coding实现1234567891011121314151617181920var majorityElement = function(nums) &#123; let maxCount=0; let num=0; let numsMap=new Map() nums.forEach(value=&gt;&#123; if(!numsMap.has(value))&#123; numsMap.set(value,1); &#125; else&#123; numsMap.set(value,numsMap.get(value)+1); &#125; &#125;) numsMap.forEach((value,key)=&gt;&#123; if(value&gt;maxCount)&#123; maxCount=value; num=key; &#125; &#125;) return num;&#125;;]]></content>
      <categories>
        <category>leetcode题解与算法</category>
      </categories>
      <tags>
        <tag>哈希表</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[leetcode-167 两数之和|| - 输入有序数组]]></title>
    <url>%2F2019%2F07%2F08%2Fleetcode-167%2F</url>
    <content type="text"><![CDATA[两数之和|| - 输入有序数组核心方法：双指针题目描述 给定一个已按照升序排列 的有序数组，找到两个数使得它们相加之和等于目标数。 函数应该返回这两个下标值 index1 和 index2，其中 index1 必须小于 index2。 说明: 返回的下标值（index1 和 index2）不是从零开始的。你可以假设每个输入只对应唯一的答案，而且你不可以重复使用相同的元素。 示例: 输入: numbers = [2, 7, 11, 15], target = 9输出: [1,2]解释: 2 与 7 之和等于目标数 9 。因此 index1 = 1, index2 = 2 。 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/two-sum-ii-input-array-is-sorted著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 核心思路 题目给定的是有序数组，所以使用双指针方法较为方便。设定min指向第一个数组元素（也就是当前最小数），max指向最后一个数组元素。令sum=numbers[min]+numbers[max] 循环比较sum与target是否相等，若想等则输出。小于target则代表min指向的元素值比输出值要小，则min++;反之，则max–; coding实现1234567891011121314var twoSum = function(numbers, target) &#123; let min=0; let max=numbers.length-1; let sum; while((sum=numbers[min]+numbers[max])!==target)&#123; if(sum&lt;target)&#123; min++; &#125; else&#123; max--; &#125; &#125; return [min+1,max+1];&#125;]]></content>
      <categories>
        <category>leetcode题解与算法</category>
      </categories>
      <tags>
        <tag>双指针</tag>
      </tags>
  </entry>
</search>
