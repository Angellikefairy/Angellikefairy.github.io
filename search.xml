<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[leetcode-113 路径总和 II]]></title>
    <url>%2F2019%2F09%2F01%2Fleetcode-113%2F</url>
    <content type="text"><![CDATA[路径总和 II题目描述给定一个二叉树和一个目标和，找到所有从根节点到叶子节点路径总和等于给定目标和的路径。 说明: 叶子节点是指没有子节点的节点。 示例:给定如下二叉树，以及目标和 sum = 22， 返回: 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/path-sum-ii著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 核心思路概述不同于上题，这次还要记录路径和为给定值的路径上的所有值。那么我们可以用数组来进行记录，每次传入一个新的数组（包括该条路径上当前记录的所有的值）。 采用先序遍历，当遍历到叶子节点时，判断路径和是否为给定值，如果是，那么将该数组插入到ans数组中；否则，return； 解题步骤 创建ans数组 创建遍历函数(传入的参数为当前节点，当前路径和，当前已经被记录的节点值的数组)，如果节点为空，那么return 否则，将该节点的值记录到传入的数组中；如果当前节点为叶子节点，那么判断此时的路径和是否为给定值，如果是，那么将此时的数组push入ans数组中；如果不是，则return，接着遍历直到整棵树遍历完毕 Coding实现123456789101112131415161718192021222324252627282930313233/** * Definition for a binary tree node. * function TreeNode(val) &#123; * this.val = val; * this.left = this.right = null; * &#125; *//** * @param &#123;TreeNode&#125; root * @param &#123;number&#125; sum * @return &#123;number[][]&#125; */var pathSum = function(root, sum) &#123; let ans=[]; (function path(root,s,array) &#123; if(root===null) return; else &#123; array.push(root.val); let arrayCloneLeft=array.slice(0); let arrayCloneRight=array.slice(0); s+=root.val; if(!root.left&amp;&amp;!root.right) &#123; if(s===sum) &#123; ans.push(array); &#125; return; &#125; path(root.left,s,arrayCloneLeft); path(root.right,s,arrayCloneRight); &#125; &#125;)(root,0,[]) return ans;&#125;;]]></content>
      <categories>
        <category>leetcode题解与算法</category>
      </categories>
      <tags>
        <tag>树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[getter与setter函数]]></title>
    <url>%2F2019%2F08%2F31%2Fgetter%E4%B8%8Esetter%E5%87%BD%E6%95%B0%2F</url>
    <content type="text"><![CDATA[访问器属性对象属性分为数据属性与访问器属性。访问器属性不包含数据值，它们包含一对getter与setter函数。在读取访问器属性时，会调用getter函数，这个函数负责返回有效的值；在写入访问器属性时，会调用setter函数并传入新值 什么是getter/setter getter是获得属性值的方法，setter是设置属性值的方法 get与set并不是对象的属性，可以说是伪属性，特性只有内部才用，一般利用Object.getOwnPropertyDescriptor()方法来查询属性的特性；利用Object.defineProperty来定义和修改属性的特性 怎么定义getter与setterget与set语法get/set语法会将对象属性绑定到查询/调用的函数 例： 12345678910111213let a=&#123; item:1, get getItem() &#123; return this.item; &#125;, set setItem(item) &#123; this.item=item; &#125;&#125;console.log(a); // &#123; item: 1, getItem: [Getter], setItem: [Setter] &#125;console.log(a.getItem); // 1a.setItem=2;console.log(a.getItem); // 2 get与set绑定的函数名可以是一样的 12345678910111213let a=&#123; item:1, get _item() &#123; return this.item; &#125;, set _item(item) &#123; this.item=item; &#125;&#125;console.log(a); // &#123; item: 1, _item: [Getter/Setter] &#125;console.log(a._item); // 1a._item=2;console.log(a._item); // 2 当然,get与set也可以绑定多个函数名 1234567891011121314151617181920212223let a=&#123; item:1, name:'ming', get _item() &#123; return this.item; &#125;, set _item(item) &#123; this.item=item; &#125;, get _name() &#123; return this.name; &#125;, set _name(name) &#123; this.name=name; &#125;&#125;console.log(a); // &#123;item: 1,name: 'ming',_item: [Getter/Setter],_name: [Getter/Setter]&#125;console.log(a._item); // 1a._item=2;console.log(a._item); // 2console.log(a._name); // minga._name='xiao ming';console.log(a._name); // xioa ming defineProperty()方法Object.defineProperty() 方法会直接在一个对象上定义一个新属性，或者修改一个对象的现有属性， 并返回这个对象。 语法： Object.defineProperty(obj, prop, descriptor) 参数 obj 要在其上定义属性的对象。 prop 要定义或修改的属性的名称。 descriptor 将被定义或修改的属性描述符 例： 12345678910111213let a=&#123;item:1&#125;;Object.defineProperty(a,'_item',&#123; get: function () &#123; return this.item; &#125;, set: function (item) &#123; this.item=item; &#125;&#125;)console.log(a._item); // 1a._item=2;console.log(a._item); // 2 getter与setter的作用getter与setter的作用我觉得是可以在对赋值和取值之前做一层封装，拦截这些操作，定义一些其他操作（在赋值与取值之前进行一些额外的操作） 1234567891011121314151617let a=&#123;item:1&#125;;Object.defineProperty(a,'_item',&#123; get: function () &#123; return this.item; &#125;, set: function (item) &#123; let date=new Date(); console.log(`a.item的值在$&#123;date.toLocaleString()&#125;被修改`); this.item=item; &#125;&#125;)console.log(a._item); // 1a._item=2;console.log(a._item);// a.item的值在2019-8-31 20:50:59被修改// 2 在上述代码中,我在setter函数赋值后，输出属性值被修改的时间。从而可以监测到值何时被修改。 这就是拦截了赋值操作,先进行了额外定义的检测值被修改的方法]]></content>
      <categories>
        <category>javaScript基础</category>
      </categories>
      <tags>
        <tag>基础语法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Es6一些新的函数参数知识]]></title>
    <url>%2F2019%2F08%2F31%2FEs6%E4%B8%80%E4%BA%9B%E6%96%B0%E7%9A%84%E5%87%BD%E6%95%B0%E5%8F%82%E6%95%B0%E7%9F%A5%E8%AF%86%2F</url>
    <content type="text"><![CDATA[arguments对象每个函数都会有一个arguments对象(类数组对象)，它引用着函数的实参而非形参。 因此，Js函数有一个十分特别的特性，即无论形参有几个，都可以传入任意个实参值，并且由arguments对象引用着 例： 12345function test(a,b) &#123; console.log(arguments); // [Arguments] &#123; '0': 1, '1': 2, '2': 3 &#125;&#125;test(1,2,3); 函数参数的默认值因为在函数定义中声明了多少形参，都可以传入任意数量的参数。那么，如果，传入的参数要比形参少时，我们能否给没有得到传值的形参赋予默认值呢？ Es5模拟默认参数值如果一个参数没有传入值，那么那个形参就会是已声明但未定义，因此，形参就会被默认赋予undefined 如： 12345function test(a,b) &#123; console.log(b); // undefined&#125;test(1); 那么，我们可以在函数体中检测该形参值是否为undefined来判断是否来赋予形参默认值 123456789function test(a,b) &#123; a=((typeof a)!=='undefined')?a:1; b=((typeof b)!=='undefined')?b:2; console.log(a,b);&#125;test(0,0); // 0,0test(0); // 0,2test(); // 1,2 Es6中的默认参数值Es6简化了像Es5模拟默认参数值进行检测形参值是否为undefined的操作，它可以在形参后赋予一个初始值，当没有实参传入时，则使用那个初始值 例如： 12345function test(a,b=1,c) &#123; console.log(a,b,c); // undefined,1,undefined&#125;test(); 如上所示，test函数调用时没有传入任何参数，因此没有赋予初始值的a,c会输出undefined，而赋予初始值的形参在没有获得实参传入时就会获得该初始值 但是，其实质上也是像Es5一样检测了形参值是否为undefined；因此，当你显示地传入undefined值时，它还是会获得被赋予的初始值； 注意，null是一个空对象指针，它不等于undefined 123456function test(a,b=1,c) &#123; console.log(a,b,c); // undefined,1,undefined&#125;test(undefined,undefined,undefined);test(null,null,null); // null,null,null 默认参数值对arguments对象的影响没有使用默认参数值在Es5非严格模式下，当形参值发生变化时，arguments对象也会做出相应的改变；即，命名参数的变化会同步更新到arguments对象中 例： 123456789101112function test(a,b) &#123; console.log(a,b,arguments); // 1 2 [Arguments] &#123; '0': 1, '1': 2 &#125; a=++a; b=++b; console.log(a,b,arguments); // 2 3 [Arguments] &#123; '0': 2, '1': 3 &#125; // arguments对象发生了变化&#125;test(1,2); 使用默认参数值在Es6中，如果函数使用了默认参数值（哪怕所有形参都被传入了实参值），那么所有形参值的变化都不会影响arguments对象，即，默认参数值的存在使得arguments对象保持与命名参数的分离 例： 123456789101112function test(a=3,b=4) &#123; console.log(a,b,arguments); // 1 2 [Arguments] &#123; '0': 1, '1': 2 &#125; a=++a; b=++b; console.log(a,b,arguments); // 2 3 [Arguments] &#123; '0': 1, '1': 2 &#125; // arguments对象没有发生变化&#125;test(1,2); 默认参数表达式默认参数初始值的赋予可以通过函数来进行 例： 123456789function getB() &#123; return 3;&#125;function test(a,b=getB()) &#123; console.log(a,b); // undefined 3&#125;test(); 对于上面的test函数，初次解析函数声明的时候并不会执行getB方法，只有放该函数被调用且没有传入b的实参时才会被执行 因此，默认参数值的赋予是在函数调用时进行的，所以，我们就可以使用先定义的参数来作为后定义的参数的初始值 1234567function test(a,b=a) &#123; console.log(a,b); // 1,1 // b形参没有传入实现值，因此会赋予形参a的值，此时a传入了实参值1，因此b也被赋予为1&#125;test(1); 但是，如果先定义的参数使用后定义的参数来作为初始值，就会发生错误 123456function test(a=b,b) &#123; console.log(a,b); // 报错： ReferenceError: Cannot access 'b' before initialization&#125;test(undefined,1); 具体原因，类似于let与const声明会具有的临时死区(TDZ) 默认参数的临时死区与let和const声明类似，默认参数也具有临时死区，在临时死区内的参数不可访问。 在参数被定义时，在预编译阶段，这些参数会被放入临时死区内，如果在运行到这些参数声明语句之前就访问这些参数，那么就会导致程序抛出错误 例： 123456function test(a=b,b) &#123; console.log(a,b); // 报错： ReferenceError: Cannot access 'b' before initialization&#125;test(undefined,1); 上述参数赋值阶段的行为类似于以下 123let a=undefined;a=b; // 此时b还在临时死区内，无法被访问let b=1;]]></content>
      <categories>
        <category>javaScript基础</category>
      </categories>
      <tags>
        <tag>基础语法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[leetcode-231 2的幂]]></title>
    <url>%2F2019%2F08%2F31%2Fleetcode-231%2F</url>
    <content type="text"><![CDATA[2的幂题目描述给定一个整数，编写一个函数来判断它是否是 2 的幂次方。 示例 1: 输入: 1输出: true解释: 20 = 1 示例 2: 输入: 16输出: true解释: 24 = 16 示例 3: 输入: 218输出: false 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/power-of-two著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 核心思路概述题目给定要求的是整数，那么也就是自然数，因为2的幂次方大于0，因此我们只要考虑大于等于1的整数即可。 对于，这些整数，我们可以将该数不断除以2，如果得到的结果不是整数，那么该数就不是2的幂次方；如果，最终得到的结果为1，那么该数就是2的幂次方 解题步骤 如果输入为0，返回false; 如果该数为1，返回true 否则，将该数除以2，如果结果不为整数，返回false；如果为整数，那么重复该步骤直到结果为1或者返回fase Coding实现1234567891011121314/** * @param &#123;number&#125; n * @return &#123;boolean&#125; */var isPowerOfTwo = function(n) &#123; if(n===0) return false; while(n) &#123; if(n===1) return true; else &#123; if(n/2!==Math.floor(n/2)) return false; &#125; n=n/2; &#125;&#125;;]]></content>
      <categories>
        <category>leetcode题解与算法</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[模板字面量]]></title>
    <url>%2F2019%2F08%2F30%2F%E6%A8%A1%E6%9D%BF%E5%AD%97%E9%9D%A2%E9%87%8F%2F</url>
    <content type="text"><![CDATA[什么是模板字面量模板字面量 是允许嵌入表达式的字符串字面量。你可以使用多行字符串和字符串插值功能。它们在ES2015规范的先前版本中被称为“模板字符串”。 基础语法12345678`string text` // 相当于普通字符串`string text line 1 string text line 2` // 多行字符串 `string text $&#123;expression&#125; string text` // 带有占位符tag `string text $&#123;expression&#125; string text` 模板字符串使用反引号 () 来代替普通字符串中的用双引号和单引号。模板字符串可以包含特定语法（${expression}）的占位符。占位符中的表达式和周围的文本会一起传递给一个默认函数，该函数负责将所有的部分连接起来，如果一个模板字符串由表达式开头，则该字符串被称为带标签的模板字符串，该表达式通常是一个函数，它会在模板字符串处理后被调用，在输出最终结果前，你都可以通过该函数来对模板字符串进行操作处理。在模版字符串内使用反引号（`）时，需要在它前面加转义符（\）。 在模板字符串中，不需要转义单双引号 多行字符串123456console.log(`abc def`); // 输出结果：abcdef 注意： 在两个反引号之间的所有空白字符串都是有效的，都属于字符串的一部分。 123456console.log(`abc def`);// 输出结果abc def 因此我们可以考虑使用第一行留白的方法来对齐缩进文本 12345678console.log(` abc def`);// 输出结果 abc def 当然我们也可以使用\n在模板字符串中显示换行 12345console.log(`abc\ndef`);// 输出结果abcdef 字符串占位符在一个模板字面量中，你可以任何合法的JavaScript表达式嵌入到占位符中并将其作为字符串中的一部分输出到结果中去 占位符由${}组成，中间可以包含任意的表达式 例： 12let name='ming';console.log(`My name is $&#123;name&#125;`); // My name is ming 除了变量，占位符还可以嵌入其他表达式，包括运算式、函数调用等等 1234567function getName()&#123; return `ming`;&#125;console.log(`My name is $&#123;getName()&#125;`); // My name is mingconsole.log(`My name is $&#123;'xiao'+'ming'&#125;`); // My name is xiaoming 嵌套模板模板字面量本身也是Js表达式，所以你可以在任意一个模板字面量里嵌入另外一个模板字面量 注意： 是另外一个模板字面量而不是占位符，即：应该是 1`$&#123;`$&#123;&#125;`&#125;` 而不是 1`&amp;&#123;&amp;&#123;&#125;&#125;` // 会报错 1console.log(`$&#123;2&gt;1?`$&#123;2&gt;1?'yes':'no'&#125;`:'no'`) // 'yes' 标签模板更高级的形式的模板字符串是带标签的模板字符串。标签使您可以用函数解析模板字符串。标签函数的第一个参数包含一个字符串值的数组。其余的参数与表达式相关。最后，你的函数可以返回处理好的的字符串（或者它可以返回完全不同的东西，）。用于该标签的函数的名称可以被命名为任何名字。 定义标签标签可以是一个函数，其函数名可以任意（符合变量命名规则） 标签函数语法： 123function tag(literals,...substitutions)&#123; // 返回一个字符串&#125; 参数解释 literals: 该参数是一个字符串数组，其包括模板字面量中占位符之前，之后，以及之间的字符串 例如，对于模板字符串${girlName},my name is ${boyName}则，其数组为[‘’,’,my name is ‘,’’] substitutions:该参数是模板字符串中所有占位符结果的值，例如以上模板字符串，则数组应该为${girlName}的值和${boyName}的值 注意 不难发现,literals数组的长度永远比substitutions数组长度多1 标签模板例子1234567891011121314151617function tag(literals,...sub)&#123; console.log(literals,sub); let ans=''; for(let i in sub) &#123; ans+=literals[i]; ans+=sub[i]; &#125; ans+=literals[literals.length-1]; return ans;&#125;let name='ming';let mes=tag`my name is $&#123;name&#125;`;console.log(mes);// 输出结果[ 'my name is ', '' ] [ 'ming' ]my name is ming]]></content>
      <categories>
        <category>javaScript基础</category>
      </categories>
      <tags>
        <tag>基础语法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[leetcode-226 翻转二叉树]]></title>
    <url>%2F2019%2F08%2F30%2Fleetcode-226%2F</url>
    <content type="text"><![CDATA[翻转二叉树题目描述翻转一棵二叉树。 示例： 输入： 输出： 备注:这个问题是受到 Max Howell 的 原问题 启发的 ： 谷歌：我们90％的工程师使用您编写的软件(Homebrew)，但是您却无法在面试时在白板上写出翻转二叉树这道题，这太糟糕了。 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/invert-binary-tree著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 核心思路概述翻转二叉树，可以利用深度优先遍历，对于二叉树来说也就是先序遍历；在遍历的同时交换其左右子树 解题步骤 如果节点为空，那么返回null 否则，交换其左右子树 递归遍历左右子树 重复1,2,3步骤直到整颗二叉树遍历完毕 Coding实现12345678910111213141516171819202122/** * Definition for a binary tree node. * function TreeNode(val) &#123; * this.val = val; * this.left = this.right = null; * &#125; *//** * @param &#123;TreeNode&#125; root * @return &#123;TreeNode&#125; */var invertTree = function(root) &#123; if(root===null) return null; else &#123; let empty=root.left; root.left=root.right; root.right=empty; invertTree(root.left); invertTree(root.right); &#125; return root;&#125;;]]></content>
      <categories>
        <category>leetcode题解与算法</category>
      </categories>
      <tags>
        <tag>树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数组扁平化]]></title>
    <url>%2F2019%2F08%2F29%2F%E6%95%B0%E7%BB%84%E6%89%81%E5%B9%B3%E5%8C%96%2F</url>
    <content type="text"><![CDATA[数组扁平化数组的扁平化，就是将一个嵌套多层的数组按照给定深度转化为原本深度减去给定深度的数组 例如： 12let arr=[1,2,[3,4]];console.log(arr.flat()); // [1,2,3,4] flat()方法概述flat() 方法会按照一个可指定的深度递归遍历数组，并将所有元素与遍历到的子数组中的元素合并为一个新数组返回。 语法 var newArray = arr.flat(depth) 参数depth(可选) 指定要提取嵌套数组的结构深度，默认值为1 返回值一个包含数组与子数组所有元素的新数组 实现数组扁平化flat()方法利用递归实现思路根据给定深度遍历，那么我们需要知道每一层数组的深度。当遍历每一层数组时，若遇到了内一层的数组，那么对该数组再执行Flat函数，也就是进行递归；若不是，则放入ans数组 代码实现123456789101112131415161718192021function Flat(arr,depth) &#123; let ans=[]; (function flat(arr,dep)&#123; dep++; if(dep&gt;depth) &#123;ans.push(arr);return;&#125; for(let i=0;i&lt;arr.length;i++) &#123; if(Array.isArray(arr[i])) &#123; flat(arr[i],dep); &#125; else &#123; if(arr[i]) ans.push(arr[i]); &#125; &#125; &#125;)(arr,-1) return ans;&#125;console.log(Flat([1,2, ,[3,4,[5,6]],[7,8,[9,10,[11,12]]]],2))// 输出结果[ 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, [ 11, 12 ] ] 利用reduce方法实现reduce方法就是遍历原数组，将每个元素利用concat方法进行拼接。因为concat方法进行拼接时会将被拼接的数组的最外层数组去掉，只取得内部的元素 12345678910111213141516171819function Flat(arr,depth)&#123; return (function flat(arr,dep) &#123; dep++; return arr.reduce((pre,cur)=&gt;&#123; if(dep&gt;=depth) &#123; return pre.concat(cur); &#125; else &#123; return Array.isArray(cur)?pre.concat(flat(cur,dep)):pre.concat(cur); &#125; &#125;,[]) &#125;)(arr,0)&#125;console.log(Flat([1,2,[3,4,[5,6,[7,8]]]],2))// 输出结果[ 1, 2, 3, 4, 5, 6, [ 7, 8 ] ] 利用toString()方法实现使用toString()方法我目前能想到的好像只能将数组完全扁平化到一维数组，而不能根据给定深度来扁平化 12345678function Flat(arr) &#123; return arr.toString().split(',').map(value=&gt;parseInt(value));&#125;console.log(Flat([1,2,[3,4,[5,6]]]));// 输出结果[ 1, 2, 3, 4, 5, 6 ] 使用展开运算符…类似于使用reduce配合concat,但是还是离不开递归]]></content>
      <categories>
        <category>javaScript基础</category>
      </categories>
      <tags>
        <tag>基础语法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[leetcode-566 重塑矩阵]]></title>
    <url>%2F2019%2F08%2F29%2Fleetcode-566%2F</url>
    <content type="text"><![CDATA[重塑矩阵题目描述在MATLAB中，有一个非常有用的函数 reshape，它可以将一个矩阵重塑为另一个大小不同的新矩阵，但保留其原始数据。 给出一个由二维数组表示的矩阵，以及两个正整数r和c，分别表示想要的重构的矩阵的行数和列数。 重构后的矩阵需要将原始矩阵的所有元素以相同的行遍历顺序填充。 如果具有给定参数的reshape操作是可行且合理的，则输出新的重塑矩阵；否则，输出原始矩阵。 示例 1: 输入:\nums = [[1,2], [3,4]]r = 1, c = 4输出: [[1,2,3,4]]解释:行遍历nums的结果是 [1,2,3,4]。新的矩阵是 1 * 4 矩阵, 用之前的元素值一行一行填充新矩阵。 示例 2: 输入: nums = [[1,2], [3,4]]r = 2, c = 4输出: [[1,2], [3,4]]解释:没有办法将 2 * 2 矩阵转化为 2 * 4 矩阵。 所以输出原矩阵。 注意： 给定矩阵的宽和高范围在 [1, 100]。 给定的 r 和 c 都是正数。 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/reshape-the-matrix著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 核心思路概述重塑矩阵，意思也就是将原先的nm矩阵转化为题目要求的rc矩阵；一种思路是我们在遍历数组的所有元素的时候就插入到rc新矩阵中；另一种思路是，将整个二维数组扁平化为一维数组，然后再转化为新的rc矩阵 解题步骤 将数组扁平化 转化为r*c矩阵 Coding实现1234567891011121314151617181920/** * @param &#123;number[][]&#125; nums * @param &#123;number&#125; r * @param &#123;number&#125; c * @return &#123;number[][]&#125; */var matrixReshape = function(nums, r, c) &#123; let ans=[]; let numsFlat=nums.flat(); if(r*c!==numsFlat.length) return nums; else &#123; for(let i=0;i&lt;r;i++) &#123; ans[i]=[]; for(let k=0;k&lt;c;k++) &#123; ans[i].push(numsFlat.shift()); &#125; &#125; &#125; return ans;&#125;;]]></content>
      <categories>
        <category>leetcode题解与算法</category>
      </categories>
      <tags>
        <tag>数组</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Javascript与简单正则表达式]]></title>
    <url>%2F2019%2F08%2F28%2FJavascript%E4%B8%8E%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[正则表达式正则表达式(regular expression)描述了一种字符串匹配的模式（pattern），可以用来检查一个串是否含有某种子串、将匹配的子串替换或者从某个串中取出符合某个条件的子串等。 Js怎么支持正则表达式Es是通过RegExp类型来支持正则表达式。 怎么创建正则表达式使用正则表达式字面量语法 let pat=/pattern/flags 其中,pattern部分是正则表达式，而flags部分是标志，可以是0或多个，其中标志包括下列三种： g: 表示全局模式，即模式将被应用到所有的字符串，而非在发现第一个匹配项时就立刻停止；若没有该标志，则表示该模式时在发现第一个匹配项时就立刻停止 i: 表示不区分大小写模式，即在确定匹配项时忽略模式与字符串的大小写 m: 表示多行模式，即在到达一行文本末尾时还会继续查找下一行中是否存在于模式匹配的项 使用RegExp构造函数创建语法 let re=new RegExp(“pattern”,”flags”); 其中，pattern与flags意义同上 正则表达式的一些相关重要方法exec()方法exec()方法是专门为捕获组而设计的。exec()接受一个参数，即要应用模式的字符串，然后返回包括第一个匹配项信息的数组；或者在没有匹配的情况下返回null 例： 123let pattern=/.at/g;let str='cat pat hat';console.oog(pattern.exec(str)); // [ 'cat', index: 0, input: 'cat pat hat', groups: undefined ] test()方法test()方法接受一个字符串参数。在模式与该参数匹配的情况下返回true;否则，返回false。经常被用于if判断语句 只要在字符串中存在某字符串能够匹配正则表达式的模式，那么就会返回true 例： 123let pattern=/.at/g;let str='cat pat hat';console.log(pattern.test(str)); // true String.match()方法match() 方法检索返回一个字符串匹配正则表达式的的结果。 语法： str.match(regexp); 参数： regexp:一个正则表达式对象。如果传入的是一个非正则表达式对象，则会隐式地使用new RegExp(obj)将其转化为一个正则表达式对象。如果没有给定任何参数，那么则会返回一个空数组 返回值： 如果使用g标志，那么则返回所有与正则表达式匹配的结果(Array)，但不会返回捕获组；或者没有匹配项返回null 如果不使用g标志，那么则返回第一个完整匹配及相关的捕获组。 例： 123let pattern=/.at/g;let str='cat pat hat';console.log(str.match(pattern)); // ['cat','pat','hat'] 元字符元字符是正则表达式的基本组成元素。 具体元字符如下： 元字符 描述 . 匹配除了换行符以外的任意字符 [] 匹配方括号中的任意一个字符,可以使用连字符’-‘来表示范围，例如 [a,b,c]可以表示为[a-c] [^] 上一个的反状态，即匹配除了括号内的任意一个字符 {n,m} 匹配前面的字符[n,m]次，即至少n次，但是不超过m次 (xyz) 相当于四则运算中常用的小括号，解释为按照确切的顺序来匹配字符xyz | 分支结构，匹配符号之前的字符或后面的字符 \ 转义符，它可以还原元字符原来的含义，允许你匹配保留元字符 * 匹配前面的子表达式0次或多次 + 匹配前面的子表达式一次或多次 ? 匹配前面的子表达式0次或一次，或指定一个非贪婪限定符 ^ 匹配行的开始 $ 匹配行的结束 \d 表示[0-9]，即1位数字 \D 表示除数字外的任意字符 \w 表示[0-9a-zA-z_]，即数字、大小写字母或下划线 \W 表示非单词字符，\w的对立 \s 表示空白符，包括空格、水平制表符、垂直制表符、换行符、回车符、换页符 \S 非空白符 如果想要匹配任意字符，根据以上元字符可以使用 \d|\D 或 [\d\D] \w|\W 或 [\w\W] \s|\S 或 [\s\S] [^] 元字符详解与例子元字符 .元字符.可以用来匹配除了换行符之外的所有单个字符 123let pattern=/.at/g;let str='cat pat hat';console.log(str.match(pattern)); // ['cat','pat','hat'] 元字符 []元字符 []用来匹配方括号内的任意一个字符 123let pattern=/[cph]at/g;let str='cat pat hat';console.log(str.match(pattern)); // ['cat','pat','hat'] 元字符 [^]元字符 [^]用来匹配除了方括号内字符的任意一个字符 123let pattern=/[^cph]at/g;let str='cat pat hat';console.log(str.match(pattern)); // null 元字符 {n,m}元字符 {n,m}用来匹配该元字符的前一个字符[n,m]次（即至少n次但不超过m次） 123let pattern=/.a&#123;1,2&#125;t/g;let str='cat paat haaat';console.log(str.match(pattern)); // ['cat','paat','aaat'] 元字符 (xyz)元字符 (xyz)我觉得其实相当于四则运算中的小括号，先执行小括号内的部分 123let pattern=/.(a|b|c)t/g;let str='cat pbt hct';console.log(str.match(pattern)); // ['cat','pbt','hct'] 元字符 |元字符 | 用来定义分支结构，分支结构就是相当于或运算。即要么执行元字符之前的字符要么执行之后的字符或者都不； 注意： 该元字符类似于或运算具有短路操作 123let pattern=/.(a|b|c)t/g;let str='cat pbt hct';console.log(str.match(pattern)); // ['cat','pbt','hct'] 1234567let pattern=/good|goodbye/g;let str='good goodbye';console.log(str.match(pattern)); // ['good','good']// 元字符 | 类似或运算具有短路操作，当前面的字符成立时就不会执行元字符之后的字符。// 上面的代码中，str字符串中的第一个'good'字符串满足正则表达式模式中的'good'，而后一个'goodbye'字符串虽然也满足'goodbye'，但是它先满足元字符之前的字符'good'，因此该运算被短路了，所以只返回了'good' 123let pattern=/goodbye|good/g;let str='good goodbye';console.log(str.match(pattern)); // ['good','goodbye'] 元字符 \元字符 \用来转义它的下一个字符。这将允许你使用保留字符来作为匹配元字符 123let pattern=/.at\./g;let str='cat\ pat/ hat.';console.log(str.match(pattern)); // ['hat.'] 元字符 *元字符 *用来匹配上一个匹配规则的0次或多次 123let pattern=/zk*/g;let str='zk z zkkk';console.log(str.match(pattern)); // [ 'zk', 'z', 'zkkk' ] 元字符 +元字符 +用来匹配上一个字符的一次或多次 123let pattern=/zk+/g;let str='zk z zkkk';console.log(str.match(pattern)); // [ 'zk','zkkk' ] 元字符 ?元字符 ?用来匹配前一个字符的0次或一次 123let pattern=/zk?/g;let str='zk z zkkk';console.log(str.match(pattern)); // [ 'zk','z','zk' ] 元字符 ^元字符 ^用来检查匹配字符是否是输入字符串的第一个字符 123let pattern=/(T|t)he/g;let str='The the';console.log(str.match(pattern)); // ['The','the'] 123let pattern=/^(T|t)he/g;let str='The the';console.log(str.match(pattern)); // ['The'] 元字符 $元字符 $用来检查匹配字符是否是输入字符串的最后一个字符 123let pattern=/.he/g;let str='The the';console.log(str.match(pattern)); // ['The','the'] 123let pattern=/.he$/g;let str='The the';console.log(str.match(pattern)); // ['the']]]></content>
      <categories>
        <category>javaScript基础</category>
      </categories>
      <tags>
        <tag>正则表达式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[leetcode-190 颠倒二进制位]]></title>
    <url>%2F2019%2F08%2F28%2Fleetcode-190%2F</url>
    <content type="text"><![CDATA[颠倒二进制位题目描述颠倒给定的 32 位无符号整数的二进制位。 示例 1： 输入: 00000010100101000001111010011100输出: 00111001011110000010100101000000解释: 输入的二进制串 00000010100101000001111010011100 表示无符号整数 43261596， 因此返回 964176192，其二进制表示形式为 00111001011110000010100101000000。 示例 2： 输入：11111111111111111111111111111101输出：10111111111111111111111111111111解释：输入的二进制串 11111111111111111111111111111101 表示无符号整数 4294967293， 因此返回 3221225471 其二进制表示形式为 10101111110010110010011101101001。 提示： 请注意，在某些语言（如 Java）中，没有无符号整数类型。在这种情况下，输入和输出都将被指定为有符号整数类型，并且不应影响您的实现，因为无论整数是有符号的还是无符号的，其内部的二进制表示形式都是相同的。 在 Java 中，编译器使用二进制补码记法来表示有符号整数。因此，在上面的 示例 2 中，输入表示有符号整数 -3，输出表示有符号整数 -1073741825。 进阶:如果多次调用这个函数，你将如何优化你的算法？ 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/reverse-bits著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 核心思路概述输入的会是一个无符号整数可以转化为32位二进制表示；要求输出的是反转该32位二进制并转化为整数输出 解题步骤 利用模二取余法得到32位二进制数 将32位二进制数反转后转化为整数并返回 Coding实现1234567891011121314151617/** * @param &#123;number&#125; n - a positive integer * @return &#123;number&#125; - a positive integer */var reverseBits = function(n) &#123; let s=[]; while(n) &#123; s.unshift(n%2); n=Math.floor(n/2); &#125; while(s.length&lt;32) &#123; s.unshift(0); &#125; return s.reduce((pre,cur,curIndex)=&gt;&#123; return pre+cur*Math.pow(2,curIndex); &#125;,0)&#125;;]]></content>
      <categories>
        <category>leetcode题解与算法</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[全局变量的声明以及如何避免声明全局变量]]></title>
    <url>%2F2019%2F08%2F27%2F%E5%85%A8%E5%B1%80%E5%8F%98%E9%87%8F%E7%9A%84%E5%A3%B0%E6%98%8E%E4%BB%A5%E5%8F%8A%E5%A6%82%E4%BD%95%E9%81%BF%E5%85%8D%E5%A3%B0%E6%98%8E%E5%85%A8%E5%B1%80%E5%8F%98%E9%87%8F%2F</url>
    <content type="text"><![CDATA[全局变量的声明 全局变量会成为全局对象的属性 那种方式的变量声明会形成全局变量呢？ Javascript运行环境分为浏览器环境和非浏览器环境（比如Node.js） 在浏览器环境中,有三种方式可以声明全局变量 使用var关键字在全局作用域下显示声明 不适用任何声明关键字(var,let,const)直接给变量赋值，这属于隐式声明 使用全局对象作为其属性来声明 浏览器环境中（全局对象为window对象） 123456a=1;var b=2;window.c=3;console.log(a===window.a); // trueconsole.log(b===window.b); // trueconsole.log(c); // 3 但是，在Node.js中，上述方法中的方法2就不成立 Node.js环境（全局对象为global对象) 123456a=1;var b=2;global.c=3;console.log(a===global.a); // trueconsole.log(b===global.b); // falseconsole.log(c===global.c); // 3 如何避免声明全局变量使用let与const声明关键字 如果你在全局作用域中使用let或const来声明变量，那么会在全局作用域下创建一个新的绑定，但该绑定不会添加为全局对象的属性。 换句话说，用let或const不能覆盖全局变量，而只能遮蔽它 浏览器环境中 12345678910window.a=1;var a=2;console.log(a); // 2 全局对象的属性a被var声明修改了console.log(a===window.a); // truewindow.b=1;let b=2;console.log(b); // 2console.log(b===window.b); // false// b不是全局变量，因为使用let声明的b没有成为全局对象的属性 总结如果不想为全局变量创建属性或修改全局变量的属性，那么使用let和const要安全的多]]></content>
      <categories>
        <category>javaScript基础</category>
      </categories>
      <tags>
        <tag>基础语法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Js中的字符与Unicode编码操作]]></title>
    <url>%2F2019%2F08%2F27%2FJs%E4%B8%AD%E7%9A%84%E5%AD%97%E7%AC%A6%E4%B8%8EUnicode%E7%BC%96%E7%A0%81%E6%93%8D%E4%BD%9C%2F</url>
    <content type="text"><![CDATA[字符转化为Unicode编码charAt()概述charAt() 方法从一个字符串中返回指定的字符。 语法 str.charAt(index) 参数： index: 一个介于0和字符转长度减1之间的整数。即0~str.length-1。如果没有提供索引值，那么index默认为0，即第一位 返回值： 返回值是一个根据给定索引的指定字符；如果，给定值超过了上述的要求范围（0~str.length-1），那么该方法返回一个空字符串 例子12345let str='abc'console.log(str.charAt()); // 'a'console.log(str.charAt(1)); // 'b'console.log(str.charAt(2)); // 'c'console.log(str.charAt(7)); // '' charCodeAt()概述charCodeAt()方法 返回给定索引处（String中index索引处）字符的 UTF-16 代码单元值的数字 语法 str.charCodeAt(index) 参数 index:一个大于等于0，小于字符串长度的整数。如果不是一个数值，则默认为0 返回值 返回值是一表示给定索引处（String中index索引处）字符的 UTF-16 代码单元值的数字；如果索引超出范围，则返回 NaN。 例子123456let str1='a';console.log(str1.charCodeAt()); // 97let str2='abc';console.log(str2.charCodeAt(0)); // 97console.log(str2.charCodeAt(1)); // 98console.log(str2.charCodeAt(7)); // NaN Unicode编码转化为字符String.fromCharCode()概述静态 String.fromCharCode() 方法返回由指定的UTF-16代码单元序列创建的字符串。 语法 String.fromCharCode(num1, …, numN) 参数 num1, …, numN一系列UTF-16代码单元的数字。 范围介于0到65535（0xFFFF）之间。 大于0xFFFF的数字将被截断。 不进行有效性检查。 返回值 一个长度为N的字符串，由N个指定的UTF-16代码单元组成；如果不给定参数，那么则返回空字符串 例子123console.log(String.fromCharCode(97)); 'a'console.log(String.fromCharCode(97,98,99)) // 'abc'console.log(String.fromCharCode()); // '']]></content>
      <categories>
        <category>javaScript基础</category>
      </categories>
      <tags>
        <tag>基础语法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[leetcode-168 Excel表列名称]]></title>
    <url>%2F2019%2F08%2F27%2Fleetcode-168%2F</url>
    <content type="text"><![CDATA[Excel表列名称题目描述给定一个正整数，返回它在 Excel 表中相对应的列名称。 例如， 1 -&gt; A 2 -&gt; B 3 -&gt; C ... 26 -&gt; Z 27 -&gt; AA 28 -&gt; AB ...示例 1: 输入: 1输出: “A” 示例 2: 输入: 28输出: “AB” 示例 3: 输入: 701输出: “ZY” 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/excel-sheet-column-title著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 核心思路概述题目要求的是1~26对应的是A~Z，然而如果使用进制来表示的话，我们一般习惯使用0开始的。因此，我们可以用0~25来表示A~Z；这样，我们之后在利用类似二进制中的模二取余法时就可以避免遇到余数0没有对应值的问题。 那么，对于输入值，每次取余时我们就应该讲值减去一之后再进行取余。这样就可以将0~25对应到输入值 解题步骤 建立哈希表，将025作为键，对应到AZ的键值 使用类似二进制的模二取余法，将给定值取余；每次取余先将值减一；取得的余数放入unshift入队列数组中 遍历队列数组，从哈希表中取出对应的键值，添加到字符串ans中 返回ans Coding实现123456789101112131415161718192021/** * @param &#123;number&#125; n * @return &#123;string&#125; */var convertToTitle = function(n) &#123; let map=new Map(); let queue=[]; let ans=''; for(let i=0;i&lt;26;i++) &#123; map.set(i,String.fromCharCode(65+i)); &#125; while(n) &#123; n--; queue.unshift(n%26); n=Math.floor(n/26); &#125; queue.forEach(value=&gt;&#123; ans+=map.get(value); &#125;) return ans;&#125;;]]></content>
      <categories>
        <category>leetcode题解与算法</category>
      </categories>
      <tags>
        <tag>哈希表</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[leetcode-811 子域名访问计数]]></title>
    <url>%2F2019%2F08%2F26%2Fleetcode-811%2F</url>
    <content type="text"><![CDATA[子域名访问计数题目描述一个网站域名，如”discuss.leetcode.com”，包含了多个子域名。作为顶级域名，常用的有”com”，下一级则有”leetcode.com”，最低的一级为”discuss.leetcode.com”。当我们访问域名”discuss.leetcode.com”时，也同时访问了其父域名”leetcode.com”以及顶级域名 “com”。 给定一个带访问次数和域名的组合，要求分别计算每个域名被访问的次数。其格式为访问次数+空格+地址，例如：”9001 discuss.leetcode.com”。 接下来会给出一组访问次数和域名组合的列表cpdomains 。要求解析出所有域名的访问次数，输出格式和输入格式相同，不限定先后顺序。 示例 1: 输入: [“9001 discuss.leetcode.com”]输出: [“9001 discuss.leetcode.com”, “9001 leetcode.com”, “9001 com”]说明: 例子中仅包含一个网站域名：”discuss.leetcode.com”。按照前文假设，子域名”leetcode.com”和”com”都会被访问，所以它们都被访问了9001次。 示例 2 输入: [“900 google.mail.com”, “50 yahoo.com”, “1 intel.mail.com”, “5 wiki.org”]输出: [“901 mail.com”,”50 yahoo.com”,”900 google.mail.com”,”5 wiki.org”,”5 org”,”1 intel.mail.com”,”951 com”]说明: 按照假设，会访问”google.mail.com” 900次，”yahoo.com” 50次，”intel.mail.com” 1次，”wiki.org” 5次。而对于父域名，会访问”mail.com” 900+1 = 901次，”com” 900 + 50 + 1 = 951次，和 “org” 5 次。 注意事项： cpdomains 的长度小于 100。 每个域名的长度小于100。 每个域名地址包含一个或两个”.”符号。 输入中任意一个域名的访问次数都小于10000。 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/subdomain-visit-count著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 核心思路概述题目给定包含一系列域名和访问次数的字符串数组。对于每个域名字符串，我们可以从后往前遍历该字符串，当遇到’.’或者到达最前端时，将’.’之后部分或全部字符串放入哈希表中并存放次数；当遇到，哈希表中已经存在该键时，则更新该键值 解题步骤 建立哈希表以及ans数组 遍历字符串数组，取当前字符串赋为s 将s分为次数count和域名domains两部分 遍历domains字符串。当遇到’.’或者到达最前端时，将’.’之后部分或全部字符串放入哈希表中并存放次数；当遇到，哈希表中已经存在该键时，则更新该键值 重复3、4直到字符串数组遍历完毕 遍历哈希表，将键值和键名合成字符串放入ans数组中 返回ans Coding实现1234567891011121314151617181920212223242526272829303132333435/** * @param &#123;string[]&#125; cpdomains * @return &#123;string[]&#125; */var subdomainVisits = function(cpdomains) &#123; if(cpdomains.length===0) return []; let map=new Map(); let ans=[]; for(let i=0;i&lt;cpdomains.length;i++) &#123; let s=cpdomains[i]; let count=s.split(' ')[0]; let domains=s.split(' ')[1]; let k=domains.length-1; while(k&gt;=0) &#123; if(domains[k]==='.'||k===0) &#123; let domain; if(k===0) &#123; domain=domains.slice(k); &#125; else domain=domains.slice(k+1); if(!map.has(domain)) &#123; map.set(domain,parseInt(count)); &#125; else &#123; map.set(domain,map.get(domain)+parseInt(count)); &#125; &#125; k--; &#125; &#125; map.forEach((value,key)=&gt;&#123; ans.push(value+' '+key); &#125;) return ans;&#125;;]]></content>
      <categories>
        <category>leetcode题解与算法</category>
      </categories>
      <tags>
        <tag>哈希表</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[leetcode-160 相交链表]]></title>
    <url>%2F2019%2F08%2F25%2Fleetcode-160%2F</url>
    <content type="text"><![CDATA[相交链表题目描述编写一个程序，找到两个单链表相交的起始节点。 如下面的两个链表： 在节点 c1 开始相交。 示例 1： 输入：intersectVal = 8, listA = [4,1,8,4,5], listB = [5,0,1,8,4,5], skipA = 2, skipB = 3输出：Reference of the node with value = 8输入解释：相交节点的值为 8 （注意，如果两个列表相交则不能为 0）。从各自的表头开始算起，链表 A 为 [4,1,8,4,5]，链表 B 为 [5,0,1,8,4,5]。在 A 中，相交节点前有 2 个节点；在 B 中，相交节点前有 3 个节点。 示例 2： 输入：intersectVal = 2, listA = [0,9,1,2,4], listB = [3,2,4], skipA = 3, skipB = 1输出：Reference of the node with value = 2输入解释：相交节点的值为 2 （注意，如果两个列表相交则不能为 0）。从各自的表头开始算起，链表 A 为 [0,9,1,2,4]，链表 B 为 [3,2,4]。在 A 中，相交节点前有 3 个节点；在 B 中，相交节点前有 1 个节点。 示例 3： 输入：intersectVal = 0, listA = [2,6,4], listB = [1,5], skipA = 3, skipB = 2输出：null输入解释：从各自的表头开始算起，链表 A 为 [2,6,4]，链表 B 为 [1,5]。由于这两个链表不相交，所以 intersectVal 必须为 0，而 skipA 和 skipB 可以是任意值。解释：这两个链表不相交，因此返回 null。 注意： 如果两个链表没有交点，返回 null. 在返回结果后，两个链表仍须保持原有的结构。 可假定整个链表结构中没有循环。 程序尽量满足 O(n) 时间复杂度，且仅用 O(1) 内存。 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/intersection-of-two-linked-lists著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 核心思路因为题目要求使用O(1)内存，那么显然就不能使用多余的数组。并且程序尽量满足O(n)时间复杂度。因此，解法有二： 哈希表法 哈希表的内存占用为O(1)，遍历第一条链表，将链表内的所有节点存入哈希表中。再遍历第二条链表，如果遇到某节点存在于哈希表中，那么就将结果返回 双指针 创建两个指针 pA 和 pB，分别初始化为链表 A 和 B 的头结点。然后让它们向后逐结点遍历。当 pA 到达链表的尾部时，将它重定位到链表 B 的头结点 (你没看错，就是链表 B); 类似的，当 pB 到达链表的尾部时，将它重定位到链表 A 的头结点。若在某一时刻 pApA 和 pBpB 相遇，则 pApA/pBpB 为相交结点。（原因如下，若两链表相交，那么相交部分加上两链表之前未相交部分的和是一定的。那么若能相交，这样子移动指针必能相遇） 解题步骤coding实现哈希表法 123456789101112131415161718192021222324252627/** * Definition for singly-linked list. * function ListNode(val) &#123; * this.val = val; * this.next = null; * &#125; *//** * @param &#123;ListNode&#125; headA * @param &#123;ListNode&#125; headB * @return &#123;ListNode&#125; */var getIntersectionNode = function(headA, headB) &#123; let map=new Map(); let cur=headA; while(cur) &#123; map.set(cur,1); cur=cur.next; &#125; cur=headB; while(cur) &#123; if(map.has(cur)) return cur; cur=cur.next; &#125; return null;&#125;; 双指针法 123456789101112131415161718192021222324252627282930313233343536/** * Definition for singly-linked list. * function ListNode(val) &#123; * this.val = val; * this.next = null; * &#125; *//** * @param &#123;ListNode&#125; headA * @param &#123;ListNode&#125; headB * @return &#123;ListNode&#125; */var getIntersectionNode = function(headA, headB) &#123; let top=headA; let down=headB; let bool=false; while(top&amp;&amp;down) &#123; if(top===down) return top; if(top.next===null) &#123; top=headB; bool=!bool; if(bool===false) return null; &#125; else &#123; top=top.next; &#125; if(down.next===null) &#123; down=headA; &#125; else &#123; down=down.next; &#125; &#125; return null;&#125;;]]></content>
      <categories>
        <category>leetcode题解与算法</category>
      </categories>
      <tags>
        <tag>链表</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[leetcode-268 缺失数字]]></title>
    <url>%2F2019%2F08%2F24%2Fleetcode-268%2F</url>
    <content type="text"><![CDATA[缺失数字题目描述给定一个包含 0, 1, 2, …, n 中 n 个数的序列，找出 0 .. n 中没有出现在序列中的那个数。 示例 1: 输入: [3,0,1]输出: 2 示例 2: 输入: [9,6,4,2,3,5,7,0,1]输出: 8 说明:你的算法应具有线性时间复杂度。你能否仅使用额外常数空间来实现? 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/missing-number著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 核心思路概述 第一种方法是将数组排序后再遍历，如果某个数与下标不相同的话，那么那个下标就是缺失的数 第二种方法是利用哈希表，在第一次遍历数组时将值记录在哈希表中。然后从0遍历到n，查看每个数是否在哈希表中，若无，则是缺失的数 第三种方法，是将0~n的和减去数组的和就是缺失的数 第四种方法，利用位运算（待补充） 解题步骤步骤易懂，直接贴代码 Coding实现第一种方法：排序遍历 12345678910/** * @param &#123;number[]&#125; nums * @return &#123;number&#125; */var missingNumber = function(nums) &#123; nums.sort((a,b)=&gt;a-b); for(let i=0;i&lt;=nums.length;i++) &#123; if(i!==nums[i]) return i; &#125;&#125;; 第二种方法：哈希表存值 12345678910111213/** * @param &#123;number[]&#125; nums * @return &#123;number&#125; */var missingNumber = function(nums) &#123; let map=new Map(); for(let i=0;i&lt;nums.length;i++) &#123; map.set(nums[i],1); &#125; for(let i=0;i&lt;=nums.length;i++) &#123; if(!map.has(i)) return i; &#125; &#125;; 第三种方法：数组求和 12345678910/** * @param &#123;number[]&#125; nums * @return &#123;number&#125; */var missingNumber = function(nums) &#123; let sum=nums.reduce((pre,value)=&gt;&#123; return pre+value; &#125;,0) return ((0+nums.length)*(nums.length+1)/2)-sum;&#125;; 第四种方法：位运算 12]]></content>
      <categories>
        <category>leetcode题解与算法</category>
      </categories>
      <tags>
        <tag>数组</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[leetcode-121 买卖股票的最佳时机]]></title>
    <url>%2F2019%2F08%2F23%2Fleetcode-121%2F</url>
    <content type="text"><![CDATA[买卖股票的最佳时机题目描述给定一个数组，它的第 i 个元素是一支给定股票第 i 天的价格。 如果你最多只允许完成一笔交易（即买入和卖出一支股票），设计一个算法来计算你所能获取的最大利润。 注意你不能在买入股票前卖出股票。 示例 1: 输入: [7,1,5,3,6,4]输出: 5解释: 在第 2 天（股票价格 = 1）的时候买入，在第 5 天（股票价格 = 6）的时候卖出，最大利润 = 6-1 = 5 。注意利润不能是 7-1 = 6, 因为卖出价格需要大于买入价格。 示例 2: 输入: [7,6,4,3,1]输出: 0解释: 在这种情况下, 没有交易完成, 所以最大利润为 0。 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 核心思路如果使用暴力解法，对每一天作为买入天进行遍历，再遍历每一天的后面的几天，找到差值最大的天数，这样就会有O(n^2)的时间复杂度。那么，一次遍历可以解决吗？ 当然，我们换一种思路，加入第一次遍历不把它当做买入天，而是当做卖出天。那么，我们只要找到当前天之前的那几天中价格最小的即可。而这最小价格，我们可以设定一个min，在遍历中不断改变。 解题步骤 设定min为第一天价格，最大差值max=0 从第二天开始遍历，因为卖出天需要在买入天之后，如果当前天的股票价格大于min，那么求得差价与max比较，赋予max较大值；若小于min，那么将当日股票价格赋予min 循环结束，返回max coding实现123456789101112131415/** * @param &#123;number[]&#125; prices * @return &#123;number&#125; */var maxProfit = function(prices) &#123; let min=prices[0]; let max=0; for(let i=1;i&lt;prices.length;i++)&#123; if(prices[i]&gt;min) &#123; max=max&gt;prices[i]-min?max:prices[i]-min; &#125; else min=prices[i]; &#125; return max;&#125;;]]></content>
      <categories>
        <category>leetcode题解与算法</category>
      </categories>
      <tags>
        <tag>数组</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[leetcode-119]]></title>
    <url>%2F2019%2F08%2F22%2Fleetcode-119%2F</url>
    <content type="text"><![CDATA[题目类似与leetcode-118 杨辉三角 不解释，直接上代码 123456789101112131415/** * @param &#123;number&#125; rowIndex * @return &#123;number[]&#125; */var getRow = function(rowIndex) &#123; let arr=[[1]]; for(let i=1;i&lt;=rowIndex;i++) &#123; arr[i]=[]; arr[i][0]=arr[i][i]=1; for(let k=1;k&lt;i;k++) &#123; arr[i][k]=arr[i-1][k-1]+arr[i-1][k]; &#125; &#125; return arr[rowIndex];&#125;;]]></content>
      <categories>
        <category>leetcode题解与算法</category>
      </categories>
      <tags>
        <tag>数组</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[闭包]]></title>
    <url>%2F2019%2F08%2F22%2F%E9%97%AD%E5%8C%85%2F</url>
    <content type="text"><![CDATA[什么是闭包闭包，实际上也是个函数，只不过他的外部被另外一个函数包围。因此，在一个函数内部创建另一个函数，就会产生闭包。 红宝书是这么定义的： 闭包是指有权访问另一个函数作用域中的变量的函数 那么这段话又该如何理解？ 执行环境分为全局执行环境和局部执行环境。全局执行环境永远存在于某条作用域链的最末端。那么，局部执行环境呢？当进入某个函数时，该函数的局部执行环境就会被压入环境栈，同时会生成一个存储当前环境所有变量、函数的活动对象。 因此，在一个函数中创建了另外一个函数，那么内部那个函数的作用域链上就包含了外部函数的活动对象，而该活动对象又具有其作用域中的所有的变量 来看一个例子： 12345678function test()&#123; let a=1; return function ()&#123; console.log(a); &#125;&#125;test()(); // 1console.log(a); // ReferenceError: a is not defined 我们首先在全局作用域下创建了一个test函数，在当前作用域中定义了a变量为1；然后在内部定义了一个新的匿名函数并返回； 从输出上，我们很容易就能验证闭包的特性。闭包的作用域链包含着自己的作用域，以及外部函数的作用域直到全局作用域 定时器与闭包我们经常可以看到这样的例子 123456for(var i=0;i&lt;10;i++)&#123; setTimeout(function ()&#123; console.log(i); // 10个10 后输出 &#125;,1000)&#125;console.log('i',i); // i 10 先输出 初学者们一般都会以为会按照0~9的顺序依次输出，然而并不是，它会打印出10个10. 那么，这又是为什么呢？ 定时器的作用是当定时器到期时，会执行传入定时器的函数； 我们往该函数中传入了一个新的匿名函数去打印i；那么对于该段代码，定时器中的匿名函数会在全局作用中被执行。因袭该匿名函数的作用域链会是其自身的作用域以及全局作用域 我们需要注意的是，在定时器开始启动之前，这10次循环已经结束了，相当于已经创建了10个还未执行的定时器，于此同时i已经变为了10 在执行定时器时，也就是每1000毫秒要去执行一次匿名函数。匿名函数就会顺着作用域去寻找i，那么，显然它会在全局作用域中找到i为10，所以也就会输出10个10了 那么如果我们顺着作用域链查找的思路稍微修改一下代码 1234567for(var i=0;i&lt;10;i++)&#123; setTimeout(function ()&#123; i=1; console.log(i); // 10个1 后输出 &#125;,1000)&#125;console.log('i',i); // i 10 先输出 显然，查找作用域链时在自身作用域中就找到了i，因此不会再向上查找位于全局作用域的i 定时器函数的优化我们已经发现了以上那个函数并不能达到想要的效果。本质上是因为作用域链的缘故。 那么使用es6的let就可以解决这个问题 let会将当前变量的作用域限制在当前代码块内，因此，上面的10次循环就会形成10个作用域，每一个函数都能够查找到正确的i 12345678910111213for(let i=0;i&lt;10;i++)&#123; setTimeout(function ()&#123; console.log(i); // 0~9 &#125;,1000)&#125;// 执行以上代码会是如下情形&#123;i=0;setTimeout();&#125;...&#123;i=9;setTimeout();&#125; 如果，此时在全局作用域下去执行console.log(i)；会报出错误i为定义。因为，全局作用下并没有定义i 闭包的应用私有变量闭包的主要应用是设计私有变量 任何在函数中定义的变量，都可以被认为是私有变量，因为不能在函数外部访问这些变量。 私有变量包括函数的参数，局部变量和在函数内部定义的其他函数 然而，闭包可以通过自身的作用域链访问到这些私有变量。因此我们经常利用闭包来创建用于访问私有变量的共有方法，又被称之为特权方法。 例如： 1234567891011121314function Person(name) &#123; // 私有变量 let rigion='Hang Zhou' // 特权方法 this.get=function ()&#123; return rigion; &#125;&#125;let ming=new Person('ming');console.log(ming); // Person &#123; get: [Function] &#125;console.log(ming.get()); // Hang Zhouconsoel.log(ming.rigion); // undefined 这个Person构造函数不同于一般的构造函数，一般的构造函数会像下例一样声明属性与方法 12345678910function Person(name) &#123; // 公有属性 this.rigion='Hang Zhou'&#125;let ming=new Person('ming');console.log(ming.rigion); // 'Hang Zhou'ming.rigion='Shang Hai';console.log(ming.rigion); // 'Shang Hai'// 此时rigion属性是公有属性，实例化之后可以直接访问和修改 而该构造函数创建的实例并不会直接添加私有变量到实例的属性上，而是需要通过get()方法去访问。此时get()方法是一个闭包，其作用链上拥有外部构造函数的作用域，因此可以访问到私有变量 模块模式模块模式是用来为单例创建私有变量和特权方法的。所谓单例，指的就是只有一个实例的对象 12345678910111213141516function Person()&#123; // 私有变量和私有函数 let rigion='Hang Zhou'; let get=function ()&#123; return rigion; &#125; // 特权方法和属性 return &#123; get:get &#125;&#125;let ming=new Person();console.log(ming); // &#123; get: [Function: get] &#125;console.log(ming.get()); // 'Hang Zhou' 闭包的缺陷一般来说，一个函数执行完毕后，会销毁其作用域及其变量对象；但是，在创建了一个闭包以后，这个函数的的作用域会一直保存到闭包不存在（手动令这个闭包函数为null）为止。 在javascript中，如果一个对象不再被引用，那么这个对象就会被垃圾回收机制回收； 如果两个对象互相引用，而不再被第3者所引用，那么这两个互相引用的对象也会被回收。有些闭包可能会被返回到全局作用域被执行 因此，闭包会携带包含它的函数的作用域，从而会占用比其他函数更多的内存。过得使用闭包会导致内存占用过多。]]></content>
      <categories>
        <category>javaScript基础</category>
      </categories>
      <tags>
        <tag>基础语法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[滑动窗口]]></title>
    <url>%2F2019%2F08%2F21%2F%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%2F</url>
    <content type="text"><![CDATA[什么是滑动窗口算法滑动窗口可以看做是一个区间。但是，这个区间是可以动态变化的。可以左右移动，也可以变大或变小 例如，假如有一个字符串为’abcabcbb’，那么对于大小为5的滑动窗口在该字符串上滑动，则有 1234abcab bcabc cabcb abcbb 滑动窗口，在我理解看来无非是一种用来大幅降低时间复杂度的算法。在某一个字符串或者一个数组中，要找到某个子字符串或者子数组来满足某些条件，那么利用滑动窗口便可以将时间复杂度降低到O(n) 用什么来实现滑动窗口leetcode题目引入题目引入：leetcode-3 无重复字符的最长子串给定一个字符串，请你找出其中不含有重复字符的 最长子串 的长度。 示例 1:输入: “abcabcbb”输出: 3 解释: 因为无重复字符的最长子串是 “abc”，所以其长度为 3。 示例 2:输入: “bbbbb”输出: 1解释: 因为无重复字符的最长子串是 “b”，所以其长度为 1。 示例 3:输入: “pwwkew”输出: 3解释: 因为无重复字符的最长子串是 “wke”，所以其长度为 3。 请注意，你的答案必须是 子串 的长度，”pwke” 是一个子序列，不是子串。 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/longest-substring-without-repeating-characters著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 解决思路如果使用常规的暴力解法。因为要找到一个字符串没有任何重复字符且是最长的。那么，很容易想到，找到以该字符串的每个字符为开头的最长无重复字符的字符串，然后比较那个字符串更长返回即可。思路很简单，但是，稍加考虑就会发现这样的时间复杂度会达到O(n^2)，很可能无法通过题目要求的时间限制 那么，滑动窗口呢。照着暴力解法的思路，在外循环遍历每一个字符时，如果遇到了与子串中已经重复的字符那么就会停止内循环遍历下去（因为这会是以当前字符为开头的最长子串）。按照暴力的思路，接下来我们会以外循环中的下一个字符来开始内循环。那么，我们很容易就会发现一个问题，倘若那个重复字符并不是外循环中立即接下去的那一个呢，那么遇到那个重复字符，我们依然要停下来。因此，我们可以直接滑动窗口到那个重复字符的后一位，再接着遍历后面的字符 队列来实现滑动窗口我们很容易可以想到利用队列来实现滑动窗口，当该窗口向右移动时，左边不需要的元素只要shift()移除队列即可 对于上题的队列实现滑动窗口解法 1234567891011121314151617181920/** * @param &#123;string&#125; s * @return &#123;number&#125; */var lengthOfLongestSubstring = function(s) &#123; if(s.length===0) return s.length; let maxLength=0; let queue=[]; for(let v of s)&#123; if(queue.includes(v)) &#123; while(queue[0]!==v) &#123; queue.shift() &#125; queue.shift(); &#125; queue.push(v); maxLength=queue.length&gt;maxLength?queue.length:maxLength; &#125; return maxLength;&#125;; 双指针来实现滑动窗口滑动窗口不过就是个动态的区间，那么使用双指针来表示区间也是不错的选择。而且对于队列滑动只能一格一格滑动，而双指针可以直接滑动多格 使用双指针来实现核心就是，要找到该次滑动的终点位置 123456789101112131415161718192021/** * @param &#123;string&#125; s * @return &#123;number&#125; */var lengthOfLongestSubstring = function(s) &#123; if(s.length===0) return s.length; let maxLength=0; let left=0; let right=0; let arr=[]; for(let v of s) &#123; if(arr.includes(v)) &#123; let index=s.indexOf(v,left); left=index+1; &#125; right++; arr=s.slice(left,right); maxLength=arr.length&gt;maxLength?arr.length:maxLength; &#125; return maxLength;&#125;; 双指针实现的优化：利用哈希表map来使字符搜索时间复杂度降至为O(1)上面的解法中，找到重复字符的位置，利用了indexOf()函数，实际上该函数的时间复杂度为O(n)，但是，如果在遍历的同时将字符下标不断更新的话，那么查找起来时间复杂度就会变为O(1) 这也是常用的以空间换时间的策略 1234567891011121314151617181920212223/** * @param &#123;string&#125; s * @return &#123;number&#125; */var lengthOfLongestSubstring = function(s) &#123; if(s.length===0) return s.length; let maxLength=0; let left=0; let right=0; let arr=[]; let map=new Map(); for(let i=0;i&lt;s.length;i++) &#123; if(arr.includes(s[i])) &#123; let index=map.get(s[i]); left=index+1; &#125; map.set(s[i],i) right++; arr=s.slice(left,right); maxLength=arr.length&gt;maxLength?arr.length:maxLength; &#125; return maxLength;&#125;; 当然，对于队列也可以像这样进行优化]]></content>
      <categories>
        <category>算法笔记</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[leetcode-112 路径总和]]></title>
    <url>%2F2019%2F08%2F21%2Fleetcode-112%2F</url>
    <content type="text"><![CDATA[路径总和题目描述给定一个二叉树和一个目标和，判断该树中是否存在根节点到叶子节点的路径，这条路径上所有节点值相加等于目标和。 说明: 叶子节点是指没有子节点的节点。 示例:给定如下二叉树，以及目标和 sum = 22， 5 / \ 4 8 / / \ 11 13 4 / \ \ 7 2 1返回 true, 因为存在目标和为 22 的根节点到叶子节点的路径 5-&gt;4-&gt;11-&gt;2。 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/path-sum著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 核心思路概述求根节点到叶子节点上的路径和，利用深度优先搜索（DFS）即可做到。当遍历到某节点时，若该节点不为空就加上该节点的值，如果遇到是叶子节点，那么就说明一条路径已经出现。比较该路径和与给定sum,若相同则返回true;否则返回false 解题步骤递归 递归式 return test(root.left,count)||test(root.right,count); 或运算是短路运算 递归终止条件： 该节点为null，返回false 该节点为叶子节点，如果路径和等于给定sum返回true,否则返回false Coding实现1234567891011121314151617181920212223/** * Definition for a binary tree node. * function TreeNode(val) &#123; * this.val = val; * this.left = this.right = null; * &#125; *//** * @param &#123;TreeNode&#125; root * @param &#123;number&#125; sum * @return &#123;boolean&#125; */var hasPathSum = function(root, sum) &#123; return (function test(root,count) &#123; if(root===null) return false; count+=root.val; if(root.left===null&amp;&amp;root.right===null) &#123; if(count===sum) return true; else return false; &#125; return test(root.left,count)||test(root.right,count); &#125;)(root,0)&#125;;]]></content>
      <categories>
        <category>leetcode题解与算法</category>
      </categories>
      <tags>
        <tag>树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[leetcode-111]]></title>
    <url>%2F2019%2F08%2F20%2Fleetcode-111%2F</url>
    <content type="text"><![CDATA[二叉树的层次遍历 II题目描述给定一个二叉树，找出其最小深度。 最小深度是从根节点到最近叶子节点的最短路径上的节点数量。 说明: 叶子节点是指没有子节点的节点。 示例: 给定二叉树 [3,9,20,null,null,15,7], 返回它的最小深度 2. 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/minimum-depth-of-binary-tree著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 核心思路概述关于二叉树的最小深度，我们可以考虑利用广度优先搜索，在这里即层序遍历的思想。当遍历到第一个叶子节点时，返回其深度即可。因为，层序遍历是从定至下，从左至右遍历的，所以遍历到的第一个叶子节点的深度必定是二叉树的最小深度 解题步骤 利用队列queue来实现层序遍历，为根节点设置属性depth=0； 判断当前节点是否有左右子树，若有，则左右子树的根节点的属性depth=当前节点的属性depth值+1；并且将子树入队列； 若没有，则返回该节点的深度 重复2,3步骤 Coding实现123456789101112131415161718192021222324252627282930/** * Definition for a binary tree node. * function TreeNode(val) &#123; * this.val = val; * this.left = this.right = null; * &#125; *//** * @param &#123;TreeNode&#125; root * @return &#123;number&#125; */var minDepth = function(root) &#123; if(root===null) return 0; else &#123; let queue=[root]; root.depth=1; while(queue.length!==0) &#123; let key=queue.shift(); if(!key.left&amp;&amp;!key.right) return key.depth; if(key.left) &#123; key.left.depth=key.depth+1; queue.push(key.left); &#125; if(key.right) &#123; key.right.depth=key.depth+1; queue.push(key.right); &#125; &#125; &#125;&#125;;]]></content>
      <categories>
        <category>leetcode题解与算法</category>
      </categories>
      <tags>
        <tag>树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[leetcode-107 二叉树的层次遍历 II]]></title>
    <url>%2F2019%2F08%2F19%2Fleetcode-107%2F</url>
    <content type="text"><![CDATA[二叉树的层次遍历 II题目描述给定一个二叉树，返回其节点值自底向上的层次遍历。 （即按从叶子节点所在层到根节点所在的层，逐层从左向右遍历） 例如： 给定二叉树 [3,9,20,null,null,15,7], 返回其自底向上的层次遍历为： [ [15,7], [9,20], [3]] 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/binary-tree-level-order-traversal-ii著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 核心思路概述返回节点值自底部向上的遍历，也就是相当于节点值自顶部向下的遍历的倒转；那么，利用队列将二叉树进行层序遍历的同时，为节点添加depth属性（表示这为第几层）；根据depth值，添加到对应的二维数组ans中;最后，返回ans数组的倒序 解题步骤 利用队列queue来实现层序遍历，为根节点设置属性depth=0； 判断ans数组的key.depth项是否为数组，若是则直接将该值加入数组；若不是，则创建数组[key] 判断当前节点是否有左右子树，若有，则左右子树的根节点的属性depth=当前节点的属性depth值+1；并且将子树入队列； 重复2,3步骤直到queue为空 返回ans.reverse() Coding实现1234567891011121314151617181920212223242526272829303132333435363738/** * Definition for a binary tree node. * function TreeNode(val) &#123; * this.val = val; * this.left = this.right = null; * &#125; *//** * @param &#123;TreeNode&#125; root * @return &#123;number[][]&#125; */var levelOrderBottom = function(root) &#123; let ans=[]; if(root===null) return ans; else &#123; let queue=[]; queue.push(root); root.depth=0; while(queue.length!==0) &#123; let key=queue.shift(); if(Array.isArray(ans[key.depth])) &#123; ans[key.depth].push(key.val); &#125; else &#123; ans[key.depth]=[key.val]; &#125; if(key.left) &#123; key.left.depth=key.depth+1; queue.push(key.left); &#125; if(key.right) &#123; key.right.depth=key.depth+1; queue.push(key.right); &#125; &#125; &#125; return ans.reverse();&#125;;]]></content>
      <categories>
        <category>leetcode题解与算法</category>
      </categories>
      <tags>
        <tag>树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[leetcode-104 二叉树的最大深度]]></title>
    <url>%2F2019%2F08%2F18%2Fleetcode-104%2F</url>
    <content type="text"><![CDATA[二叉树的最大深度题目描述给定一个二叉树，找出其最大深度。 二叉树的深度为根节点到最远叶子节点的最长路径上的节点数。 说明: 叶子节点是指没有子节点的节点。 示例： 给定二叉树 [3,9,20,null,null,15,7]， 返回它的最大深度 3 。 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/maximum-depth-of-binary-tree著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 核心思路概述获取一棵树的二叉树地最大深度，也就是需要获得该树的层数。那么，很自然可以想到利用层序遍历来获取到层数 解题步骤 利用队列来实现层序遍历，为根节点设置属性depth=1；并使最大层数max=1; 判断当前节点是否有左右子树，若有，则左右子树的根节点的属性depth=当前节点的属性depth值+1；并且将子树入队列 每个节点depth值与max值进行比较，将max赋予较大值 返回max Coding实现12345678910111213141516171819202122232425262728293031323334/** * Definition for a binary tree node. * function TreeNode(val) &#123; * this.val = val; * this.left = this.right = null; * &#125; *//** * @param &#123;TreeNode&#125; root * @return &#123;number&#125; */var maxDepth = function(root) &#123; let max=0; if(root===null) return max; else &#123; let queue=[]; queue.push(root); max=root.depth=1; while(queue.length!==0)&#123; let key=queue.shift(); if(key.left!==null) &#123; key.left.depth=key.depth+1; if(key.left.depth&gt;max) max=key.left.depth; queue.push(key.left) &#125;; if(key.right!==null) &#123; key.right.depth=key.depth+1; if(key.right.depth&gt;max) max=key.right.depth; queue.push(key.right) &#125; &#125; return max; &#125;&#125;;]]></content>
      <categories>
        <category>leetcode题解与算法</category>
      </categories>
      <tags>
        <tag>树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[leetcode-101 对称二叉树]]></title>
    <url>%2F2019%2F08%2F18%2Fleetcode-101%2F</url>
    <content type="text"><![CDATA[对称二叉树题目描述给定一个二叉树，检查它是否是镜像对称的。 例如，二叉树 [1,2,2,3,4,4,3] 是对称的。 但是下面这个 [1,2,2,null,3,null,3] 则不是镜像对称的: 说明: 如果你可以运用递归和迭代两种方法解决这个问题，会很加分。 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/symmetric-tree著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 核心思路概述对于对称二叉树，我们只需要判断根节点的左子树和右子树是否是镜像对称的。那么，我们只需要将其中一个子树的所有节点的子树对换位置，再与另一个子树比较是否是相同的树（树结构相同，节点值也一样，参考leetcode100-相同的树） 那么按照这个思路，我们可以直接比较根节点的左子树中的每一个节点的左右子树是否都与右子树中的每一个节点的左右子树镜像对称，也就是leftTree.left===rightTree.right&amp;&amp;leftTree.right===rightTree.left对于每个节点是否成立 解题步骤 如果树为空，那么该树为对称数组，直接返回true 如果该树非空，那么遍历根节点的左右子树的每一个节点，如果他们的左右子树都相同那么返回true，否则返回false Coding实现1234567891011121314151617181920212223/** * Definition for a binary tree node. * function TreeNode(val) &#123; * this.val = val; * this.left = this.right = null; * &#125; *//** * @param &#123;TreeNode&#125; root * @return &#123;boolean&#125; */var isSymmetric = function(root) &#123; if(root===null) return true; let rightTree=root.right; let leftTree=root.left; function isSame(leftTree,rightTree)&#123; if(leftTree==null&amp;&amp;rightTree==null) return true; if(leftTree==null||rightTree==null) return false; if(leftTree.val!==rightTree.val) return false; return isSame(leftTree.left,rightTree.right)&amp;&amp;isSame(leftTree.right,rightTree.left); &#125; return isSame(root.left,root.right);&#125;;]]></content>
      <categories>
        <category>leetcode题解与算法</category>
      </categories>
      <tags>
        <tag>树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[leetcode-100 相同的树]]></title>
    <url>%2F2019%2F08%2F16%2Fleetcode-100%2F</url>
    <content type="text"><![CDATA[相同的树题目描述给定两个二叉树，编写一个函数来检验它们是否相同。 如果两个树在结构上相同，并且节点具有相同的值，则认为它们是相同的。 示例 1: 示例 2: 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/same-tree著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 核心思路概述想要确定两棵树是否结构相同，并且节点的值也相同。那么从两树的根节点开始遍历每棵树的每个节点，如果值都相同，那么两棵树就是相同的 解题步骤以下是递归终止条件 遍历节点，如果两树的节点不同，那么返回false 如果两树的节点都为null那么返回true 如果两树的节点一个为null，另一个不为null，那么返回false Coding实现123456789101112131415161718192021/** * Definition for a binary tree node. * function TreeNode(val) &#123; * this.val = val; * this.left = this.right = null; * &#125; *//** * @param &#123;TreeNode&#125; p * @param &#123;TreeNode&#125; q * @return &#123;boolean&#125; */var isSameTree = function(p, q) &#123; if(p == null &amp;&amp; q == null) return true; if(p == null || q == null) return false; if(p.val != q.val) return false; return isSameTree(p.left, q.left) &amp;&amp; isSameTree(p.right, q.right);&#125;;]]></content>
      <categories>
        <category>leetcode题解与算法</category>
      </categories>
      <tags>
        <tag>树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[leetcode-38 报数]]></title>
    <url>%2F2019%2F08%2F15%2Fleetcode-38%2F</url>
    <content type="text"><![CDATA[报数题目描述报数序列是一个整数序列，按照其中的整数的顺序进行报数，得到下一个数。其前五项如下： 1. 1 2. 11 3. 21 4. 1211 5. 1112211 被读作 “one 1” (“一个一”) , 即 11。11 被读作 “two 1s” (“两个一”）, 即 21。21 被读作 “one 2”, “one 1” （”一个二” , “一个一”) , 即 1211。 给定一个正整数 n（1 ≤ n ≤ 30），输出报数序列的第 n 项。 注意：整数顺序将表示为一个字符串。 示例 1: 输入: 1输出: “1” 示例 2: 输入: 4输出: “1211” 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/count-and-say著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 核心思路概述报数，指报的是前一个数。当前一个数有连续个同样地数比如’111’，那么把这个念作（3个1），因此会输出31；又比如’123’，因为这三个数都不同，我们会报数为（1个1；1个2；1个3），因此会输出111213 解题步骤不想多说，直接上代码 Coding实现12345678910111213141516171819202122/** * @param &#123;number&#125; n * @return &#123;string&#125; */var countAndSay = function(n) &#123; let ans=[]; ans[0]='1'; for(let i=1;i&lt;n;i++)&#123; let sum=1; ans[i]=''; for(let k=0;k&lt;ans[i-1].length;k++)&#123; if(ans[i-1][k]!==ans[i-1][k+1])&#123; ans[i]+=sum.toString()+ans[i-1][k]; sum=1; &#125; else &#123; sum++; &#125; &#125; &#125; return ans[n-1];&#125;;]]></content>
      <categories>
        <category>leetcode题解与算法</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[二叉树与二叉搜索树]]></title>
    <url>%2F2019%2F08%2F15%2F%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%8E%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%2F</url>
    <content type="text"><![CDATA[二叉树的定义二叉树的递归定义 要么二叉树没有根节点，是一棵空树 要么二叉树是由根节点、左子树、右子树组成，且左子树和右子树都是二叉树 简单来说，就是二叉树要么是一棵空树，要么这棵树的每一个节点最多只有两个节点，并且左右子树是严格区分的 二叉搜索树（BST）定义二叉搜索树（Binary Search Tree）是一种特殊的二叉树，又称为排序二叉树，二叉查找树、二叉排序树。 二叉搜索树的递归定义 要么二叉搜索树是一棵空树 要么二叉搜索树是由根节点、左子树、右子树组成，其中左子树和右子树都是二叉搜索树，且左子树上所有节点的数据域均小于根节点的数据域，右子树上所有节点的数据域均大于或等于根节点的数据域 简单来说，二叉搜索树是二叉树的一种，但是它只允许你在左侧节点存储比父节点小的值；在右侧节点存储比父节点大或等于的值 二叉搜索树的插入如果要插入的树为空树，那么就将要插入的节点作为这颗二叉搜索树的根节点； 如果不是，那么就根据二叉搜索树的特性，判断它与根节点的大小关系不断递归直到找到它的位置 二叉搜索树的插入实现 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162class Node&#123; // 节点类 constructor(key)&#123; this.key=key; this.left=null; this.right=null; &#125;&#125;class BinarySearchTree&#123; // 二叉搜索树类 constructor(root)&#123; this.root=root; &#125; insert(node)&#123; // 二叉搜索树的插入方法 if(this.root===null)&#123; this.root=node; &#125; else &#123; this.insertNode(this.root,node); &#125; &#125; insertNode(root,node)&#123; // insertNode方法（用来找到合适的位置进行插入） if(node.key&lt;root.key)&#123; if(root.left===null) &#123; root.left=node; return; &#125; else &#123; this.insertNode(root.left,node); &#125; &#125; else &#123; if(root.right===null) &#123; root.right=node; return; &#125; else &#123; this.insertNode(root.right,node); &#125; &#125; &#125;&#125;let A=new Node(10);let B=new Node(15);let C=new Node(13);let D=new Node(7);let root=new BinarySearchTree(A);root.insert(B);root.insert(C);root.insert(D);console.log(root);/** 输出结果*//*BinarySearchTree &#123; root: Node &#123; key: 10, left: Node &#123; key: 7, left: null, right: null &#125;, right: Node &#123; key: 15, left: [Node], right: null &#125; &#125;&#125;*/ 二叉搜索树的性质因为二叉搜索树的所有节点的左子树会小于它，右子树会大于它，因此，对二叉搜索树使用中序遍历会得到一个有序序列 二叉树（二叉搜索树）的四种遍历因为二叉搜索树是特殊的二叉树，因此讲清楚二叉树地遍历即可 先序遍历对于先序遍历来说，总是先访问根节点，然后才去访问左子树和右子树，因此先序遍历的遍历顺序是根节点-&gt;左子树-&gt;右子树 先序遍历的代码实现 12345678function preOrder(root)&#123; if(root===null) return; else &#123; console.log(root); preOrder(root.left); preOrder(root.right); &#125;&#125; 中序遍历和后序遍历的代码实现与先序遍历类似，就不再展开 层序遍历层序遍历是指按照层次的顺序从根节点向下逐层进行遍历，且对同一层次的节点为从左到右遍历 层序遍历的实现步骤对于层序遍历，我们需要一层一层的访问，因此像之前的三种遍历方式使用递归我们无法做到，因此我们可以考虑使用队列来实现 将根节点tree.root加入队列queue 取出队首节点，访问它 如果该节点有左孩子，将左孩子入队 如果该节点有右孩子，将右孩子入队 返回2，直到队列为空 1234567891011121314151617function layerOrder(tree)&#123; if(tree.root===null) return; else &#123; let queue=[]; queue.push(tree.root); while(queue.length!==0)&#123; let key=queue.shift(); console.log(key); if(key.left!==null)&#123; queue.push(key.left); &#125; if(key.right!==null)&#123; queue.push(key.right); &#125; &#125; &#125;&#125; 根据遍历序列重建二叉树中序序列可以与先序序列、后序序列、层序序列中的任意一个来构建唯一的二叉树，而后三者两两搭配或是三个一起上都无法构建唯一的二叉树 原因是先序、后序、层序均是提供根节点。然而只有中序序列才能区分出左右子树 给定二叉树的先序遍历和中序遍历来重建二叉树的步骤 通过先序遍历来确定根节点，一开始会是数组的第一项 通过中序遍历来确定这棵树根节点的左子树和右子树，左子树会是数组中根节点项的前面那所有项；右子树会是数组中根节点项的后面的所有值 通过步骤2确定的中序遍历中的左子树数组和右子树数组来确定先序遍历中的左子树数组和右子树数组 递归左子树数组和右子树数组，重复步骤1,2,3直到数组为空 代码实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354class Node&#123; constructor(key)&#123; this.key=key; this.left=null; this.right=null; &#125;&#125;let A=new Node('A');let B=new Node('B');let C=new Node('C');let D=new Node('D');let E=new Node('E');let F=new Node('F');let G=new Node('G');// 给定二叉树的先序遍历和中序遍历重建二叉树函数function createTree(m,n)&#123; if(m.length===0) &#123;return;&#125;; let root=m[0]; let rootIndex=n.indexOf(root); let leftNTree=n.slice(0,rootIndex); let rightNTree=n.slice(rootIndex+1); let leftMTree=m.slice(1,leftNTree.length+1); let rightMTree=m.slice(rootIndex+1); if(leftMTree[0])&#123;root.left=leftMTree[0];&#125; if(rightMTree[0])&#123;root.right=rightMTree[0];&#125; createTree(leftMTree,leftNTree); createTree(rightMTree,rightNTree);&#125;createTree([A,B,C,D,E,F,G],[B,D,C,A,F,E,G]);console.log(A);/** 输出结果*//*Node &#123; key: 'A', left: Node &#123; key: 'B', left: null, right: Node &#123; key: 'C', left: [Node], right: null &#125; &#125;, right: Node &#123; key: 'E', left: Node &#123; key: 'F', left: null, right: null &#125;, right: Node &#123; key: 'G', left: null, right: null &#125; &#125;&#125;*/]]></content>
      <categories>
        <category>算法笔记</category>
      </categories>
      <tags>
        <tag>排序</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[leetcode-118 杨辉三角]]></title>
    <url>%2F2019%2F08%2F14%2Fleetcode-118%2F</url>
    <content type="text"><![CDATA[杨辉三角题目描述给定一个非负整数 numRows，生成杨辉三角的前 numRows 行。 在杨辉三角中，每个数是它左上方和右上方的数的和。 示例: 输入: 5输出:[ [1], [1,1], [1,2,1], [1,3,3,1], [1,4,6,4,1]] 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/pascals-triangle著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 核心思路杨辉三角的每一行，除了首尾都是为1外，每一项都是前一行的两项之和 解题步骤 设置一个数组 建立numRows行二维数组，每一行除了首尾都是为1外，每一项都是前一行的两项之和 返回数组 coding实现12345678910111213141516/** * @param &#123;number&#125; numRows * @return &#123;number[][]&#125; */var generate = function(numRows) &#123; let ans=[]; for(let i=0;i&lt;numRows;i++)&#123; ans[i]=[]; ans[i][0]=1; ans[i][i]=1; for(let k=1;k&lt;i;k++)&#123; ans[i][k]=ans[i-1][k-1]+ans[i-1][k]; &#125; &#125; return ans;&#125;;]]></content>
      <categories>
        <category>leetcode题解与算法</category>
      </categories>
      <tags>
        <tag>数组</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[操作符new到底做了哪些事]]></title>
    <url>%2F2019%2F08%2F13%2F%E6%93%8D%E4%BD%9C%E7%AC%A6new%E5%88%B0%E5%BA%95%E5%81%9A%E4%BA%86%E5%93%AA%E4%BA%9B%E4%BA%8B%2F</url>
    <content type="text"><![CDATA[new操作符的作用new操作符可以快速创建构造函数的实例，如： 12345678910111213function Person(name,age,job)&#123; this.name=name; this.age=age; this.job=job;&#125;Person.prototype.sayHello=function ()&#123; console.log('hello');&#125;let man=new Person('zjb','18','frontEnd');console.log(man); // Object &#123; name: "zjb", age: "18", job: "frontEnd" &#125;man.sayHello(); // 'hello' 那么，使用new操作符来创建某构造函数的实例会经历以下四个步骤： 内部创建一个新对象 将构造函数的作用域赋给新对象（因此this就指向了这个新对象） 执行构造函数中的代码 返回新对象 自己实现一个new操作符既然new操作符的作用是创建一个构造函数的实例，那么new操作无非就是创建一个新的对象，将这个新对象的proto属性指向其构造函数的原型对象，然后该新对象绑定到构造函数上并获得传入的值，从而执行代码获得自身的对象属性 new操作符的代码实现 12345678function New(obj,...arr)&#123; let ans=&#123;&#125;; ans.__proto__=obj.prototype; // 连接原型对象 //Object.setPrototypeOf(ans, obj.prototype) 也可以，或许更高效 let result=obj.apply(ans,arr); // 获得构造函数的返回值 return ans===Object?ans:result; //用来判断构造函数的返回值是否与创建的实例不同&#125;]]></content>
  </entry>
  <entry>
    <title><![CDATA[如何优雅地使用箭头函数]]></title>
    <url>%2F2019%2F08%2F13%2F%E5%A6%82%E4%BD%95%E4%BC%98%E9%9B%85%E5%9C%B0%E4%BD%BF%E7%94%A8%E7%AE%AD%E5%A4%B4%E5%87%BD%E6%95%B0%2F</url>
    <content type="text"><![CDATA[什么是箭头函数箭头函数是ES6新增语法特性，它是一种使用箭头（=&gt;）定义函数的新语法，但是，他与传统的函数有些许的不同，主要集中在以下方面： 没有this,super,arguments和new.target绑定 箭头函数中的this,supper,arguments及new.target这些值有外围最近一层非箭头函数决定 不能通过new关键字调用 箭头函数没有[ [Constuct]]方法，所以不能被作为构造函数 没有原型 箭头函数不存在prototype这个属性 不可以改变this的绑定 箭头函数语法当函数右侧的表达式只有一个时，可以没有显式的返回语句 12const test=a=&gt;a+1;console.log(test(1)); // 2 如果函数没有参数，也要在声明的时候写一组没有内容的小括号 12const test=()=&gt;'hello';console.log(test()); // 'hello' 如果想要返回一个对象字面量，则需要将该字面量包裹在小括号里 12const test=()=&gt;(&#123;item:1&#125;);console.log(test()); // &#123;item:1&#125; 没有this绑定箭头函数中没有this绑定，必须通过查找作用域链来确定this的值。 箭头函数的this在定义时就确定了，是由其外层代码的this决定 对于其外层代码的this指向我们可以参考另一篇博文《Js中的this到底指向哪》 简单来说，假设外层代码里有一句输出语句console.log(this); 那么输出的对象即为this的指向 被全局环境中定义的函数包含 123(function test()&#123; console.log((()=&gt;this)()); // window&#125;)() 被对象中定义的方法包含 12345678const obj=&#123; a()&#123; return ()=&gt;&#123; console.log(this); &#125; &#125;&#125;obj.a()(); // obj &#123; a: a() &#125; 全局环境下定义 12const a=()=&gt;this;console.log(a()); // window 被另一个箭头函数包含 12345678910111213const obj=&#123; a()&#123; return ()=&gt;&#123; console.log('outter'); console.log(this); // Object &#123; a: a() &#125; (()=&gt;&#123; console.log('inner'); console.log(this); // Object &#123; a: a() &#125; &#125;)() &#125; &#125;&#125;obj.a()(); 最后，因为箭头函数没有 this，所以也不能用 call()、apply()、bind() 这些方法改变 this 的指向 123const test=()=&gt;this;const obj=&#123;&#125;console.log(test.apply(obj)); // window 创建立即执行表达式立即执行表达式，即可以定义一个匿名函数并调用，自始至终不保存对该函数的引用 123(()=&gt;&#123; console.log('hello'); // 'hello'&#125;)(); 没有arguments绑定箭头函数没有自己的arguments对象，且未来无论函数在哪个上下文中执行，箭头函数始终可以访问到外围函数的arguments对象 123456(function a()&#123; console.log(arguments[0]); // 5 ((m)=&gt;&#123; console.log(arguments[0]); // 5 &#125;)(1)&#125;)(5)]]></content>
      <categories>
        <category>ES6</category>
      </categories>
      <tags>
        <tag>基础语法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Js中的this到底指向哪]]></title>
    <url>%2F2019%2F08%2F13%2FJs%E4%B8%AD%E7%9A%84this%E5%88%B0%E5%BA%95%E6%8C%87%E5%90%91%E5%93%AA%2F</url>
    <content type="text"><![CDATA[什么是this对于this,我们可以下一个定义 this是在执行上下文创建时确定的一个在执行过程中不可更改的变量。 简单来说,this应当是当前执行代码的环境对象 在函数中使用this函数调用一般会有以下四种情境： 在全局环境或是普通函数中直接调用 作为对象的方法 使用apply和call 作为构造函数 在全局环境或是普通函数中直接调用ps：全文均在浏览器环境下执行 在全局环境中直接调用1234567console.log(this===window); // truevar a=1;function test()&#123; var a=2; console.log(this.a);&#125;test(); // 1 在函数中直接调用123456789var a=1;function test()&#123; let a=2; function m()&#123; console.log(this.a); // 1 &#125; m();&#125;test(); 从这两个例子中，我们很容易可以得到：当函数在全局环境下或在某个函数中被直接调用时，那么其中的this会指向全局对象（window） 函数作为对象的方法被调用先说结论，当函数作为对象的方法被调用时，this就会指向该对象 如： 12345678var a=1;let obj=&#123; a:2, func()&#123; console.log(this.a); // 2 &#125;&#125;obj.func(); 由于func函数被作为obj的对象调用，那么this就会指向obj 然而，我们经常会遇到这样的陷阱： 123456789var a=1;let obj=&#123; a:2, func()&#123; console.log(this.a); // 1 &#125;&#125;const func=obj.func;func(); 此时，fnc函数被赋值给了全局作用域下的func变量。因为我们知道，函数名只是一个指向函数对象的指针，因此，此时全局作用域下定义的func域obj对象中的func一样指向了同一个函数对象；然后，这个函数在全局作用域下被直接调用，所以this指向了window 使用apply,call,bind apply() 方法调用一个具有给定this值的函数，以及作为一个数组（或类似数组对象）提供的参数。 call() 方法使用一个指定的 this 值和单独给出的一个或多个参数来调用一个函数。 注意：该方法的语法和作用与 apply() 方法类似，只有一个区别，就是 call() 方法接受的是一个参数列表，而 apply() 方法接受的是一个包含多个参数的数组。 bind()方法创建一个新的函数，在bind()被调用时，这个新函数的this被bind的第一个参数指定，其余的参数将作为新函数的参数供调用时使用。 其中，apply和call方法返回的是调用有指定this值和参数的函数的结果。 而bind方法是返回构建的新的函数 apply与call的使用例子123456789var a=1;function test()&#123; console.log(this.a);&#125;function func()&#123; console.log(this===window); // true test.apply(this); // 1&#125;func(); 执行func函数，因为func函数被直接调用，因此func函数内部的this指向全局对象，在浏览器中即为window。然后，test函数通过apply方法被调用，因此test函数被传入的this值也是指向window的。 另一个例子： 1234567891011var name='bjz'function test()&#123; let name='fairy' console.log(this.name);&#125;var obj=&#123; name:'angel'&#125;test.apply(obj); // 'angel' 与上个例子同理，test函数通过apply方法传入的this指向的是obj对象。 因为call方法与apply方法的作用是一样的，只是参数传递的形式有区别，因此，call的例子将会在下面列出 apply与call方法的参数传递区别1234567891011function sum(num1,num2)&#123; this.sum=num1+num2; console.log(this); // &#123; sum: 3, callSum: callSum() &#125;&#125;var obj=&#123; sum:0, callSum()&#123; sum.call(this,1,2)// 或者是sum.apply(this,[1,2]) &#125;&#125;obj.callSum(); callSum函数被作为obj的对象被调用，因此callSum函数内部的this指向obj对象。因此，sum函数通过call方法被传入的this对象也指向obj对象 bind的使用例子mdn上的解释 bind() 最简单的用法是创建一个函数，不论怎么调用，这个函数都有同样的 this 值。JavaScript新手经常犯的一个错误是将一个方法从对象中拿出来，然后再调用，期望方法中的 this 是原来的对象（比如在回调中传入这个方法）。如果不做特殊处理的话，一般会丢失原来的对象。基于这个函数，用原始的对象创建一个绑定函数，巧妙地解决了这个问题： 官方例子： 12345678910111213141516this.x = 9; // 在浏览器中，this指向全局的 "window" 对象var module = &#123; x: 81, getX: function() &#123; return this.x; &#125;&#125;;module.getX(); // 81var retrieveX = module.getX;retrieveX(); // 返回9 - 因为函数是在全局作用域中调用的// 创建一个新函数，把 'this' 绑定到 module 对象// 新手可能会将全局变量 x 与 module 的属性 x 混淆var boundGetX = retrieveX.bind(module);boundGetX(); // 81 一个简单的小例子： 1234567function test()&#123; console.log(this);&#125;var obj=&#123; item:1&#125;test.bind(obj)() //&#123;item:1&#125; 由此可以看出，bind方法的返回值是一个新创建的函数，函数内部的this指向为传入的this值 函数作为构造函数被调用何为构造函数？所谓构造函数就是用来new对象的函数，像Function、Object、Array、Date等都是全局定义的构造函数。 来看例子： 12345function Test()&#123; this.item=1;&#125;let b=new Test();console.log(b.item); // 1 如果函数作为构造函数用，那么其中的this就代表它即将new出来的对象。 箭头函数参考另一篇博文 如何优雅地使用箭头函数]]></content>
      <categories>
        <category>javaScript基础</category>
      </categories>
      <tags>
        <tag>基础语法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[leetcode-867 转置矩阵]]></title>
    <url>%2F2019%2F08%2F13%2Fleetcode-867%2F</url>
    <content type="text"><![CDATA[转置矩阵题目描述给定一个矩阵 A， 返回 A 的转置矩阵。 矩阵的转置是指将矩阵的主对角线翻转，交换矩阵的行索引与列索引。 示例 1： 输入：[[1,2,3],[4,5,6],[7,8,9]]输出：[[1,4,7],[2,5,8],[3,6,9]] 示例 2： 输入：[[1,2,3],[4,5,6]]输出：[[1,4],[2,5],[3,6]] 提示： 1&lt;= A.length &lt;= 1000 1&lt;= A[0].length &lt;= 1000 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/transpose-matrix著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 核心思路概述对于转置矩阵的特点，我们很容易得到，对于原数组A，ans[k][i]=A[i][k] 解题步骤 根据矩阵列数来创建ans二维数组的行数 由ans[k][i]=A[i][k]循环得到ans数组并返回 Coding实现1234567891011121314/** * @param &#123;number[][]&#125; A * @return &#123;number[][]&#125; */var transpose = function(A) &#123; let ans=[]; for(let i=0;i&lt;A[0].length;i++)&#123; ans[i]=[]; for(let k=0;k&lt;A.length;k++)&#123; ans[i][k]=A[k][i]; &#125; &#125; return ans;&#125;;]]></content>
      <categories>
        <category>leetcode题解与算法</category>
      </categories>
      <tags>
        <tag>数组</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[对象的属性类型与特性]]></title>
    <url>%2F2019%2F08%2F12%2F%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%B1%9E%E6%80%A7%E7%B1%BB%E5%9E%8B%E4%B8%8E%E7%89%B9%E6%80%A7%2F</url>
    <content type="text"><![CDATA[对象的属性类型对象包括两种属性类型，分别是 数据属性 访问器属性 数据属性定义及特性数据属性相对于访问器属性来说，它拥有数据值 数据属性有4个描述其行为的特性，分别是 configurable：可配置。（具体来说指的是，1.能否通过delete删除属性从而重新定义属性； 2.能否修改属性的特性；3.能否把属性修改为访问器属性；默认为true） enumerable：可枚举。（表示是否可以通过for-in循环来返回属性；默认为true） writable：可写。（表示能否修改属性的值；默认为true） 以上三个属性取值为true或false。 value：属性值。 我们可以通过Object.getOwnPropertyDescriptor()这个方法来查看对象属性的特性 此方法可得到对象的数据属性，传入两个参数：第一个是要查找的对象名；第二个是要查找的属性名。 如下： 12345let test=&#123; item:1&#125;console.log(Object.getOwnPropertyDescriptor(test,'item')) //&#123; value: 1, writable: true, enumerable: true, configurable: true &#125; Object.defineProperty()要修改属性的默认特性，我们可以使用Object.defineProperty()来进行修改。当然我们也可以使用该方法来新建属性并同时制定它的属性特性 注意： 在调用该方法创建新的属性时，如果不指定，默认会将除value外的特性值置为false;如果调用该方法只是修改已有属性，则无此限制 这个方法接收三个参数：属性所在的对象、属性的名字(字符串类型),一个描述符对象。其中描述符对象的属性必须是数据属性四个特性中的一或多个 12345678910111213141516171819202122232425let test=&#123; item:1, name:2&#125;Object.defineProperty(test,'item',&#123; enumerable:false // 该属性无法被枚举&#125;)for(let i in test)&#123; console.log(i) // name&#125;Object.defineProperty(test,'item',&#123; configurable:false //让该属性不能被配置，具体指无法被删除，无法修改属性特性，无法修改为访问器属性&#125;)delete test.item // 该属性无法被删除console.log(test); // &#123;item:1&#125;Object.defineProperty(test,'item',&#123; value:2 // 修改该属性的值为2&#125;)console.log(test); // &#123;item:2&#125;Object.defineProperty(test,'item',&#123; writable:false // 该属性的值无法被修改&#125;)test.item=3;console.log(test); // &#123;item:2&#125; 访问器属性访问器属性不包含数据值；他们包含一对儿getter和setter函数；在读取访问器属性时，会调用getter函数，这个函数负责返回有效的值；在写入访问器属性时，会调用setter函数并传入新值，这个函数负责决定如何处理数据 访问器属性有4个描述其行为的特性，分别是 configurable：可配置。（具体来说指的是，1.能否通过delete删除属性从而重新定义属性； 2.能否修改属性的特性；3.能否把属性修改为访问器属性；默认为true） enumerable：可枚举。（表示是否可以通过for-in循环来返回属性；默认为true） get：在读取属性时调用的函数。默认值为undefined set：在写入属性时调用的函数。默认值为undefined 访问器属性不像数据属性一样可以直接被定义，它只能通过Object.defineProperty()来定义 如下： 12345678910111213141516let test=&#123; _item:1&#125;Object.defineProperty(test,'item',&#123; get:function()&#123; return this._item; &#125;, set:function(num)&#123; if(num&gt;10)&#123; this._item++; &#125; &#125;&#125;)test.item=15;console.log(test.item); // 2 访问器属性的意义 修改访问器属性动态修改相关联的数据属性 监听访问器属性的修改去操作其它业务逻辑]]></content>
      <categories>
        <category>javaScript基础</category>
      </categories>
      <tags>
        <tag>基础语法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[leetcode-509 斐波那契数]]></title>
    <url>%2F2019%2F08%2F12%2Fleetcode-509%2F</url>
    <content type="text"><![CDATA[斐波那契数题目描述斐波那契数，通常用 F(n) 表示，形成的序列称为斐波那契数列。该数列由 0 和 1 开始，后面的每一项数字都是前面两项数字的和。也就是： F(0) = 0, F(1) = 1F(N) = F(N - 1) + F(N - 2), 其中 N &gt; 1.给定 N，计算 F(N)。 示例 1： 输入：2输出：1解释：F(2) = F(1) + F(0) = 1 + 0 = 1. 示例 2： 输入：3输出：2解释：F(3) = F(2) + F(1) = 1 + 1 = 2. 示例 3： 输入：4输出：3解释：F(4) = F(3) + F(2) = 2 + 1 = 3. 提示： 0 ≤ N ≤ 30 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/fibonacci-number著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 核心思路概述一开始会很容易想到用递归的方式来解决，但是递归会很容易超出时间限制。因此，利用动态规划就很容易解决这个问题 解题步骤 建立一个数组，数组的第一项和第二项分别为0,1 从第三项开始一直到第N项，每一项等于前两项的和，并存放到数组中 返回数组第N项存储的值 Coding实现1234567891011/** * @param &#123;number&#125; N * @return &#123;number&#125; */var fib = function(N) &#123; let arr=[0,1]; for(let i=2;i&lt;=N;i++)&#123; arr[i]=arr[i-1]+arr[i-2]; &#125; return arr[N];&#125;;]]></content>
      <categories>
        <category>leetcode题解与算法</category>
      </categories>
      <tags>
        <tag>数组</tag>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[leetcode-561 数组拆分 I]]></title>
    <url>%2F2019%2F08%2F09%2Fleetcode-561%2F</url>
    <content type="text"><![CDATA[数组拆分 I题目描述给定长度为 2n 的数组, 你的任务是将这些数分成 n 对, 例如 (a1, b1), (a2, b2), …, (an, bn) ，使得从1 到 n 的 min(ai, bi) 总和最大。 示例 1: 输入: [1,4,3,2]输出: 4解释: n 等于 2, 最大总和为 4 = min(1, 2) + min(3, 4). 提示: n 是正整数,范围在 [1, 10000]. 数组中的元素范围在 [-10000, 10000]. 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/array-partition-i著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 核心思路概述当将整个数组排序后，第一个数必定为最小的数也是必须参加和运算的数假设为a。那么假如与这个最小的数a配对的数n并不是这个数组排序后a的后一个数b，那么b此时成为了剩下的数中最小的数因此必定也要参加和运算；但显然的是，此时a+b所组成的和运算中必定不是最大的和了 解题步骤 将原数组按从小到大进行排序 将数组中所有下标为偶数的数组元素相加得到的和返回 Coding实现1234567891011121314/** * @param &#123;number[]&#125; nums * @return &#123;number&#125; */var arrayPairSum = function(nums) &#123; let ans=0; nums.sort((a,b)=&gt;&#123; return a-b; &#125;); for(let i=0;i&lt;nums.length;i=i+2)&#123; ans+=nums[i]; &#125; return ans;&#125;;]]></content>
      <categories>
        <category>leetcode题解与算法</category>
      </categories>
      <tags>
        <tag>数组</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[leetcode-905 按奇偶排序数组]]></title>
    <url>%2F2019%2F08%2F08%2Fleetcode-905%2F</url>
    <content type="text"><![CDATA[按奇偶排序数组题目描述给定一个非负整数数组 A，返回一个数组，在该数组中， A 的所有偶数元素之后跟着所有奇数元素。 你可以返回满足此条件的任何数组作为答案。 示例： 输入：[3,1,2,4]输出：[2,4,3,1]输出 [4,2,3,1]，[2,4,1,3] 和 [4,2,1,3] 也会被接受。 提示： 1&lt;= A.length &lt;= 5000 0&lt;= A[i] &lt;= 5000 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/sort-array-by-parity著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 核心思路概述 数组 遍历原数组，将奇数放到奇数数组，偶数放到偶数数组，concat后返回 双指针 left指针从前往后遍历,right指针从后往前遍历，如果left指针指向奇数而right指针指向偶数，那么两数交换，直到left&gt;=right 解题步骤数组 设定奇数数组、偶数数组 遍历原数组，将奇数放到奇数数组，偶数放到偶数数组 返回 奇数数组concat偶数数组 双指针 设定left=0,right=A.length-1 left指针从前往后遍历,right指针从后往前遍历，如果left指针指向奇数而right指针指向偶数，那么两数交换，直到left&gt;=right 返回ACoding实现数组实现1234567891011121314151617/** * @param &#123;number[]&#125; A * @return &#123;number[]&#125; */var sortArrayByParity = function(A) &#123; let odd=[]; let even=[]; A.forEach(value=&gt;&#123; if(value%2===0)&#123; even.push(value); &#125; else &#123; odd.push(value); &#125; &#125;) return even.concat(odd);&#125;; 双指针实现12345678910111213141516171819202122/** * @param &#123;number[]&#125; A * @return &#123;number[]&#125; */var sortArrayByParity = function(A) &#123; let left=0; let right=A.length-1; while(left&lt;right)&#123; if(A[left]%2===0)&#123; left++; continue; &#125; if(A[right]%2!==0)&#123; right--; continue; &#125; let temp=A[left]; A[left]=A[right]; A[right]=temp; &#125; return A;&#125;;]]></content>
      <categories>
        <category>leetcode题解与算法</category>
      </categories>
      <tags>
        <tag>数组</tag>
        <tag>双指针</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[引用类型]]></title>
    <url>%2F2019%2F08%2F07%2F%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B%2F</url>
    <content type="text"><![CDATA[引言 新对象的创建可以通过new操作符后跟一个构造函数来创建 例： 1let a=new Object() Object类型创建Object实例的两个方法new操作符1let a=new Object() 对象字面量法1let a=&#123;item:1&#125; 在使用对象字面量语法时，属性名也可以使用字符串和可计算属性名 字符串属性名 1234let a=&#123; 'item':1&#125;console.log(a.item); // 1 可计算属性名(方括号语法：使用变量来访问属性) 12345let n=123;let a=&#123; [n+'abc']:'hello'&#125;console.log(a['123abc']); // hello Array类型创建数组的几种方式 Array构造函数 12let a=new Array(1,2,3);console.log(a); // [1,2,3] 数组字面量法 12let a=[1,2,3];console.log(a); //[1,2,3] 数组的length属性设置值的索引下标超过数组长度当设置值的索引下标超过数组长度时，那么数组的长度会自动加到该索引值加一的长度，并且中间未设置的元素还是undefined 1234let a=[1,2,3];a[8]=1;console.log(a); //[ 1, 2, 3, &lt;5 empty items&gt;, 1 ]console.log(a[5]); //undefined 利用数组的length属性来移除数组项和添加项当将数组的length值设置为小于原数组的length时，则会将原数组后面的几项移除掉 123let a=[1,2,3];a.length=1;console.log(a); //[1] 常用的数组方法栈方法 方法名 作用 返回值 push() 接受任意参数并添加到数组末尾 修改后的数组长度 pop() 从数组末尾移除最后一项 被移除的项 队列方法 方法名 作用 返回值 shift() 移除数组的第一个项 被移除的项 unshift() 接受任意参数并添加到数组前端 修改后的数组长度 重排序方法 方法名 作用 返回值 reverse() 翻转数组项的顺序 修改后的数组 sort() 默认是将数组元素转化为字符串进行比较并按升序排列，但可以添加比较函数 修改后的数组 操作方法 方法名 作用 返回值 concat() 该方法会先创建当前数组的一个副本，然后将接收到的参数添加到这个副本的末尾，最后返回构建的数组 新数组 slice() 返回给定起始位置和结束位置之间的项（左开右闭）（该方法不会影响原始数组） 新数组 splice() 1.删除（删除的第一项的位置和要删除的项数） 2.插入（插入的第一项的位置，0，要插入的元素） 3.替换（替换的第一项位置，要替换的项数，要插入的项数） 从原始数组中删除的项（如果没有删除任何项，则返回一个空数组） 位置方法 方法名 作用 返回值 indexOf() 从数组开头查找第一个全等于给定参数的数组项的下标，若没找到则返回-1 要查找的项在数组中的位置或-1 lastIndexOf() 从数组末尾查找第一个全等于给定参数的数组项的下标，若没找到则返回-1 要查找的项在数组中的位置或-1 迭代方法 方法名 作用 返回值 every() 对数组中的每一项运行给定函数，如果该函数对每一项都返回true，则返回true true或false some() 对数组中的每一项运行给定函数，如果该函数对任一项返回true，则返回true true或false filter() 过滤得到满足给定函数的项的组成的数组 新数组 forEach() 对数组中的每一项运行给定函数 undefined map() 对数组中的每一项运行给定函数，返回每次函数调用的结果组成的数组 新数组 归并方法 方法名 作用 返回值 reduce() 从数组第一项开始，向后对数组中的每个元素执行一个由您提供的reducer函数(升序执行)，将其结果汇总为单个返回值。 新数组 reduceRight() 从数组最后一项开始，向前对数组中的每个元素执行一个由您提供的reducer函数(升序执行)，将其结果汇总为单个返回值。 新数组 方法参数：这两个方法都接收两个参数：一个在每一项上调用的reucer函数和（可选的）作为归并基础的初始值 reducer函数参数：接收四个参数：前一个值、当前值、项的索引和数组对象。这个函数的返回的任何值都后悔作为第一个参数自动传给下一项 Date类型创建日期对象 12let date=new Date();console.log(date.toLocaleString()); RegExp类型Function类型函数实际上是对象。因此函数名实际上也是一个指向函数对象的指针，并不会与某个函数绑定 因此使用不带圆括号的函数名是访问函数指针，而非调用函数 语法 函数声明式语法 （整体提升） 123function test()&#123; console.log(1);&#125; 函数表达式语法 （变量提升，给变量赋值为undefined）123const test=function()&#123; console.log(1);&#125; 作为值的函数因为函数名只是一个指向函数对象的指针，因此函数也可以作为参数的值进行传递 123456789function test()&#123; console.log(1);&#125;function a(test)&#123; test();&#125;a(test); //1 基本包装类型组成 Boolean Number String 定义每当读取一个基本类型值的时候，后台就会自动创建一个对应的基本包装类型的对象。 处理步骤：\ 创建基本包装类型的一个实例 在实例上调用制定的方法 销毁这个实例 生命周期：自动创建的基本包装类型的对象，只存在于一行代码的执行瞬间，然后立即被销毁，这意味着我们不能在运行时为基本类型值添加属性和方法 123let a='hello';a.test=4;console.log(a.test); // undefined Boolean类型Number类型String类型String类型的每个实例都有一个length属性，表示字符串中包含多少个字符 123let a='hello';a.length=1; // 创建a的基本包装类型对象，修改掉length之后，被立即销毁console.log(a.length); // 5 创建a的基本包装类型对象，并返回length属性值 字符方法charAt()与charCodeAt() 字符串操作方法 concat() slice() substr() substring() indexOf() lastIndexOf() toLowerCase() toUpperCase() split() 单体内置对象Global对象Math对象]]></content>
      <categories>
        <category>javaScript基础</category>
      </categories>
      <tags>
        <tag>基础语法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[leetcode-1051 高度检查器]]></title>
    <url>%2F2019%2F08%2F07%2Fleetcode-1051%2F</url>
    <content type="text"><![CDATA[高度检查器题目描述学校在拍年度纪念照时，一般要求学生按照 非递减 的高度顺序排列。 请你返回至少有多少个学生没有站在正确位置数量。该人数指的是：能让所有学生以 非递减 高度排列的必要移动人数。 示例： 输入：[1,1,4,2,1,3]输出：3解释：高度为 4、3 和最后一个 1 的学生，没有站在正确的位置。 提示： 1&lt;= heights.length &lt;= 100 1&lt;= heights[i] &lt;= 100 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/height-checker著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 核心思路概述只需比较原数组和排序后的数组的每个位置上的元素有几个不一样即可 解题步骤 复制原数组，并排序 比较原数组和排序后的数组的各个位置上的元素，若不同则ans++ 返回ans Coding实现12345678910111213141516/** * @param &#123;number[]&#125; heights * @return &#123;number&#125; */var heightChecker = function(heights) &#123; let heightsSort=(new Array(...heights)).sort((a,b)=&gt;&#123; return a-b; &#125;); let ans=0; for(let i in heights)&#123; if(heights[i]!==heightsSort[i])&#123; ans++; &#125; &#125; return ans;&#125;;]]></content>
      <categories>
        <category>leetcode题解与算法</category>
      </categories>
      <tags>
        <tag>数组</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[leetcode-832 翻转图像]]></title>
    <url>%2F2019%2F08%2F06%2Fleetcode-832%2F</url>
    <content type="text"><![CDATA[翻转图像题目描述 给定一个二进制矩阵 A，我们想先水平翻转图像，然后反转图像并返回结果。 水平翻转图片就是将图片的每一行都进行翻转，即逆序。例如，水平翻转 [1, 1, 0] 的结果是 [0, 1, 1]。 反转图片的意思是图片中的 0 全部被 1 替换， 1 全部被 0 替换。例如，反转 [0, 1, 1] 的结果是 [1, 0, 0]。 示例 1: 输入: [[1,1,0],[1,0,1],[0,0,0]]输出: [[1,0,0],[0,1,0],[1,1,1]]解释: 首先翻转每一行: [[0,1,1],[1,0,1],[0,0,0]]； 然后反转图片: [[1,0,0],[0,1,0],[1,1,1]] 示例 2: 输入: [[1,1,0,0],[1,0,0,1],[0,1,1,1],[1,0,1,0]]输出: [[1,1,0,0],[0,1,1,0],[0,0,0,1],[1,0,1,0]]解释: 首先翻转每一行: [[0,0,1,1],[1,0,0,1],[1,1,1,0],[0,1,0,1]]； 然后反转图片: [[1,1,0,0],[0,1,1,0],[0,0,0,1],[1,0,1,0]] 说明: 1&lt;= A.length = A[0].length &lt;= 20 0&lt;= A[i][j] &lt;= 1 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/flipping-an-image著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 核心思路概述利用es6数组方法map()快速地修改数组元素 解题步骤 因为是二维数组，遍历该二维数组将一维数组倒序，并且1变成0,0变成1 Coding实现12345678910111213141516/** * @param &#123;number[][]&#125; A * @return &#123;number[][]&#125; */var flipAndInvertImage = function(A) &#123; return A.map(value=&gt;&#123; value.reverse(); return value.map(value1=&gt;&#123; if(value1===0)&#123; value1=1; &#125; else value1=0; return value1; &#125;); &#125;)&#125;;]]></content>
      <categories>
        <category>leetcode题解与算法</category>
      </categories>
      <tags>
        <tag>数组</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[leetcode-345 反转字符串中的元音字母]]></title>
    <url>%2F2019%2F08%2F05%2Fleetcode-345%2F</url>
    <content type="text"><![CDATA[反转字符串中的元音字母题目描述编写一个函数，以字符串作为输入，反转该字符串中的元音字母。 示例 1: 输入: “hello”输出: “holle” 示例 2: 输入: “leetcode”输出: “leotcede” 说明:元音字母不包含字母”y”。 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/reverse-vowels-of-a-string著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 核心思路概述元音字母一共有5个，分别为’a’,’e’,’i’,’o’,’u’; 当然该题要注意元音字母对应的大写形式也算 因此，使用双指针，一个在首，一个在尾，当两指针未相遇时，如果两个指针指的都是元音字母或其大写形式，那么就交换两个字母；如果不是，那么就左指针向后，右指针往前 解题步骤 建立left,right双指针；将字符串s转换为字符串数组 left与right双指针，一个在首，一个在尾，当两指针未相遇时，如果两个指针指的都是元音字母或其大写形式，那么就交换两个字母；如果不是，那么就左指针向后，右指针往前 Coding实现123456789101112131415161718192021222324/** * @param &#123;string&#125; s * @return &#123;string&#125; */var reverseVowels = function(s) &#123; s=s.split(''); let left=0; let yuan=['a','e','i','o','u']; let right=s.length-1; while(left&lt;right)&#123; if(yuan.includes(s[left].toLowerCase())&amp;&amp;yuan.includes(s[right].toLowerCase()))&#123; [s[left],s[right]]=[s[right],s[left]]; left++; right--; &#125; if(!yuan.includes(s[left].toLowerCase())) &#123; left++; &#125; if(!yuan.includes(s[right].toLowerCase())) &#123; right--; &#125; &#125; return s.join('');&#125;;]]></content>
      <categories>
        <category>leetcode题解与算法</category>
      </categories>
      <tags>
        <tag>双指针</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[leetcode-933 最近的请求次数]]></title>
    <url>%2F2019%2F08%2F04%2Fleetcode-933%2F</url>
    <content type="text"><![CDATA[最近的请求次数题目描述写一个 RecentCounter 类来计算最近的请求。 它只有一个方法：ping(int t)，其中 t 代表以毫秒为单位的某个时间。 返回从 3000 毫秒前到现在的 ping 数。 任何处于 [t - 3000, t] 时间范围之内的 ping 都将会被计算在内，包括当前（指 t 时刻）的 ping。 保证每次对 ping 的调用都使用比之前更大的 t 值。 示例： 输入：inputs = [“RecentCounter”,”ping”,”ping”,”ping”,”ping”], inputs = [[],[1],[100],[3001],[3002]]输出：[null,1,2,3,3] 提示： 每个测试用例最多调用 10000 次 ping。 每个测试用例会使用严格递增的 t 值来调用 ping。 每次调用 ping 都有 1 &lt;= t &lt;= 10^9。 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/number-of-recent-calls著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 核心思路概述该题目的意思就是计算在当前时刻往前3000毫秒到此时（即[t - 3000, t]）的所有Ping的数量 解题步骤 在RecentCounter构造函数中设置一个队列queue用来保存按时间顺序到来的ping的时间 利用出队列来删去当前队列中小于当前时间-3000毫秒的队列项 返回队列长度 Coding实现1234567891011121314151617181920212223242526var RecentCounter = function() &#123; this.queue=[];&#125;;/** * @param &#123;number&#125; t * @return &#123;number&#125; */RecentCounter.prototype.ping = function(t) &#123; let queue=this.queue; if(t===null) return null; else&#123; queue.push(t); while(queue[0]&lt;t-3000)&#123; queue.shift(); &#125; return queue.length; &#125;&#125;;/** * Your RecentCounter object will be instantiated and called as such: * var obj = new RecentCounter() * var param_1 = obj.ping(t) */]]></content>
      <categories>
        <category>leetcode题解与算法</category>
      </categories>
      <tags>
        <tag>队列</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[变量、作用域和内存问题]]></title>
    <url>%2F2019%2F08%2F04%2F%E5%8F%98%E9%87%8F%E3%80%81%E4%BD%9C%E7%94%A8%E5%9F%9F%E5%92%8C%E5%86%85%E5%AD%98%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[基本类型值和引用类型值的存储与复制变量类型与内存的关系栈内存基本数据类型保存在栈内存中，因为基本数据类型占用空间小、大小固定，通过按值来访问，属于被频繁使用的数据 堆内存引用数据类型存储在堆内存中，因为引用数据类型占据空间大、大小不固定。 如果存储在栈中，将会影响程序运行的性能； 引用数据类型在栈中存储了指针，该指针指向堆中该实体的起始地址。 当解释器寻找引用值时，会首先检索其在栈中的地址，取得地址后从堆中获得实体 变量复制基本类型值的变量复制如果从一个变量向另一个变量复制基本类型的值，那么就会在变量对象（每个执行环境都有一个与之相关联的变量对象，当前环境中的所有变量和函数都会保存在这个对象中）上创建一个新的值，然后把该值复制到为新变量分配的位置上。 基本类型变量复制完毕后，两个变量是相互独立的。因为两个变量占据的是不同的栈内存空间。 12345const a=20;let b=a;console.log(a,b); // 20,20b=30;console.log(a,b); // 20,30 引用数据类型值的变量复制当从一个变量向另一个变量复制引用类型的值时，同样也会将存储在变量对象中的值复制一份放到位新变量分配的空间中。不同的是，这个值的副本实际上是一个指针，而这个指针指向存储在堆中的一个对象。 两个变量实际上引用的是同一个对象，因此改变其中一个变量，就会影响另一个变量。 123let m=&#123;a:10,b:20&#125;;let n=m;console.log(n); //&#123;a:10,b:20&#125; 函数的参数传递相当于变量复制es中所有函数的参数传递都是按值传递的。 基本类型值的参数传递就相当于基本类型值的变量复制，即创建了一个新的局部变量，值为传过来的参数值。 1234567let a=1;function test(n)&#123; console.log(n); //1 n++;&#125;test(a);console.log(a); // 1 引用类型值的参数传递也相当于引用类型值的变量传递，即创建了一个新的局部变量，保存的是传过来的参数的指针地址，两个变量在栈内存中有着不同的内存空间，但是指向堆内存中的同一个对象。 函数内部变量有变化时（指的是不改变该变量的指针指向地址）也会影响函数外部对象 而当该变量的指针指向地址改变后，两个变量就不在指向了同一个变量，因此之后函数内部变量的变化不会体现在函数外部 123456let a=&#123;item:1&#125;;function test(n)&#123; console.log(a===n); //true n=&#123;&#125;; console.log(a===n);&#125; 执行环境及作用域执行环境(执行上下文)执行环境可能有三种情况 全局执行环境(浏览器中的window对象和node环境中的global对象) —— 代码第一次执行的默认环境 函数执行环境 —— 执行流进入函数体 当执行流进入一个函数时，函数的执行环境会被推入一个环境中。当该函数执行完毕后，栈将其环境弹出，把控制权返回给之前的执行环境 Eval code（Eval code）——代码在eval函数内部执行 每个执行环境中都有一个与之关联的变量对象，用来存储在该环境中定义的变量和函数(但是我们无法访问到这个变量对象，是解析器在后台处理数据时会使用到) 作用域对于作用域，我的理解是它在某种程度上相当于执行环境，每个作用域都有当前作用域的变量和对象。但是作用域之间的变量和函数时相互隔离的，也就说不同作用域下的同名变量不会产生冲突 作用域链当代码在一个环境中执行时，会创建变量对象的一个作用域链。 作用域链的用途：是用来保证对执行环境有权访问的所有变量和函数的有序访问。 作用域的前端，始终都是当前的执行环境的变量对象。如果这个环境是函数，那么将其环境对象作为变量对象。作用链中的下一个对象是包含当前执行环境的执行环境的变量对象。这样，一直延续到全局执行环境。全局执行环境的变量对象始终都是作用域链的最后一个对象 12345678910function a()&#123; let m=1; function b()&#123; let m=2; console.log(m); // 2 &#125; b(); console.log(m); // 1&#125;a(); 延长作用域链有两种方式可以延长作用域链 try-catch语句的catch块 with语句 这两个语句都会在当前作用域链的前端添加一个变量对象。 对with语句来说，会将指定的对象添加到作用域链中。 对catch语句来说，会创建一个新的变量对象，其中包含的是被抛出的错误对象的声明 垃圾收集JavaScript 具有自动垃圾收集机制（GC：Garbage Collecation），也就是说，执行环境会负责管理代码执行过程中使用的内存。 标记清除JavaScript中最常用的垃圾收集方式就是标记清除，当变量进入环境后，就将这个变量标记为“进入环境”；而当变量离开环境时，就将其标记为“离开环境”。从而垃圾回收器完成垃圾回收工作 管理内存优化内存占用的最佳方式，就是为执行中的代码只保存必要的数据。一旦数据不再有用，最好将其值设置为null来释放其引用————这个做法叫做解除引用。 局部变量在离开执行环境是会自动被解除引用。 因此我们通常来解除全局执行环境中的引用]]></content>
      <categories>
        <category>javaScript基础</category>
      </categories>
      <tags>
        <tag>基础语法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[leetcode-237 删除链表中的节点]]></title>
    <url>%2F2019%2F08%2F03%2Fleetcode-237%2F</url>
    <content type="text"><![CDATA[删除链表中的节点题目描述请编写一个函数，使其可以删除某个链表中给定的（非末尾）节点，你将只被给定要求被删除的节点。 现有一个链表 – head = [4,5,1,9]，它可以表示为: 示例 1: 输入: head = [4,5,1,9], node = 5输出: [4,1,9]解释: 给定你链表中值为 5 的第二个节点，那么在调用了你的函数之后，该链表应变为 4 -&gt; 1 -&gt; 9. 示例 2: 输入: head = [4,5,1,9], node = 1输出: [4,5,9]解释: 给定你链表中值为 1 的第三个节点，那么在调用了你的函数之后，该链表应变为 4 -&gt; 5 -&gt; 9. 说明: 链表至少包含两个节点。 链表中所有节点的值都是唯一的。 给定的节点为非末尾节点并且一定是链表中的一个有效节点。 不要从你的函数中返回任何结果。 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/delete-node-in-a-linked-list著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 核心思路概述一开始看到这个题目也是傻了一下，为什么只是传入一个要删除的节点，而不传入整个链表。后来一想，题目给定的初始链表中，每个节点的next存在的指向关系是一定的。那么我们就可以不需要考虑要删除节点之前的节点，只需要将要删除的节点的val值和next指向改变就可以了 解题步骤 改变要删除节点的val值为其下一个节点的val值 改变要删除节点的next指向为其下一个节点的下一个节点 Coding实现123456789101112131415/** * Definition for singly-linked list. * function ListNode(val) &#123; * this.val = val; * this.next = null; * &#125; *//** * @param &#123;ListNode&#125; node * @return &#123;void&#125; Do not return anything, modify node in-place instead. */var deleteNode = function(node) &#123; node.val=node.next.val; node.next=node.next.next;&#125;;]]></content>
      <categories>
        <category>leetcode题解与算法</category>
      </categories>
      <tags>
        <tag>链表</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[arguments与模拟函数重载]]></title>
    <url>%2F2019%2F08%2F03%2Farguments%E4%B8%8E%E6%A8%A1%E6%8B%9F%E5%87%BD%E6%95%B0%E9%87%8D%E8%BD%BD%2F</url>
    <content type="text"><![CDATA[argumentsarguments对象是所有（非箭头）函数中都可用的局部变量。 通过该对象可以访问参数数组。因为此对象包含传递给函数的每个参数，第一个参数在索引0处。 12345function a()&#123; console.log(arguments); //Arguments &#123; 0: 1, 1: 2, 2: 3, … &#125; console.log(arguments[0]); //1&#125;a(1,2,3); 由此可以看到，arguments对象并不是Array的实例，它是类数组对象。因此，可以通过方括号语法访问它的每一个元素 arguments对象内的属性值永远与对应命名参数的值保持同步 123456function a(num)&#123; console.log(arguments[0]); //1 num=11; console.log(arguments[0]); //11&#125;a(1,2,3); 模拟函数重载重载的概念在Java语言中，函数或者方法有相同的名称，但是参数的类型或数量不同，这样的同名不同参数的函数或者方法之间，互相称之为重载函数。 为什么js没有重载然而，js中并没有重载的概念，因为： 1234567function a(num)&#123; console.log(1);&#125;function a(num1,num2)&#123; console.log(2);&#125;a(); // 2 如果定义了多个同名函数，那么该名字只属于后定义的函数，所以js中不能像Java一样有传统意义上的重载 js模拟函数重载其实，通过arguments,我们就可以通过检查传入函数中的参数类型和数量来做出不同的反应，从而模拟方法的重载 12345678910function a()&#123; if(arguments.length===0)&#123; console.log(0); &#125; else if(arguments.length===1)&#123; console.log(1); &#125;&#125;a(); // 0a(1); // 1]]></content>
      <categories>
        <category>javaScript基础</category>
      </categories>
      <tags>
        <tag>基础语法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[循环 (for...of与for...in)]]></title>
    <url>%2F2019%2F08%2F03%2F%E5%BE%AA%E7%8E%AF%2F</url>
    <content type="text"><![CDATA[循环语句类型 for 语句 do…while 语句 while 语句 labeled 语句 break 语句 continue 语句 for…in 语句 for…of 语句 for…infor…in 语句循环一个指定的变量来循环一个对象所有可枚举的属性。JavaScript 会为每一个不同的属性执行指定的语句。 123456789const items=&#123; item1:1, item2:2, item3:3&#125;for(let a in items)&#123; console.log(a); // item1,item2,item3 console.log(items[a]); //1,2,3&#125; for…offor…of语句在可迭代的对象(在es6中，所有的集合对象(数组、Set集合及Map集合)和字符串都是可迭代对象)上创建了一个循环 ，对值的每一个独特的属性调用一个将被执行的自定义的和语句挂钩的迭代。 for…of循环每执行一次都会调用可迭代对象的next()方法，并将迭代器返回的结果对象的value属性存储在一个变量中，循环将持续执行这一过程直到返回对象的done属性的值为true 与 for…in 循环遍历的结果是数组元素的下标不同的是， for…of 遍历的结果是元素的值： 1234567891011121314151617181920let arr=[4,5,6];let str='string';let set=new Set([1,'a',3]);let map=new Map([['a',1],['b',2]]);//遍历数组for(let a of arr)&#123; console.log(a); //4,5,6&#125;//遍历字符串for(let s of str)&#123; console.log(s); //s,t,r,i,n,g&#125;//遍历set集合for(let k of set)&#123; console.log(k); //1,'a',3&#125;//遍历map集合for(let m of map)&#123; console.log(m); //[ 'a', 1 ],[ 'b', 2 ]&#125; 总结 倘若是遍历普通对象(非迭代对象)，那么使用for…in最佳，遍历得到属性名 倘若是遍历可迭代对象，那么根据需求来，如果不需要一些下标信息（例如set集合，字符串）那么使用for…of最佳 如果是数组和map，那么使用forEach会更加方便]]></content>
      <categories>
        <category>javaScript基础</category>
      </categories>
      <tags>
        <tag>基础语法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[null与{}其实不相等]]></title>
    <url>%2F2019%2F08%2F03%2F%E7%A9%BA%E5%AF%B9%E8%B1%A1%2F</url>
    <content type="text"><![CDATA[引言{}与null相等吗？看一下下面的例子： 1console.log(&#123;&#125;===null); //false 显然，{}与null是不相等的 关于{}与null当我们在浏览器环境下，输入以下代码会发现： 1console.log(&#123;&#125;); // Object &#123; &#125; 作为比较，当需要输出null时会发现： 1console.log(null); // null 关于是否是空对象，我们可以采用instanceof的方法来检测 1console.log(&#123;&#125; instanceof Object); //true 那么，{}这个对象的原型链顶部会是Object，那么{}是一个不完全空的对象，只不过他没有任何属性罢了 1console.log(null instanceof Object); //false 而null的原型链上都找不到Object，那么null就是一个完完全全的空对象指针]]></content>
      <categories>
        <category>javaScript基础</category>
      </categories>
      <tags>
        <tag>基础语法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[布尔操作符(1&&2和1||2)]]></title>
    <url>%2F2019%2F08%2F03%2F%E5%B8%83%E5%B0%94%E6%93%8D%E4%BD%9C%E7%AC%A6%2F</url>
    <content type="text"><![CDATA[mdn总结 运算符 语法 说明 逻辑与，AND（&amp;&amp;） expr1 &amp;&amp; expr2 若 expr1 可转换为 true，则返回 expr2；否则，返回 expr1。 逻辑或，OR（||） expr1 || expr2 若 expr1 可转换为 true，则返回 expr1；否则，返回 expr2。 逻辑非，NOT（!） !expr 若 expr 可转换为 true，则返回 false；否则，返回 true。 逻辑非 – !逻辑非操作符首先会将它的操作数转换为一个布尔值，然后再对其求反 123456console.log(!123); //falseconsole.log(!''); //trueconsole.log(!undefined); //trueconsole.log(!null); //trueconsole.log(!new String('1')); //falseconsole.log(!false); //true 逻辑与 – &amp;&amp;注意：逻辑与(&amp;&amp;)操作可以应用于任何类型的操纵数，而不仅仅是布尔值。 在有一个操作数不是布尔值的情况下，逻辑与操作就不一定返回布尔值；因此若要显示返回布尔值，则可以使用Boolean转型函数显示返回 逻辑与操作属于短路操作，即如果第一个操作数能够决定结果，那么就不会再对第二个操作数求值。 1234console.log(1&amp;&amp;2); //2console.log(0&amp;&amp;1); //0console.log(123&amp;&amp;'qwe'); //'qwe'console.log(&#123;&#125;&amp;&amp;null); //null 因为&#123;&#125;并不等于null，&#123;&#125;是一个不完全为空的对象，所以&#123;&#125;转换为逻辑值会是true 逻辑或 – ||与逻辑与操作类似，逻辑或操作也是短路操作。也就是说，如果第一个操作数的求值结果为true,就不会对第二个操作数求值了 1234console.log(1||2); //1console.log(0||1); //1console.log(123||'qwe'); //123console.log(&#123;&#125;||null); //&#123;&#125;]]></content>
      <categories>
        <category>javaScript基础</category>
      </categories>
      <tags>
        <tag>基础语法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[leetcode-283 移动零]]></title>
    <url>%2F2019%2F08%2F02%2Fleetcode-283%2F</url>
    <content type="text"><![CDATA[移动零题目描述给定一个数组 nums，编写一个函数将所有 0 移动到数组的末尾，同时保持非零元素的相对顺序。 示例: 输入: [0,1,0,3,12]输出: [1,3,12,0,0] 说明: 必须在原数组上操作，不能拷贝额外的数组。 尽量减少操作次数。 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/move-zeroes著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 核心思路概述利用双指针，一个left指针用来寻找为0的元素，当找到后，该元素后面的所有元素前移，并将第二个指向数组末尾的指针right的元素值赋为0；如此循环直到left&gt;right 解题步骤 设置left指针指向数组第一个元素，设置right指针指向数组的最后一个元素 移动Left寻找数组中为0元素，当找到后，该元素后面的所有元素前移，并将第二个指向数组末尾的指针right的元素值赋为0；如此循环直到left&gt;right Coding实现123456789101112131415161718192021/** * @param &#123;number[]&#125; nums * @return &#123;void&#125; Do not return anything, modify nums in-place instead. */var moveZeroes = function(nums) &#123; let left=0; let right=nums.length-1; while(left&lt;right)&#123; if(nums[left]===0)&#123; for(let i=left;i&lt;right;i++)&#123; nums[i]=nums[i+1]; &#125; nums[right]=0; right--; &#125; else &#123; left++; &#125; &#125; return nums;&#125;;]]></content>
      <categories>
        <category>leetcode题解与算法</category>
      </categories>
      <tags>
        <tag>双指针</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据类型]]></title>
    <url>%2F2019%2F08%2F01%2F%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%2F</url>
    <content type="text"><![CDATA[数据类型简单数据类型 Null (null值本质上是一个空对象指针) Undefined String Number Boolean Symbol 复杂数据类型 Object(包括Array、Function、Date、RegExp、Error、Arguments等更为具体的引用类型) 数据类型的检测判断typeof typeof 常用于判断基本数据类型 一些注意点 typeof返回的是一个字符串,因此 typeof typeof 1 //(任意数据类型)都会返回string null是一个空对象指针，因此typeof null会返回object 对于函数function的判断，tpeof function会返回function而不是对象object 从技术角度讲，函数在es中是对象，而不是一种数据类型。然而，函数也确实有一些特殊的属性，因此通过typeof操作符来区分函数和其他对象是有必要的 对于除function外的复杂数据类型，例如数组，set,map都会返回对象object 1234567891011121314151617181920212223typeof 123 // "number"typeof "abc" // "string" typeof (new String()) //objecttypeof true // "boolean" typeof &#123;a: 1&#125; // "object" typeof null //objecttypeof function foo() &#123;&#125; // "function" typeof undefined // "undefined" typeof Symbol('foo') // "symbol"typeof (new Set()) //"object"typeof (new Map()) //"object"typeof typeof 1 //"string" typeof的不足使用 typeof 方法来检测数据类型，基本类型大部分都能被准确检测并返回正确的字符串（除了 Null 类型，其返回 object 字符串），而引用类型大部分都不能够被准确检测（除了 Function 类型能够准确返回 function 字符串外，其它的都返回了 object 字符串）。 instanceofinstanceof用于判断引用类型 instanceof 运算符用于测试构造函数的prototype属性是否出现在对象的原型链中的任何位置 12let str=new String();console.log(str instanceof String); //true 123456function Person()&#123;&#125;;function Student()&#123;&#125;;let person=new Person();Student.prototype=person;let student=new Student();console.log(student instanceof Person) //true 语法 object instanceof constructor 因此当使用instanceof判断基本数据类型时就会返回false,与此同时,instanceof 右端也必须是某个构造函数 12'a' instanceof String //false123 instanceof Number //false null instanceof object那么基本数据类型中的null呢，既然typeof null===object;那么null instanceof object呢？很不幸,返回的会是false 简单来说，null并不是以Object为原型创建出来的 1null instanceof object //false 函数模拟instanceof知道instaceof的原理是判断构造函数的prototype属性是否出现在对象的原型链中的任何位置时，那么就不难模拟一个函数来实现instanceof 12345678910function instance(a,b)&#123; let bPro=b.prototype; //取b的显示原型 let aPro=a.__proto__; //取a的隐式原型 //或者使用Object.getPrototypeOf(a)取得a的隐式原型 while(true)&#123; if(aPro===bPro) return true; if(aPro===Object.prototype) return false; aPro=aPro.__proto__; &#125;&#125; Object.prototype.toString()一个完善的类型检测方案 每个对象都有一个toString()方法，当该对象被表示为一个文本值时，或者一个对象以预期的字符串方式引用时自动调用。默认情况下，toString()方法被每个Object对象继承。如果此方法在自定义对象中未被覆盖，toString() 返回 “[object type]”，其中type是对象的类型 可以通过toString() 来获取每个对象的类型。为了每个对象都能通过 Object.prototype.toString() 来检测，需要以 Function.prototype.call() 或者 Function.prototype.apply() 的形式来调用，传递要检查的对象作为第一个参数，称为thisArg。 123456789101112var toString=Object.prototype.toString;console.log(toString.call(undefined)); // [object Undefined]console.log(toString.call(null)); // [object Null]console.log(toString.call(true)); // [object Boolean]console.log(toString.call(123)); // [object Number]console.log(toString.call('a')); // [object String]console.log(toString.call(new Object()); // [object Object]console.log(toString.call([1,2,3])); // [object Array]console.log(toString.call(function a()&#123;&#125;)); // [object Function]console.log(toString.call(new Date())); // [object Date] 数组判断isArray() Array.isArray() 用于确定传递的值是否是一个 Array。 12345678Array.isArray([1, 2, 3]); // trueArray.isArray(&#123;foo: 123&#125;); // falseArray.isArray("foobar"); // falseArray.isArray(undefined); // false instanceof12let a=[1,2,3];console.log(a instanceof Array); // true 综述一个较好的解决方案应该是检测基本数据类型时使用typeof，当然null除外；检测复杂数据类型时使用Object.prototype.toString() Undefined类型undefined指那些被声明但未被初始化的值 Null类型null值表示一个空对象指针，因此typeof null === object Boolean类型及相应转换规则转型函数Boolean()12let str='hello';console.log(Boolean(str)); //true Boolean自动转换规则 数据类型 转换为true值 转换为false值 Number 任何非0数值 0和NaN String 非空字符串 空字符串（””） Bollean true false Object 任何object(包括{}，因为{}是一个不完全空的对象) null Undefined 无 undefined Number类型为什么0.1+0.2!==0.3 NaNNaN,指的是非数值，用来表示一个本来要返回数值的操作数未返回数值的情况，例如： 1console.log('a'-1); //NaN 任何设置NaN的操作都会返回NaN,甚至NaN与任何值都不相等包括其本身，包括但不限于： 12console.log(NaN-1); //NaNconsole.log(NaN===NaN); //false isNaN函数 isNaN() 函数用来确定一个值是否为NaN 。注：isNaN函数内包含一些非常有趣的规则；你也可以使用 ECMAScript 2015 中定义的 Number.isNaN() 来判断。 下一个版本的ECMAScript (ES2015)包含Number.isNaN()函数。通过Number.isNaN(x)来检测变量x是否是一个NaN将会是一种可靠的做法。然而，在缺少Number.isNaN函数的情况下, 通过表达式(x != x) 来检测变量x是否是NaN会更加可靠。 一个isNaN的 polyfill 可以理解为（这个polyfill利用了NaN自身永不相等于自身这一特征 ）： 1234var isNaN = function(value) &#123; var n = Number(value); //利用Number()函数进行数值转换 return n !== n;&#125;; 例子12345678910111213141516171819202122isNaN(NaN); // trueisNaN(undefined); // trueisNaN(&#123;&#125;); // trueisNaN(true); // falseisNaN(null); // falseisNaN(37); // false// stringsisNaN("37"); // false: 可以被转换成数值37isNaN("37.37"); // false: 可以被转换成数值37.37isNaN("37,5"); // trueisNaN('123ABC'); // true: parseInt("123ABC")的结果是 123, 但是Number("123ABC")结果是 NaNisNaN(""); // false: 空字符串被转换成0isNaN(" "); // false: 包含空格的字符串被转换成0// datesisNaN(new Date()); // falseisNaN(new Date().toString()); // trueisNaN("blabla") // true: "blabla"不能转换成数值 // 转换成数值失败， 返回NaN 数值转换 Number() parseInt() parseFloat() String类型toString()方法作用：返回值的字符串表现数值，布尔值，对象和字符串都有该方法但是undefined和null没有该方法 1234console.log(123.toString()); //'123'console.log(true.toString()); //'true'let a=&#123;item:1&#125;;console.log(a.toString()); //'[object Object]' String()转型函数该函数不同于toString不能转换null和undefined;该方法可以转换任何类型的值 转换规则如下： 如果该类型有toString()方法，那么就调用该方法 如果为null，则返回”null” 如果为undefined，则返回”undefined” Object类型Object类型是所有对象的基础，也就是所有对象都是继承与Object的 123456let a=new Object();let str=new String();let date=new Date();console.log(a instanceof Object); //trueconsole.log(str instanceof Object); //trueconsole.log(date instanceof Object); //true 对象可以通过执行new操作符后跟要创建的对象类型的名称来创建，例 123let a=new Object();let str=new String();let date=new Date(); Object实例的一些属性与方法 constructor: 指向构造函数 isPrototypeOf(object)：用于检查传入的对象是否是当前对象的原型 toString()：返回对象的字符串表示 valueOf(): 返回对象的字符串、数值或布尔值表示。通常与toString()方法返回值相同]]></content>
      <categories>
        <category>javaScript基础</category>
      </categories>
      <tags>
        <tag>基础语法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[leetcode-1021 删除最外层的括号]]></title>
    <url>%2F2019%2F07%2F31%2Fleetcode-1021%2F</url>
    <content type="text"><![CDATA[删除最外层的括号题目描述有效括号字符串为空 (“”)、”(“ + A + “)” 或 A + B，其中 A 和 B 都是有效的括号字符串，+ 代表字符串的连接。例如，””，”()”，”(())()” 和 “(()(()))” 都是有效的括号字符串。 如果有效字符串 S 非空，且不存在将其拆分为 S = A+B 的方法，我们称其为原语（primitive），其中 A 和 B 都是非空有效括号字符串。 给出一个非空有效字符串 S，考虑将其进行原语化分解，使得：S = P_1 + P_2 + … + P_k，其中 P_i 是有效括号字符串原语。 对 S 进行原语化分解，删除分解中每个原语字符串的最外层括号，返回 S 。 示例 1： 输入：”(()())(())”输出：”()()()”解释：输入字符串为 “(()())(())”，原语化分解得到 “(()())” + “(())”，删除每个部分中的最外层括号后得到 “()()” + “()” = “()()()”。 示例 2： 输入：”(()())(())(()(()))”输出：”()()()()(())”解释：输入字符串为 “(()())(())(()(()))”，原语化分解得到 “(()())” + “(())” + “(()(()))”，删除每隔部分中的最外层括号后得到 “()()” + “()” + “()(())” = “()()()()(())”。 示例 3： 输入：”()()”输出：””解释：输入字符串为 “()()”，原语化分解得到 “()” + “()”，删除每个部分中的最外层括号后得到 “” + “” = “”。 提示： S.length &lt;= 10000 S[i] 为 “(“ 或 “)” S 是一个有效括号字符串 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/remove-outermost-parentheses著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 核心思路概述关于括号匹配问题，很容易想到用栈来解决。 遇到 ‘ ( ‘ 入栈，遇到 ‘ ) ‘ 则出栈。则当该栈为空时，则代表之前的括号都已匹配。那么就可以将先前的括号去掉最外层的括号 解题步骤 设定一个数组stack用来表示栈操作，并预先压入第一个元素’(‘ 设定一个数组temp用来存放已经匹配完成的括号，并预先设定第一个元素’(‘ 从第二个元素开始遍历，遇到 ‘ ( ‘ 入栈，遇到 ‘ ) ‘ 则出栈。则当该栈为空时，则代表之前的括号都已匹配。那么就可以将先前的括号去掉最外层的括号,并压入结果数组ans 返回ans Coding实现123456789101112131415161718192021222324/** * @param &#123;string&#125; S * @return &#123;string&#125; */var removeOuterParentheses = function(S) &#123; let stack=['(']; let temp=['(']; let ans=[]; S=S.split(''); for(let i=1;i&lt;S.length;i++)&#123; temp.push(S[i]); if(S[i]===')')&#123; stack.pop(); if(stack.length===0)&#123; temp.pop(); temp.shift(); ans.push(...temp); temp=[]; &#125; &#125; else stack.push(S[i]); &#125; return ans.join('');&#125;;]]></content>
      <categories>
        <category>leetcode题解与算法</category>
      </categories>
      <tags>
        <tag>栈</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[leetcode-1122 数组的相对排序]]></title>
    <url>%2F2019%2F07%2F30%2Fleetcode-1122%2F</url>
    <content type="text"><![CDATA[数组的相对排序题目描述给你两个数组，arr1 和 arr2， arr2 中的元素各不相同 arr2 中的每个元素都出现在 arr1 中 对 arr1 中的元素进行排序，使 arr1 中项的相对顺序和 arr2 中的相对顺序相同。未在 arr2 中出现过的元素需要按照升序放在 arr1 的末尾。 示例： 输入：arr1 = [2,3,1,3,2,4,6,7,9,2,19], arr2 = [2,1,4,3,9,6]输出：[2,2,2,1,4,3,3,9,6,7,19] 提示： arr1.length, arr2.length &lt;= 1000 0 &lt;= arr1[i], arr2[i] &lt;= 1000 arr2 中的元素 arr2[i] 各不相同 arr2 中的每个元素 arr2[i] 都出现在 arr1 中 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/relative-sort-array著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 核心思路概述目前觉得暴力解法最简单 解题步骤双循环，时间复杂度为O(n*m) Coding实现1234567891011121314151617181920212223/** * @param &#123;number[]&#125; arr1 * @param &#123;number[]&#125; arr2 * @return &#123;number[]&#125; */var relativeSortArray = function(arr1, arr2) &#123; let ans=[]; let el=[]; arr1.forEach(value=&gt;&#123; if(!arr2.includes(value))&#123; el.push(value); &#125; &#125;) arr2.forEach(value2=&gt;&#123; arr1.forEach(value1=&gt;&#123; if(value1===value2)&#123; ans.push(value2); &#125; &#125;) &#125;) el.sort((a,b)=&gt;&#123;return a-b;&#125;) return ans.concat(el);&#125;;]]></content>
      <categories>
        <category>leetcode题解与算法</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[leetcode-344 反转字符串]]></title>
    <url>%2F2019%2F07%2F30%2Fleetcode-344%2F</url>
    <content type="text"><![CDATA[反转字符串题目描述编写一个函数，其作用是将输入的字符串反转过来。输入字符串以字符数组 char[] 的形式给出。 不要给另外的数组分配额外的空间，你必须原地修改输入数组、使用 O(1) 的额外空间解决这一问题。 你可以假设数组中的所有字符都是 ASCII 码表中的可打印字符。 示例 1： 输入：[“h”,”e”,”l”,”l”,”o”]输出：[“o”,”l”,”l”,”e”,”h”] 示例 2： 输入：[“H”,”a”,”n”,”n”,”a”,”h”]输出：[“h”,”a”,”n”,”n”,”a”,”H”] 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/reverse-string著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 核心思路概述题目要求是原地修改数组，并且只能使用O(1)的额外空间。因此，不能创建新的数组来存放数组元素，此时可以考虑使用双指针，一个置首，一个置尾。首向后，尾向前，交换两个指针的值即可。 解题步骤 建立left,right双指针 当left&lt;=right时，交换两指针元素 Coding实现1234567891011121314/** * @param &#123;character[]&#125; s * @return &#123;void&#125; Do not return anything, modify s in-place instead. */var reverseString = function(s) &#123; let left=0; let right=s.length-1; while(left&lt;=right)&#123; [s[left],s[right]]=[s[right],s[left]]; left++; right--; &#125; return s;&#125;;]]></content>
      <categories>
        <category>leetcode题解与算法</category>
      </categories>
      <tags>
        <tag>双指针</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[leetcode-977 有序数组的平方]]></title>
    <url>%2F2019%2F07%2F29%2Fleetcode-977%2F</url>
    <content type="text"><![CDATA[有序数组的平方题目描述给定一个按非递减顺序排序的整数数组 A，返回每个数字的平方组成的新数组，要求也按非递减顺序排序。 示例 1： 输入：[-4,-1,0,3,10]输出：[0,1,9,16,100] 示例 2： 输入：[-7,-3,2,3,11]输出：[4,9,9,49,121] 提示： 1&lt;= A.length &lt;= 10000 -10000 &lt;= A[i] &lt;= 10000 A 已按非递减顺序排序。 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/squares-of-a-sorted-array著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 核心思路概述将该数组的每一个元素平方后在将该数组排序并返回 解题步骤 将该数组的每一个元素平方 排序该数组并返回 Coding实现123456789/** * @param &#123;number[]&#125; A * @return &#123;number[]&#125; */var sortedSquares = function(A) &#123; return A.map(value=&gt;&#123; return value*value; &#125;).sort((a,b)=&gt;&#123;return a-b;&#125;)&#125;;]]></content>
      <categories>
        <category>leetcode题解与算法</category>
      </categories>
      <tags>
        <tag>数组</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[leetcode-350 两个数组的交集 II]]></title>
    <url>%2F2019%2F07%2F28%2Fleetcode-350%2F</url>
    <content type="text"><![CDATA[两个数组的交集 II题目描述给定两个数组，编写一个函数来计算它们的交集。 示例 1: 输入: nums1 = [1,2,2,1], nums2 = [2,2]输出: [2,2] 示例 2: 输入: nums1 = [4,9,5], nums2 = [9,4,9,8,4]输出: [4,9] 说明： 输出结果中每个元素出现的次数，应与元素在两个数组中出现的次数一致。我们可以不考虑输出结果的顺序。 进阶: 如果给定的数组已经排好序呢？你将如何优化你的算法？ 如果 nums1 的大小比 nums2 小很多，哪种方法更优？ 如果 nums2 的元素存储在磁盘上，磁盘内存是有限的，并且你不能一次加载所有的元素到内存中，你该怎么办？ 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/intersection-of-two-arrays-ii著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 核心思路概述该题可以考虑用双指针方法和哈希表去解决。双指针主要循环比较两个数是否相等；哈希表主要是记录每个数组中每个元素出现的次数 解题步骤双指针 将两个数组进行排序 设定两个指针，分别指向两个数组的第一个元素 如果两个指针指向的元素相等，那么就把该元素push入ans数组；并且两个指针向后移动 如果不等，那么指向较小元素的那个指针向后移动 哈希表 建立两个哈希表，分别存储每个数组中的每个元素存储的个数 遍历其中一个哈希表，如果另一个哈希表中也存在该键，比较两个键值大小，按照小的那个键值循环则将该键push入ans数组； Coding实现双指针解法代码12345678910111213141516171819202122232425262728/** * @param &#123;number[]&#125; nums1 * @param &#123;number[]&#125; nums2 * @return &#123;number[]&#125; */var intersect = function(nums1, nums2) &#123; let nums1Index=0; let nums2Index=0; let ans=[]; nums1.sort((a,b)=&gt;&#123;return a-b;&#125;); nums2.sort((a,b)=&gt;&#123;return a-b;&#125;); while(nums1Index&lt;nums1.length&amp;&amp;nums2Index&lt;nums2.length)&#123; let num1=nums1[nums1Index]; let num2=nums2[nums2Index]; if(num1===num2)&#123; ans.push(num1); nums1Index++; nums2Index++; &#125; else if(num1&lt;num2)&#123; nums1Index++; &#125; else&#123; nums2Index++; &#125; &#125; return ans;&#125;; 哈希表解法代码12345678910111213141516171819202122232425262728293031/** * @param &#123;number[]&#125; nums1 * @param &#123;number[]&#125; nums2 * @return &#123;number[]&#125; */var intersect = function(nums1, nums2) &#123; let map1=new Map(); let map2=new Map(); let ans=[]; function count(nums,map)&#123; nums.forEach(value=&gt;&#123; if(!map.has(value))&#123; map.set(value,1); &#125; else &#123; map.set(value,map.get(value)+1); &#125; &#125;) &#125; count(nums1,map1); count(nums2,map2); map1.forEach((value,key)=&gt;&#123; if(map2.has(key))&#123; let num=value&gt;map2.get(key)?map2.get(key):value; for(let i=0;i&lt;num;i++)&#123; ans.push(key); &#125; &#125; &#125;) return ans;&#125;;]]></content>
      <categories>
        <category>leetcode题解与算法</category>
      </categories>
      <tags>
        <tag>哈希表</tag>
        <tag>双指针</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[二分查找]]></title>
    <url>%2F2019%2F07%2F27%2F%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE%2F</url>
    <content type="text"><![CDATA[二分查找概述 二分查找的高效之处在于，每一步都可以去除当前区间中的一半元素，因此时间复杂度为O(logn) 严格递增序列的二分查找 输入：[1,2,3,7,9,11] , 3返回: 2 输入：[1,2,3,7,9,11] , 8返回：false 1234567891011121314151617function F(n,m)&#123; let left=0; let right=n.length-1; while(left&lt;=right)&#123; let mid=Math.floor((left+right)/2); if(m===n[mid])&#123; return mid; &#125; if(m&lt;n[mid])&#123; right=mid-1; &#125; else&#123; left=mid+1; &#125; &#125; return false;&#125; 在整体递增，局部重复的序列中二分查找第一个符合要求的元素位置 输入：[1,2,3,3,3,7,9,11],3返回: 2 输入：[1,2,3,3,3,7,9,11],8返回：false 123456789101112131415function F(n,m)&#123; let left=0; let right=n.length; while(left&lt;right)&#123; let mid=Math.floor((left+right)/2); //floor()函数，不大于当前数的最大数 if(m&lt;=n[mid])&#123; right=mid; &#125; else&#123; left=mid+1; &#125; &#125; if(n[left]===m) return left; else return false;&#125; 在整体递增，局部重复的序列中二分查找第一个大于给定元素的元素位置 输入：[1,2,3,3,3,7,9,11],3返回：5 输入：[1,2,3,3,3,7,9,11],4返回: ‘给定元素不存在’ 1234567891011121314151617function F(n,m)&#123; let left=0; let right=n.length-1; while(left&lt;right)&#123; let mid=Math.ceil((left+right)/2); //ceil()函数，不小于当前数的最小整数 if(m&gt;=n[mid])&#123; left=mid; &#125; else&#123; right=mid-1; &#125; &#125; if(n[right]===m) return right+1; else &#123; return ('给定元素不存在'); &#125;&#125; 求根号2的近似值 输入：0.00001 //精确度返回：(1.4142074584960938,1.414215087890625) 123456789101112131415function F(x)&#123; let left=1; let right=2; let num=Math.sqrt(2); while(right-left&gt;x)&#123; let mid=(left+right)/2; if(num&lt;mid)&#123; right=mid; &#125; if(num&gt;mid)&#123; left=mid; &#125; &#125; return `($&#123;left&#125;,$&#123;right&#125;)`&#125; 快速幂用于求解高次幂的快速求法比如2^10 基于二分的思想，又被称之为二分幂 快速幂基于以下原理： 如果b是奇数，那么有a^b=a*a^(b-1) 如果b是偶数，那么有a^b=(a^(b/2))*(a^(b/2)) 因此可以利用递归来求解快速幂 输入 2,10返回: 1024 123456789function F(a,n)&#123; if(n===0) return 1; if(n%2===1)&#123; return F(a,n-1)*a; &#125; else &#123; return F(a,n/2)*F(a,n/2); &#125;&#125;]]></content>
      <categories>
        <category>算法笔记</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[leetcode-852 山脉数组的峰顶索引]]></title>
    <url>%2F2019%2F07%2F27%2Fleetcode-852%2F</url>
    <content type="text"><![CDATA[山脉数组的峰顶索引题目描述我们把符合下列属性的数组 A 称作山脉： A.length &gt;= 3 存在 0 &lt; i &lt; A.length - 1 使得A[0] &lt; A[1] &lt; … A[i-1] &lt; A[i] &gt; A[i+1] &gt; … &gt; A[A.length - 1] 给定一个确定为山脉的数组，返回任何满足 A[0] &lt; A[1] &lt; … A[i-1] &lt; A[i] &gt; A[i+1] &gt; … &gt; A[A.length - 1] 的 i 的值。 示例 1： 输入：[0,1,0]输出：1 示例 2： 输入：[0,2,1,0]输出：1 提示： 3&lt;= A.length &lt;= 10000 0&lt;= A[i] &lt;= 10^6 A是如上定义的山脉 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/peak-index-in-a-mountain-array著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 核心思路概述要找某个特定的值，都可以使用二分查找来提高效率 解题步骤 二分法查找山脉的下标 一开始设定left为0，right为A.length-1,mid为Math.floor((left+right)/2) 如果A[mid]&gt;A[mid+1]&amp;&amp;A[mid]&gt;A[mid-1],那么此时mid就是山脉的下标 如果A[mid]&lt;A[mid+1]，那么就说明山脉应该在mid的右边区间，故left=mid+1 如果A[mid]&gt;A[mid+1]，那么就说明山脉应该在mid的右边区间，故right=mid-1 Coding实现1234567891011121314151617181920/** * @param &#123;number[]&#125; A * @return &#123;number&#125; */var peakIndexInMountainArray = function(A) &#123; let left=0; let right=A.length-1; while(left&lt;=right)&#123; let mid=Math.floor((left+right)/2); if(A[mid]&gt;A[mid+1]&amp;&amp;A[mid]&gt;A[mid-1])&#123; return mid; &#125; else if(A[mid]&lt;A[mid+1])&#123; left=mid+1; &#125; else&#123; right=mid-1; &#125; &#125;&#125;; 时间复杂度时间复杂度为O(log2N);]]></content>
      <categories>
        <category>leetcode题解与算法</category>
      </categories>
      <tags>
        <tag>二分查找</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[leetcode-944 删列造序]]></title>
    <url>%2F2019%2F07%2F26%2Fleetcode-944%2F</url>
    <content type="text"><![CDATA[删列造序题目描述给定由 N 个小写字母字符串组成的数组 A，其中每个字符串长度相等。 删除 操作的定义是：选出一组要删掉的列，删去 A 中对应列中的所有字符，形式上，第 n 列为 [A[0][n], A[1][n], …, A[A.length-1][n]]）。 比如，有 A = [“abcdef”, “uvwxyz”]， 要删掉的列为 {0, 2, 3}，删除后 A 为[“bef”, “vyz”]， A 的列分别为[“b”,”v”], [“e”,”y”], [“f”,”z”]。 你需要选出一组要删掉的列 D，对 A 执行删除操作，使 A 中剩余的每一列都是 非降序 排列的，然后请你返回 D.length 的最小可能值。 示例 1： 输入：[“cba”, “daf”, “ghi”]输出：1解释：当选择 D = {1}，删除后 A 的列为：[“c”,”d”,”g”] 和 [“a”,”f”,”i”]，均为非降序排列。若选择 D = {}，那么 A 的列 [“b”,”a”,”h”] 就不是非降序排列了。 示例 2： 输入：[“a”, “b”]输出：0解释：D = {} 示例 3： 输入：[“zyx”, “wvu”, “tsr”]输出：3解释：D = {0, 1, 2} 提示： 1&lt;= A.length &lt;= 100 1&lt;= A[i].length &lt;= 1000 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/delete-columns-to-make-sorted著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 核心思路概述题目要求得到删去列数的最小值来使剩余的每一列都是非降序的，那么对于贪心思想，只要找到某些列存在降序的删除即可，而无需删除那些已经是非降序的列 解题步骤 根据数组第一个字符串元素长度来确认列数 根据列数，遍历每一个字符串中的那一列 如果某一列存在降序则将ans加1 返回ans Coding实现12345678910111213141516/** * @param &#123;string[]&#125; A * @return &#123;number&#125; */var minDeletionSize = function(A) &#123; let ans=0; for(let i=0;i&lt;A[0].length;i++)&#123; for(let k=0;k&lt;A.length-1;k++)&#123; if(A[k+1][i].charCodeAt()-A[k][i].charCodeAt()&lt;0)&#123; ans++; break; &#125; &#125; &#125; return ans; &#125;;]]></content>
      <categories>
        <category>leetcode题解与算法</category>
      </categories>
      <tags>
        <tag>贪心</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[贪心]]></title>
    <url>%2F2019%2F07%2F26%2F%E8%B4%AA%E5%BF%83%2F</url>
    <content type="text"><![CDATA[##简单贪心 贪心法是求解一类最优化问题的方法，它总是考虑在当前状态下局部最优（或较优）的策略，来使全局的结果达到最优（或较优） 简单来说，也就是，在对问题求解时，总是做出在当前看来是最好的选择。 贪心算法的基本思路 将求解的问题分成若干子问题 对于每一个子问题，考虑得到该子问题的局部最优解 把所有子问题的局部最优解合成一个原问题的解 贪心算法的适用前提和问题 局部最优解能够影响全局最优解 贪心算法得到的不一定就是问题的最优解 贪心算法题目设有n个正整数，将它们连接成一排，组成一个最大的多位整数。 例如：n=3时，3个整数13，312，343，连成的最大整数为34331213。又如：n=4时，4个整数7，13，4，246，连成的最大整数为7424613。 输入：nN个数输出：连成的多位数 思路因为要得到最大的正整数，那么高位数据越大则值越大。因此，使用贪心算法，每次选值的时候优先选择最高位最大的，如若相同，则比较次高位，直到选出较优值 因此，通过这个思路，比较高位可以利用字符串UniCode码来比较，比如’7’&gt;’432’ js的sort()函数可以完美解决，利用sort函数对输入值由高到低进行排序，最后转化为数值进行返回 Coding实现123function F(n)&#123; return parseInt(n.sort().reverse().join(''));&#125; 区间贪心]]></content>
  </entry>
  <entry>
    <title><![CDATA[排序]]></title>
    <url>%2F2019%2F07%2F25%2F%E6%8E%92%E5%BA%8F%2F</url>
    <content type="text"><![CDATA[选择排序定义选择排列是指，对一个序列A中的元素，令i从0到n-1枚举，进行n趟操作，每趟从待排序部分（i+1,n）中选择最小的元素，令其与待排序部分的第一个元素A[i]进行交换，这样在n趟操作后，所有元素都会是有序的 动图演示 Coding实现1234567891011121314function selectSort(n)&#123; for(let i=0;i&lt;n.length-1;i++)&#123; let min=i; for(let k=i;k&lt;n.length;k++)&#123; if(n[k]&lt;n[min])&#123; min=k; &#125; &#125; let temp=n[min]; n[min]=n[i]; n[i]=temp; &#125; return n;&#125; 插入排序直接插入排序定义直接插入排序是指，对序列A的n个元素A[0]到A[n-1],令n从1到n-1枚举，进行n-1趟操作。每一趟排序时，该待排列元素之前的所有元素已经是有序的，则在该有序队列中寻找一个位置进行插入，使得该序列依旧有序 动图演示 Coding实现1234567891011function insertionSort(n)&#123; for(let i=1;i&lt;n.length;i++)&#123; let num=n[i]; while(num&lt;n[i-1])&#123; n[i]=n[i-1]; i--; &#125; n[i]=num; &#125; return n;&#125; 折半插入排序定义 有一组数据待排序，排序区间为Array[0] ~ Array[n-1]。将数据分为有序数据和无序数据，第一次排序时默认Array[0]为有序数据，Array[1]~Array[n-1]为无序数据。有序数据分区的第一个元素位置为low，最后一个元素的位置为high。 遍历无序区间的所有元素，每次取无序区间的第一个元素Array[i]，因为0 ~ i-1是有序排列的，所以用中点m将其平分为两部分，然后将待排序数据同中间位置为m的数据进行比较，若待排序数据较大，则low ~ m-1分区的数据都比待排序数据小，反之，若待排序数据较小，则m+1 ~ high分区的数据都比 待排序数据大，此时将low或high重新定义为新的合适分区的边界，对新的小分区重复上面操作。直到low和high 的前后顺序改变，此时high+1所处位置为待排序数据的合适位置。 作者：weixin_42245157来源：CSDN原文：https://blog.csdn.net/weixin_42245157/article/details/80458542版权声明：本文为博主原创文章，转载请附上博文链接！ Coding实现123456789101112131415161718192021function BinaryInsertSortup(n)&#123; for(let i=1;i&lt;n.length;i++)&#123; let low=0; let high=i-1; let num=n[i]; while(low&lt;=high)&#123; let mid=Math.floor((low+high)/2); if(num&lt;n[mid])&#123; high=mid-1; &#125; else&#123; low=mid+1; &#125; &#125; for(k=i;k&gt;low;k--)&#123; n[k]=n[k-1]; &#125; n[k]=num; &#125; return n;&#125; 冒泡排序定义冒泡排序旨在每次冒泡一个最大或最小的元素到顶端，因此需遍历n次。（若冒泡较大元素）则每次遍历，比较相邻两个元素大小，若底部元素（数组下标较小）大于其相邻顶部元素，则两元素交换位置，直至最大的元素冒泡到最顶端 动图演示 Coding实现12345678910111213141516function bubbleSort(n)&#123; let flag; do&#123; flag=0; for(let i=0;i&lt;n.length;i++)&#123; let temp; if(n[i]&gt;n[i+1])&#123; temp=n[i]; n[i]=n[i+1]; n[i+1]=temp; flag=1; &#125; &#125; &#125;while(flag===1) return n;&#125; 归并排序定义归并排序是一种基于归并思想的排序方法。 实现思路： 将序列分成Math.ceil(n/2)个组，组内单独排序 将这些组两两归并，这样就会变成Math.ceil(n/4)个组，组内再单独排序 以此类推，直到最后只剩下一个组为止 Coding实现1234567891011121314151617181920212223242526272829303132333435363738394041function mergeSort(arr) &#123; const length = arr.length; if (length === 1) &#123; //递归算法的停止条件，即为判断数组长度是否为1 return arr; &#125; const mid = Math.floor(length / 2); const left = arr.slice(0, mid); const right = arr.slice(mid, length); return merge(mergeSort(left), mergeSort(right)); //要将原始数组分割直至只有一个元素时，才开始归并&#125;function merge(left, right) &#123; const result = []; let il = 0; let ir = 0; //left, right本身肯定都是从小到大排好序的 while( il &lt; left.length &amp;&amp; ir &lt; right.length) &#123; if (left[il] &lt; right[ir]) &#123; result.push(left[il]); il++; &#125; else &#123; result.push(right[ir]); ir++; &#125; &#125; //不可能同时存在left和right都有剩余项的情况, 要么left要么right有剩余项, 把剩余项加进来即可 while (il &lt; left.length) &#123; result.push(left[il]); il++; &#125; while(ir &lt; right.length) &#123; result.push(right[ir]); ir++; &#125; return result;&#125; 快速排序定义快速排序是排序算法中平均时间复杂度为O(logn)的一种算法。 其主要步骤为 调整序列中的元素，使得当前序列的第一个元素在调整后所处的位置的左侧元素都小于它，在右侧的位置都大于它 对该元素的左侧和右侧区间分别递归进行1的调整，直到当前调整区间的长度不大于1 Coding实现123456789101112131415function F(n)&#123; if(n.length&lt;2) return n; let first=n[0]; let small=[]; let large=[]; for(let i=1;i&lt;n.length;i++)&#123; if(n[i]&lt;first)&#123; small.push(n[i]); &#125; else&#123; large.push(n[i]); &#125; &#125; return F(small).concat([first],F(large));&#125;]]></content>
      <categories>
        <category>算法笔记</category>
      </categories>
      <tags>
        <tag>排序</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[leetcode-1002 查找常用字符]]></title>
    <url>%2F2019%2F07%2F24%2Fleetcode-1002%2F</url>
    <content type="text"><![CDATA[查找常用字符题目描述给定仅有小写字母组成的字符串数组 A，返回列表中的每个字符串中都显示的全部字符（包括重复字符）组成的列表。例如，如果一个字符在每个字符串中出现 3 次，但不是 4 次，则需要在最终答案中包含该字符 3 次。 你可以按任意顺序返回答案。 示例 1： 输入：[“bella”,”label”,”roller”]输出：[“e”,”l”,”l”] 示例 2： 输入：[“cool”,”lock”,”cook”]输出：[“c”,”o”] 提示： 1&lt;= A.length &lt;= 100 1&lt;= A[i].length &lt;= 100 A[i][j] 是小写字母 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/find-common-characters著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 核心思路概述统计每个字符串中字符的出现个数，返回出现相同字符的最少个数字符 解题步骤 建立哈希表A，存储第一个字符串个字符的出现次数 遍历后面的字符串，在每个循环中建立新的哈希表，存储该字符串中第一个字符串所有字符的个数；比较新哈希表与步骤1建立的哈希表A，更新A哈希表中的键值为两者较小值 遍历A哈希表，存储value次key到ans数组并返回 Coding实现12345678910111213141516171819202122232425262728293031323334353637383940/** * @param &#123;string[]&#125; A * @return &#123;string[]&#125; */var commonChars = function(A) &#123; let map=new Map(); let ans=[]; for(let i=0;i&lt;A[0].length;i++)&#123; if(!map.has(A[0][i]))&#123; map.set(A[0][i],1); &#125; else &#123; map.set(A[0][i],map.get(A[0][i])+1); &#125; &#125; for(let i=1;i&lt;A.length;i++)&#123; let mapEve=new Map(); map.forEach((value,key)=&gt;&#123; mapEve.set(key,0); &#125;) for(let k=0;k&lt;A[i].length;k++)&#123; if(map.has(A[i][k]))&#123; mapEve.set(A[i][k],mapEve.get(A[i][k])+1); &#125; &#125; map.forEach((value,key)=&gt;&#123; if(value&gt;mapEve.get(key))&#123; map.set(key,mapEve.get(key)); &#125; &#125;) &#125; map.forEach((value,key)=&gt;&#123; if(value&gt;0)&#123; for(let i=0;i&lt;value;i++)&#123; ans.push(key); &#125; &#125; &#125;); return ans;&#125;;]]></content>
      <categories>
        <category>leetcode题解与算法</category>
      </categories>
      <tags>
        <tag>哈希表</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[递归与分治]]></title>
    <url>%2F2019%2F07%2F24%2F%E9%80%92%E5%BD%92%E4%B8%8E%E5%88%86%E6%B2%BB%2F</url>
    <content type="text"><![CDATA[分治分治的全称为“分而治之”。分治法将原问题划分为若干个规模较小而结构与原问题相同或类似的子问题，然后分别解决这些子问题，最后合并子问题的解，即可得到原问题的解 减治、分治 一般把子问题个数为1的情况称为减治（例如对n!的求解） 123456function F(n)&#123; if(n===1) return 1; else &#123; return F(n-1)*n; &#125;&#125; 子问题个数大于1的情况称为分治（例如对Fibonacci数列的求解） 1234function F(n)&#123; if(n===1||n===0) return 1; else return F(n-1)+F(n-2);&#125; 递归 递归适合用来实现分治思想 递归的两个核心概念 递归边界 递归式（递归调用） 对于n!的求解，可以很容易的到F(n)=F(n-1)*n ;这就是递归式而F(1)=1; 这是递归的边界 分治思想的应用全排列n皇后问题]]></content>
      <categories>
        <category>算法笔记</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[leetcode-349 两个数组的交集]]></title>
    <url>%2F2019%2F07%2F23%2Fleetcode-349%2F</url>
    <content type="text"><![CDATA[两个数组的交集题目描述给定两个数组，编写一个函数来计算它们的交集。 示例 1: 输入: nums1 = [1,2,2,1], nums2 = [2,2]输出: [2] 示例 2: 输入: nums1 = [4,9,5], nums2 = [9,4,9,8,4]输出: [9,4] 说明: 输出结果中的每个元素一定是唯一的。我们可以不考虑输出结果的顺序。 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/intersection-of-two-arrays著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 核心思路概述将两个数组都去重后，比较另一个数组是否包含这个数组的某些元素，返回即可 解题步骤 使用set将两个数组去重 比较去重后的两个数组的大小，遍历较小的那个数组，查看另一个数组是否includes这个数组中的某些元素，有则添加到ans数组返回 Coding实现12345678910111213141516171819/** * @param &#123;number[]&#125; nums1 * @param &#123;number[]&#125; nums2 * @return &#123;number[]&#125; */var intersection = function(nums1, nums2) &#123; let ans=[]; nums1=[...new Set(nums1)]; nums2=[...new Set(nums2)]; function inter(nums1,nums2)&#123; nums1.forEach(value=&gt;&#123; if(nums2.includes(value))&#123; ans.push(value); &#125; &#125;) &#125; nums1.length&gt;nums2.length?inter(nums2,nums1):inter(nums1,nums2); return ans;&#125;;]]></content>
      <categories>
        <category>leetcode题解与算法</category>
      </categories>
      <tags>
        <tag>数组</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[leetcode-961 重复 N 次的元素]]></title>
    <url>%2F2019%2F07%2F23%2Fleetcode-961%2F</url>
    <content type="text"><![CDATA[重复 N 次的元素题目描述在大小为 2N 的数组 A 中有 N+1 个不同的元素，其中有一个元素重复了 N 次。 返回重复了 N 次的那个元素。 示例 1： 输入：[1,2,3,3]输出：3 示例 2： 输入：[2,1,2,5,3,2]输出：2 示例 3： 输入：[5,1,5,2,5,3,5,4]输出：5 提示： 4 &lt;= A.length &lt;= 100000 &lt;= A[i] &lt; 10000A.length 为偶数 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/n-repeated-element-in-size-2n-array著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 核心思路概述因为该数组大小为2N，其中由N+1个不同的元素，并且有一个元素重复了N次，那么剩余的N个数都是不同的 所以题目可转化为返回有重复的那个数 解题步骤 建立哈希表 遍历给定数组，若哈希表中没有该键名，则加入哈希表；若有，则直接返回该数组元素 Coding实现123456789101112131415/** * @param &#123;number[]&#125; A * @return &#123;number&#125; */var repeatedNTimes = function(A) &#123; let map=new Map(); for(let i=0;i&lt;A.length;i++)&#123; if(!map.has(A[i]))&#123; map.set(A[i],0); &#125; else&#123; return A[i]; &#125; &#125;&#125;;]]></content>
      <categories>
        <category>leetcode题解与算法</category>
      </categories>
      <tags>
        <tag>哈希表</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[leetcode-500 键盘行]]></title>
    <url>%2F2019%2F07%2F23%2Fleetcode-500%2F</url>
    <content type="text"><![CDATA[键盘行题目描述 给定一个单词列表，只返回可以使用在键盘同一行的字母打印出来的单词。键盘如下图所示。 示例： 输入: [“Hello”, “Alaska”, “Dad”, “Peace”]输出: [“Alaska”, “Dad”] 注意： 你可以重复使用键盘上同一字符。你可以假设输入的字符串将只包含字母。 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/keyboard-row著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 核心思路概述利用哈希表,分别即字母为键名，字母所在行号为键值建立哈希表。遍历给定字符串，若字符串的所有字符的所在哈希表的键值都一样，则说明该字符串的字符都在同一行上 解题步骤 建立哈希表以及键盘字符数组 将每个字符以字符为键名，字符所在行号为键值建立哈希表。 遍历题目给定字符串数组，若每个字符串中的字符在哈希表中的键值都一样，则将该字符串加入到要返回的数组中 遍历字符串方法：先得到字符串的第一个字符的所在行号，接着循环得到后面的字符的行号，若不一样则直接退出该循环 注意 将所有字符都转换为小写形式再去得到字符的键值 Coding实现123456789101112131415161718192021222324252627282930313233/** * @param &#123;string&#125; J * @param &#123;string&#125; S * @return &#123;number&#125; *//** * @param &#123;string[]&#125; words * @return &#123;string[]&#125; */var findWords = function(words) &#123; const str=['qwertyuiop','asdfghjkl','zxcvbnm']; let ans=[]; let map=new Map(); str.forEach((value,index)=&gt;&#123; for(let i=0;i&lt;value.length;i++)&#123; map.set(value[i],index+1); &#125; &#125;); words.forEach(value=&gt;&#123; let flag=0; let first=map.get(value[0].toLowerCase()); for(let i=1;i&lt;value.length;i++)&#123; if(map.get(value[i].toLowerCase())!=first)&#123; flag=1; break; &#125; &#125; if(flag===0)&#123; ans.push(value); &#125; &#125;) return ans;&#125;;]]></content>
      <categories>
        <category>leetcode题解与算法</category>
      </categories>
      <tags>
        <tag>哈希表</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[散列]]></title>
    <url>%2F2019%2F07%2F22%2F%E6%95%A3%E5%88%97%2F</url>
    <content type="text"><![CDATA[散列的定义 简单来说：就是将某个元素通过一个函数转换为整数，使得该整数可以尽量唯一地代表这个元素 常用的散列函数 直接定址法 直接把key值作为哈希表的下标 平方取中法 取key的平方的中间若干位作为哈希表的下标 除留余数法（常用） 指把key除以一个数得到的余数作为hash值的方法 冲突处理 线性探查法 如果该hash值已经被占用，那么就不断检查下一个位置，直到找到没被占用的。如果检查过程中超过了表长，则返回到哈希表的首位继续循环查找，或是发现所有的位置都被占用 该方法容易造成扎堆现象，即表中的若干个连续位置都被使用 平方探查法 按照下列的顺序进行探查： H(key)+1^2,H(key)-1^2, H(key)+2^2,H(key)-2^2, H(key)+3^2,H(key)-3^2, … … 如果，检查过程中H(key)+k^2超过了表长Tsize，那么就把(H(key)+k^2) % Tsize 作为hash值 链地址法 链地址法不计算新的hash值，而是把所有H(key)相同的key连接成一条单链表 字符串hash字符串hash是指将字符串S映射为一个整数，使得该整数尽可能唯一地代表该字符串 假设字符串只由AZ构成，那么可以将AZ映射为0~25；比如，ABC则就可以看作是012。显然，与二进制类似，我们可以把其看作为26进制，再将其转化为10进制，即可得到该字符串唯一地hash映射。 代码 1234567const hashFunc(str,length)&#123; let hash=0; for(let i=0;i&lt;length;i++)&#123; hash=hash*26+str[i].charCodeAt()-'A'.charCodeAt(); &#125; return hash;&#125; 如果外加有小写字母，则就是52进制转换若还有数字，则就是62进制转换 一些散列表算法题散列表相关算法题]]></content>
      <categories>
        <category>算法笔记</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[leetcode-771 宝石与石头]]></title>
    <url>%2F2019%2F07%2F22%2Fleetcode-771%2F</url>
    <content type="text"><![CDATA[宝石与石头题目描述 给定字符串J 代表石头中宝石的类型，和字符串 S代表你拥有的石头。 S 中每个字符代表了一种你拥有的石头的类型，你想知道你拥有的石头中有多少是宝石。 J 中的字母不重复，J 和 S中的所有字符都是字母。字母区分大小写，因此”a”和”A”是不同类型的石头。 示例 1: 输入: J = “aA”, S = “aAAbbbb”输出: 3 示例 2: 输入: J = “z”, S = “ZZ”输出: 0 注意: S 和 J 最多含有50个字母。 J 中的字符不重复。 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/jewels-and-stones著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 核心思路概述利用哈希表，遍历宝石类型字符串，建立以宝石类型为键名，宝石数量为值的哈希表。哈希表中的所有键值之和就是所拥有的宝石的数量。 解题步骤 建立哈希表，声明所拥有的宝石数量为ans=0 遍历J字符串，以字符为键名，0为键值建立哈希表 遍历S字符串，若哈希表中存在该键名，则ans++ 返回ans Coding实现123456789101112131415161718/** * @param &#123;string&#125; J * @param &#123;string&#125; S * @return &#123;number&#125; */var numJewelsInStones = function(J, S) &#123; let map=new Map(); let ans=0; for(let i=0;i&lt;J.length;i++)&#123; map.set(J[i],0); &#125;; for(let i=0;i&lt;S.length;i++)&#123; if(map.has(S[i]))&#123; ans++; &#125; &#125; return ans;&#125;;]]></content>
      <categories>
        <category>leetcode题解与算法</category>
      </categories>
      <tags>
        <tag>哈希表</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[leetcode-219 存在重复元素 II]]></title>
    <url>%2F2019%2F07%2F21%2Fleetcode-219%2F</url>
    <content type="text"><![CDATA[存在重复元素 II题目描述给定一个整数数组和一个整数 k，判断数组中是否存在两个不同的索引 i 和 j，使得 nums [i] = nums [j]，并且 i 和 j 的差的绝对值最大为 k。 示例 1: 输入: nums = [1,2,3,1], k = 3输出: true 示例 2: 输入: nums = [1,0,1,1], k = 1输出: true 示例 3: 输入: nums = [1,2,3,1,2,3], k = 2输出: false 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/contains-duplicate-ii著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 核心思路概述利用哈希表，存储以值为键，下标为键值的哈希表。当某个键值需要更新时，比较当前下标与键值的差值是否小于题目给定值，若是则返回true; 解题步骤 建立哈希表 当以当前数组元素的值为键名的键不存在时，则以值为键，下标为键值添加到哈希表中。若存在，则比较当前下标与键值的差值是否小于题目给定值，若是则返回true; Coding实现1234567891011121314151617181920/** * @param &#123;number[]&#125; nums * @param &#123;number&#125; k * @return &#123;boolean&#125; */var containsNearbyDuplicate = function(nums, k) &#123; let map = new Map(); return nums.some((value, index) =&gt; &#123; if (!map.has(value)) &#123; map.set(value, index); &#125; else &#123; if (index - map.get(value) &lt;= k) &#123; return true; &#125; else &#123; map.set(value, index); &#125; &#125; return false; &#125;);&#125;;]]></content>
      <categories>
        <category>leetcode题解与算法</category>
      </categories>
      <tags>
        <tag>哈希表</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[leetcode-217 存在重复元素]]></title>
    <url>%2F2019%2F07%2F20%2Fleetcode-217%2F</url>
    <content type="text"><![CDATA[存在重复元素题目描述给定一个整数数组，判断是否存在重复元素。 如果任何值在数组中出现至少两次，函数返回 true。如果数组中每个元素都不相同，则返回 false。 示例 1: 输入: [1,2,3,1]输出: true 示例 2: 输入: [1,2,3,4]输出: false 示例 3: 输入: [1,1,1,3,3,4,3,2,4,2]输出: true 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/contains-duplicate著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 核心思路概述将该数组去重之后的元素个数与原数组长度进行比较，不一样则有重复； 解题步骤 建立set集合，用于数组去重 将set集合的size与数组长度进行比较 不相同则有重复,返回true;反之,false Coding实现123456789/** * @param &#123;number[]&#125; nums * @return &#123;boolean&#125; */var containsDuplicate = function(nums) &#123; let set=new Set(nums); if(set.size===nums.length) return false; else return true;&#125;;]]></content>
      <categories>
        <category>leetcode题解与算法</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Java解决算法题一些记录(杂)]]></title>
    <url>%2F2019%2F07%2F20%2FJava%E8%A7%A3%E5%86%B3%E7%AE%97%E6%B3%95%E9%A2%98%2F</url>
    <content type="text"><![CDATA[ArrayListArrayList的一些方法 方法 描述 add() 在list的末尾添加一个元素 add(index: int, o: E) 在指定的index处插入元素 clear() 从list中删除所有元素 contains(o: Object) 如果list含有元素o，返回true get(index: int) 返回指定index处的元素 indexOf(o: Object) 返回list中第一个匹配元素的index isEmpty() 如果list不含元素，返回true lastIndexOf(o: Object) 返回list中最后一个匹配元素的index remove(o: Object) 删除list中的第一个元素o，如果元素被删除，返回true size() 返回list中元素个数 remove(index: int) 删除指定index处的元素，如果元素被删除，返回true set(index: int, o: E) 设置指定index处的元素为o]]></content>
      <categories>
        <category>Java</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[leetcode-206 反转链表]]></title>
    <url>%2F2019%2F07%2F19%2Fleetcode-206%2F</url>
    <content type="text"><![CDATA[反转链表题目描述反转一个单链表。 示例: 输入: 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL输出: 5-&gt;4-&gt;3-&gt;2-&gt;1-&gt;NULL 进阶:你可以迭代或递归地反转链表。你能否用两种方法解决这道题？ 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/reverse-linked-list著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 核心思路概述将链表所有的元素取出并倒序放到数组，按照数组元素创建新链表并返回 解题步骤 遍历链表，并将数组元素unshift入数组 按照数组元素添加节点到新创建的链表上 Coding实现12345678910111213141516171819202122232425/** * Definition for singly-linked list. * function ListNode(val) &#123; * this.val = val; * this.next = null; * &#125; *//** * @param &#123;ListNode&#125; head * @return &#123;ListNode&#125; */var reverseList = function(head) &#123; let newList=new ListNode(0); let newHead=newList; let numArray=[]; while(head)&#123; numArray.unshift(head.val); head=head.next; &#125; numArray.forEach(value=&gt;&#123; newHead.next=new ListNode(value); newHead=newHead.next; &#125;) return newList.next;&#125;;]]></content>
      <categories>
        <category>leetcode题解与算法</category>
      </categories>
      <tags>
        <tag>链表</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[leetcode-205 同构字符串]]></title>
    <url>%2F2019%2F07%2F18%2Fleetcode-205%2F</url>
    <content type="text"><![CDATA[同构字符串题目描述给定两个字符串 s 和 t，判断它们是否是同构的。 如果 s 中的字符可以被替换得到 t ，那么这两个字符串是同构的。 所有出现的字符都必须用另一个字符替换，同时保留字符的顺序。两个字符不能映射到同一个字符上，但字符可以映射自己本身。 示例 1: 输入: s = “egg”, t = “add”输出: true 示例 2: 输入: s = “foo”, t = “bar”输出: false 示例 3: 输入: s = “paper”, t = “title”输出: true 说明:你可以假设 s 和 t 具有相同的长度。 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/isomorphic-strings著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 核心思路概述解法1利用哈希表进行映射，两个字符串相互映射 解法2对比两个字符串对应位置的字符在字符串内第一次出现的位置，若不同则返回false 解题步骤解法1 建立哈希映射函数，若哈希表中没有该键值对，则插入表中；若有，则比较值是否相同，不同则返回fasle 两个字符串依次使用哈希映射函数进行比较 解法2 同时遍历两字符串，若当前字符的第一次出现的位置不相同则返回false Coding实现解法1123456789101112131415161718192021222324252627/** * @param &#123;string&#125; s * @param &#123;string&#125; t * @return &#123;boolean&#125; */function match(map,s,t)&#123; for(let i=0;i&lt;s.length;i++)&#123; if(!map.has(s[i]))&#123; map.set(s[i],t[i]); &#125; else&#123; if(map.get(s[i])!=t[i])&#123; return false; &#125; &#125; &#125; return true;&#125;var isIsomorphic = function(s, t) &#123; s=s.split(''); t=t.split(''); let map=new Map(); if(!match(map,s,t)) return false; map.clear(); return match(map,t,s);&#125;; 解法2123456789101112/** * @param &#123;string&#125; s * @param &#123;string&#125; t * @return &#123;boolean&#125; */var isIsomorphic = function(s, t) &#123; for (let i = 0; i &lt; s.length; i++) &#123; if (s.indexOf(s[i]) !== t.indexOf(t[i])) return false; &#125; return true;&#125;]]></content>
      <categories>
        <category>leetcode题解与算法</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[leetcode-204 计数质数]]></title>
    <url>%2F2019%2F07%2F17%2Fleetcode-204%2F</url>
    <content type="text"><![CDATA[计数质数题目描述统计所有小于非负整数 n 的质数的数量。 示例: 输入: 10输出: 4解释: 小于 10 的质数一共有 4 个, 它们是 2, 3, 5, 7 。 核心思路概述质数的定义 质数又称素数。一个大于1的自然数，除了1和它自身外，不能被其他自然数整除的数叫做质数；否则称为合数。 此题的基本解法即为遍历给定数之前的数，若为质数则计数加一 解题步骤 建立一个函数用来判断当前数是否为质数 对于1中的函数质数判断条件，若在1~开根号n的左开右闭的区间内无法被整除，那么该数即为质数。 遍历给定数之前的数，若为质数则计数加一 Coding实现1234567891011121314151617181920212223/** * @param &#123;number&#125; n * @return &#123;number&#125; */const checkPrimes=function(n)&#123; if(n===2) return true; if(n===1) return false; if(n%2===1)&#123; for(let i=1;i&lt;=Math.sqrt(n);i=i+2)&#123; if(n%i===0&amp;&amp;i!==1) return false; &#125; return true; &#125;&#125;var countPrimes = function(n) &#123; let count=0; for(let i=2;i&lt;n;i++)&#123; if(checkPrimes(i))&#123; count++; &#125; &#125; return count;&#125;;]]></content>
      <categories>
        <category>leetcode题解与算法</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[leetcode-203 移除链表元素]]></title>
    <url>%2F2019%2F07%2F16%2Fleetcode-203%2F</url>
    <content type="text"><![CDATA[移除链表元素题目描述删除链表中等于给定值 val 的所有节点。 示例: 输入: 1-&gt;2-&gt;6-&gt;3-&gt;4-&gt;5-&gt;6, val = 6输出: 1-&gt;2-&gt;3-&gt;4-&gt;5 核心思路概述此题为单链表删除指定元素 解题步骤单独考虑头节点（因为头节点之前没有节点） 考虑头节点即为指定需删除元素，那么应当将头指针指向下一个元素。循环检验，当头节点不是指定需删除元素时则退出循环 若步骤1之后，该链表为空链表则直接返回该空链表 1、2步骤之后，当前链表则为头节点不为指定需删除元素的非空链表。遍历当前链表，设置pre和cur指针方便删除链表节点。 设置虚拟头节点（指向头节点的节点） 创建新节点指向当前头节点 遍历该链表，删除指定元素 返回以创建的新节点的下一个节点为头节点所在的链表 Coding实现单独处理头节点的Coding1234567891011121314151617181920212223242526272829/** * Definition for singly-linked list. * function ListNode(val) &#123; * this.val = val; * this.next = null; * &#125; *//** * @param &#123;ListNode&#125; head * @param &#123;number&#125; val * @return &#123;ListNode&#125; */var removeElements = function(head, val) &#123; while(head&amp;&amp;head.val===val)&#123; head=head.next &#125; if(head===null) return head; let cur=head; let pre=head; while(cur.next)&#123; pre=cur; cur=cur.next; if(cur.val===val)&#123; pre.next=cur.next; cur=pre; &#125; &#125; return head;&#125;; 设置指向头节点的指针节点的Coding12345678910111213141516171819202122232425/** * Definition for singly-linked list. * function ListNode(val) &#123; * this.val = val; * this.next = null; * &#125; *//** * @param &#123;ListNode&#125; head * @param &#123;number&#125; val * @return &#123;ListNode&#125; */var removeElements = function(head, val) &#123; let listNode=new ListNode(val-1); listNode.next=head; let list=listNode; while(list.next)&#123; if(list.next.val===val)&#123; list.next=list.next.next; continue; &#125; list=list.next; &#125; return listNode.next;&#125;;]]></content>
      <categories>
        <category>leetcode题解与算法</category>
      </categories>
      <tags>
        <tag>链表</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[leetcode-202 快乐数]]></title>
    <url>%2F2019%2F07%2F15%2Fleetcode-202%2F</url>
    <content type="text"><![CDATA[快乐数题目描述编写一个算法来判断一个数是不是“快乐数”。 一个“快乐数”定义为：对于一个正整数，每一次将该数替换为它每个位置上的数字的平方和，然后重复这个过程直到这个数变为 1，也可能是无限循环但始终变不到 1。如果可以变为 1，那么这个数就是快乐数。 示例: 输入: 19输出: true解释: 12 + 92 = 8282 + 22 = 6862 + 82 = 10012 + 02 + 02 = 1 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/happy-number著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 核心思路概述 正面解题，寻找快乐数。当重复过程变为1则为快乐数，若当循环过程中得到的数与之前出现过的数相重复，则表示之后会在这两数之间无限循环，此时即可返回false. 快慢指针解法：使用快慢指针来判断该循环是否为无限死循环。 解题步骤正面解题法(遇到重复数字则退出) 若输入为1，则直接返回true 设置set集合用来存储循环过程中得到的数 进入do-while循环，将参数转化为数组，利用reduce函数进行平方和累加，判断该得到的数是否存在于set集合中，若存在则返回false，否则则将该数放入set集合中。同时,若该数为1则返回true退出函数快慢指针法 设置两个指针，一个指针移动较快，一个指针移动较慢，若两指针相遇，则代表该循环中存在死循环，则应退出该函数。Coding实现正面解题的Coding12345678910111213141516var isHappy = function(n) &#123; if(n===1) return true; let arr; let set=new Set([n]); do&#123; arr=n.toString().split(''); n=arr.reduce((pre,value)=&gt;&#123; return pre+Math.pow(parseInt(value),2) &#125;,0); if(set.has(n))&#123; return false; &#125; set.add(n); &#125;while(n!=1) return true;&#125;; 递归法的Coding12]]></content>
      <categories>
        <category>leetcode题解与算法</category>
      </categories>
      <tags>
        <tag>快慢指针</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[var、let与const的比较以及作用域]]></title>
    <url>%2F2019%2F07%2F15%2Fvar%E3%80%81let%E4%B8%8Econst%2F</url>
    <content type="text"><![CDATA[var、let与const的比较以及作用域 var、let与const的比较 \ var let const 变量提升机制 有 无 无 重声明 允许 在同个作用域下禁止,不同作用域下允许 同let 能否更改 允许 允许 不允许 初始化 可以不用 可以不用 必须 const的一些注意点 const不允许修改基本类型值，但是允许修改对象的属性值（没有修改对象的绑定）；123456789101112(function test()&#123; const person = &#123; a:1 &#125; console.log(person.a); // 1 person.a=2; console.log(person.a); // 2 person=&#123; a:3 &#125; console.log(person.a); // 报错： 不允许修改使用const声明的对象的绑定&#125;)() 预编译与词法分析预编译 JS引擎会在正式执行代码之前进行一次”预编译“，预编译简单理解就是在内存中开辟一些空间，存放一些变量和函数。 具体步骤 页面创建全局对象（Global Object）对象（window对象）。 加载第一个脚本文件 脚本加载完毕后，进行语法分析。 开始预编译 查找函数声明，作为GO属性，值赋予函数体（函数声明优先） 查找变量声明（除了函数内部的），作为GO属性，值赋予undefined 若函数声明与变量声明同名，则函数声明会优先于变量声明。具体来说即是1. 函数声明替换变量声明 2. 后面的函数声明替换前面的函数声明 3. 后面的变量声明无效 例如 1234567console.log(a); //[function: a]a(); //hellofunction a()&#123; console.log('hello');&#125;var a=1;console.log(a); //1 词法分析 创建AO活动对象（Active Object 每个执行环境都有一个与之对应的活动对象） 查找形参和变量声明，值赋予undefined 实参值赋给形参 查找函数声明，值赋给函数体 解释执行函数中的代码 提升机制对于用var定义的变量会被提升到当前作用域的顶端并赋值为undefined123console.log(a); //undefinedvar a='hello';console.log(a); //hello 函数声明整体提升1234a(); //hellofunction a()&#123; console.log('hello');&#125; 123456console.log(a); //undefineda(); //报错：a is not a functionvar a=function()&#123; /*遇见var a= 会直接将a当作一个变量提升并赋值为undefined;*/console.log('hello');&#125; 123456console.log(a); /*报错：Cannot access 'a' before initialization*/a(); let a=function()&#123; /*这里为let a= ,不会有变量提升机制*/console.log('hello');&#125; 块级声明与块级作用域块级作用域存在于： 1.函数内部2.块中（{ }之间的区域） 注意： 只有使用let和const声明（const与let都是块级标识符），块语句（{ } 比如for循环语句和if判断语句）才会将快语句中声明的变量限制在该块级作用域；而使用var声明则不会 例如 12345678910111213(function test()&#123; console.log(a); // undefined if(true)&#123; var a=1; &#125;&#125;)()(function test()&#123; console.log(a); //报错：a is not defined if(true)&#123; let a=1; &#125;&#125;)() let声明不会被提升 用let声明变量，会将变量的作用域限制在当前代码块中（即块级作用域）;因此块级作用域外部无法访问 禁止重声明同一作用域中不能使用let来重复定义已经存在的标识符 1234(function test()&#123; var a=1; let a=2; // Identifier 'a' has already been declared&#125;)() 但是在不同作用域下声明同名变量是没有问题的，因为不同作用域之间的变量是没有关系的。内部作用域的变量会遮蔽外部作用域的同名变量 12345678(function test()&#123; let a=1; &#123; let a=2; console.log(a); // 2 &#125; console.log(a); // 1&#125;)() 临时死区 javascript引擎在预编译阶段时，要么将变量提升至作用域顶部（遇到var声明）,要么就将其放到TDZ（临时死区中，遇到let或const声明）。访问临时死区的变量会触发运行错误，即使是相对安全的typeof操作也会报错 我对于临时死区的理解是，相当于临时死区内部的代码在预编译阶段时被放进了一个黑匣子内（暂时从代码块中移除）。这些声明在预编译阶段不会进行任何操作；只有当运行代码块到这些声明时，这些代码才会被执行声明 例如 12console.log(typeof a); //报错: Cannot access 'a' before initializationlet a=1; 为什么typeof是相对安全的？ 如果某个变量未声明就被调用，那么一般其他操作就会报错，然而typeof只会返回undefined而不报错 12console.log(typeof a); // undefinedconsole.log(a); // 报错 a未定义 for循环中的块级作用域使用var声明变量的一些偏离预想的问题来看一段代码 12345678let funcs=[];for(var i=0;i&lt;10;i++) &#123; funcs.push(function ()&#123; console.log(i); &#125;)&#125;console.log('i',i); // 10funcs.forEach(value=&gt;value()); // 输出10个10 为什么不是我们想要的结果0~9，而是输出10个10 因为，使用var声明的变量在预编译阶段会被提升到当前作用域顶部；因此，当函数执行前i已经变为了10 那么，我们该怎么解决这个问题呢？ 使用IIFE（立即执行函数）来解决使用立即执行函数，说的更加明确一点，应该是利用闭包的特性，将当时的变量保存在闭包的作用域链上 12345678910let funcs=[];for(var i=0;i&lt;10;i++) &#123; funcs.push((function (value)&#123; return function ()&#123; console.log(value); &#125; &#125;)(i))&#125;console.log('i',i); // 10funcs.forEach(value=&gt;value()); // 0~9 使用let声明来解决12345678let funcs=[];for(let i=0;i&lt;10;i++) &#123; funcs.push(function ()&#123; console.log(i); &#125;)&#125;funcs.forEach(value=&gt;value()); // 0~9console.log('i',i); // 报错 i未定义 每次迭代循环都会创建一个块级作用域，而使用let声明则可以将变量绑定在当前作用域，因此每个作用域中的同名变量不会相互影响，并且会是0~9 循环中的const声明在不改变const定义的值得情况下，const声明在循环中的作用和表现与let一样 12345678910111213let obj=&#123; a:1, b:2&#125;let funcs=[];for(const key in obj) &#123; funcs.push(function ()&#123; console.log(key); &#125;)&#125;funcs.forEach(value=&gt;value()); // 'a' 'b' 但是，如果在某个作用内企图改变const定义的变量就会报错 1234567891011121314let obj=&#123; a:1, b:2&#125;let funcs=[];for(const key in obj) &#123; funcs.push(function ()&#123; key='c'; // 试图修改const定义的变量key console.log(key); &#125;)&#125;funcs.forEach(value=&gt;value()); // 报错]]></content>
      <categories>
        <category>javaScript基础</category>
      </categories>
      <tags>
        <tag>基础语法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[leetcode-172 阶乘后的零]]></title>
    <url>%2F2019%2F07%2F14%2Fleetcode-172%2F</url>
    <content type="text"><![CDATA[阶乘后的零题目描述给定一个整数 n，返回 n! 结果尾数中零的数量。 示例 1: 输入: 3输出: 0解释: 3! = 6, 尾数中没有零。 示例 2: 输入: 5输出: 1解释: 5! = 120, 尾数中有 1 个零. 说明: 你算法的时间复杂度应为 O(log n) 。 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/factorial-trailing-zeroes著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 核心思路概述一开始看到题目时的第一反应就是求解出n!的值，再遍历得到0的个数。然后提交之后，报错提示：超出最大堆栈大小（RangeError: Maximum call stack size exceeded）。因此，看题解之后得到提示，开始寻找规律。 若要某个数中有某位为0,那么他必定是10的倍数。而10=2 * 5；因此，该阶乘中有几对2 * 5，则该数就有几个0；又因为该阶乘为递减，则5的个数必定小于2的个数，则题目即可转化为求出5的个数即可。 解题步骤 归纳得： n 式子 5的个数 5的总个数 5 1*5 1 1 10 2*5 1 2 15 3*5 1 3 20 4*5 1 4 25 5*5 2 6 因此，可以通过 1234while (n &gt;= 5) &#123; n = Math.floor(n / 5); total += n;&#125; 得到5的个数 Coding实现一开始使用递归报错的coding1234567891011121314151617var trailingZeroes = function(n) &#123; let sum=(function circle(n)&#123; if(n!=1)&#123; return circle(n-1)*n; &#125; return 1; &#125;)(n) console.log(sum); sum=sum.toString().split(''); let count=0; sum.forEach(value=&gt;&#123; if(value==0)&#123; count++; &#125; &#125;); return count;&#125;; 优化过的coding12345678const trailingZeroes = n =&gt; &#123; let total = 0; while (n &gt;= 5) &#123; n = Math.floor(n / 5); total += n; &#125; return total;&#125;;]]></content>
      <categories>
        <category>leetcode题解与算法</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[leetcode-171 Excel表列序号]]></title>
    <url>%2F2019%2F07%2F13%2Fleetcode-171%2F</url>
    <content type="text"><![CDATA[Excel表列序号题目描述给定一个Excel表格中的列名称，返回其相应的列序号。 例如， A -&gt; 1 B -&gt; 2 C -&gt; 3 ... Z -&gt; 26 AA -&gt; 27 AB -&gt; 28 ...示例 1: 输入: “A” 输出: 1 示例 2: 输入: “AB” 输出: 28 示例 3: 输入: “ZY”输出: 701 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/excel-sheet-column-number著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 核心思路概述通过观察，不难发现其实这类似于二进制之类的表示形式。只不过对于该题可以把其称之为26进制。再按照二进制转化为十进制方法将其转化为对应的表示数 A的Unicode编码为65，在该题目中对应的是1.因此可以通过letter.charCodeAt()函数得到的Unicode编码值减去64即可得到对应的单个字母对应值。 解题步骤 将字符串转化为数组从而可以进行遍历 将转化得到的数组反转(reverse()) 【类似于二进制转化为十进制的方法，因此，反转后的数组的下标index就是他们在累加时的26幂的次方】 利用reduce()函数进行累加 Coding实现我一开始的coding12345678910var titleToNumber = function(s) &#123; const sArray=s.split(''); let length=sArray.length-1; let sum=0; sArray.forEach(value=&gt;&#123; sum+=(value.charCodeAt()%'A'.charCodeAt()+1)*Math.pow(26,length); length--; &#125;); return sum;&#125;; 优化过的coding123456var titleToNumber = function(s) &#123; const sArray=s.split('').reverse(); return (sArray.reduce((pre,cur,index)=&gt;&#123; return pre+(cur.charCodeAt()-64)*Math.pow(26,index); &#125;,0))&#125;;]]></content>
      <categories>
        <category>leetcode题解与算法</category>
      </categories>
      <tags>
        <tag>数组</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Vue项目代码与命名规范]]></title>
    <url>%2F2019%2F07%2F11%2FVue%E9%A1%B9%E7%9B%AE%E4%BB%A3%E7%A0%81%E4%B8%8E%E5%91%BD%E5%90%8D%E8%A7%84%E8%8C%83%2F</url>
    <content type="text"><![CDATA[Vue项目代码与命名规范 项目结构文件命名 单文件组件命名规范 组件名为多个单词 组件名应该始终是多个单词的，根组件 App 以及 &lt; transition &gt;、&lt; component &gt; 之类的 Vue 内置组件除外。 这样做可以避免跟现有的以及未来的 HTML 元素相冲突，因为所有的 HTML 元素名称都是单个单词的。 MyComponent.vue 语义化及单词顺序 SearchButtonRun.vue 文件名以单词大写开头 MyComponent.vue 组件名应该倾向于完整单词而不是缩写 UserProfileOptions.vue 文件夹命名规范 属于components文件夹下的子文件夹，使用大写字母开头的PascalBase风格 所有组件放在components文件夹下，对于各个页面应当新建立业务页面组件文件夹。 一些通用组件可以建立common文件夹放在components文件夹下 应当建立api文件夹，统一定义管理接口请求 建立router文件夹，进行路由管理 建立store文件夹，进行vuex状态管理]]></content>
      <categories>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>命名规范</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Vue项目的快速搭建]]></title>
    <url>%2F2019%2F07%2F11%2FVue%E9%A1%B9%E7%9B%AE%E7%9A%84%E5%BF%AB%E9%80%9F%E6%90%AD%E5%BB%BA%2F</url>
    <content type="text"><![CDATA[Vue项目的快速搭建 vue-cli创建项目12vue create &lt;项目名&gt;//选择手动设置特性（Manually select features） 安装必要依赖包括但不限于vue-router,vuex,vue-axios,axios1cnpm install vue-router --save 建立基本路由管理在router.js中配置路由 1234567891011121314151617181920212223242526import Vue from 'vue'import VueRouter from 'vue-router'import RouterView1 from '@/component/RouterView1'//@默认表示src文件夹Vue.use(VueRouter) /*安装 Vue.js 插件。如果插件是一个对象，必须提供 install 方法。如果插件是一个函数，它会被作为 install 方法。install 方法调用时，会将 Vue 作为参数传入。*/export default new VueRouter(&#123; routes:[ &#123; path:'/RouterView1', name:'view1', component:RouterView1 &#125;, &#123; path:'/RouterView2', name:'view2', component:()=&gt;&#123; import('@/component/RouterView2') &#125; /*import() es6函数，动态异步加载模块，返回一个promise*/ &#125; ]&#125;) 在main.js中注册12345new Vue(&#123; router, store, render: h =&gt; h(App)&#125;).$mount("#app"); 使用axios（或vue-axios）引入 第一种方式（main.js直接引入) 1234import axios from 'axios'import VueAxios from 'vue-axios'Vue.use(axios,vue-axios) 第二种方式（在api文件夹中引入） 建立api.js文件用来编写接口函数 建立index.js导出api.js的所有函数 使用 1234567891011Vue.axios.get(api).then((response) =&gt; &#123;console.log(response.data)&#125;)this.axios.get(api).then((response) =&gt; &#123;console.log(response.data)&#125;)this.$http.get(api).then((response) =&gt; &#123;console.log(response.data)&#125;)]]></content>
      <categories>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>Vue Cli</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[leetcode-169 求众数]]></title>
    <url>%2F2019%2F07%2F09%2Fleetcode-169%2F</url>
    <content type="text"><![CDATA[求众数核心方法：哈希表题目描述 给定一个大小为 n 的数组，找到其中的众数。众数是指在数组中出现次数大于 ⌊ n/2 ⌋ 的元素。 你可以假设数组是非空的，并且给定的数组总是存在众数。 示例 1: 输入: [3,2,3]输出: 3 示例 2: 输入: [2,2,1,1,1,2,2]输出: 2 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/majority-element著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 核心思路 利用哈希表这一数据结构来存储每个数的出现次数。元素作为键名，他们所出现的次数作为键值，进行存储。 遍历给定数组，若当前数组元素未在哈希表map中（map.has(key)===false），则以该元素为键名添加该元素，并置键值为1（map.set(value,1)）；若已存在，则更新该键值（键值加1:map.set(value,map.get(value)+1)） 遍历哈希表map，找到键值最大的那个键名并返回 coding实现1234567891011121314151617181920var majorityElement = function(nums) &#123; let maxCount=0; let num=0; let numsMap=new Map() nums.forEach(value=&gt;&#123; if(!numsMap.has(value))&#123; numsMap.set(value,1); &#125; else&#123; numsMap.set(value,numsMap.get(value)+1); &#125; &#125;) numsMap.forEach((value,key)=&gt;&#123; if(value&gt;maxCount)&#123; maxCount=value; num=key; &#125; &#125;) return num;&#125;;]]></content>
      <categories>
        <category>leetcode题解与算法</category>
      </categories>
      <tags>
        <tag>哈希表</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[leetcode-167 两数之和|| - 输入有序数组]]></title>
    <url>%2F2019%2F07%2F08%2Fleetcode-167%2F</url>
    <content type="text"><![CDATA[两数之和|| - 输入有序数组核心方法：双指针题目描述给定一个已按照升序排列 的有序数组，找到两个数使得它们相加之和等于目标数。 函数应该返回这两个下标值 index1 和 index2，其中 index1 必须小于 index2。 说明: 返回的下标值（index1 和 index2）不是从零开始的。 你可以假设每个输入只对应唯一的答案，而且你不可以重复使用相同的元素。 示例: 输入: numbers = [2, 7, 11, 15], target = 9输出: [1,2]解释: 2 与 7 之和等于目标数 9 。因此 index1 = 1, index2 = 2 。 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/two-sum-ii-input-array-is-sorted著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 核心思路题目给定的是有序数组，所以使用双指针方法较为方便。设定min指向第一个数组元素（也就是当前最小数），max指向最后一个数组元素。令sum=numbers[min]+numbers[max] 循环比较sum与target是否相等，若想等则输出。小于target则代表min指向的元素值比输出值要小，则min++;反之，则max–; coding实现1234567891011121314var twoSum = function(numbers, target) &#123; let min=0; let max=numbers.length-1; let sum; while((sum=numbers[min]+numbers[max])!==target)&#123; if(sum&lt;target)&#123; min++; &#125; else&#123; max--; &#125; &#125; return [min+1,max+1];&#125;]]></content>
      <categories>
        <category>leetcode题解与算法</category>
      </categories>
      <tags>
        <tag>双指针</tag>
      </tags>
  </entry>
</search>
