<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Hexo</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2019-08-03T07:16:57.922Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>Angel</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>leetcode-237 删除链表中的节点</title>
    <link href="http://yoursite.com/2019/08/03/leetcode-237/"/>
    <id>http://yoursite.com/2019/08/03/leetcode-237/</id>
    <published>2019-08-03T07:10:36.000Z</published>
    <updated>2019-08-03T07:16:57.922Z</updated>
    
    <content type="html"><![CDATA[<h1 id="删除链表中的节点"><a href="#删除链表中的节点" class="headerlink" title="删除链表中的节点"></a>删除链表中的节点</h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>请编写一个函数，使其可以删除某个链表中给定的（非末尾）节点，你将只被给定要求被删除的节点。</p><p>现有一个链表 – head = [4,5,1,9]，它可以表示为:</p><p>示例 1:</p><blockquote><p>输入: head = [4,5,1,9], node = 5<br>输出: [4,1,9]<br>解释: 给定你链表中值为 5 的第二个节点，那么在调用了你的函数之后，该链表应变为 4 -&gt; 1 -&gt; 9.</p></blockquote><p>示例 2:</p><blockquote><p>输入: head = [4,5,1,9], node = 1<br>输出: [4,5,9]<br>解释: 给定你链表中值为 1 的第三个节点，那么在调用了你的函数之后，该链表应变为 4 -&gt; 5 -&gt; 9.</p></blockquote><p>说明:</p><ol><li>链表至少包含两个节点。</li><li>链表中所有节点的值都是唯一的。</li><li>给定的节点为非末尾节点并且一定是链表中的一个有效节点。</li><li>不要从你的函数中返回任何结果。<a id="more"></a>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/delete-node-in-a-linked-list" target="_blank" rel="noopener">https://leetcode-cn.com/problems/delete-node-in-a-linked-list</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</li></ol><h2 id="核心思路"><a href="#核心思路" class="headerlink" title="核心思路"></a>核心思路</h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>一开始看到这个题目也是傻了一下，为什么只是传入一个要删除的节点，而不传入整个链表。后来一想，题目给定的初始链表中，每个节点的next存在的指向关系是一定的。那么我们就可以不需要考虑要删除节点之前的节点，只需要将要删除的节点的val值和next指向改变就可以了</p><h3 id="解题步骤"><a href="#解题步骤" class="headerlink" title="解题步骤"></a>解题步骤</h3><ol><li>改变要删除节点的val值为其下一个节点的val值</li><li>改变要删除节点的next指向为其下一个节点的下一个节点</li></ol><h2 id="Coding实现"><a href="#Coding实现" class="headerlink" title="Coding实现"></a>Coding实现</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * function ListNode(val) &#123;</span></span><br><span class="line"><span class="comment"> *     this.val = val;</span></span><br><span class="line"><span class="comment"> *     this.next = null;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @param &#123;ListNode&#125; node</span></span><br><span class="line"><span class="comment"> * @return &#123;void&#125; Do not return anything, modify node in-place instead.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> deleteNode = <span class="function"><span class="keyword">function</span>(<span class="params">node</span>) </span>&#123;</span><br><span class="line">    node.val=node.next.val;</span><br><span class="line">    node.next=node.next.next;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;删除链表中的节点&quot;&gt;&lt;a href=&quot;#删除链表中的节点&quot; class=&quot;headerlink&quot; title=&quot;删除链表中的节点&quot;&gt;&lt;/a&gt;删除链表中的节点&lt;/h1&gt;&lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h2&gt;&lt;p&gt;请编写一个函数，使其可以删除某个链表中给定的（非末尾）节点，你将只被给定要求被删除的节点。&lt;/p&gt;
&lt;p&gt;现有一个链表 – head = [4,5,1,9]，它可以表示为:&lt;/p&gt;
&lt;p&gt;示例 1:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;输入: head = [4,5,1,9], node = 5&lt;br&gt;输出: [4,1,9]&lt;br&gt;解释: 给定你链表中值为 5 的第二个节点，那么在调用了你的函数之后，该链表应变为 4 -&amp;gt; 1 -&amp;gt; 9.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;示例 2:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;输入: head = [4,5,1,9], node = 1&lt;br&gt;输出: [4,5,9]&lt;br&gt;解释: 给定你链表中值为 1 的第三个节点，那么在调用了你的函数之后，该链表应变为 4 -&amp;gt; 5 -&amp;gt; 9.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;说明:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;链表至少包含两个节点。&lt;/li&gt;
&lt;li&gt;链表中所有节点的值都是唯一的。&lt;/li&gt;
&lt;li&gt;给定的节点为非末尾节点并且一定是链表中的一个有效节点。&lt;/li&gt;
&lt;li&gt;不要从你的函数中返回任何结果。
    
    </summary>
    
      <category term="leetcode题解与算法" scheme="http://yoursite.com/categories/leetcode%E9%A2%98%E8%A7%A3%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="链表" scheme="http://yoursite.com/tags/%E9%93%BE%E8%A1%A8/"/>
    
  </entry>
  
  <entry>
    <title>arguments与模拟函数重载</title>
    <link href="http://yoursite.com/2019/08/03/arguments%E4%B8%8E%E6%A8%A1%E6%8B%9F%E5%87%BD%E6%95%B0%E9%87%8D%E8%BD%BD/"/>
    <id>http://yoursite.com/2019/08/03/arguments与模拟函数重载/</id>
    <published>2019-08-03T05:57:50.000Z</published>
    <updated>2019-08-03T06:51:51.528Z</updated>
    
    <content type="html"><![CDATA[<h2 id="arguments"><a href="#arguments" class="headerlink" title="arguments"></a>arguments</h2><p>arguments对象是所有（非箭头）函数中都可用的局部变量。</p><p>通过该对象可以访问参数数组。因为此对象包含传递给函数的每个参数，第一个参数在索引0处。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">a</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">arguments</span>); <span class="comment">//Arguments &#123; 0: 1, 1: 2, 2: 3, … &#125;</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">arguments</span>[<span class="number">0</span>]); <span class="comment">//1</span></span><br><span class="line">&#125;</span><br><span class="line">a(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>);</span><br></pre></td></tr></table></figure><p>由此可以看到，arguments对象并不是Array的实例，它是类数组对象。因此，可以通过方括号语法访问它的每一个元素</p><blockquote><p>arguments对象内的属性值永远与对应命名参数的值保持同步</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">a</span>(<span class="params">num</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">arguments</span>[<span class="number">0</span>]); <span class="comment">//1</span></span><br><span class="line">    num=<span class="number">11</span>;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">arguments</span>[<span class="number">0</span>]); <span class="comment">//11</span></span><br><span class="line">&#125;</span><br><span class="line">a(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>);</span><br></pre></td></tr></table></figure><h2 id="模拟函数重载"><a href="#模拟函数重载" class="headerlink" title="模拟函数重载"></a>模拟函数重载</h2><h3 id="重载的概念"><a href="#重载的概念" class="headerlink" title="重载的概念"></a>重载的概念</h3><p>在Java语言中，函数或者方法有相同的名称，但是参数的类型或数量不同，这样的同名不同参数的函数或者方法之间，互相称之为重载函数。</p><h3 id="为什么js没有重载"><a href="#为什么js没有重载" class="headerlink" title="为什么js没有重载"></a>为什么js没有重载</h3><p>然而，js中并没有重载的概念，因为：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">a</span>(<span class="params">num</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">a</span>(<span class="params">num1,num2</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">2</span>);</span><br><span class="line">&#125;</span><br><span class="line">a(); <span class="comment">// 2</span></span><br></pre></td></tr></table></figure><p>如果定义了多个同名函数，那么该名字只属于后定义的函数，所以js中不能像Java一样有传统意义上的重载</p><h3 id="js模拟函数重载"><a href="#js模拟函数重载" class="headerlink" title="js模拟函数重载"></a>js模拟函数重载</h3><p>其实，通过arguments,我们就可以通过检查传入函数中的参数类型和数量来做出不同的反应，从而模拟方法的重载</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">a</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">arguments</span>.length===<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(<span class="built_in">arguments</span>.length===<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">a(); <span class="comment">// 0</span></span><br><span class="line">a(<span class="number">1</span>); <span class="comment">// 1</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;arguments&quot;&gt;&lt;a href=&quot;#arguments&quot; class=&quot;headerlink&quot; title=&quot;arguments&quot;&gt;&lt;/a&gt;arguments&lt;/h2&gt;&lt;p&gt;arguments对象是所有（非箭头）函数中都可用的局部变量。&lt;/p&gt;
&lt;p&gt;通过该
      
    
    </summary>
    
      <category term="javaScript基础" scheme="http://yoursite.com/categories/javaScript%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="基础语法" scheme="http://yoursite.com/tags/%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>循环 (for...of与for...in)</title>
    <link href="http://yoursite.com/2019/08/03/%E5%BE%AA%E7%8E%AF/"/>
    <id>http://yoursite.com/2019/08/03/循环/</id>
    <published>2019-08-03T05:14:43.000Z</published>
    <updated>2019-08-03T05:55:10.271Z</updated>
    
    <content type="html"><![CDATA[<h2 id="循环语句类型"><a href="#循环语句类型" class="headerlink" title="循环语句类型"></a>循环语句类型</h2><ol><li>for 语句</li><li>do…while 语句</li><li>while 语句</li><li>labeled 语句</li><li>break 语句</li><li>continue 语句</li><li>for…in 语句</li><li>for…of 语句</li></ol><h2 id="for…in"><a href="#for…in" class="headerlink" title="for…in"></a>for…in</h2><p>for…in 语句循环一个指定的变量来循环一个对象所有可枚举的属性。JavaScript 会为每一个不同的属性执行指定的语句。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> items=&#123;</span><br><span class="line">    item1:<span class="number">1</span>,</span><br><span class="line">    item2:<span class="number">2</span>,</span><br><span class="line">    item3:<span class="number">3</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> a <span class="keyword">in</span> items)&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(a);  <span class="comment">// item1,item2,item3</span></span><br><span class="line">    <span class="built_in">console</span>.log(items[a]); <span class="comment">//1,2,3</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="for…of"><a href="#for…of" class="headerlink" title="for…of"></a>for…of</h2><p>for…of语句在<strong>可迭代的对象</strong>(在es6中，所有的集合对象(数组、Set集合及Map集合)和字符串都是可迭代对象)上创建了一个循环 ，对值的每一个独特的属性调用一个将被执行的自定义的和语句挂钩的迭代。</p><p>for…of循环每执行一次都会调用可迭代对象的next()方法，并将迭代器返回的结果对象的value属性存储在一个变量中，循环将持续执行这一过程直到返回对象的done属性的值为true</p><p>与 for…in 循环遍历的结果是数组元素的下标不同的是， for…of 遍历的结果是元素的值：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr=[<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>];</span><br><span class="line"><span class="keyword">let</span> str=<span class="string">'string'</span>;</span><br><span class="line"><span class="keyword">let</span> <span class="keyword">set</span>=new Set([1,'a',3]);</span><br><span class="line">let map=new Map([['a',1],['b',2]]);</span><br><span class="line">//遍历数组</span><br><span class="line">for(let a of arr)&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(a); <span class="comment">//4,5,6</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//遍历字符串</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> s <span class="keyword">of</span> str)&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(s); <span class="comment">//s,t,r,i,n,g</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//遍历set集合</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> k <span class="keyword">of</span> <span class="keyword">set</span>)&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(k); <span class="comment">//1,'a',3</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//遍历map集合</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> m <span class="keyword">of</span> map)&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(m); <span class="comment">//[ 'a', 1 ],[ 'b', 2 ]</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ol><li>倘若是遍历普通对象(非迭代对象)，那么使用for…in最佳，遍历得到属性名</li><li>倘若是遍历可迭代对象，那么根据需求来，如果不需要一些下标信息（例如set集合，字符串）那么使用for…of最佳</li><li>如果是数组和map，那么使用forEach会更加方便</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;循环语句类型&quot;&gt;&lt;a href=&quot;#循环语句类型&quot; class=&quot;headerlink&quot; title=&quot;循环语句类型&quot;&gt;&lt;/a&gt;循环语句类型&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;for 语句&lt;/li&gt;
&lt;li&gt;do…while 语句&lt;/li&gt;
&lt;li&gt;while 语句&lt;/l
      
    
    </summary>
    
      <category term="javaScript基础" scheme="http://yoursite.com/categories/javaScript%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="基础语法" scheme="http://yoursite.com/tags/%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>布尔操作符(1&amp;&amp;2和1||2)</title>
    <link href="http://yoursite.com/2019/08/03/%E5%B8%83%E5%B0%94%E6%93%8D%E4%BD%9C%E7%AC%A6/"/>
    <id>http://yoursite.com/2019/08/03/布尔操作符/</id>
    <published>2019-08-03T02:45:43.000Z</published>
    <updated>2019-08-03T05:01:41.396Z</updated>
    
    <content type="html"><![CDATA[<h2 id="mdn总结"><a href="#mdn总结" class="headerlink" title="mdn总结"></a>mdn总结</h2><table><thead><tr><th>运算符</th><th>语法</th><th>说明</th></tr></thead><tbody><tr><td>逻辑与，AND（&amp;&amp;）</td><td>expr1 &amp;&amp; expr2</td><td>若 expr1 可转换为 true，则返回 expr2；否则，返回 expr1。</td></tr><tr><td>逻辑或，OR（||）</td><td>expr1 || expr2</td><td>若 expr1 可转换为 true，则返回 expr1；否则，返回 expr2。</td></tr><tr><td>逻辑非，NOT（!）</td><td>!expr</td><td>若 expr 可转换为 true，则返回 false；否则，返回 true。</td></tr></tbody></table><h2 id="逻辑非-–"><a href="#逻辑非-–" class="headerlink" title="逻辑非 – !"></a>逻辑非 – !</h2><p>逻辑非操作符首先会将它的操作数转换为一个布尔值，然后再对其求反</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(!<span class="number">123</span>); <span class="comment">//false</span></span><br><span class="line"><span class="built_in">console</span>.log(!<span class="string">''</span>); <span class="comment">//true</span></span><br><span class="line"><span class="built_in">console</span>.log(!<span class="literal">undefined</span>); <span class="comment">//true</span></span><br><span class="line"><span class="built_in">console</span>.log(!<span class="literal">null</span>); <span class="comment">//true</span></span><br><span class="line"><span class="built_in">console</span>.log(!<span class="keyword">new</span> <span class="built_in">String</span>(<span class="string">'1'</span>)); <span class="comment">//false</span></span><br><span class="line"><span class="built_in">console</span>.log(!<span class="literal">false</span>); <span class="comment">//true</span></span><br></pre></td></tr></table></figure><h2 id="逻辑与-–-amp-amp"><a href="#逻辑与-–-amp-amp" class="headerlink" title="逻辑与 – &amp;&amp;"></a>逻辑与 – &amp;&amp;</h2><p>注意：逻辑与(&amp;&amp;)操作可以应用于任何类型的操纵数，而不仅仅是布尔值。</p><p>在有一个操作数不是布尔值的情况下，逻辑与操作就不一定返回布尔值；因此若要显示返回布尔值，则可以使用<strong>Boolean转型函数</strong>显示返回</p><p>逻辑与操作属于短路操作，即如果第一个操作数能够决定结果，那么就不会再对第二个操作数求值。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="number">1</span>&amp;&amp;<span class="number">2</span>); <span class="comment">//2</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">0</span>&amp;&amp;<span class="number">1</span>); <span class="comment">//0</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">123</span>&amp;&amp;<span class="string">'qwe'</span>); <span class="comment">//'qwe'</span></span><br><span class="line"><span class="built_in">console</span>.log(&#123;&#125;&amp;&amp;<span class="literal">null</span>); <span class="comment">//null 因为&#123;&#125;并不等于null，&#123;&#125;是一个不完全为空的对象，所以&#123;&#125;转换为逻辑值会是true</span></span><br></pre></td></tr></table></figure><h2 id="逻辑或-–"><a href="#逻辑或-–" class="headerlink" title="逻辑或 – ||"></a>逻辑或 – ||</h2><p>与逻辑与操作类似，逻辑或操作也是短路操作。也就是说，如果第一个操作数的求值结果为true,就不会对第二个操作数求值了</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="number">1</span>||<span class="number">2</span>); <span class="comment">//1</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">0</span>||<span class="number">1</span>); <span class="comment">//1</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">123</span>||<span class="string">'qwe'</span>); <span class="comment">//123</span></span><br><span class="line"><span class="built_in">console</span>.log(&#123;&#125;||<span class="literal">null</span>); <span class="comment">//&#123;&#125;</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;mdn总结&quot;&gt;&lt;a href=&quot;#mdn总结&quot; class=&quot;headerlink&quot; title=&quot;mdn总结&quot;&gt;&lt;/a&gt;mdn总结&lt;/h2&gt;&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;运算符&lt;/th&gt;
&lt;th&gt;语法&lt;/th&gt;
&lt;th&gt;说明&lt;/th&gt;
&lt;/t
      
    
    </summary>
    
      <category term="javaScript基础" scheme="http://yoursite.com/categories/javaScript%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="基础语法" scheme="http://yoursite.com/tags/%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>leetcode-283 移动零</title>
    <link href="http://yoursite.com/2019/08/02/leetcode-283/"/>
    <id>http://yoursite.com/2019/08/02/leetcode-283/</id>
    <published>2019-08-02T07:19:27.000Z</published>
    <updated>2019-08-02T07:27:14.546Z</updated>
    
    <content type="html"><![CDATA[<h1 id="移动零"><a href="#移动零" class="headerlink" title="移动零"></a>移动零</h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>给定一个数组 nums，编写一个函数将所有 0 移动到数组的末尾，同时保持非零元素的相对顺序。</p><p>示例:</p><blockquote><p>输入: [0,1,0,3,12]<br>输出: [1,3,12,0,0]</p></blockquote><p>说明:</p><ol><li>必须在原数组上操作，不能拷贝额外的数组。</li><li>尽量减少操作次数。<a id="more"></a>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/move-zeroes" target="_blank" rel="noopener">https://leetcode-cn.com/problems/move-zeroes</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</li></ol><h2 id="核心思路"><a href="#核心思路" class="headerlink" title="核心思路"></a>核心思路</h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>利用双指针，一个left指针用来寻找为0的元素，当找到后，该元素后面的所有元素前移，并将第二个指向数组末尾的指针right的元素值赋为0；如此循环直到left&gt;right</p><h3 id="解题步骤"><a href="#解题步骤" class="headerlink" title="解题步骤"></a>解题步骤</h3><ol><li>设置left指针指向数组第一个元素，设置right指针指向数组的最后一个元素</li><li>移动Left寻找数组中为0元素，当找到后，该元素后面的所有元素前移，并将第二个指向数组末尾的指针right的元素值赋为0；如此循环直到left&gt;right</li></ol><h2 id="Coding实现"><a href="#Coding实现" class="headerlink" title="Coding实现"></a>Coding实现</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @param &#123;number[]&#125; nums</span></span><br><span class="line"><span class="comment"> * @return &#123;void&#125; Do not return anything, modify nums in-place instead.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> moveZeroes = <span class="function"><span class="keyword">function</span>(<span class="params">nums</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> left=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">let</span> right=nums.length<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">while</span>(left&lt;right)&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums[left]===<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">let</span> i=left;i&lt;right;i++)&#123;</span><br><span class="line">                nums[i]=nums[i+<span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">            nums[right]=<span class="number">0</span>;</span><br><span class="line">            right--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            left++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> nums;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;移动零&quot;&gt;&lt;a href=&quot;#移动零&quot; class=&quot;headerlink&quot; title=&quot;移动零&quot;&gt;&lt;/a&gt;移动零&lt;/h1&gt;&lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h2&gt;&lt;p&gt;给定一个数组 nums，编写一个函数将所有 0 移动到数组的末尾，同时保持非零元素的相对顺序。&lt;/p&gt;
&lt;p&gt;示例:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;输入: [0,1,0,3,12]&lt;br&gt;输出: [1,3,12,0,0]&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;说明:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;必须在原数组上操作，不能拷贝额外的数组。&lt;/li&gt;
&lt;li&gt;尽量减少操作次数。
    
    </summary>
    
      <category term="leetcode题解与算法" scheme="http://yoursite.com/categories/leetcode%E9%A2%98%E8%A7%A3%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="双指针" scheme="http://yoursite.com/tags/%E5%8F%8C%E6%8C%87%E9%92%88/"/>
    
  </entry>
  
  <entry>
    <title>数据类型</title>
    <link href="http://yoursite.com/2019/08/01/%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/"/>
    <id>http://yoursite.com/2019/08/01/数据类型/</id>
    <published>2019-08-01T07:04:58.000Z</published>
    <updated>2019-08-03T02:59:37.735Z</updated>
    
    <content type="html"><![CDATA[<h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h2><h3 id="简单数据类型"><a href="#简单数据类型" class="headerlink" title="简单数据类型"></a>简单数据类型</h3><ol><li>Null (null值本质上是一个空对象指针)</li><li>Undefined</li><li>String</li><li>Number</li><li>Boolean</li><li>Symbol</li></ol><h3 id="复杂数据类型"><a href="#复杂数据类型" class="headerlink" title="复杂数据类型"></a>复杂数据类型</h3><ol><li>Object(包括Array、Function、Date、RegExp、Error、Arguments等更为具体的引用类型)</li></ol><h2 id="数据类型的检测判断"><a href="#数据类型的检测判断" class="headerlink" title="数据类型的检测判断"></a>数据类型的检测判断</h2><h3 id="typeof"><a href="#typeof" class="headerlink" title="typeof"></a>typeof</h3><blockquote><p>typeof 常用于判断基本数据类型</p></blockquote><h4 id="一些注意点"><a href="#一些注意点" class="headerlink" title="一些注意点"></a>一些注意点</h4><ol><li>typeof返回的是一个字符串,因此 typeof typeof 1 //(任意数据类型)都会返回string</li><li>null是一个空对象指针，因此typeof null会返回object</li><li>对于函数function的判断，tpeof function会返回function而不是对象object<blockquote><p>从技术角度讲，函数在es中是对象，而不是一种数据类型。然而，函数也确实有一些特殊的属性，因此通过typeof操作符来区分函数和其他对象是有必要的</p></blockquote></li><li>对于除function外的复杂数据类型，例如数组，set,map都会返回对象object </li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typeof</span> <span class="number">123</span> <span class="comment">// "number"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typeof</span> <span class="string">"abc"</span> <span class="comment">// "string"  </span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typeof</span> (<span class="keyword">new</span> <span class="built_in">String</span>()) <span class="comment">//object</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typeof</span> <span class="literal">true</span> <span class="comment">// "boolean"  </span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typeof</span> &#123;<span class="attr">a</span>: <span class="number">1</span>&#125; <span class="comment">// "object"  </span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typeof</span> <span class="literal">null</span> <span class="comment">//object</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typeof</span> <span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;&#125; <span class="comment">// "function"  </span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typeof</span> <span class="literal">undefined</span> <span class="comment">// "undefined"  </span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typeof</span> <span class="built_in">Symbol</span>(<span class="string">'foo'</span>) <span class="comment">// "symbol"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typeof</span> (<span class="keyword">new</span> <span class="built_in">Set</span>()) <span class="comment">//"object"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typeof</span> (<span class="keyword">new</span> <span class="built_in">Map</span>()) <span class="comment">//"object"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typeof</span> <span class="keyword">typeof</span> <span class="number">1</span> <span class="comment">//"string"</span></span><br></pre></td></tr></table></figure><h4 id="typeof的不足"><a href="#typeof的不足" class="headerlink" title="typeof的不足"></a>typeof的不足</h4><p>使用 typeof 方法来检测数据类型，基本类型大部分都能被准确检测并返回正确的字符串（除了 Null 类型，其返回 object 字符串），而引用类型大部分都不能够被准确检测（除了 Function 类型能够准确返回 function 字符串外，其它的都返回了 object 字符串）。</p><h3 id="instanceof"><a href="#instanceof" class="headerlink" title="instanceof"></a>instanceof</h3><p>instanceof用于判断引用类型</p><blockquote><p>instanceof 运算符用于测试构造函数的prototype属性是否出现在对象的原型链中的任何位置</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> str=<span class="keyword">new</span> <span class="built_in">String</span>();</span><br><span class="line"><span class="built_in">console</span>.log(str <span class="keyword">instanceof</span> <span class="built_in">String</span>);  <span class="comment">//true</span></span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>)</span>&#123;&#125;;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Student</span>(<span class="params"></span>)</span>&#123;&#125;;</span><br><span class="line"><span class="keyword">let</span> person=<span class="keyword">new</span> Person();</span><br><span class="line">Student.prototype=person;</span><br><span class="line"><span class="keyword">let</span> student=<span class="keyword">new</span> Student();</span><br><span class="line"><span class="built_in">console</span>.log(student <span class="keyword">instanceof</span> Person) <span class="comment">//true</span></span><br></pre></td></tr></table></figure><h4 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h4><blockquote><p>object instanceof constructor</p></blockquote><p>因此当使用instanceof判断基本数据类型时就会返回false,与此同时,instanceof 右端也必须是某个构造函数</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">'a'</span> <span class="keyword">instanceof</span> <span class="built_in">String</span> <span class="comment">//false</span></span><br><span class="line"><span class="number">123</span> <span class="keyword">instanceof</span> <span class="built_in">Number</span> <span class="comment">//false</span></span><br></pre></td></tr></table></figure><h4 id="null-instanceof-object"><a href="#null-instanceof-object" class="headerlink" title="null instanceof object"></a>null instanceof object</h4><p>那么基本数据类型中的null呢，既然typeof null===object;那么null instanceof object呢？<br>很不幸,返回的会是false</p><p>简单来说，null并不是以Object为原型创建出来的</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="literal">null</span> <span class="keyword">instanceof</span> object <span class="comment">//false</span></span><br></pre></td></tr></table></figure><h4 id="函数模拟instanceof"><a href="#函数模拟instanceof" class="headerlink" title="函数模拟instanceof"></a>函数模拟instanceof</h4><p>知道instaceof的原理是判断构造函数的prototype属性是否出现在对象的原型链中的任何位置时，那么就不难模拟一个函数来实现instanceof</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">instance</span>(<span class="params">a,b</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">let</span> bPro=b.prototype; <span class="comment">//取b的显示原型</span></span><br><span class="line">    <span class="keyword">let</span> aPro=a.__proto__; <span class="comment">//取a的隐式原型</span></span><br><span class="line">    <span class="comment">//或者使用Object.getPrototypeOf(a)取得a的隐式原型</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(aPro===bPro) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span>(aPro===<span class="built_in">Object</span>.prototype) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        aPro=aPro.__proto__;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Object-prototype-toString-一个完善的类型检测方案"><a href="#Object-prototype-toString-一个完善的类型检测方案" class="headerlink" title="Object.prototype.toString()一个完善的类型检测方案"></a>Object.prototype.toString()一个完善的类型检测方案</h3><blockquote><p>每个对象都有一个toString()方法，当该对象被表示为一个文本值时，或者一个对象以预期的字符串方式引用时自动调用。默认情况下，toString()方法被每个Object对象继承。如果此方法在自定义对象中未被覆盖，toString() 返回 “[object type]”，其中type是对象的类型</p></blockquote><blockquote><p>可以通过toString() 来获取每个对象的类型。为了每个对象都能通过 Object.prototype.toString() 来检测，需要以 Function.prototype.call() 或者 Function.prototype.apply() 的形式来调用，传递要检查的对象作为第一个参数，称为thisArg。</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> toString=<span class="built_in">Object</span>.prototype.toString;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(toString.call(<span class="literal">undefined</span>));  <span class="comment">// [object Undefined]</span></span><br><span class="line"><span class="built_in">console</span>.log(toString.call(<span class="literal">null</span>));  <span class="comment">// [object Null]</span></span><br><span class="line"><span class="built_in">console</span>.log(toString.call(<span class="literal">true</span>));  <span class="comment">// [object Boolean]</span></span><br><span class="line"><span class="built_in">console</span>.log(toString.call(<span class="number">123</span>));  <span class="comment">// [object Number]</span></span><br><span class="line"><span class="built_in">console</span>.log(toString.call(<span class="string">'a'</span>));  <span class="comment">// [object String]</span></span><br><span class="line"><span class="built_in">console</span>.log(toString.call(<span class="keyword">new</span> <span class="built_in">Object</span>());  <span class="comment">// [object Object]</span></span><br><span class="line"><span class="built_in">console</span>.log(toString.call([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]));  <span class="comment">// [object Array]</span></span><br><span class="line"><span class="built_in">console</span>.log(toString.call(<span class="function"><span class="keyword">function</span> <span class="title">a</span>(<span class="params"></span>)</span>&#123;&#125;));  <span class="comment">// [object Function]</span></span><br><span class="line"><span class="built_in">console</span>.log(toString.call(<span class="keyword">new</span> <span class="built_in">Date</span>()));  <span class="comment">// [object Date]</span></span><br></pre></td></tr></table></figure><h3 id="数组判断isArray"><a href="#数组判断isArray" class="headerlink" title="数组判断isArray()"></a>数组判断isArray()</h3><blockquote><p>Array.isArray() 用于确定传递的值是否是一个 Array。</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Array</span>.isArray([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]);  </span><br><span class="line"><span class="comment">// true</span></span><br><span class="line"><span class="built_in">Array</span>.isArray(&#123;<span class="attr">foo</span>: <span class="number">123</span>&#125;); </span><br><span class="line"><span class="comment">// false</span></span><br><span class="line"><span class="built_in">Array</span>.isArray(<span class="string">"foobar"</span>);   </span><br><span class="line"><span class="comment">// false</span></span><br><span class="line"><span class="built_in">Array</span>.isArray(<span class="literal">undefined</span>);  </span><br><span class="line"><span class="comment">// false</span></span><br></pre></td></tr></table></figure><h3 id="综述"><a href="#综述" class="headerlink" title="综述"></a>综述</h3><p>一个较好的解决方案应该是检测基本数据类型时使用typeof，当然null除外；检测复杂数据类型时使用Object.prototype.toString()</p><h2 id="Undefined类型"><a href="#Undefined类型" class="headerlink" title="Undefined类型"></a>Undefined类型</h2><p>undefined指那些被声明但未被初始化的值</p><h2 id="Null类型"><a href="#Null类型" class="headerlink" title="Null类型"></a>Null类型</h2><p>null值表示一个空对象指针，因此typeof null === object</p><h2 id="Boolean类型及相应转换规则"><a href="#Boolean类型及相应转换规则" class="headerlink" title="Boolean类型及相应转换规则"></a>Boolean类型及相应转换规则</h2><h3 id="转型函数Boolean"><a href="#转型函数Boolean" class="headerlink" title="转型函数Boolean()"></a>转型函数Boolean()</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> str=<span class="string">'hello'</span>;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Boolean</span>(str)); <span class="comment">//true</span></span><br></pre></td></tr></table></figure><h3 id="Boolean自动转换规则"><a href="#Boolean自动转换规则" class="headerlink" title="Boolean自动转换规则"></a>Boolean自动转换规则</h3><table><thead><tr><th>数据类型</th><th>转换为true值</th><th>转换为false值</th></tr></thead><tbody><tr><td>Number</td><td>任何非0数值</td><td>0和NaN</td></tr><tr><td>String</td><td>非空字符串</td><td>空字符串（””）</td></tr><tr><td>Bollean</td><td>true</td><td>false</td></tr><tr><td>Object</td><td>任何object(包括{}，因为{}是一个不完全空的对象)</td><td>null</td></tr><tr><td>Undefined</td><td>无</td><td>undefined</td></tr></tbody></table><h2 id="Number类型"><a href="#Number类型" class="headerlink" title="Number类型"></a>Number类型</h2><p><a href>为什么0.1+0.2!==0.3</a></p><h3 id="NaN"><a href="#NaN" class="headerlink" title="NaN"></a>NaN</h3><p>NaN,指的是非数值，用来表示一个本来要返回数值的操作数未返回数值的情况，例如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="string">'a'</span><span class="number">-1</span>); <span class="comment">//NaN</span></span><br></pre></td></tr></table></figure><p>任何设置NaN的操作都会返回NaN,甚至NaN与任何值都不相等包括其本身，包括但不限于：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="literal">NaN</span><span class="number">-1</span>); <span class="comment">//NaN</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="literal">NaN</span>===<span class="literal">NaN</span>); <span class="comment">//false</span></span><br></pre></td></tr></table></figure><h4 id="isNaN函数"><a href="#isNaN函数" class="headerlink" title="isNaN函数"></a>isNaN函数</h4><blockquote><p>isNaN() 函数用来确定一个值是否为NaN 。注：isNaN函数内包含一些非常有趣的规则；你也可以使用 ECMAScript 2015 中定义的 Number.isNaN() 来判断。</p></blockquote><blockquote><p>下一个版本的ECMAScript (ES2015)包含Number.isNaN()函数。通过Number.isNaN(x)来检测变量x是否是一个NaN将会是一种可靠的做法。然而，在缺少Number.isNaN函数的情况下, 通过表达式(x != x) 来检测变量x是否是NaN会更加可靠。</p></blockquote><p>一个isNaN的 polyfill 可以理解为（这个polyfill利用了NaN自身永不相等于自身这一特征 ）：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> <span class="built_in">isNaN</span> = <span class="function"><span class="keyword">function</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> n = <span class="built_in">Number</span>(value); <span class="comment">//利用Number()函数进行数值转换</span></span><br><span class="line">    <span class="keyword">return</span> n !== n;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h5 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">isNaN</span>(<span class="literal">NaN</span>);       <span class="comment">// true</span></span><br><span class="line"><span class="built_in">isNaN</span>(<span class="literal">undefined</span>); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">isNaN</span>(&#123;&#125;);        <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">isNaN</span>(<span class="literal">true</span>);      <span class="comment">// false</span></span><br><span class="line"><span class="built_in">isNaN</span>(<span class="literal">null</span>);      <span class="comment">// false</span></span><br><span class="line"><span class="built_in">isNaN</span>(<span class="number">37</span>);        <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// strings</span></span><br><span class="line"><span class="built_in">isNaN</span>(<span class="string">"37"</span>);      <span class="comment">// false: 可以被转换成数值37</span></span><br><span class="line"><span class="built_in">isNaN</span>(<span class="string">"37.37"</span>);   <span class="comment">// false: 可以被转换成数值37.37</span></span><br><span class="line"><span class="built_in">isNaN</span>(<span class="string">"37,5"</span>);    <span class="comment">// true</span></span><br><span class="line"><span class="built_in">isNaN</span>(<span class="string">'123ABC'</span>);  <span class="comment">// true:  parseInt("123ABC")的结果是 123, 但是Number("123ABC")结果是 NaN</span></span><br><span class="line"><span class="built_in">isNaN</span>(<span class="string">""</span>);        <span class="comment">// false: 空字符串被转换成0</span></span><br><span class="line"><span class="built_in">isNaN</span>(<span class="string">" "</span>);       <span class="comment">// false: 包含空格的字符串被转换成0</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// dates</span></span><br><span class="line"><span class="built_in">isNaN</span>(<span class="keyword">new</span> <span class="built_in">Date</span>());                <span class="comment">// false</span></span><br><span class="line"><span class="built_in">isNaN</span>(<span class="keyword">new</span> <span class="built_in">Date</span>().toString());     <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">isNaN</span>(<span class="string">"blabla"</span>)   <span class="comment">// true: "blabla"不能转换成数值</span></span><br><span class="line">                  <span class="comment">// 转换成数值失败， 返回NaN</span></span><br></pre></td></tr></table></figure><h3 id="数值转换"><a href="#数值转换" class="headerlink" title="数值转换"></a>数值转换</h3><ol><li>Number()</li><li>parseInt()</li><li>parseFloat()</li></ol><h2 id="String类型"><a href="#String类型" class="headerlink" title="String类型"></a>String类型</h2><h3 id="toString-方法"><a href="#toString-方法" class="headerlink" title="toString()方法"></a>toString()方法</h3><p>作用：返回值的字符串表现<br>数值，布尔值，对象和字符串都有该方法<br>但是undefined和null没有该方法</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="number">123.</span>toString()); <span class="comment">//'123'</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="literal">true</span>.toString()); <span class="comment">//'true'</span></span><br><span class="line"><span class="keyword">let</span> a=&#123;<span class="attr">item</span>:<span class="number">1</span>&#125;;</span><br><span class="line"><span class="built_in">console</span>.log(a.toString()); <span class="comment">//'[object Object]'</span></span><br></pre></td></tr></table></figure><h3 id="String-转型函数"><a href="#String-转型函数" class="headerlink" title="String()转型函数"></a>String()转型函数</h3><p>该函数不同于toString不能转换null和undefined;该方法可以转换任何类型的值</p><p>转换规则如下：</p><ol><li>如果该类型有toString()方法，那么就调用该方法</li><li>如果为null，则返回”null”</li><li>如果为undefined，则返回”undefined”</li></ol><h2 id="Object类型"><a href="#Object类型" class="headerlink" title="Object类型"></a>Object类型</h2><p>Object类型是所有对象的基础，也就是所有对象都是继承与Object的</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a=<span class="keyword">new</span> <span class="built_in">Object</span>();</span><br><span class="line"><span class="keyword">let</span> str=<span class="keyword">new</span> <span class="built_in">String</span>();</span><br><span class="line"><span class="keyword">let</span> date=<span class="keyword">new</span> <span class="built_in">Date</span>();</span><br><span class="line"><span class="built_in">console</span>.log(a <span class="keyword">instanceof</span> <span class="built_in">Object</span>); <span class="comment">//true</span></span><br><span class="line"><span class="built_in">console</span>.log(str <span class="keyword">instanceof</span> <span class="built_in">Object</span>); <span class="comment">//true</span></span><br><span class="line"><span class="built_in">console</span>.log(date <span class="keyword">instanceof</span> <span class="built_in">Object</span>); <span class="comment">//true</span></span><br></pre></td></tr></table></figure><p>对象可以通过执行new操作符后跟要创建的对象类型的名称来创建，例</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a=<span class="keyword">new</span> <span class="built_in">Object</span>();</span><br><span class="line"><span class="keyword">let</span> str=<span class="keyword">new</span> <span class="built_in">String</span>();</span><br><span class="line"><span class="keyword">let</span> date=<span class="keyword">new</span> <span class="built_in">Date</span>();</span><br></pre></td></tr></table></figure><h3 id="Object实例的一些属性与方法"><a href="#Object实例的一些属性与方法" class="headerlink" title="Object实例的一些属性与方法"></a>Object实例的一些属性与方法</h3><ol><li>constructor: 指向构造函数</li><li>isPrototypeOf(object)：用于检查传入的对象是否是当前对象的原型</li><li>toString()：返回对象的字符串表示</li><li>valueOf(): 返回对象的字符串、数值或布尔值表示。通常与toString()方法返回值相同</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;数据类型&quot;&gt;&lt;a href=&quot;#数据类型&quot; class=&quot;headerlink&quot; title=&quot;数据类型&quot;&gt;&lt;/a&gt;数据类型&lt;/h2&gt;&lt;h3 id=&quot;简单数据类型&quot;&gt;&lt;a href=&quot;#简单数据类型&quot; class=&quot;headerlink&quot; title=&quot;简单数据类
      
    
    </summary>
    
      <category term="javaScript基础" scheme="http://yoursite.com/categories/javaScript%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="基础语法" scheme="http://yoursite.com/tags/%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>leetcode-1021 删除最外层的括号</title>
    <link href="http://yoursite.com/2019/07/31/leetcode-1021/"/>
    <id>http://yoursite.com/2019/07/31/leetcode-1021/</id>
    <published>2019-07-31T08:11:10.000Z</published>
    <updated>2019-07-31T08:19:06.012Z</updated>
    
    <content type="html"><![CDATA[<h1 id="删除最外层的括号"><a href="#删除最外层的括号" class="headerlink" title="删除最外层的括号"></a>删除最外层的括号</h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>有效括号字符串为空 (“”)、”(“ + A + “)” 或 A + B，其中 A 和 B 都是有效的括号字符串，+ 代表字符串的连接。例如，””，”()”，”(())()” 和 “(()(()))” 都是有效的括号字符串。</p><p>如果有效字符串 S 非空，且不存在将其拆分为 S = A+B 的方法，我们称其为原语（primitive），其中 A 和 B 都是非空有效括号字符串。</p><p>给出一个非空有效字符串 S，考虑将其进行原语化分解，使得：S = P_1 + P_2 + … + P_k，其中 P_i 是有效括号字符串原语。</p><p>对 S 进行原语化分解，删除分解中每个原语字符串的最外层括号，返回 S 。</p><p>示例 1：</p><blockquote><p>输入：”(()())(())”<br>输出：”()()()”<br>解释：<br>输入字符串为 “(()())(())”，原语化分解得到 “(()())” + “(())”，<br>删除每个部分中的最外层括号后得到 “()()” + “()” = “()()()”。</p></blockquote><p>示例 2：</p><blockquote><p>输入：”(()())(())(()(()))”<br>输出：”()()()()(())”<br>解释：<br>输入字符串为 “(()())(())(()(()))”，原语化分解得到 “(()())” + “(())” + “(()(()))”，<br>删除每隔部分中的最外层括号后得到 “()()” + “()” + “()(())” = “()()()()(())”。</p></blockquote><p>示例 3：</p><blockquote><p>输入：”()()”<br>输出：””<br>解释：<br>输入字符串为 “()()”，原语化分解得到 “()” + “()”，<br>删除每个部分中的最外层括号后得到 “” + “” = “”。</p></blockquote><p>提示：</p><ol><li>S.length &lt;= 10000</li><li>S[i] 为 “(“ 或 “)”</li><li>S 是一个有效括号字符串<a id="more"></a>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/remove-outermost-parentheses" target="_blank" rel="noopener">https://leetcode-cn.com/problems/remove-outermost-parentheses</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</li></ol><h2 id="核心思路"><a href="#核心思路" class="headerlink" title="核心思路"></a>核心思路</h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>关于括号匹配问题，很容易想到用栈来解决。</p><p>遇到 ‘ ( ‘ 入栈，遇到 ‘ ) ‘ 则出栈。则当该栈为空时，则代表之前的括号都已匹配。那么就可以将先前的括号去掉最外层的括号</p><h3 id="解题步骤"><a href="#解题步骤" class="headerlink" title="解题步骤"></a>解题步骤</h3><ol><li>设定一个数组stack用来表示栈操作，并预先压入第一个元素’(‘</li><li>设定一个数组temp用来存放已经匹配完成的括号，并预先设定第一个元素’(‘</li><li>从第二个元素开始遍历，遇到 ‘ ( ‘ 入栈，遇到 ‘ ) ‘ 则出栈。则当该栈为空时，则代表之前的括号都已匹配。那么就可以将先前的括号去掉最外层的括号,并压入结果数组ans</li><li>返回ans</li></ol><h2 id="Coding实现"><a href="#Coding实现" class="headerlink" title="Coding实现"></a>Coding实现</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @param &#123;string&#125; S</span></span><br><span class="line"><span class="comment"> * @return &#123;string&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> removeOuterParentheses = <span class="function"><span class="keyword">function</span>(<span class="params">S</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> stack=[<span class="string">'('</span>];</span><br><span class="line">    <span class="keyword">let</span> temp=[<span class="string">'('</span>];</span><br><span class="line">    <span class="keyword">let</span> ans=[];</span><br><span class="line">    S=S.split(<span class="string">''</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">1</span>;i&lt;S.length;i++)&#123;</span><br><span class="line">        temp.push(S[i]);</span><br><span class="line">        <span class="keyword">if</span>(S[i]===<span class="string">')'</span>)&#123;</span><br><span class="line">            stack.pop();</span><br><span class="line">            <span class="keyword">if</span>(stack.length===<span class="number">0</span>)&#123;</span><br><span class="line">                temp.pop();</span><br><span class="line">                temp.shift();</span><br><span class="line">                ans.push(...temp);</span><br><span class="line">                temp=[];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> stack.push(S[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans.join(<span class="string">''</span>);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;删除最外层的括号&quot;&gt;&lt;a href=&quot;#删除最外层的括号&quot; class=&quot;headerlink&quot; title=&quot;删除最外层的括号&quot;&gt;&lt;/a&gt;删除最外层的括号&lt;/h1&gt;&lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h2&gt;&lt;p&gt;有效括号字符串为空 (“”)、”(“ + A + “)” 或 A + B，其中 A 和 B 都是有效的括号字符串，+ 代表字符串的连接。例如，””，”()”，”(())()” 和 “(()(()))” 都是有效的括号字符串。&lt;/p&gt;
&lt;p&gt;如果有效字符串 S 非空，且不存在将其拆分为 S = A+B 的方法，我们称其为原语（primitive），其中 A 和 B 都是非空有效括号字符串。&lt;/p&gt;
&lt;p&gt;给出一个非空有效字符串 S，考虑将其进行原语化分解，使得：S = P_1 + P_2 + … + P_k，其中 P_i 是有效括号字符串原语。&lt;/p&gt;
&lt;p&gt;对 S 进行原语化分解，删除分解中每个原语字符串的最外层括号，返回 S 。&lt;/p&gt;
&lt;p&gt;示例 1：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;输入：”(()())(())”&lt;br&gt;输出：”()()()”&lt;br&gt;解释：&lt;br&gt;输入字符串为 “(()())(())”，原语化分解得到 “(()())” + “(())”，&lt;br&gt;删除每个部分中的最外层括号后得到 “()()” + “()” = “()()()”。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;示例 2：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;输入：”(()())(())(()(()))”&lt;br&gt;输出：”()()()()(())”&lt;br&gt;解释：&lt;br&gt;输入字符串为 “(()())(())(()(()))”，原语化分解得到 “(()())” + “(())” + “(()(()))”，&lt;br&gt;删除每隔部分中的最外层括号后得到 “()()” + “()” + “()(())” = “()()()()(())”。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;示例 3：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;输入：”()()”&lt;br&gt;输出：””&lt;br&gt;解释：&lt;br&gt;输入字符串为 “()()”，原语化分解得到 “()” + “()”，&lt;br&gt;删除每个部分中的最外层括号后得到 “” + “” = “”。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;提示：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;S.length &amp;lt;= 10000&lt;/li&gt;
&lt;li&gt;S[i] 为 “(“ 或 “)”&lt;/li&gt;
&lt;li&gt;S 是一个有效括号字符串
    
    </summary>
    
      <category term="leetcode题解与算法" scheme="http://yoursite.com/categories/leetcode%E9%A2%98%E8%A7%A3%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="栈" scheme="http://yoursite.com/tags/%E6%A0%88/"/>
    
  </entry>
  
  <entry>
    <title>leetcode-1122 数组的相对排序</title>
    <link href="http://yoursite.com/2019/07/30/leetcode-1122/"/>
    <id>http://yoursite.com/2019/07/30/leetcode-1122/</id>
    <published>2019-07-30T06:14:33.000Z</published>
    <updated>2019-07-30T06:17:41.290Z</updated>
    
    <content type="html"><![CDATA[<h1 id="数组的相对排序"><a href="#数组的相对排序" class="headerlink" title="数组的相对排序"></a>数组的相对排序</h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>给你两个数组，arr1 和 arr2，</p><ol><li>arr2 中的元素各不相同</li><li>arr2 中的每个元素都出现在 arr1 中</li></ol><p>对 arr1 中的元素进行排序，使 arr1 中项的相对顺序和 arr2 中的相对顺序相同。未在 arr2 中出现过的元素需要按照升序放在 arr1 的末尾。</p><p>示例：</p><blockquote><p>输入：arr1 = [2,3,1,3,2,4,6,7,9,2,19], arr2 = [2,1,4,3,9,6]<br>输出：[2,2,2,1,4,3,3,9,6,7,19]</p></blockquote><p>提示：</p><ol><li>arr1.length, arr2.length &lt;= 1000</li><li>0 &lt;= arr1[i], arr2[i] &lt;= 1000</li><li>arr2 中的元素 arr2[i] 各不相同</li><li>arr2 中的每个元素 arr2[i] 都出现在 arr1 中<a id="more"></a>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/relative-sort-array" target="_blank" rel="noopener">https://leetcode-cn.com/problems/relative-sort-array</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</li></ol><h2 id="核心思路"><a href="#核心思路" class="headerlink" title="核心思路"></a>核心思路</h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>目前觉得暴力解法最简单</p><h3 id="解题步骤"><a href="#解题步骤" class="headerlink" title="解题步骤"></a>解题步骤</h3><p>双循环，时间复杂度为O(n*m)</p><h2 id="Coding实现"><a href="#Coding实现" class="headerlink" title="Coding实现"></a>Coding实现</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @param &#123;number[]&#125; arr1</span></span><br><span class="line"><span class="comment"> * @param &#123;number[]&#125; arr2</span></span><br><span class="line"><span class="comment"> * @return &#123;number[]&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> relativeSortArray = <span class="function"><span class="keyword">function</span>(<span class="params">arr1, arr2</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> ans=[];</span><br><span class="line">    <span class="keyword">let</span> el=[];</span><br><span class="line">    arr1.forEach(<span class="function"><span class="params">value</span>=&gt;</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!arr2.includes(value))&#123;</span><br><span class="line">            el.push(value);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">    arr2.forEach(<span class="function"><span class="params">value2</span>=&gt;</span>&#123;</span><br><span class="line">        arr1.forEach(<span class="function"><span class="params">value1</span>=&gt;</span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(value1===value2)&#123;</span><br><span class="line">                ans.push(value2);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">    el.sort(<span class="function">(<span class="params">a,b</span>)=&gt;</span>&#123;<span class="keyword">return</span> a-b;&#125;)</span><br><span class="line">    <span class="keyword">return</span> ans.concat(el);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;数组的相对排序&quot;&gt;&lt;a href=&quot;#数组的相对排序&quot; class=&quot;headerlink&quot; title=&quot;数组的相对排序&quot;&gt;&lt;/a&gt;数组的相对排序&lt;/h1&gt;&lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h2&gt;&lt;p&gt;给你两个数组，arr1 和 arr2，&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;arr2 中的元素各不相同&lt;/li&gt;
&lt;li&gt;arr2 中的每个元素都出现在 arr1 中&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;对 arr1 中的元素进行排序，使 arr1 中项的相对顺序和 arr2 中的相对顺序相同。未在 arr2 中出现过的元素需要按照升序放在 arr1 的末尾。&lt;/p&gt;
&lt;p&gt;示例：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;输入：arr1 = [2,3,1,3,2,4,6,7,9,2,19], arr2 = [2,1,4,3,9,6]&lt;br&gt;输出：[2,2,2,1,4,3,3,9,6,7,19]&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;提示：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;arr1.length, arr2.length &amp;lt;= 1000&lt;/li&gt;
&lt;li&gt;0 &amp;lt;= arr1[i], arr2[i] &amp;lt;= 1000&lt;/li&gt;
&lt;li&gt;arr2 中的元素 arr2[i] 各不相同&lt;/li&gt;
&lt;li&gt;arr2 中的每个元素 arr2[i] 都出现在 arr1 中
    
    </summary>
    
      <category term="leetcode题解与算法" scheme="http://yoursite.com/categories/leetcode%E9%A2%98%E8%A7%A3%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
  </entry>
  
  <entry>
    <title>leetcode-344 反转字符串</title>
    <link href="http://yoursite.com/2019/07/30/leetcode-344/"/>
    <id>http://yoursite.com/2019/07/30/leetcode-344/</id>
    <published>2019-07-30T05:42:24.000Z</published>
    <updated>2019-07-30T06:14:13.403Z</updated>
    
    <content type="html"><![CDATA[<h1 id="反转字符串"><a href="#反转字符串" class="headerlink" title="反转字符串"></a>反转字符串</h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>编写一个函数，其作用是将输入的字符串反转过来。输入字符串以字符数组 char[] 的形式给出。</p><p>不要给另外的数组分配额外的空间，你必须原地修改输入数组、使用 O(1) 的额外空间解决这一问题。</p><p>你可以假设数组中的所有字符都是 ASCII 码表中的可打印字符。</p><p>示例 1：</p><blockquote><p>输入：[“h”,”e”,”l”,”l”,”o”]<br>输出：[“o”,”l”,”l”,”e”,”h”]</p></blockquote><p>示例 2：</p><blockquote><p>输入：[“H”,”a”,”n”,”n”,”a”,”h”]<br>输出：[“h”,”a”,”n”,”n”,”a”,”H”]</p></blockquote><a id="more"></a><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/reverse-string" target="_blank" rel="noopener">https://leetcode-cn.com/problems/reverse-string</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p><h2 id="核心思路"><a href="#核心思路" class="headerlink" title="核心思路"></a>核心思路</h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>题目要求是原地修改数组，并且只能使用O(1)的额外空间。因此，不能创建新的数组来存放数组元素，此时可以考虑使用双指针，一个置首，一个置尾。首向后，尾向前，交换两个指针的值即可。</p><h3 id="解题步骤"><a href="#解题步骤" class="headerlink" title="解题步骤"></a>解题步骤</h3><ol><li>建立left,right双指针</li><li>当left&lt;=right时，交换两指针元素</li></ol><h2 id="Coding实现"><a href="#Coding实现" class="headerlink" title="Coding实现"></a>Coding实现</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @param &#123;character[]&#125; s</span></span><br><span class="line"><span class="comment"> * @return &#123;void&#125; Do not return anything, modify s in-place instead.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> reverseString = <span class="function"><span class="keyword">function</span>(<span class="params">s</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> left=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">let</span> right=s.length<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">while</span>(left&lt;=right)&#123;</span><br><span class="line">        [s[left],s[right]]=[s[right],s[left]];</span><br><span class="line">        left++;</span><br><span class="line">        right--;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> s;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;反转字符串&quot;&gt;&lt;a href=&quot;#反转字符串&quot; class=&quot;headerlink&quot; title=&quot;反转字符串&quot;&gt;&lt;/a&gt;反转字符串&lt;/h1&gt;&lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h2&gt;&lt;p&gt;编写一个函数，其作用是将输入的字符串反转过来。输入字符串以字符数组 char[] 的形式给出。&lt;/p&gt;
&lt;p&gt;不要给另外的数组分配额外的空间，你必须原地修改输入数组、使用 O(1) 的额外空间解决这一问题。&lt;/p&gt;
&lt;p&gt;你可以假设数组中的所有字符都是 ASCII 码表中的可打印字符。&lt;/p&gt;
&lt;p&gt;示例 1：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;输入：[“h”,”e”,”l”,”l”,”o”]&lt;br&gt;输出：[“o”,”l”,”l”,”e”,”h”]&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;示例 2：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;输入：[“H”,”a”,”n”,”n”,”a”,”h”]&lt;br&gt;输出：[“h”,”a”,”n”,”n”,”a”,”H”]&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="leetcode题解与算法" scheme="http://yoursite.com/categories/leetcode%E9%A2%98%E8%A7%A3%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="双指针" scheme="http://yoursite.com/tags/%E5%8F%8C%E6%8C%87%E9%92%88/"/>
    
  </entry>
  
  <entry>
    <title>leetcode-977 有序数组的平方</title>
    <link href="http://yoursite.com/2019/07/29/leetcode-977/"/>
    <id>http://yoursite.com/2019/07/29/leetcode-977/</id>
    <published>2019-07-29T14:06:32.000Z</published>
    <updated>2019-07-29T14:09:26.726Z</updated>
    
    <content type="html"><![CDATA[<h1 id="有序数组的平方"><a href="#有序数组的平方" class="headerlink" title="有序数组的平方"></a>有序数组的平方</h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>给定一个按非递减顺序排序的整数数组 A，返回每个数字的平方组成的新数组，要求也按非递减顺序排序。</p><p>示例 1：</p><blockquote><p>输入：[-4,-1,0,3,10]<br>输出：[0,1,9,16,100]</p></blockquote><p>示例 2：</p><blockquote><p>输入：[-7,-3,2,3,11]<br>输出：[4,9,9,49,121]</p></blockquote><p>提示：</p><ol><li>1&lt;= A.length &lt;= 10000</li><li>-10000 &lt;= A[i] &lt;= 10000</li><li>A 已按非递减顺序排序。<a id="more"></a>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/squares-of-a-sorted-array" target="_blank" rel="noopener">https://leetcode-cn.com/problems/squares-of-a-sorted-array</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</li></ol><h2 id="核心思路"><a href="#核心思路" class="headerlink" title="核心思路"></a>核心思路</h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>将该数组的每一个元素平方后在将该数组排序并返回</p><h3 id="解题步骤"><a href="#解题步骤" class="headerlink" title="解题步骤"></a>解题步骤</h3><ol><li>将该数组的每一个元素平方</li><li>排序该数组并返回</li></ol><h2 id="Coding实现"><a href="#Coding实现" class="headerlink" title="Coding实现"></a>Coding实现</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @param &#123;number[]&#125; A</span></span><br><span class="line"><span class="comment"> * @return &#123;number[]&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> sortedSquares = <span class="function"><span class="keyword">function</span>(<span class="params">A</span>) </span>&#123;</span><br><span class="line">   <span class="keyword">return</span> A.map(<span class="function"><span class="params">value</span>=&gt;</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> value*value;</span><br><span class="line">    &#125;).sort(<span class="function">(<span class="params">a,b</span>)=&gt;</span>&#123;<span class="keyword">return</span> a-b;&#125;)</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;有序数组的平方&quot;&gt;&lt;a href=&quot;#有序数组的平方&quot; class=&quot;headerlink&quot; title=&quot;有序数组的平方&quot;&gt;&lt;/a&gt;有序数组的平方&lt;/h1&gt;&lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h2&gt;&lt;p&gt;给定一个按非递减顺序排序的整数数组 A，返回每个数字的平方组成的新数组，要求也按非递减顺序排序。&lt;/p&gt;
&lt;p&gt;示例 1：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;输入：[-4,-1,0,3,10]&lt;br&gt;输出：[0,1,9,16,100]&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;示例 2：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;输入：[-7,-3,2,3,11]&lt;br&gt;输出：[4,9,9,49,121]&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;提示：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;1&amp;lt;= A.length &amp;lt;= 10000&lt;/li&gt;
&lt;li&gt;-10000 &amp;lt;= A[i] &amp;lt;= 10000&lt;/li&gt;
&lt;li&gt;A 已按非递减顺序排序。
    
    </summary>
    
      <category term="leetcode题解与算法" scheme="http://yoursite.com/categories/leetcode%E9%A2%98%E8%A7%A3%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="数组" scheme="http://yoursite.com/tags/%E6%95%B0%E7%BB%84/"/>
    
  </entry>
  
  <entry>
    <title>leetcode-350 两个数组的交集 II</title>
    <link href="http://yoursite.com/2019/07/28/leetcode-350/"/>
    <id>http://yoursite.com/2019/07/28/leetcode-350/</id>
    <published>2019-07-28T09:11:39.000Z</published>
    <updated>2019-07-29T14:11:48.595Z</updated>
    
    <content type="html"><![CDATA[<h1 id="两个数组的交集-II"><a href="#两个数组的交集-II" class="headerlink" title="两个数组的交集 II"></a>两个数组的交集 II</h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>给定两个数组，编写一个函数来计算它们的交集。</p><p>示例 1:</p><blockquote><p>输入: nums1 = [1,2,2,1], nums2 = [2,2]<br>输出: [2,2]</p></blockquote><p>示例 2:</p><blockquote><p>输入: nums1 = [4,9,5], nums2 = [9,4,9,8,4]<br>输出: [4,9]</p></blockquote><p>说明：</p><p>输出结果中每个元素出现的次数，应与元素在两个数组中出现的次数一致。<br>我们可以不考虑输出结果的顺序。</p><p>进阶:</p><ol><li>如果给定的数组已经排好序呢？你将如何优化你的算法？</li><li>如果 nums1 的大小比 nums2 小很多，哪种方法更优？</li><li>如果 nums2 的元素存储在磁盘上，磁盘内存是有限的，并且你不能一次加载所有的元素到内存中，你该怎么办？<a id="more"></a>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/intersection-of-two-arrays-ii" target="_blank" rel="noopener">https://leetcode-cn.com/problems/intersection-of-two-arrays-ii</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</li></ol><h2 id="核心思路"><a href="#核心思路" class="headerlink" title="核心思路"></a>核心思路</h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>该题可以考虑用双指针方法和哈希表去解决。双指针主要循环比较两个数是否相等；哈希表主要是记录每个数组中每个元素出现的次数</p><h3 id="解题步骤"><a href="#解题步骤" class="headerlink" title="解题步骤"></a>解题步骤</h3><h4 id="双指针"><a href="#双指针" class="headerlink" title="双指针"></a>双指针</h4><ol><li>将两个数组进行排序</li><li>设定两个指针，分别指向两个数组的第一个元素</li><li>如果两个指针指向的元素相等，那么就把该元素push入ans数组；并且两个指针向后移动</li><li>如果不等，那么指向较小元素的那个指针向后移动 </li></ol><h4 id="哈希表"><a href="#哈希表" class="headerlink" title="哈希表"></a>哈希表</h4><ol><li>建立两个哈希表，分别存储每个数组中的每个元素存储的个数</li><li>遍历其中一个哈希表，如果另一个哈希表中也存在该键，比较两个键值大小，按照小的那个键值循环则将该键push入ans数组；</li></ol><h2 id="Coding实现"><a href="#Coding实现" class="headerlink" title="Coding实现"></a>Coding实现</h2><h3 id="双指针解法代码"><a href="#双指针解法代码" class="headerlink" title="双指针解法代码"></a>双指针解法代码</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @param &#123;number[]&#125; nums1</span></span><br><span class="line"><span class="comment"> * @param &#123;number[]&#125; nums2</span></span><br><span class="line"><span class="comment"> * @return &#123;number[]&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> intersect = <span class="function"><span class="keyword">function</span>(<span class="params">nums1, nums2</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> nums1Index=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">let</span> nums2Index=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">let</span> ans=[];</span><br><span class="line">    nums1.sort(<span class="function">(<span class="params">a,b</span>)=&gt;</span>&#123;<span class="keyword">return</span> a-b;&#125;);</span><br><span class="line">    nums2.sort(<span class="function">(<span class="params">a,b</span>)=&gt;</span>&#123;<span class="keyword">return</span> a-b;&#125;);</span><br><span class="line">    <span class="keyword">while</span>(nums1Index&lt;nums1.length&amp;&amp;nums2Index&lt;nums2.length)&#123;</span><br><span class="line">        <span class="keyword">let</span> num1=nums1[nums1Index];</span><br><span class="line">        <span class="keyword">let</span> num2=nums2[nums2Index];</span><br><span class="line">        <span class="keyword">if</span>(num1===num2)&#123;</span><br><span class="line">            ans.push(num1);</span><br><span class="line">            nums1Index++;</span><br><span class="line">            nums2Index++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(num1&lt;num2)&#123;</span><br><span class="line">            nums1Index++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            nums2Index++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="哈希表解法代码"><a href="#哈希表解法代码" class="headerlink" title="哈希表解法代码"></a>哈希表解法代码</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @param &#123;number[]&#125; nums1</span></span><br><span class="line"><span class="comment"> * @param &#123;number[]&#125; nums2</span></span><br><span class="line"><span class="comment"> * @return &#123;number[]&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> intersect = <span class="function"><span class="keyword">function</span>(<span class="params">nums1, nums2</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> map1=<span class="keyword">new</span> <span class="built_in">Map</span>();</span><br><span class="line">  <span class="keyword">let</span> map2=<span class="keyword">new</span> <span class="built_in">Map</span>();</span><br><span class="line">  <span class="keyword">let</span> ans=[];</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">count</span>(<span class="params">nums,map</span>)</span>&#123;</span><br><span class="line">      nums.forEach(<span class="function"><span class="params">value</span>=&gt;</span>&#123;</span><br><span class="line">          <span class="keyword">if</span>(!map.has(value))&#123;</span><br><span class="line">              map.set(value,<span class="number">1</span>);</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">else</span> &#123;</span><br><span class="line">              map.set(value,map.get(value)+<span class="number">1</span>);</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">  count(nums1,map1);</span><br><span class="line">  count(nums2,map2);</span><br><span class="line">  map1.forEach(<span class="function">(<span class="params">value,key</span>)=&gt;</span>&#123;</span><br><span class="line">      <span class="keyword">if</span>(map2.has(key))&#123;</span><br><span class="line">          <span class="keyword">let</span> num=value&gt;map2.get(key)?map2.get(key):value;</span><br><span class="line">          <span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">0</span>;i&lt;num;i++)&#123;</span><br><span class="line">              ans.push(key);</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="keyword">return</span> ans;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;两个数组的交集-II&quot;&gt;&lt;a href=&quot;#两个数组的交集-II&quot; class=&quot;headerlink&quot; title=&quot;两个数组的交集 II&quot;&gt;&lt;/a&gt;两个数组的交集 II&lt;/h1&gt;&lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h2&gt;&lt;p&gt;给定两个数组，编写一个函数来计算它们的交集。&lt;/p&gt;
&lt;p&gt;示例 1:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;输入: nums1 = [1,2,2,1], nums2 = [2,2]&lt;br&gt;输出: [2,2]&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;示例 2:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;输入: nums1 = [4,9,5], nums2 = [9,4,9,8,4]&lt;br&gt;输出: [4,9]&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;说明：&lt;/p&gt;
&lt;p&gt;输出结果中每个元素出现的次数，应与元素在两个数组中出现的次数一致。&lt;br&gt;我们可以不考虑输出结果的顺序。&lt;/p&gt;
&lt;p&gt;进阶:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;如果给定的数组已经排好序呢？你将如何优化你的算法？&lt;/li&gt;
&lt;li&gt;如果 nums1 的大小比 nums2 小很多，哪种方法更优？&lt;/li&gt;
&lt;li&gt;如果 nums2 的元素存储在磁盘上，磁盘内存是有限的，并且你不能一次加载所有的元素到内存中，你该怎么办？
    
    </summary>
    
      <category term="leetcode题解与算法" scheme="http://yoursite.com/categories/leetcode%E9%A2%98%E8%A7%A3%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="哈希表" scheme="http://yoursite.com/tags/%E5%93%88%E5%B8%8C%E8%A1%A8/"/>
    
      <category term="双指针" scheme="http://yoursite.com/tags/%E5%8F%8C%E6%8C%87%E9%92%88/"/>
    
  </entry>
  
  <entry>
    <title>二分查找</title>
    <link href="http://yoursite.com/2019/07/27/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/"/>
    <id>http://yoursite.com/2019/07/27/二分查找/</id>
    <published>2019-07-27T09:49:17.000Z</published>
    <updated>2019-07-28T02:49:38.604Z</updated>
    
    <content type="html"><![CDATA[<h2 id="二分查找概述"><a href="#二分查找概述" class="headerlink" title="二分查找概述"></a>二分查找概述</h2><blockquote><p>二分查找的高效之处在于，每一步都可以去除当前区间中的一半元素，因此时间复杂度为O(logn)</p></blockquote><h2 id="严格递增序列的二分查找"><a href="#严格递增序列的二分查找" class="headerlink" title="严格递增序列的二分查找"></a>严格递增序列的二分查找</h2><blockquote><p>输入：[1,2,3,7,9,11] , 3<br>返回: 2</p></blockquote><blockquote><p>输入：[1,2,3,7,9,11] , 8<br>返回：false</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">F</span>(<span class="params">n,m</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">let</span> left=<span class="number">0</span>;</span><br><span class="line">  <span class="keyword">let</span> right=n.length<span class="number">-1</span>;</span><br><span class="line">  <span class="keyword">while</span>(left&lt;=right)&#123;</span><br><span class="line">    <span class="keyword">let</span> mid=<span class="built_in">Math</span>.floor((left+right)/<span class="number">2</span>);</span><br><span class="line">    <span class="keyword">if</span>(m===n[mid])&#123;</span><br><span class="line">      <span class="keyword">return</span> mid;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(m&lt;n[mid])&#123;</span><br><span class="line">      right=mid<span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">      left=mid+<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="在整体递增，局部重复的序列中二分查找第一个符合要求的元素位置"><a href="#在整体递增，局部重复的序列中二分查找第一个符合要求的元素位置" class="headerlink" title="在整体递增，局部重复的序列中二分查找第一个符合要求的元素位置"></a>在整体递增，局部重复的序列中二分查找第一个符合要求的元素位置</h2><blockquote><p>输入：[1,2,3,3,3,7,9,11],3<br>返回: 2</p></blockquote><blockquote><p>输入：[1,2,3,3,3,7,9,11],8<br>返回：false</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">F</span>(<span class="params">n,m</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">let</span> left=<span class="number">0</span>;</span><br><span class="line">  <span class="keyword">let</span> right=n.length;</span><br><span class="line">  <span class="keyword">while</span>(left&lt;right)&#123;</span><br><span class="line">    <span class="keyword">let</span> mid=<span class="built_in">Math</span>.floor((left+right)/<span class="number">2</span>);  <span class="comment">//floor()函数，不大于当前数的最大数</span></span><br><span class="line">    <span class="keyword">if</span>(m&lt;=n[mid])&#123;</span><br><span class="line">      right=mid;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">      left=mid+<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span>(n[left]===m) <span class="keyword">return</span> left;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="在整体递增，局部重复的序列中二分查找第一个大于给定元素的元素位置"><a href="#在整体递增，局部重复的序列中二分查找第一个大于给定元素的元素位置" class="headerlink" title="在整体递增，局部重复的序列中二分查找第一个大于给定元素的元素位置"></a>在整体递增，局部重复的序列中二分查找第一个大于给定元素的元素位置</h2><blockquote><p>输入：[1,2,3,3,3,7,9,11],3<br>返回：5</p></blockquote><blockquote><p>输入：[1,2,3,3,3,7,9,11],4<br>返回: ‘给定元素不存在’</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">F</span>(<span class="params">n,m</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">let</span> left=<span class="number">0</span>;</span><br><span class="line">  <span class="keyword">let</span> right=n.length<span class="number">-1</span>;</span><br><span class="line">  <span class="keyword">while</span>(left&lt;right)&#123;</span><br><span class="line">    <span class="keyword">let</span> mid=<span class="built_in">Math</span>.ceil((left+right)/<span class="number">2</span>);  <span class="comment">//ceil()函数，不小于当前数的最小整数</span></span><br><span class="line">    <span class="keyword">if</span>(m&gt;=n[mid])&#123;</span><br><span class="line">      left=mid;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">      right=mid<span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span>(n[right]===m) <span class="keyword">return</span> right+<span class="number">1</span>;</span><br><span class="line">  <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> (<span class="string">'给定元素不存在'</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="求根号2的近似值"><a href="#求根号2的近似值" class="headerlink" title="求根号2的近似值"></a>求根号2的近似值</h2><blockquote><p>输入：0.00001  //精确度<br>返回：(1.4142074584960938,1.414215087890625)</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">F</span>(<span class="params">x</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">let</span> left=<span class="number">1</span>;</span><br><span class="line">  <span class="keyword">let</span> right=<span class="number">2</span>;</span><br><span class="line">  <span class="keyword">let</span> num=<span class="built_in">Math</span>.sqrt(<span class="number">2</span>);</span><br><span class="line">  <span class="keyword">while</span>(right-left&gt;x)&#123;</span><br><span class="line">    <span class="keyword">let</span> mid=(left+right)/<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span>(num&lt;mid)&#123;</span><br><span class="line">      right=mid;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(num&gt;mid)&#123;</span><br><span class="line">      left=mid;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">`(<span class="subst">$&#123;left&#125;</span>,<span class="subst">$&#123;right&#125;</span>)`</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="快速幂"><a href="#快速幂" class="headerlink" title="快速幂"></a>快速幂</h2><p>用于求解高次幂的快速求法<br>比如2^10</p><blockquote><p>基于二分的思想，又被称之为二分幂</p></blockquote><p>快速幂基于以下原理：</p><ol><li>如果b是奇数，那么有a^b=a*a^(b-1)</li><li>如果b是偶数，那么有a^b=(a^(b/2))*(a^(b/2))</li></ol><p>因此可以利用递归来求解快速幂</p><blockquote><p>输入 2,10<br>返回: 1024</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">F</span>(<span class="params">a,n</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(n===<span class="number">0</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">if</span>(n%<span class="number">2</span>===<span class="number">1</span>)&#123;</span><br><span class="line">    <span class="keyword">return</span> F(a,n<span class="number">-1</span>)*a;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> F(a,n/<span class="number">2</span>)*F(a,n/<span class="number">2</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;二分查找概述&quot;&gt;&lt;a href=&quot;#二分查找概述&quot; class=&quot;headerlink&quot; title=&quot;二分查找概述&quot;&gt;&lt;/a&gt;二分查找概述&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;二分查找的高效之处在于，每一步都可以去除当前区间中的一半元素，因此时间复杂度为O(
      
    
    </summary>
    
      <category term="算法笔记" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/"/>
    
    
  </entry>
  
  <entry>
    <title>leetcode-852 山脉数组的峰顶索引</title>
    <link href="http://yoursite.com/2019/07/27/leetcode-852/"/>
    <id>http://yoursite.com/2019/07/27/leetcode-852/</id>
    <published>2019-07-27T07:42:56.000Z</published>
    <updated>2019-07-27T09:45:44.292Z</updated>
    
    <content type="html"><![CDATA[<h1 id="山脉数组的峰顶索引"><a href="#山脉数组的峰顶索引" class="headerlink" title="山脉数组的峰顶索引"></a>山脉数组的峰顶索引</h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>我们把符合下列属性的数组 A 称作山脉：</p><ol><li>A.length &gt;= 3</li><li>存在 0 &lt; i &lt; A.length - 1 使得A[0] &lt; A[1] &lt; … A[i-1] &lt; A[i] &gt; A[i+1] &gt; … &gt; A[A.length - 1]</li></ol><p>给定一个确定为山脉的数组，返回任何满足 A[0] &lt; A[1] &lt; … A[i-1] &lt; A[i] &gt; A[i+1] &gt; … &gt; A[A.length - 1] 的 i 的值。</p><p>示例 1：</p><blockquote><p>输入：[0,1,0]<br>输出：1</p></blockquote><p>示例 2：</p><blockquote><p>输入：[0,2,1,0]<br>输出：1</p></blockquote><p>提示：</p><ol><li>3&lt;= A.length &lt;= 10000</li><li>0&lt;= A[i] &lt;= 10^6</li><li>A是如上定义的山脉<a id="more"></a>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/peak-index-in-a-mountain-array" target="_blank" rel="noopener">https://leetcode-cn.com/problems/peak-index-in-a-mountain-array</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</li></ol><h2 id="核心思路"><a href="#核心思路" class="headerlink" title="核心思路"></a>核心思路</h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>要找某个特定的值，都可以使用二分查找来提高效率</p><h3 id="解题步骤"><a href="#解题步骤" class="headerlink" title="解题步骤"></a>解题步骤</h3><ol><li>二分法查找山脉的下标</li><li>一开始设定left为0，right为A.length-1,mid为Math.floor((left+right)/2)</li><li>如果A[mid]&gt;A[mid+1]&amp;&amp;A[mid]&gt;A[mid-1],那么此时mid就是山脉的下标</li><li>如果A[mid]&lt;A[mid+1]，那么就说明山脉应该在mid的右边区间，故left=mid+1</li><li>如果A[mid]&gt;A[mid+1]，那么就说明山脉应该在mid的右边区间，故right=mid-1</li></ol><h2 id="Coding实现"><a href="#Coding实现" class="headerlink" title="Coding实现"></a>Coding实现</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @param &#123;number[]&#125; A</span></span><br><span class="line"><span class="comment"> * @return &#123;number&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> peakIndexInMountainArray = <span class="function"><span class="keyword">function</span>(<span class="params">A</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> left=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">let</span> right=A.length<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">while</span>(left&lt;=right)&#123;</span><br><span class="line">        <span class="keyword">let</span> mid=<span class="built_in">Math</span>.floor((left+right)/<span class="number">2</span>);</span><br><span class="line">        <span class="keyword">if</span>(A[mid]&gt;A[mid+<span class="number">1</span>]&amp;&amp;A[mid]&gt;A[mid<span class="number">-1</span>])&#123;</span><br><span class="line">            <span class="keyword">return</span> mid;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(A[mid]&lt;A[mid+<span class="number">1</span>])&#123;</span><br><span class="line">            left=mid+<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            right=mid<span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h3><p>时间复杂度为O(log2N);</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;山脉数组的峰顶索引&quot;&gt;&lt;a href=&quot;#山脉数组的峰顶索引&quot; class=&quot;headerlink&quot; title=&quot;山脉数组的峰顶索引&quot;&gt;&lt;/a&gt;山脉数组的峰顶索引&lt;/h1&gt;&lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h2&gt;&lt;p&gt;我们把符合下列属性的数组 A 称作山脉：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;A.length &amp;gt;= 3&lt;/li&gt;
&lt;li&gt;存在 0 &amp;lt; i &amp;lt; A.length - 1 使得A[0] &amp;lt; A[1] &amp;lt; … A[i-1] &amp;lt; A[i] &amp;gt; A[i+1] &amp;gt; … &amp;gt; A[A.length - 1]&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;给定一个确定为山脉的数组，返回任何满足 A[0] &amp;lt; A[1] &amp;lt; … A[i-1] &amp;lt; A[i] &amp;gt; A[i+1] &amp;gt; … &amp;gt; A[A.length - 1] 的 i 的值。&lt;/p&gt;
&lt;p&gt;示例 1：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;输入：[0,1,0]&lt;br&gt;输出：1&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;示例 2：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;输入：[0,2,1,0]&lt;br&gt;输出：1&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;提示：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;3&amp;lt;= A.length &amp;lt;= 10000&lt;/li&gt;
&lt;li&gt;0&amp;lt;= A[i] &amp;lt;= 10^6&lt;/li&gt;
&lt;li&gt;A是如上定义的山脉
    
    </summary>
    
      <category term="leetcode题解与算法" scheme="http://yoursite.com/categories/leetcode%E9%A2%98%E8%A7%A3%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="二分查找" scheme="http://yoursite.com/tags/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/"/>
    
  </entry>
  
  <entry>
    <title>leetcode-944 删列造序</title>
    <link href="http://yoursite.com/2019/07/26/leetcode-944/"/>
    <id>http://yoursite.com/2019/07/26/leetcode-944/</id>
    <published>2019-07-26T02:55:29.000Z</published>
    <updated>2019-07-26T03:05:06.927Z</updated>
    
    <content type="html"><![CDATA[<h1 id="删列造序"><a href="#删列造序" class="headerlink" title="删列造序"></a>删列造序</h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>给定由 N 个小写字母字符串组成的数组 A，其中每个字符串长度相等。</p><p>删除 操作的定义是：选出一组要删掉的列，删去 A 中对应列中的所有字符，形式上，第 n 列为 [A[0][n], A[1][n], …, A[A.length-1][n]]）。</p><p>比如，有 A = [“abcdef”, “uvwxyz”]，</p><p><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2019/07/06/944_1.png" alt></p><p>要删掉的列为 {0, 2, 3}，删除后 A 为[“bef”, “vyz”]， A 的列分别为[“b”,”v”], [“e”,”y”], [“f”,”z”]。</p><p><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2019/07/06/944_2.png" alt></p><p>你需要选出一组要删掉的列 D，对 A 执行删除操作，使 A 中剩余的每一列都是 非降序 排列的，然后请你返回 D.length 的最小可能值。</p><p>示例 1：</p><blockquote><p>输入：[“cba”, “daf”, “ghi”]<br>输出：1<br>解释：<br>当选择 D = {1}，删除后 A 的列为：[“c”,”d”,”g”] 和 [“a”,”f”,”i”]，均为非降序排列。<br>若选择 D = {}，那么 A 的列 [“b”,”a”,”h”] 就不是非降序排列了。</p></blockquote><p>示例 2：</p><blockquote><p>输入：[“a”, “b”]<br>输出：0<br>解释：D = {}</p></blockquote><p>示例 3：</p><blockquote><p>输入：[“zyx”, “wvu”, “tsr”]<br>输出：3<br>解释：D = {0, 1, 2}</p></blockquote><p>提示：</p><ol><li>1&lt;= A.length &lt;= 100</li><li>1&lt;= A[i].length &lt;= 1000<a id="more"></a>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/delete-columns-to-make-sorted" target="_blank" rel="noopener">https://leetcode-cn.com/problems/delete-columns-to-make-sorted</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</li></ol><h2 id="核心思路"><a href="#核心思路" class="headerlink" title="核心思路"></a>核心思路</h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>题目要求得到删去列数的最小值来使剩余的每一列都是非降序的，那么对于贪心思想，只要找到某些列存在降序的删除即可，而无需删除那些已经是非降序的列</p><h3 id="解题步骤"><a href="#解题步骤" class="headerlink" title="解题步骤"></a>解题步骤</h3><ol><li>根据数组第一个字符串元素长度来确认列数</li><li>根据列数，遍历每一个字符串中的那一列</li><li>如果某一列存在降序则将ans加1</li><li>返回ans</li></ol><h2 id="Coding实现"><a href="#Coding实现" class="headerlink" title="Coding实现"></a>Coding实现</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @param &#123;string[]&#125; A</span></span><br><span class="line"><span class="comment"> * @return &#123;number&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> minDeletionSize = <span class="function"><span class="keyword">function</span>(<span class="params">A</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> ans=<span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">0</span>;i&lt;A[<span class="number">0</span>].length;i++)&#123;</span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">let</span> k=<span class="number">0</span>;k&lt;A.length<span class="number">-1</span>;k++)&#123;</span><br><span class="line">          <span class="keyword">if</span>(A[k+<span class="number">1</span>][i].charCodeAt()-A[k][i].charCodeAt()&lt;<span class="number">0</span>)&#123;</span><br><span class="line">              ans++;</span><br><span class="line">              <span class="keyword">break</span>;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;  </span><br><span class="line">    <span class="keyword">return</span> ans; </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;删列造序&quot;&gt;&lt;a href=&quot;#删列造序&quot; class=&quot;headerlink&quot; title=&quot;删列造序&quot;&gt;&lt;/a&gt;删列造序&lt;/h1&gt;&lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h2&gt;&lt;p&gt;给定由 N 个小写字母字符串组成的数组 A，其中每个字符串长度相等。&lt;/p&gt;
&lt;p&gt;删除 操作的定义是：选出一组要删掉的列，删去 A 中对应列中的所有字符，形式上，第 n 列为 [A[0][n], A[1][n], …, A[A.length-1][n]]）。&lt;/p&gt;
&lt;p&gt;比如，有 A = [“abcdef”, “uvwxyz”]，&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2019/07/06/944_1.png&quot; alt&gt;&lt;/p&gt;
&lt;p&gt;要删掉的列为 {0, 2, 3}，删除后 A 为[“bef”, “vyz”]， A 的列分别为[“b”,”v”], [“e”,”y”], [“f”,”z”]。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2019/07/06/944_2.png&quot; alt&gt;&lt;/p&gt;
&lt;p&gt;你需要选出一组要删掉的列 D，对 A 执行删除操作，使 A 中剩余的每一列都是 非降序 排列的，然后请你返回 D.length 的最小可能值。&lt;/p&gt;
&lt;p&gt;示例 1：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;输入：[“cba”, “daf”, “ghi”]&lt;br&gt;输出：1&lt;br&gt;解释：&lt;br&gt;当选择 D = {1}，删除后 A 的列为：[“c”,”d”,”g”] 和 [“a”,”f”,”i”]，均为非降序排列。&lt;br&gt;若选择 D = {}，那么 A 的列 [“b”,”a”,”h”] 就不是非降序排列了。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;示例 2：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;输入：[“a”, “b”]&lt;br&gt;输出：0&lt;br&gt;解释：D = {}&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;示例 3：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;输入：[“zyx”, “wvu”, “tsr”]&lt;br&gt;输出：3&lt;br&gt;解释：D = {0, 1, 2}&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;提示：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;1&amp;lt;= A.length &amp;lt;= 100&lt;/li&gt;
&lt;li&gt;1&amp;lt;= A[i].length &amp;lt;= 1000
    
    </summary>
    
      <category term="leetcode题解与算法" scheme="http://yoursite.com/categories/leetcode%E9%A2%98%E8%A7%A3%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="贪心" scheme="http://yoursite.com/tags/%E8%B4%AA%E5%BF%83/"/>
    
  </entry>
  
  <entry>
    <title>贪心</title>
    <link href="http://yoursite.com/2019/07/26/%E8%B4%AA%E5%BF%83/"/>
    <id>http://yoursite.com/2019/07/26/贪心/</id>
    <published>2019-07-26T01:34:08.000Z</published>
    <updated>2019-07-26T02:54:43.732Z</updated>
    
    <content type="html"><![CDATA[<p>##简单贪心</p><blockquote><p>贪心法是求解一类最优化问题的方法，它总是考虑在当前状态下局部最优（或较优）的策略，来使全局的结果达到最优（或较优）</p></blockquote><p>简单来说，也就是，在对问题求解时，总是做出在当前看来是最好的选择。</p><h3 id="贪心算法的基本思路"><a href="#贪心算法的基本思路" class="headerlink" title="贪心算法的基本思路"></a>贪心算法的基本思路</h3><ol><li>将求解的问题分成若干子问题</li><li>对于每一个子问题，考虑得到该子问题的局部最优解</li><li>把所有子问题的局部最优解合成一个原问题的解</li></ol><h3 id="贪心算法的适用前提和问题"><a href="#贪心算法的适用前提和问题" class="headerlink" title="贪心算法的适用前提和问题"></a>贪心算法的适用前提和问题</h3><ol><li>局部最优解能够影响全局最优解</li><li>贪心算法得到的不一定就是问题的最优解</li></ol><h3 id="贪心算法题目"><a href="#贪心算法题目" class="headerlink" title="贪心算法题目"></a>贪心算法题目</h3><p>设有n个正整数，将它们连接成一排，组成一个最大的多位整数。</p><p>例如：n=3时，3个整数13，312，343，连成的最大整数为34331213。<br><br>又如：n=4时，4个整数7，13，4，246，连成的最大整数为7424613。</p><blockquote><p>输入：n<br><br>N个数<br><br>输出：连成的多位数</p></blockquote><h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><p>因为要得到最大的正整数，那么高位数据越大则值越大。因此，使用贪心算法，每次选值的时候优先选择最高位最大的，如若相同，则比较次高位，直到选出较优值</p><p>因此，通过这个思路，比较高位可以利用字符串UniCode码来比较，比如’7’&gt;’432’</p><p>js的sort()函数可以完美解决，利用sort函数对输入值由高到低进行排序，最后转化为数值进行返回</p><h4 id="Coding实现"><a href="#Coding实现" class="headerlink" title="Coding实现"></a>Coding实现</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">F</span>(<span class="params">n</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">parseInt</span>(n.sort().reverse().join(<span class="string">''</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="区间贪心"><a href="#区间贪心" class="headerlink" title="区间贪心"></a>区间贪心</h2>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;##简单贪心&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;贪心法是求解一类最优化问题的方法，它总是考虑在当前状态下局部最优（或较优）的策略，来使全局的结果达到最优（或较优）&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;简单来说，也就是，在对问题求解时，总是做出在当前看来是最好的选
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>排序</title>
    <link href="http://yoursite.com/2019/07/25/%E6%8E%92%E5%BA%8F/"/>
    <id>http://yoursite.com/2019/07/25/排序/</id>
    <published>2019-07-25T01:27:08.000Z</published>
    <updated>2019-07-30T03:01:20.224Z</updated>
    
    <content type="html"><![CDATA[<h2 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>选择排列是指，对一个序列A中的元素，令i从0到n-1枚举，进行n趟操作，每趟从待排序部分（i+1,n）中选择最小的元素，令其与待排序部分的第一个元素A[i]进行交换，这样在n趟操作后，所有元素都会是有序的</p><h3 id="动图演示"><a href="#动图演示" class="headerlink" title="动图演示"></a>动图演示</h3><p><img src="https://lc-api-gold-cdn.xitu.io/9c3e16e6e5d0a5ac7721?imageView2/0/w/1280/h/960/ignore-error/1" alt></p><h3 id="Coding实现"><a href="#Coding实现" class="headerlink" title="Coding实现"></a>Coding实现</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">selectSort</span>(<span class="params">n</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">0</span>;i&lt;n.length<span class="number">-1</span>;i++)&#123;</span><br><span class="line">    <span class="keyword">let</span> min=i;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> k=i;k&lt;n.length;k++)&#123;</span><br><span class="line">      <span class="keyword">if</span>(n[k]&lt;n[min])&#123;</span><br><span class="line">       min=k;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">let</span> temp=n[min];</span><br><span class="line">    n[min]=n[i];</span><br><span class="line">    n[i]=temp;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> n;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h2><h3 id="直接插入排序"><a href="#直接插入排序" class="headerlink" title="直接插入排序"></a>直接插入排序</h3><h4 id="定义-1"><a href="#定义-1" class="headerlink" title="定义"></a>定义</h4><p>直接插入排序是指，对序列A的n个元素A[0]到A[n-1],令n从1到n-1枚举，进行n-1趟操作。每一趟排序时，该待排列元素之前的所有元素已经是有序的，则在该有序队列中寻找一个位置进行插入，使得该序列依旧有序</p><h4 id="动图演示-1"><a href="#动图演示-1" class="headerlink" title="动图演示"></a>动图演示</h4><p><img src="https://lc-api-gold-cdn.xitu.io/9a1264832cad9bfd4100?imageView2/0/w/1280/h/960/ignore-error/1" alt></p><h4 id="Coding实现-1"><a href="#Coding实现-1" class="headerlink" title="Coding实现"></a>Coding实现</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">insertionSort</span>(<span class="params">n</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">1</span>;i&lt;n.length;i++)&#123;</span><br><span class="line">    <span class="keyword">let</span> num=n[i];</span><br><span class="line">    <span class="keyword">while</span>(num&lt;n[i<span class="number">-1</span>])&#123;</span><br><span class="line">      n[i]=n[i<span class="number">-1</span>];</span><br><span class="line">      i--;</span><br><span class="line">    &#125;</span><br><span class="line">    n[i]=num;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> n;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="折半插入排序"><a href="#折半插入排序" class="headerlink" title="折半插入排序"></a>折半插入排序</h3><h4 id="定义-2"><a href="#定义-2" class="headerlink" title="定义"></a>定义</h4><blockquote><p>有一组数据待排序，排序区间为Array[0] ~ Array[n-1]。将数据分为有序数据和无序数据，第一次排序时默认Array[0]为有序数据，Array[1]~Array[n-1]为无序数据。有序数据分区的第一个元素位置为low，最后一个元素的位置为high。</p></blockquote><blockquote><p>遍历无序区间的所有元素，每次取无序区间的第一个元素Array[i]，因为0 ~ i-1是有序排列的，所以用中点m将其平分为两部分，然后将待排序数据同中间位置为m的数据进行比较，若待排序数据较大，则low ~ m-1分区的数据都比待排序数据小，反之，若待排序数据较小，则m+1 ~ high分区的数据都比 待排序数据大，此时将low或high重新定义为新的合适分区的边界，对新的小分区重复上面操作。直到low和high 的前后顺序改变，此时high+1所处位置为待排序数据的合适位置。</p></blockquote><hr><p>作者：weixin_42245157<br>来源：CSDN<br>原文：<a href="https://blog.csdn.net/weixin_42245157/article/details/80458542" target="_blank" rel="noopener">https://blog.csdn.net/weixin_42245157/article/details/80458542</a><br>版权声明：本文为博主原创文章，转载请附上博文链接！</p><h3 id="Coding实现-2"><a href="#Coding实现-2" class="headerlink" title="Coding实现"></a>Coding实现</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">BinaryInsertSortup</span>(<span class="params">n</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">1</span>;i&lt;n.length;i++)&#123;</span><br><span class="line">    <span class="keyword">let</span> low=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">let</span> high=i<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">let</span> num=n[i];</span><br><span class="line">    <span class="keyword">while</span>(low&lt;=high)&#123;</span><br><span class="line">      <span class="keyword">let</span> mid=<span class="built_in">Math</span>.floor((low+high)/<span class="number">2</span>);</span><br><span class="line">      <span class="keyword">if</span>(num&lt;n[mid])&#123;</span><br><span class="line">        high=mid<span class="number">-1</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span>&#123;</span><br><span class="line">        low=mid+<span class="number">1</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(k=i;k&gt;low;k--)&#123;</span><br><span class="line">        n[k]=n[k<span class="number">-1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    n[k]=num;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> n;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h2><h3 id="定义-3"><a href="#定义-3" class="headerlink" title="定义"></a>定义</h3><p>冒泡排序旨在每次冒泡一个最大或最小的元素到顶端，因此需遍历n次。（若冒泡较大元素）则每次遍历，比较相邻两个元素大小，若底部元素（数组下标较小）大于其相邻顶部元素，则两元素交换位置，直至最大的元素冒泡到最顶端</p><h3 id="动图演示-2"><a href="#动图演示-2" class="headerlink" title="动图演示"></a>动图演示</h3><p><img src="https://lc-api-gold-cdn.xitu.io/ffef8bdf5a3b0dd54859?imageView2/0/w/1280/h/960/ignore-error/1" alt></p><h3 id="Coding实现-3"><a href="#Coding实现-3" class="headerlink" title="Coding实现"></a>Coding实现</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bubbleSort</span>(<span class="params">n</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">let</span> flag;</span><br><span class="line">  <span class="keyword">do</span>&#123;</span><br><span class="line">    flag=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">0</span>;i&lt;n.length;i++)&#123;</span><br><span class="line">      <span class="keyword">let</span> temp;</span><br><span class="line">      <span class="keyword">if</span>(n[i]&gt;n[i+<span class="number">1</span>])&#123;</span><br><span class="line">        temp=n[i];</span><br><span class="line">        n[i]=n[i+<span class="number">1</span>];</span><br><span class="line">        n[i+<span class="number">1</span>]=temp;</span><br><span class="line">        flag=<span class="number">1</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;<span class="keyword">while</span>(flag===<span class="number">1</span>)</span><br><span class="line">  <span class="keyword">return</span> n;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h2><h3 id="定义-4"><a href="#定义-4" class="headerlink" title="定义"></a>定义</h3><p>归并排序是一种基于归并思想的排序方法。</p><p>实现思路：</p><ol><li>将序列分成Math.ceil(n/2)个组，组内单独排序</li><li>将这些组两两归并，这样就会变成Math.ceil(n/4)个组，组内再单独排序</li><li>以此类推，直到最后只剩下一个组为止</li></ol><h3 id="Coding实现-4"><a href="#Coding实现-4" class="headerlink" title="Coding实现"></a>Coding实现</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">mergeSort</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> length = arr.length;</span><br><span class="line">  <span class="keyword">if</span> (length === <span class="number">1</span>) &#123; <span class="comment">//递归算法的停止条件，即为判断数组长度是否为1</span></span><br><span class="line">      <span class="keyword">return</span> arr;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">const</span> mid = <span class="built_in">Math</span>.floor(length / <span class="number">2</span>);</span><br><span class="line"> </span><br><span class="line">  <span class="keyword">const</span> left = arr.slice(<span class="number">0</span>,  mid);</span><br><span class="line">  <span class="keyword">const</span> right = arr.slice(mid, length);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> merge(mergeSort(left), mergeSort(right)); <span class="comment">//要将原始数组分割直至只有一个元素时，才开始归并</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">merge</span>(<span class="params">left, right</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> result = [];</span><br><span class="line">  <span class="keyword">let</span> il = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">let</span> ir = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//left, right本身肯定都是从小到大排好序的</span></span><br><span class="line">  <span class="keyword">while</span>( il &lt; left.length &amp;&amp; ir &lt; right.length) &#123;</span><br><span class="line">      <span class="keyword">if</span> (left[il] &lt; right[ir]) &#123;</span><br><span class="line">          result.push(left[il]);</span><br><span class="line">          il++;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          result.push(right[ir]);</span><br><span class="line">          ir++;</span><br><span class="line">      &#125;</span><br><span class="line">      </span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//不可能同时存在left和right都有剩余项的情况, 要么left要么right有剩余项, 把剩余项加进来即可</span></span><br><span class="line">  <span class="keyword">while</span> (il &lt; left.length) &#123; </span><br><span class="line">      result.push(left[il]);</span><br><span class="line">      il++;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">while</span>(ir &lt; right.length) &#123;</span><br><span class="line">      result.push(right[ir]);</span><br><span class="line">      ir++;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h2><h3 id="定义-5"><a href="#定义-5" class="headerlink" title="定义"></a>定义</h3><p>快速排序是排序算法中平均时间复杂度为O(logn)的一种算法。</p><p>其主要步骤为</p><ol><li>调整序列中的元素，使得当前序列的第一个元素在调整后所处的位置的左侧元素都小于它，在右侧的位置都大于它</li><li>对该元素的左侧和右侧区间分别递归进行1的调整，直到当前调整区间的长度不大于1</li></ol><h3 id="Coding实现-5"><a href="#Coding实现-5" class="headerlink" title="Coding实现"></a>Coding实现</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">F</span>(<span class="params">n</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(n.length&lt;<span class="number">2</span>) <span class="keyword">return</span> n;</span><br><span class="line">  <span class="keyword">let</span> first=n[<span class="number">0</span>];</span><br><span class="line">  <span class="keyword">let</span> small=[];</span><br><span class="line">  <span class="keyword">let</span> large=[];</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">1</span>;i&lt;n.length;i++)&#123;</span><br><span class="line">    <span class="keyword">if</span>(n[i]&lt;first)&#123;</span><br><span class="line">      small.push(n[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">      large.push(n[i]);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> F(small).concat([first],F(large));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;选择排序&quot;&gt;&lt;a href=&quot;#选择排序&quot; class=&quot;headerlink&quot; title=&quot;选择排序&quot;&gt;&lt;/a&gt;选择排序&lt;/h2&gt;&lt;h3 id=&quot;定义&quot;&gt;&lt;a href=&quot;#定义&quot; class=&quot;headerlink&quot; title=&quot;定义&quot;&gt;&lt;/a&gt;定义&lt;/h
      
    
    </summary>
    
      <category term="算法笔记" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/"/>
    
    
  </entry>
  
  <entry>
    <title>leetcode-1002 查找常用字符</title>
    <link href="http://yoursite.com/2019/07/24/leetcode-1002/"/>
    <id>http://yoursite.com/2019/07/24/leetcode-1002/</id>
    <published>2019-07-24T06:51:44.000Z</published>
    <updated>2019-07-24T07:05:22.438Z</updated>
    
    <content type="html"><![CDATA[<h1 id="查找常用字符"><a href="#查找常用字符" class="headerlink" title="查找常用字符"></a>查找常用字符</h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>给定仅有小写字母组成的字符串数组 A，返回列表中的每个字符串中都显示的全部字符（包括重复字符）组成的列表。例如，如果一个字符在每个字符串中出现 3 次，但不是 4 次，则需要在最终答案中包含该字符 3 次。</p><p>你可以按任意顺序返回答案。</p><p>示例 1：</p><blockquote><p>输入：[“bella”,”label”,”roller”]<br>输出：[“e”,”l”,”l”]</p></blockquote><p>示例 2：</p><blockquote><p>输入：[“cool”,”lock”,”cook”]<br>输出：[“c”,”o”]</p></blockquote><p>提示：</p><ol><li>1&lt;= A.length &lt;= 100</li><li>1&lt;= A[i].length &lt;= 100</li><li>A[i][j] 是小写字母<a id="more"></a>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/find-common-characters" target="_blank" rel="noopener">https://leetcode-cn.com/problems/find-common-characters</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</li></ol><h2 id="核心思路"><a href="#核心思路" class="headerlink" title="核心思路"></a>核心思路</h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>统计每个字符串中字符的出现个数，返回出现相同字符的最少个数字符</p><h3 id="解题步骤"><a href="#解题步骤" class="headerlink" title="解题步骤"></a>解题步骤</h3><ol><li>建立哈希表A，存储第一个字符串个字符的出现次数</li><li>遍历后面的字符串，在每个循环中建立新的哈希表，存储该字符串中第一个字符串所有字符的个数；比较新哈希表与步骤1建立的哈希表A，更新A哈希表中的键值为两者较小值</li><li>遍历A哈希表，存储value次key到ans数组并返回</li></ol><h2 id="Coding实现"><a href="#Coding实现" class="headerlink" title="Coding实现"></a>Coding实现</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @param &#123;string[]&#125; A</span></span><br><span class="line"><span class="comment"> * @return &#123;string[]&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> commonChars = <span class="function"><span class="keyword">function</span>(<span class="params">A</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> map=<span class="keyword">new</span> <span class="built_in">Map</span>();</span><br><span class="line">    <span class="keyword">let</span> ans=[];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">0</span>;i&lt;A[<span class="number">0</span>].length;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(!map.has(A[<span class="number">0</span>][i]))&#123;</span><br><span class="line">            map.set(A[<span class="number">0</span>][i],<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            map.set(A[<span class="number">0</span>][i],map.get(A[<span class="number">0</span>][i])+<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">1</span>;i&lt;A.length;i++)&#123;</span><br><span class="line">        <span class="keyword">let</span> mapEve=<span class="keyword">new</span> <span class="built_in">Map</span>();</span><br><span class="line">        map.forEach(<span class="function">(<span class="params">value,key</span>)=&gt;</span>&#123;</span><br><span class="line">            mapEve.set(key,<span class="number">0</span>);</span><br><span class="line">        &#125;)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">let</span> k=<span class="number">0</span>;k&lt;A[i].length;k++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(map.has(A[i][k]))&#123;</span><br><span class="line">                 mapEve.set(A[i][k],mapEve.get(A[i][k])+<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        map.forEach(<span class="function">(<span class="params">value,key</span>)=&gt;</span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(value&gt;mapEve.get(key))&#123;</span><br><span class="line">                map.set(key,mapEve.get(key));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">    map.forEach(<span class="function">(<span class="params">value,key</span>)=&gt;</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(value&gt;<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">0</span>;i&lt;value;i++)&#123;</span><br><span class="line">                ans.push(key);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;查找常用字符&quot;&gt;&lt;a href=&quot;#查找常用字符&quot; class=&quot;headerlink&quot; title=&quot;查找常用字符&quot;&gt;&lt;/a&gt;查找常用字符&lt;/h1&gt;&lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h2&gt;&lt;p&gt;给定仅有小写字母组成的字符串数组 A，返回列表中的每个字符串中都显示的全部字符（包括重复字符）组成的列表。例如，如果一个字符在每个字符串中出现 3 次，但不是 4 次，则需要在最终答案中包含该字符 3 次。&lt;/p&gt;
&lt;p&gt;你可以按任意顺序返回答案。&lt;/p&gt;
&lt;p&gt;示例 1：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;输入：[“bella”,”label”,”roller”]&lt;br&gt;输出：[“e”,”l”,”l”]&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;示例 2：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;输入：[“cool”,”lock”,”cook”]&lt;br&gt;输出：[“c”,”o”]&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;提示：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;1&amp;lt;= A.length &amp;lt;= 100&lt;/li&gt;
&lt;li&gt;1&amp;lt;= A[i].length &amp;lt;= 100&lt;/li&gt;
&lt;li&gt;A[i][j] 是小写字母
    
    </summary>
    
      <category term="leetcode题解与算法" scheme="http://yoursite.com/categories/leetcode%E9%A2%98%E8%A7%A3%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="哈希表" scheme="http://yoursite.com/tags/%E5%93%88%E5%B8%8C%E8%A1%A8/"/>
    
  </entry>
  
  <entry>
    <title>递归与分治</title>
    <link href="http://yoursite.com/2019/07/24/%E9%80%92%E5%BD%92%E4%B8%8E%E5%88%86%E6%B2%BB/"/>
    <id>http://yoursite.com/2019/07/24/递归与分治/</id>
    <published>2019-07-24T01:04:47.000Z</published>
    <updated>2019-07-24T01:18:43.131Z</updated>
    
    <content type="html"><![CDATA[<h1 id="分治"><a href="#分治" class="headerlink" title="分治"></a>分治</h1><p>分治的全称为“分而治之”。分治法将原问题划分为若干个规模较小而结构与原问题相同或类似的子问题，然后分别解决这些子问题，最后合并子问题的解，即可得到原问题的解</p><h2 id="减治、分治"><a href="#减治、分治" class="headerlink" title="减治、分治"></a>减治、分治</h2><ol><li><p>一般把子问题个数为1的情况称为减治（例如对n!的求解）</p> <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">F</span>(<span class="params">n</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(n===<span class="number">1</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> F(n<span class="number">-1</span>)*n;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>子问题个数大于1的情况称为分治（例如对Fibonacci数列的求解）</p> <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">F</span>(<span class="params">n</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(n===<span class="number">1</span>||n===<span class="number">0</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> F(n<span class="number">-1</span>)+F(n<span class="number">-2</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h1 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h1><blockquote><p>递归适合用来实现分治思想</p></blockquote><h2 id="递归的两个核心概念"><a href="#递归的两个核心概念" class="headerlink" title="递归的两个核心概念"></a>递归的两个核心概念</h2><ol><li>递归边界</li><li>递归式（递归调用）</li></ol><p>对于n!的求解，可以很容易的到F(n)=F(n-1)*n ;这就是递归式<br>而F(1)=1; 这是递归的边界</p><h1 id="分治思想的应用"><a href="#分治思想的应用" class="headerlink" title="分治思想的应用"></a>分治思想的应用</h1><h2 id="全排列"><a href="#全排列" class="headerlink" title="全排列"></a>全排列</h2><h2 id="n皇后问题"><a href="#n皇后问题" class="headerlink" title="n皇后问题"></a>n皇后问题</h2>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;分治&quot;&gt;&lt;a href=&quot;#分治&quot; class=&quot;headerlink&quot; title=&quot;分治&quot;&gt;&lt;/a&gt;分治&lt;/h1&gt;&lt;p&gt;分治的全称为“分而治之”。分治法将原问题划分为若干个规模较小而结构与原问题相同或类似的子问题，然后分别解决这些子问题，最后合并子问题的解，即
      
    
    </summary>
    
      <category term="算法笔记" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/"/>
    
    
  </entry>
  
  <entry>
    <title>leetcode-349 两个数组的交集</title>
    <link href="http://yoursite.com/2019/07/23/leetcode-349/"/>
    <id>http://yoursite.com/2019/07/23/leetcode-349/</id>
    <published>2019-07-23T03:14:11.000Z</published>
    <updated>2019-07-23T03:19:44.629Z</updated>
    
    <content type="html"><![CDATA[<h1 id="两个数组的交集"><a href="#两个数组的交集" class="headerlink" title="两个数组的交集"></a>两个数组的交集</h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>给定两个数组，编写一个函数来计算它们的交集。</p><p>示例 1:</p><blockquote><p>输入: nums1 = [1,2,2,1], nums2 = [2,2]<br>输出: [2]</p></blockquote><p>示例 2:</p><blockquote><p>输入: nums1 = [4,9,5], nums2 = [9,4,9,8,4]<br>输出: [9,4]</p></blockquote><p>说明:</p><p>输出结果中的每个元素一定是唯一的。<br>我们可以不考虑输出结果的顺序。</p><a id="more"></a><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/intersection-of-two-arrays" target="_blank" rel="noopener">https://leetcode-cn.com/problems/intersection-of-two-arrays</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p><h2 id="核心思路"><a href="#核心思路" class="headerlink" title="核心思路"></a>核心思路</h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>将两个数组都去重后，比较另一个数组是否包含这个数组的某些元素，返回即可</p><h3 id="解题步骤"><a href="#解题步骤" class="headerlink" title="解题步骤"></a>解题步骤</h3><ol><li>使用set将两个数组去重</li><li>比较去重后的两个数组的大小，遍历较小的那个数组，查看另一个数组是否includes这个数组中的某些元素，有则添加到ans数组返回</li></ol><h2 id="Coding实现"><a href="#Coding实现" class="headerlink" title="Coding实现"></a>Coding实现</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @param &#123;number[]&#125; nums1</span></span><br><span class="line"><span class="comment"> * @param &#123;number[]&#125; nums2</span></span><br><span class="line"><span class="comment"> * @return &#123;number[]&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> intersection = <span class="function"><span class="keyword">function</span>(<span class="params">nums1, nums2</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> ans=[];</span><br><span class="line">    nums1=[...new <span class="built_in">Set</span>(nums1)];</span><br><span class="line">    nums2=[...new <span class="built_in">Set</span>(nums2)];</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">inter</span>(<span class="params">nums1,nums2</span>)</span>&#123;</span><br><span class="line">        nums1.forEach(<span class="function"><span class="params">value</span>=&gt;</span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums2.includes(value))&#123;</span><br><span class="line">                ans.push(value);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">    nums1.length&gt;nums2.length?inter(nums2,nums1):inter(nums1,nums2);</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;两个数组的交集&quot;&gt;&lt;a href=&quot;#两个数组的交集&quot; class=&quot;headerlink&quot; title=&quot;两个数组的交集&quot;&gt;&lt;/a&gt;两个数组的交集&lt;/h1&gt;&lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h2&gt;&lt;p&gt;给定两个数组，编写一个函数来计算它们的交集。&lt;/p&gt;
&lt;p&gt;示例 1:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;输入: nums1 = [1,2,2,1], nums2 = [2,2]&lt;br&gt;输出: [2]&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;示例 2:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;输入: nums1 = [4,9,5], nums2 = [9,4,9,8,4]&lt;br&gt;输出: [9,4]&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;说明:&lt;/p&gt;
&lt;p&gt;输出结果中的每个元素一定是唯一的。&lt;br&gt;我们可以不考虑输出结果的顺序。&lt;/p&gt;
    
    </summary>
    
      <category term="leetcode题解与算法" scheme="http://yoursite.com/categories/leetcode%E9%A2%98%E8%A7%A3%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="数组" scheme="http://yoursite.com/tags/%E6%95%B0%E7%BB%84/"/>
    
  </entry>
  
  <entry>
    <title>leetcode-961 重复 N 次的元素</title>
    <link href="http://yoursite.com/2019/07/23/leetcode-961/"/>
    <id>http://yoursite.com/2019/07/23/leetcode-961/</id>
    <published>2019-07-23T02:48:57.000Z</published>
    <updated>2019-07-23T02:54:24.612Z</updated>
    
    <content type="html"><![CDATA[<h1 id="重复-N-次的元素"><a href="#重复-N-次的元素" class="headerlink" title="重复 N 次的元素"></a>重复 N 次的元素</h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>在大小为 2N 的数组 A 中有 N+1 个不同的元素，其中有一个元素重复了 N 次。</p><p>返回重复了 N 次的那个元素。</p><p>示例 1：</p><blockquote><p>输入：[1,2,3,3]<br>输出：3</p></blockquote><p>示例 2：</p><blockquote><p>输入：[2,1,2,5,3,2]<br>输出：2</p></blockquote><p>示例 3：</p><blockquote><p>输入：[5,1,5,2,5,3,5,4]<br>输出：5</p></blockquote><p>提示：</p><p>4 &lt;= A.length &lt;= 10000<br>0 &lt;= A[i] &lt; 10000<br>A.length 为偶数</p><a id="more"></a><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/n-repeated-element-in-size-2n-array" target="_blank" rel="noopener">https://leetcode-cn.com/problems/n-repeated-element-in-size-2n-array</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p><h2 id="核心思路"><a href="#核心思路" class="headerlink" title="核心思路"></a>核心思路</h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>因为该数组大小为2N，其中由N+1个不同的元素，并且有一个元素重复了N次，那么剩余的N个数都是不同的</p><p>所以题目可转化为返回有重复的那个数</p><h3 id="解题步骤"><a href="#解题步骤" class="headerlink" title="解题步骤"></a>解题步骤</h3><ol><li>建立哈希表</li><li>遍历给定数组，若哈希表中没有该键名，则加入哈希表；若有，则直接返回该数组元素</li></ol><h2 id="Coding实现"><a href="#Coding实现" class="headerlink" title="Coding实现"></a>Coding实现</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @param &#123;number[]&#125; A</span></span><br><span class="line"><span class="comment"> * @return &#123;number&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> repeatedNTimes = <span class="function"><span class="keyword">function</span>(<span class="params">A</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> map=<span class="keyword">new</span> <span class="built_in">Map</span>();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">0</span>;i&lt;A.length;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(!map.has(A[i]))&#123;</span><br><span class="line">            map.set(A[i],<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> A[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;重复-N-次的元素&quot;&gt;&lt;a href=&quot;#重复-N-次的元素&quot; class=&quot;headerlink&quot; title=&quot;重复 N 次的元素&quot;&gt;&lt;/a&gt;重复 N 次的元素&lt;/h1&gt;&lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h2&gt;&lt;p&gt;在大小为 2N 的数组 A 中有 N+1 个不同的元素，其中有一个元素重复了 N 次。&lt;/p&gt;
&lt;p&gt;返回重复了 N 次的那个元素。&lt;/p&gt;
&lt;p&gt;示例 1：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;输入：[1,2,3,3]&lt;br&gt;输出：3&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;示例 2：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;输入：[2,1,2,5,3,2]&lt;br&gt;输出：2&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;示例 3：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;输入：[5,1,5,2,5,3,5,4]&lt;br&gt;输出：5&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;提示：&lt;/p&gt;
&lt;p&gt;4 &amp;lt;= A.length &amp;lt;= 10000&lt;br&gt;0 &amp;lt;= A[i] &amp;lt; 10000&lt;br&gt;A.length 为偶数&lt;/p&gt;
    
    </summary>
    
      <category term="leetcode题解与算法" scheme="http://yoursite.com/categories/leetcode%E9%A2%98%E8%A7%A3%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="哈希表" scheme="http://yoursite.com/tags/%E5%93%88%E5%B8%8C%E8%A1%A8/"/>
    
  </entry>
  
</feed>
