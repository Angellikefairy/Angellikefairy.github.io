<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Hexo</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2019-10-09T06:36:58.557Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>Angel</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>跨域与解决方案</title>
    <link href="http://yoursite.com/2019/10/07/%E8%B7%A8%E5%9F%9F%E4%B8%8E%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/"/>
    <id>http://yoursite.com/2019/10/07/跨域与解决方案/</id>
    <published>2019-10-07T08:11:53.000Z</published>
    <updated>2019-10-09T06:36:58.557Z</updated>
    
    <content type="html"><![CDATA[<h2 id="什么是跨域"><a href="#什么是跨域" class="headerlink" title="什么是跨域"></a>什么是跨域</h2><p>通过XHR对象来实现Ajax通信的一个主要限制，来源于跨域安全策略。在默认的情况下，XHR对象只能访问与包含它的页面位于同一个域中的资源。</p><p>那么，什么样的情况算是同一个域，什么样的情况算是不同的域呢？</p><h3 id="同源"><a href="#同源" class="headerlink" title="同源"></a>同源</h3><p>所谓同源（即指在同一个域）就是两个页面具有相同的协议（包括HTTP和HTTPS），主机（host）和端口号（port）</p><h3 id="跨域"><a href="#跨域" class="headerlink" title="跨域"></a>跨域</h3><p>当一个请求url的协议、域名、端口三者之间任意一个与当前页面url不同即为跨域</p><h3 id="域名层次"><a href="#域名层次" class="headerlink" title="域名层次"></a>域名层次</h3><h4 id="域名语法"><a href="#域名语法" class="headerlink" title="域名语法"></a>域名语法</h4><p>域名由一或多个部分组成，这些部分通常连接在一起，并由点分隔，例如zh.wikipedia.org。最右边的一个标签是顶级域名，例如zh.wikipedia.org的顶级域名是org。一个域名的层次结构，从右侧到左侧隔一个点依次下降一层。</p><h4 id="顶级域名"><a href="#顶级域名" class="headerlink" title="顶级域名"></a>顶级域名</h4><p>顶级域名是域名中最高的一级，每个域名都以顶级域名结尾。</p><h4 id="子域名"><a href="#子域名" class="headerlink" title="子域名"></a>子域名</h4><p>子域名将顶级域名进一步细分。域名层次结构中，顶级域名下面是二级域名，它位于顶级域名的左侧。例如，在zh.wikipedia.org中，wikipedia是二级域名。w3.org中，w3也是二级域名，与前例中的wikipedia属于一个层面。</p><p>二级域名下面是三级域名，它位于二级域名的左侧。例如，在zh.wikipedia.org中，zh是三级域名；zh-classical.wikipedia.org（文言文维基大典的域名）中，zh-classical也是三级域名，与前例中的zh属于一个层面。从右侧到左侧，隔一个点依次下降一层。</p><h3 id="常见跨域场景"><a href="#常见跨域场景" class="headerlink" title="常见跨域场景"></a>常见跨域场景</h3><table><thead><tr><th>当前页面URL</th><th>请求页面URL</th><th>是否跨域</th><th>原因</th></tr></thead><tbody><tr><td><a href="http://www.example.com/a.js" target="_blank" rel="noopener">http://www.example.com/a.js</a></td><td><a href="http://www.example.com/b.js" target="_blank" rel="noopener">http://www.example.com/b.js</a></td><td>否</td><td>协议、域名、端口号均相同</td></tr><tr><td><a href="http://www.example.com/a.js" target="_blank" rel="noopener">http://www.example.com/a.js</a></td><td><a href="https://www.example.com/b.js" target="_blank" rel="noopener">https://www.example.com/b.js</a></td><td>是</td><td>协议不同（http与https）</td></tr><tr><td><a href="http://www.example.com/a.js" target="_blank" rel="noopener">http://www.example.com/a.js</a></td><td><a href="http://www.test.com/b.js" target="_blank" rel="noopener">http://www.test.com/b.js</a></td><td>是</td><td>域名不同</td></tr><tr><td><a href="http://www.example.com/a.js" target="_blank" rel="noopener">http://www.example.com/a.js</a></td><td><a href="http://www.blog.example.com/b.js" target="_blank" rel="noopener">http://www.blog.example.com/b.js</a></td><td>是</td><td>主域名相同，但子域名不同</td></tr><tr><td><a href="http://www.example.com/a.js" target="_blank" rel="noopener">http://www.example.com/a.js</a></td><td><a href="http://192.168.56.1/b.js" target="_blank" rel="noopener">http://192.168.56.1/b.js</a></td><td>是</td><td>域名与其对应ip地址之间的请求也算跨域</td></tr><tr><td><a href="http://www.example.com" target="_blank" rel="noopener">http://www.example.com</a></td><td><a href="http://www.example.com:8888/b.js" target="_blank" rel="noopener">http://www.example.com:8888/b.js</a></td><td>是</td><td>端口不同</td></tr></tbody></table><h2 id="跨域解决方案"><a href="#跨域解决方案" class="headerlink" title="跨域解决方案"></a>跨域解决方案</h2><h3 id="JSONP"><a href="#JSONP" class="headerlink" title="JSONP"></a>JSONP</h3><h4 id="什么是JSONP"><a href="#什么是JSONP" class="headerlink" title="什么是JSONP"></a>什么是JSONP</h4><p>JSONP是JSON with padding（填充式JSON或参数是JSON）的简写，是应用JSON的一种新方法。JSONP看起来与JSON差不多，只不过是被包含在函数调用中的JSON，例如</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">callback(&#123;<span class="string">"name"</span>:<span class="string">"Ming"</span>&#125;)</span><br></pre></td></tr></table></figure><p>JSONP由两部分组成：回调函数以及传递给回调函数的参数JSON字符串</p><h4 id="JSONP的原理及具体实现过程"><a href="#JSONP的原理及具体实现过程" class="headerlink" title="JSONP的原理及具体实现过程"></a>JSONP的原理及具体实现过程</h4><ol><li><p>因为&lt;script&gt;元素可以不受限制地从其他域加载资源。因此<br>我们可以在web端通过动态&lt;script&gt;来实现一个JSONP请求，例如</p> <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> script = <span class="built_in">document</span>.createElement(<span class="string">'script'</span>);</span><br><span class="line">script.src = <span class="string">'http://localhost:8888/getTestData?callback=handle'</span></span><br></pre></td></tr></table></figure></li><li><p>通过上一步，我们就可以引入<a href="http://localhost:8888/getTestData?callback=handle该文件，同时将参数callback发送给服务器" target="_blank" rel="noopener">http://localhost:8888/getTestData?callback=handle该文件，同时将参数callback发送给服务器</a></p></li><li><p>因为script标签内需要可执行的javascript代码，因此我们可以知道使用JSONP是需要后端配合的，后端需要返回一个javascript类型数据才可以。我们通过express来模拟返回一下数据</p> <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> express = <span class="built_in">require</span>(<span class="string">'express'</span>);</span><br><span class="line"><span class="keyword">let</span> app = express();</span><br><span class="line"></span><br><span class="line">app.listen(<span class="number">8888</span>);</span><br><span class="line"></span><br><span class="line">app.get(<span class="string">'/getTestData'</span>,<span class="function"><span class="keyword">function</span>(<span class="params">req,res,next</span>) </span>&#123;</span><br><span class="line"><span class="keyword">let</span> _callback = req.query.callback;</span><br><span class="line"><span class="keyword">let</span> _data = &#123;</span><br><span class="line">    <span class="string">"code"</span>: <span class="number">0</span>,</span><br><span class="line">    <span class="string">"msg"</span>: <span class="string">'hello world'</span></span><br><span class="line">&#125;;</span><br><span class="line">res.type(<span class="string">'text/javascript'</span>);</span><br><span class="line">res.send(_callback+<span class="string">'('</span>+<span class="built_in">JSON</span>.stringify(_data)+<span class="string">')'</span>);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p> 我们可以看到，服务器会接收到我们请求的参数，也就是回调函数名callback；接着，服务器生成_data数据，将其序列化后作为参数传入callback函数并返回给前端（注意的是，返回的内容类型是javascript代码）</p></li><li><p>收到服务器返回的javascript代码，也就是一个准备执行的已传入参数的函数。（需要注意的是，script标签内的代码会成为全局代码，也就是该函数会成为全局函数）</p></li><li><p>因此，如果我们在使用模块化开发的时候，模块内的代码都是局部代码，因此，我们需要注册一个全局的callback函数让服务器返回的Javascript代码可以执行。同时，我们的业务逻辑也就可以写在这个callback函数中。例如：</p> <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">window</span>.handle = <span class="function"><span class="keyword">function</span>(<span class="params">res</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(res);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>捕获错误：我们可以使用onerror事件处理程序来确定JSONP请求是否成功</p> <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">script.onerror = <span class="function"><span class="keyword">function</span> (<span class="params">err</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'error'</span>,err);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h4 id="JSONP的前后端代码示例"><a href="#JSONP的前后端代码示例" class="headerlink" title="JSONP的前后端代码示例"></a>JSONP的前后端代码示例</h4><h5 id="前端代码"><a href="#前端代码" class="headerlink" title="前端代码"></a>前端代码</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> script = <span class="built_in">document</span>.createElement(<span class="string">'script'</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">window</span>.handle = <span class="function"><span class="keyword">function</span> (<span class="params">res</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.console.log(res.code);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">script.src = <span class="string">'http://localhost:8888/getTestData?callback=handle'</span>;</span><br><span class="line">script.onerror = <span class="function"><span class="keyword">function</span> (<span class="params">err</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'error'</span>,err);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">document</span>.body.appendChild(script);</span><br></pre></td></tr></table></figure><h5 id="Node-js代码"><a href="#Node-js代码" class="headerlink" title="Node.js代码"></a>Node.js代码</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> express = <span class="built_in">require</span>(<span class="string">'express'</span>);</span><br><span class="line"><span class="keyword">let</span> app = express();</span><br><span class="line"></span><br><span class="line">app.listen(<span class="number">8888</span>);</span><br><span class="line"></span><br><span class="line">app.get(<span class="string">'/getTestData'</span>,<span class="function"><span class="keyword">function</span>(<span class="params">req,res,next</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> _callback = req.query.callback;</span><br><span class="line">  <span class="keyword">let</span> _data = &#123;</span><br><span class="line">    code: <span class="number">0</span>,</span><br><span class="line">    msg: <span class="string">'hello world'</span></span><br><span class="line">  &#125;;</span><br><span class="line">  res.type(<span class="string">'text/javascript'</span>);</span><br><span class="line">  res.send(_callback+<span class="string">'('</span>+<span class="built_in">JSON</span>.stringify(_data)+<span class="string">')'</span>);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h4 id="JSONP的一些个人思考"><a href="#JSONP的一些个人思考" class="headerlink" title="JSONP的一些个人思考"></a>JSONP的一些个人思考</h4><ol><li>为什么后端返回的javascript代码中传给函数的参数是JSON而不是javascript对象？<br>关于这个，我们要记住，JSON数据是我们的要获取的东西（json易于人阅读和编写，也易于机器解析和生成，相对网络传输速率较高，因此，进行数据交换我们一般使用JSON），而JSONP是我们获取JSON数据的手段。</li><li>JSONP能够直接访问响应文本，并且支持在浏览器与服务器之间双向通信</li><li>可以看到，JSONP只支持GET请求</li></ol><h3 id="CORS"><a href="#CORS" class="headerlink" title="CORS"></a>CORS</h3><p>CORS （Cross-Origin Resource Sharing，跨域资源共享）是一个系统，它由一系列传输的HTTP头组成，这些HTTP头决定浏览器是否阻止前端 JavaScript 代码获取跨域请求的响应。</p><p>同源安全策略 默认阻止“跨域”获取资源。但是 CORS 给了web服务器这样的权限，即服务器可以选择，允许跨域请求访问到它们的资源。</p><h4 id="简单请求"><a href="#简单请求" class="headerlink" title="简单请求"></a>简单请求</h4><p>某些请求不会触发CORS预检请求，这样的请求被视为简单请求。</p><p>满足以下条件之一就被视为简单请求</p><ol><li><p>使用下列方法之一：</p><p> GET<br> HEAD<br> POST</p></li><li><p>Content-Type 的值仅限于下列三者之一：</p><p> text/plain<br> multipart/form-data<br> application/x-www-form-urlencoded</p></li></ol><p>目前浏览器基本都实现了XHR对象对CORS的原生支持。因此，对于简单请求，浏览器就会直接发出CORS请求，具体来说，就是会在请求的头信息中，增加一个Origin字段来表示请求源</p><p>我们查看一下请求报文就可以发现，在请求报文中会多出一个字段origin来说明请求的源；在响应报文中会多出一个字段Access-Control-Allow-Origin:*来允许所有的源进行跨域；当然也可以设置这个字段只允许一个或几个域才可以跨域</p><p><strong>请求报文与响应报文</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">GET /resources/public-data/ HTTP/1.1</span><br><span class="line">Host: bar.other</span><br><span class="line">User-Agent: Mozilla/5.0 (Macintosh; U; Intel Mac OS X 10.5; en-US; rv:1.9.1b3pre) Gecko/20081130 Minefield/3.1b3pre</span><br><span class="line">Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8</span><br><span class="line">Accept-Language: en-us,en;q=0.5</span><br><span class="line">Accept-Encoding: gzip,deflate</span><br><span class="line">Accept-Charset: ISO-8859-1,utf-8;q=0.7,*;q=0.7</span><br><span class="line">Connection: keep-alive</span><br><span class="line">Referer: http://foo.example/examples/access-control/simpleXSInvocation.html</span><br><span class="line"></span><br><span class="line">// origin</span><br><span class="line">Origin: http://foo.example</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">HTTP/1.1 200 OK</span><br><span class="line">Date: Mon, 01 Dec 2008 00:23:53 GMT</span><br><span class="line">Server: Apache/2.0.61</span><br><span class="line"></span><br><span class="line">// Access-Control-Allow-Origin</span><br><span class="line">Access-Control-Allow-Origin: *</span><br><span class="line">Keep-Alive: timeout=2, max=100</span><br><span class="line">Connection: Keep-Alive</span><br><span class="line">Transfer-Encoding: chunked</span><br><span class="line">Content-Type: application/xml</span><br><span class="line"></span><br><span class="line">[XML Data]</span><br></pre></td></tr></table></figure><h4 id="非简单请求（预检请求）"><a href="#非简单请求（预检请求）" class="headerlink" title="非简单请求（预检请求）"></a>非简单请求（预检请求）</h4><p>与简单请求不同，非简单请求（预检请求）会要求使用OPTIONS方法预先发送一个预检请求给服务器，以货值服务器是否允许该实际请求。预检请求的使用，可以一定程度上来避免跨域请求对服务器的用户数据产生未预期的影响</p><p>当请求满足以下任一条件时，就会发送预检请求</p><ol><li><p>使用了下面任一HTTP方法</p><ol><li>PUT</li><li>DELETE</li><li>CONNECT</li><li>OPTIONS</li><li>TRACE</li><li>PATCH</li></ol></li><li><p>人为设置了对 CORS 安全的首部字段集合之外的其他首部字段。该集合为：</p><p> Accept<br> Accept-Language<br> Content-Language<br> Content-Type (需要注意额外的限制)<br> DPR<br> Downlink<br> Save-Data<br> Viewport-Width<br> Width</p></li><li><p>Content-Type 的值不属于下列之一:</p><ol><li>application/ x-www-form-urlencoded</li><li>multipart/form-data</li><li>text/plain</li></ol></li></ol><p>非简单请求（预检请求）的示意图如下：</p><p><img src="https://mdn.mozillademos.org/files/16753/preflight_correct.png" alt></p><h3 id="node中间件代理"><a href="#node中间件代理" class="headerlink" title="node中间件代理"></a>node中间件代理</h3><p>node中间件实现跨域代理，是通过启一个代理服务器，实现数据的转发</p><p>前端所在的域与node代理服务器处在同一个域上，所有发送给代理服务器的请求都会被该服务器代理并转发给预先设定的服务器地址</p><h4 id="前端请求"><a href="#前端请求" class="headerlink" title="前端请求"></a>前端请求</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> xhr = <span class="keyword">new</span> XMLHttpRequest();</span><br><span class="line">xhr.onreadystatechange = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(xhr.readyState===<span class="number">4</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span>(xhr.status&gt;=<span class="number">200</span>&amp;&amp;xhr.status&lt;<span class="number">300</span>) &#123;</span><br><span class="line">            <span class="built_in">console</span>.log(xhr.responseText);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">'error'</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">xhr.open(<span class="string">'get'</span>,<span class="string">'http://localhost:3000'</span>,<span class="literal">true</span>);</span><br><span class="line">xhr.send(<span class="literal">null</span>);</span><br></pre></td></tr></table></figure><h4 id="node代理服务器"><a href="#node代理服务器" class="headerlink" title="node代理服务器"></a>node代理服务器</h4><p>利用http-proxy-middleware该中间件实现代理服务器</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> express = <span class="built_in">require</span>(<span class="string">'express'</span>);</span><br><span class="line"><span class="keyword">const</span> proxy = <span class="built_in">require</span>(<span class="string">'http-proxy-middleware'</span>)</span><br><span class="line"><span class="keyword">let</span> app = express();</span><br><span class="line"></span><br><span class="line">app.use(<span class="string">'/'</span>,proxy(&#123;</span><br><span class="line">  target: <span class="string">'http://localhost:3000'</span>,</span><br><span class="line">  changeOrigin: <span class="literal">true</span></span><br><span class="line">&#125;))</span><br><span class="line"></span><br><span class="line">app.listen(<span class="number">8080</span>,<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'8080端口已打开'</span>);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h4 id="node-js后端"><a href="#node-js后端" class="headerlink" title="node.js后端"></a>node.js后端</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> express = <span class="built_in">require</span>(<span class="string">'express'</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> app = express();</span><br><span class="line"></span><br><span class="line">app.get(<span class="string">'/'</span>,(req,res)=&gt;&#123;</span><br><span class="line">    res.send(<span class="string">'hello'</span>);</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">app.listen(<span class="number">3000</span>,<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'3000端口已打开'</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>这样我们就可以通过代理服务器进行跨域请求</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;什么是跨域&quot;&gt;&lt;a href=&quot;#什么是跨域&quot; class=&quot;headerlink&quot; title=&quot;什么是跨域&quot;&gt;&lt;/a&gt;什么是跨域&lt;/h2&gt;&lt;p&gt;通过XHR对象来实现Ajax通信的一个主要限制，来源于跨域安全策略。在默认的情况下，XHR对象只能访问与包含它的页面
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Ajax</title>
    <link href="http://yoursite.com/2019/09/30/Ajax/"/>
    <id>http://yoursite.com/2019/09/30/Ajax/</id>
    <published>2019-09-30T10:39:26.000Z</published>
    <updated>2019-10-01T11:28:00.474Z</updated>
    
    <content type="html"><![CDATA[<h2 id="什么是Ajax"><a href="#什么是Ajax" class="headerlink" title="什么是Ajax"></a>什么是Ajax</h2><p>AJAX即“Asynchronous JavaScript and XML”（异步的JavaScript与XML技术）。使用Ajax可以无需刷新页面就可以从服务器取得数据</p><h2 id="Ajax的核心–XMLHttpRequest对象"><a href="#Ajax的核心–XMLHttpRequest对象" class="headerlink" title="Ajax的核心–XMLHttpRequest对象"></a>Ajax的核心–XMLHttpRequest对象</h2><p>如果不考虑IE7以前的版本，那么对于所有的标准浏览器我们都可以使用如下来创建一个XHR对象</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> xhr = <span class="keyword">new</span> XMLHttpRequest();</span><br></pre></td></tr></table></figure><h3 id="XHR对象的一些属性"><a href="#XHR对象的一些属性" class="headerlink" title="XHR对象的一些属性"></a>XHR对象的一些属性</h3><table><thead><tr><th>属性名</th><th>作用</th></tr></thead><tbody><tr><td>status</td><td>响应的HTTP状态码</td></tr><tr><td>statusText</td><td>HTTP状态码的说明</td></tr><tr><td>responseText</td><td>作为响应主体被返回的文本</td></tr><tr><td>responseXml</td><td>对请求的响应，解析为 XML 并作为 Document 对象返回</td></tr><tr><td>readyState</td><td>请求/响应过程的当前活动状态</td></tr><tr><td>onreadystatechange()</td><td>readyState属性值改变触发的readystatechange事件的绑定函数</td></tr></tbody></table><p>readyState属性的说明：<br>属性可取值|名称|说明<br>–|–|–<br>0|未初始化|尚未调用open()方法<br>1|启动|已经调用open()方法，但尚未调用send()方法<br>2|发送|已经调用send()方法，但尚未接收到响应<br>3|接收|已经接收到部分响应数据<br>4|完成|已经接收到全部响应数据</p><p>status（HTTP常见状态码）<br>状态码|名称|说明<br>–|–|–<br>200|OK|请求成功，信息在返回的响应报文中<br>301|Moved Permanently|请求的对象已经被永久转移了，新的URL定义在响应报文的Location: 首部行中。客户软件将自动获取新的URL<br>304|Not Modified|未修改。所请求的资源未修改，服务器返回此状态码时，不会返回任何资源。客户端通常会缓存访问过的资源，通过提供一个头信息指出客户端希望只返回在指定日期之后修改的资源<br>400|Bad Request|一个通用差错代码，指示该请求不能被服务器理解<br>404|Not Found|请求的资源不存在<br>500|Internal Server Error|内部服务器错误<br>505|HTTP Version Not Supported|服务器不支持请求报文使用的HTTP协议版本</p><p>HTTP状态码分类</p><table><thead><tr><th>状态码</th><th>名称</th><th>说明</th></tr></thead><tbody><tr><td>1**</td><td>信息</td><td>服务器收到请求，需要请求者继续执行操作</td></tr><tr><td>2**</td><td>成功</td><td>操作被成功接收并处理</td></tr><tr><td>3**</td><td>重定向</td><td>需要进一步的操作以完成请求</td></tr><tr><td>4**</td><td>客户端错误</td><td>请求包含语法错误或无法完成请求</td></tr><tr><td>5**</td><td>服务器错误</td><td>服务器在处理请求的过程中发生了错误</td></tr></tbody></table><h3 id="XHR对象的一些方法"><a href="#XHR对象的一些方法" class="headerlink" title="XHR对象的一些方法"></a>XHR对象的一些方法</h3><h4 id="open"><a href="#open" class="headerlink" title="open()"></a>open()</h4><p>参数：</p><p>method<br>    要使用的HTTP方法，比如「GET」、「POST」、「PUT」、「DELETE」、等。对于非HTTP(S) URL被忽略。</p><p>url<br>    一个DOMString表示要向其发送请求的URL。</p><p>async 可选<br>    一个可选的布尔参数，默认为true，表示要不要异步执行操作。如果值为false（表示同步执行），send()方法直到收到答复前不会返回。如果true（表示异步执行），已完成事务的通知可供事件监听器使用。</p><pre><code>注意：主线程上的同步请求很容易破坏用户体验，应该避免；实际上，许多浏览器已完全弃用主线程上的同步XHR支持。在 Worker中允许同步请求</code></pre><p>user 可选<br>    可选的用户名用于认证用途；默认为null。</p><p>password 可选<br>    可选的密码用于认证用途，默认为null。 </p><h4 id="send"><a href="#send" class="headerlink" title="send()"></a>send()</h4><p>XMLHttpRequest.send() 方法接受一个可选的参数，其作为请求主体；如果请求方法是 GET 或者 HEAD，则应将请求主体设置为 null。（注：在HTTP请求报文中，使用GET方法时，请求实体为空，而是用POST方法时传输的内容保存在该请求实体中）</p><h4 id="setRequestHeader"><a href="#setRequestHeader" class="headerlink" title="setRequestHeader"></a>setRequestHeader</h4><p>XMLHttpRequest.setRequestHeader() 是设置HTTP请求头部的方法。此方法必须在  open() 方法和 send()   之间调用。如果多次对同一个请求头赋值，只会生成一个合并了多个值的请求头。</p><h4 id="abort"><a href="#abort" class="headerlink" title="abort()"></a>abort()</h4><p>如果该请求已被发出，XMLHttpRequest.abort() 方法将终止该请求。当一个请求被终止，它的 readyState 属性将被置为0（ UNSENT )。</p><h3 id="使用XHR对象进行同步请求"><a href="#使用XHR对象进行同步请求" class="headerlink" title="使用XHR对象进行同步请求"></a>使用XHR对象进行同步请求</h3><p>对于同步请求，也就是意味着该次请求是阻塞的。因此，之后的代码会等到服务器响应之后才会执行。</p><p>在收到响应后，响应的数据会自动填充到XHR对象的属性</p><p>例如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> xhr = <span class="keyword">new</span> XMLHttpRequest();</span><br><span class="line"><span class="comment">// 使用同步请求时，open()方法的第三个参数设置为false</span></span><br><span class="line">xhr.open(<span class="string">"get"</span>,<span class="string">"https://www.baidu.com"</span>,<span class="literal">false</span>);</span><br><span class="line">xhr.send(<span class="literal">null</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>((xhr.status&gt;=<span class="number">200</span>&amp;&amp;xhr.status&lt;<span class="number">300</span>)||xhr.status===<span class="number">304</span>) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(xhr.responseText);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"Request was failed"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="使用XHR对象进行异步请求"><a href="#使用XHR对象进行异步请求" class="headerlink" title="使用XHR对象进行异步请求"></a>使用XHR对象进行异步请求</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> xhr = <span class="keyword">new</span> XMLHttpRequest();</span><br><span class="line">xhr.onreadystatechange=<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(xhr.readyState===<span class="number">4</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span>((xhr.status&gt;=<span class="number">200</span>&amp;&amp;xhr.status&lt;<span class="number">300</span>)||xhr.status===<span class="number">304</span>) &#123;</span><br><span class="line">            <span class="built_in">console</span>.log(xhr.responseText);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">"Request was failed"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 使用异步请求时，open()方法的第三个参数设置为true</span></span><br><span class="line">xhr.open(<span class="string">"get"</span>,<span class="string">"https://www.baidu.com"</span>,<span class="literal">true</span>);</span><br><span class="line">xhr.send(<span class="literal">null</span>);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'异步请求'</span>);</span><br></pre></td></tr></table></figure><blockquote><p>注意：我们必须在调用open()方法之前指定onreadystatechange事件处理程序才能确保跨浏览器兼容性</p></blockquote><h3 id="GET请求"><a href="#GET请求" class="headerlink" title="GET请求"></a>GET请求</h3><p>对于GET请求，我们经常将查询字符串参数追加到URL的末尾，以便将信息发送给服务器</p><p>但是，我们经常会遇到URL的编码问题（查询字符串的格式有问题，例如在传递中文字符的时候）。因此，我们需要将每个参数的名称和值使用encodeURIComponent()进行编码，然后才能放到URL的末尾</p><p>encodeURIComponent()是对统一资源标识符（URI）的组成部分进行编码的方法。它使用一到四个转义序列来表示字符串中的每个字符的UTF-8编码。它会转义除了字母、数字、(、)、.、!、~、*、’、-和_之外的所有字符。</p><p>decodeURIComponent() 方法用于解码由 encodeURIComponent 方法或者其它类似方法编码的部分统一资源标识符（URI）。</p><p>因此，我们利用一个函数，将每个参数的键与值进行编码后加入到URL的末尾</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">addURLParam</span>(<span class="params">url,key,value</span>) </span>&#123;</span><br><span class="line">    url+=url.indexOf(<span class="string">'?'</span>)&lt;<span class="number">0</span>?<span class="string">'?'</span>:<span class="string">'&amp;'</span>;</span><br><span class="line">    <span class="comment">// 编码参数</span></span><br><span class="line">    url+=<span class="built_in">encodeURIComponent</span>(key)+<span class="string">'='</span>+<span class="built_in">encodeURIComponent</span>(value);</span><br><span class="line">    <span class="keyword">return</span> url;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> url = addURLParam(<span class="string">'https://www.baidu.com'</span>,<span class="string">'a'</span>,<span class="string">'天'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(url);</span><br><span class="line"><span class="keyword">let</span> url1 = addURLParam(url,<span class="string">'b'</span>,<span class="string">'才'</span>);</span><br><span class="line"><span class="comment">// 解码URL</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">decodeURIComponent</span>(url1));</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">https://www.baidu.com?a=%E5%A4%A9</span></span><br><span class="line"><span class="comment">https://www.baidu.com?a=天&amp;b=才</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h3 id="POST请求"><a href="#POST请求" class="headerlink" title="POST请求"></a>POST请求</h3><p>POST请求的内容不会明文出现在URL上，它会存放在请求的实体部分进行传递。值得注意的是，POST请求的主体可包含非常多的数据，而且格式不限</p><p>注意，在使用POST请求提交数据的时候，我们需要将请求头设置一下</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">xhr.setRequestHeader(<span class="string">"Content-Type"</span>,<span class="string">"application/x-www-form-urlencoded"</span>);</span><br></pre></td></tr></table></figure><p>POST完整请求示例</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> xhr = <span class="keyword">new</span> XMLHttpRequest();</span><br><span class="line">xhr.onreadystatechange=<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(xhr.readyState===<span class="number">4</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span>(xhr.status&gt;=<span class="number">200</span>&amp;&amp;xhr.status&lt;<span class="number">300</span>) &#123;</span><br><span class="line">            <span class="built_in">console</span>.log(xhr.responseText);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">'error'</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">xhr.open(<span class="string">"post"</span>,<span class="string">"https://www.baidu.com"</span>,<span class="string">"true"</span>);</span><br><span class="line">xhr.setRequestHeader(<span class="string">"Content-Type"</span>,<span class="string">"x-www-from-urlencoded"</span>);</span><br><span class="line">xhr.send(<span class="string">'123'</span>);</span><br></pre></td></tr></table></figure><h3 id="XMLHttpRequest-2级"><a href="#XMLHttpRequest-2级" class="headerlink" title="XMLHttpRequest 2级"></a>XMLHttpRequest 2级</h3><h4 id="FormData"><a href="#FormData" class="headerlink" title="FormData"></a>FormData</h4><p>在上面提到过，使用POST请求进行传输时，我们需要明确地设置请求头</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">xhr.setRequestHeader(<span class="string">"Content-Type"</span>,<span class="string">"x-www-from-urlencoded"</span>);</span><br></pre></td></tr></table></figure><p>但是，如果使用FormData的话，我们就不要进行设置。因为，XHR对象能够识别传入的数据类型是FormData的实例，并配置适当的头部信息</p><p>例如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建FormData实例</span></span><br><span class="line"><span class="keyword">let</span> data = <span class="keyword">new</span> FormData();</span><br><span class="line"><span class="comment">// 向对象添加数据，append()方法接受两个参数：键和值</span></span><br><span class="line">data.append(<span class="string">"name"</span>,<span class="string">"Ming"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 我们可以看到没有设置POST请求头</span></span><br><span class="line"><span class="keyword">let</span> xhr = <span class="keyword">new</span> XMLHttpRequest();</span><br><span class="line">xhr.onreadystatechange=<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(xhr.readyState===<span class="number">4</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span>(xhr.status&gt;=<span class="number">200</span>&amp;&amp;xhr.status&lt;<span class="number">300</span>) &#123;</span><br><span class="line">            <span class="built_in">console</span>.log(xhr.responseText);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">'error'</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">xhr.open(<span class="string">"post"</span>,<span class="string">"https://www.baidu.com"</span>,<span class="literal">true</span>);</span><br><span class="line">xhr.send(data);</span><br></pre></td></tr></table></figure><h4 id="进度事件"><a href="#进度事件" class="headerlink" title="进度事件"></a>进度事件</h4><p>我们可以利用进度事件来实现一个进度指示器</p><p>progress事件会在浏览器接收新数据期间周期性地触发。而onprogress事件处理程序就会接收到一个events对象，其有三个关于进度的属性：lengthComputable(表示进度信息是否可用),position(表示已经接受的字节数),totalSize(表示总字节数)</p><p>例如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> xhr = <span class="keyword">new</span> XMLHttpRequest();</span><br><span class="line">xhr.onprogress=<span class="function"><span class="keyword">function</span>(<span class="params">events</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(events.lengthComputable)&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(events.position+<span class="string">"/"</span>+events.totalSize);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">xhr.open(<span class="string">"get"</span>,<span class="string">"https://www.baidu.com"</span>,<span class="literal">true</span>);</span><br><span class="line">xhr.send(<span class="literal">null</span>);</span><br></pre></td></tr></table></figure><h3 id="Ajax的一些知识点总结"><a href="#Ajax的一些知识点总结" class="headerlink" title="Ajax的一些知识点总结"></a>Ajax的一些知识点总结</h3><h4 id="原生Js-Ajax请求有几个步骤"><a href="#原生Js-Ajax请求有几个步骤" class="headerlink" title="原生Js Ajax请求有几个步骤"></a>原生Js Ajax请求有几个步骤</h4><p>我们以步骤最多的POST请求为例</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1. 创建XHR对象</span></span><br><span class="line"><span class="keyword">let</span> xhr = <span class="keyword">new</span> XMLHttpRequest();</span><br><span class="line"><span class="comment">// 响应服务器返回的数据</span></span><br><span class="line">xhr.onreadystatechange=<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(xhr.readyState===<span class="number">4</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span>(xhr.status&gt;=<span class="number">200</span>&amp;&amp;xhr.status&lt;<span class="number">300</span>) &#123;</span><br><span class="line">            <span class="built_in">console</span>.log(xhr.responseText);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">'error'</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 2. 准备一个请求，规定请求的类型、URL 以及是否异步处理请求</span></span><br><span class="line">xhr.open(<span class="string">"post"</span>,<span class="string">"https://www.baidu.com"</span>,<span class="string">"true"</span>);</span><br><span class="line"><span class="comment">// 3. 设置请求头中的Content-type</span></span><br><span class="line">xhr.setRequestHeader(<span class="string">"Content-Type"</span>,<span class="string">"x-www-from-urlencoded"</span>);</span><br><span class="line"><span class="comment">// 发送请求</span></span><br><span class="line">xhr.send(<span class="string">'123'</span>);</span><br></pre></td></tr></table></figure><h4 id="Ajax有哪几种请求方式"><a href="#Ajax有哪几种请求方式" class="headerlink" title="Ajax有哪几种请求方式"></a>Ajax有哪几种请求方式</h4><p>常用的有GET,POST,DELETE,PUT。</p><h4 id="POST请求与GET请求的区别"><a href="#POST请求与GET请求的区别" class="headerlink" title="POST请求与GET请求的区别"></a>POST请求与GET请求的区别</h4><ol><li>POST请求更加安全，因为POST请求将参数存放在请求实体中，而GET请求参数在URL上</li><li>GET请求传输速度更快。因为post通过请求体传参，后台通过数据流接收。速度稍微慢一些。而get通过url传参可以直接获取</li><li>POST请求没有数据量的限制</li><li>POST请求的参数内容没有格式限制</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;什么是Ajax&quot;&gt;&lt;a href=&quot;#什么是Ajax&quot; class=&quot;headerlink&quot; title=&quot;什么是Ajax&quot;&gt;&lt;/a&gt;什么是Ajax&lt;/h2&gt;&lt;p&gt;AJAX即“Asynchronous JavaScript and XML”（异步的JavaScri
      
    
    </summary>
    
      <category term="javaScript基础" scheme="http://yoursite.com/categories/javaScript%E5%9F%BA%E7%A1%80/"/>
    
    
  </entry>
  
  <entry>
    <title>JSON的解析与序列化</title>
    <link href="http://yoursite.com/2019/09/30/JSON%E7%9A%84%E8%A7%A3%E6%9E%90%E4%B8%8E%E5%BA%8F%E5%88%97%E5%8C%96/"/>
    <id>http://yoursite.com/2019/09/30/JSON的解析与序列化/</id>
    <published>2019-09-30T06:51:09.000Z</published>
    <updated>2019-09-30T08:49:03.754Z</updated>
    
    <content type="html"><![CDATA[<h2 id="JSON简介"><a href="#JSON简介" class="headerlink" title="JSON简介"></a>JSON简介</h2><p>JSON（JavaScript Object Notation，JavaScript对象表示法）是一种数据格式，而不是一种编程语言。</p><p>我们可以使用JSON来通过网络进行数据交互和处理。</p><h3 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h3><p>JSON的语法可以表示一下三种类型的值：</p><ol><li>简单值：可以在JSON中表示字符串、数值、布尔值和null。但JSON不支持undefined</li><li>对象： 对象作为一种复杂数据类型，表示的是一组无序的键值对儿</li><li>数组</li></ol><p>值得注意的是：<br>除了undefined，JSON也不支持变量、函数或对象实例</p><p>另外，JSON字符串必须使用双引号（单引号会导致语法错误）</p><p>例如：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"name"</span>: <span class="string">"Ming"</span>,</span><br><span class="line">    <span class="attr">"age"</span>: <span class="number">18</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="解析与序列化"><a href="#解析与序列化" class="headerlink" title="解析与序列化"></a>解析与序列化</h2><h3 id="JavaScript对象序列化为JSON字符串"><a href="#JavaScript对象序列化为JSON字符串" class="headerlink" title="JavaScript对象序列化为JSON字符串"></a>JavaScript对象序列化为JSON字符串</h3><p>JSON.stringify() 方法是将一个JavaScript值(对象或者数组)转换为一个 JSON字符串，如果指定了replacer是一个函数，则可以选择性的替换值，或者如果指定了replacer是一个数组，可选择性的仅包含数组指定的属性。</p><p>语法</p><p>JSON.stringify(value[, replacer [, space]])</p><p>参数</p><p>value<br>    将要序列化成 一个JSON 字符串的值。</p><p>replacer 可选<br>    如果该参数是一个函数（传入的函数接受连个参数，属性名和属性值），则在序列化过程中，被序列化的值的每个属性都会经过该函数的转换和处理（值得注意的是，如果过滤器函数没有返回值或者显示返回undefined，那么相应的属性就会被忽略；因为JSON语法默认不支持undefined）；如果该参数是一个数组，则只有包含在这个数组中的属性名才会被序列化到最终的 JSON 字符串中；如果该参数为null或者未提供，则对象所有的属性都会被序列化；</p><p>space 可选<br>    指定缩进用的空白字符串，用于美化输出（pretty-print）；如果参数是个数字，它代表有多少的空格；上限为10。该值若小于1，则意味着没有空格；如果该参数为字符串(字符串的前十个字母)，该字符串将被作为空格；如果该参数没有提供（或者为null）将没有空格。</p><p>返回值 </p><p>一个表示给定值的JSON字符串。</p><p>例如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> test = &#123;</span><br><span class="line">    name: <span class="string">'Ming'</span>,</span><br><span class="line">    age: <span class="number">18</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 未传入过滤数组或过滤函数</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">JSON</span>.stringify(test,<span class="literal">null</span>,<span class="number">4</span>));</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">&#123;</span></span><br><span class="line"><span class="comment">    "name": "Ming",</span></span><br><span class="line"><span class="comment">    "age": 18</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 传入过滤数组</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">JSON</span>.stringify(test,[<span class="string">"name"</span>],<span class="number">4</span>));</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">&#123;</span></span><br><span class="line"><span class="comment">    "name": "Ming"</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 传入过滤函数</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">JSON</span>.stringify(test,<span class="function"><span class="keyword">function</span> (<span class="params">key,value</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(key===<span class="string">"name"</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"My name is"</span>+value;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> value;</span><br><span class="line">&#125;,<span class="number">4</span>))</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">&#123;</span></span><br><span class="line"><span class="comment">    "name": "My name isMing",</span></span><br><span class="line"><span class="comment">    "age": 18</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 值得注意的是，如果过滤器函数没有返回值或者显示返回undefined，那么相应的属性就会被忽略</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">JSON</span>.stringify(test,<span class="function"><span class="keyword">function</span>(<span class="params">key,value</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(key===<span class="string">"name"</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> value;</span><br><span class="line">&#125;,<span class="number">4</span>))</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">&#123;</span></span><br><span class="line"><span class="comment">    "age": 18</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h3 id="JSON字符串解析成原生JavaScript值"><a href="#JSON字符串解析成原生JavaScript值" class="headerlink" title="JSON字符串解析成原生JavaScript值"></a>JSON字符串解析成原生JavaScript值</h3><p>JSON.parse() 方法用来解析JSON字符串，构造由字符串描述的JavaScript值或对象。提供可选的reviver函数用以在返回之前对所得到的对象执行变换(操作)。</p><p>语法</p><p>JSON.parse(text[, reviver])</p><p>参数</p><p>text<br>    要被解析成JavaScript值的字符串，关于JSON的语法格式。</p><p>reviver 可选<br>    转换器, 如果传入该参数(函数)，可以用来修改解析生成的原始值。如果还原函数返回undefined，则表示要从结果中删除相应的键。（因为JSON语法默认不支持undefined）</p><p>返回值</p><p>Object类型, 对应给定JSON文本的对象/值。</p><p>异常</p><p>若传入的字符串不符合 JSON 规范，则会抛出 SyntaxError 异常。</p><h4 id="不传入还原函数"><a href="#不传入还原函数" class="headerlink" title="不传入还原函数"></a>不传入还原函数</h4><p>我们将JSON.parse()的第二个函数参数称之为还原参数</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> text = &#123;</span><br><span class="line">  name: <span class="string">'Ming'</span>,</span><br><span class="line">  age: <span class="number">18</span>,</span><br><span class="line">  friends: [</span><br><span class="line">      &#123;</span><br><span class="line">          name: <span class="string">'Lin'</span>,</span><br><span class="line">          age: <span class="number">19</span></span><br><span class="line">      &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> jsonText = <span class="built_in">JSON</span>.stringify(text,<span class="literal">null</span>,<span class="number">4</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> textCopy = <span class="built_in">JSON</span>.parse(jsonText);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(textCopy); <span class="comment">// &#123; name: 'Ming', age: 18, friends: [ &#123; name: 'Lin', age: 19 &#125; ] &#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(textCopy <span class="keyword">instanceof</span> <span class="built_in">Object</span>); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(textCopy===text); <span class="comment">// false</span></span><br><span class="line"><span class="built_in">console</span>.log(textCopy.friends[<span class="number">0</span>]===text.friends[<span class="number">0</span>]); <span class="comment">// false</span></span><br></pre></td></tr></table></figure><p>因此，我们经常使用JSON.parse(JSON.stringify(example))来深拷贝一个对象（注意：JSON语法不支持undefined与函数…）</p><h4 id="传入还原函数"><a href="#传入还原函数" class="headerlink" title="传入还原函数"></a>传入还原函数</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> text = &#123;</span><br><span class="line">    name: <span class="string">'Ming'</span>,</span><br><span class="line">    age: <span class="number">18</span>,</span><br><span class="line">    friends: [</span><br><span class="line">        &#123;</span><br><span class="line">            name: <span class="string">'Lin'</span>,</span><br><span class="line">            age: <span class="number">19</span></span><br><span class="line">        &#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> jsonText = <span class="built_in">JSON</span>.stringify(text,<span class="literal">null</span>,<span class="number">4</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> textCopy = <span class="built_in">JSON</span>.parse(jsonText,<span class="function"><span class="keyword">function</span>(<span class="params">key,value</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(key===<span class="string">"name"</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"My name is"</span>+value;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> value;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(textCopy);</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">&#123;</span></span><br><span class="line"><span class="comment">  name: 'My name isMing',</span></span><br><span class="line"><span class="comment">  age: 18,</span></span><br><span class="line"><span class="comment">  friends: [ &#123; name: 'My name isLin', age: 19 &#125; ]</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;JSON简介&quot;&gt;&lt;a href=&quot;#JSON简介&quot; class=&quot;headerlink&quot; title=&quot;JSON简介&quot;&gt;&lt;/a&gt;JSON简介&lt;/h2&gt;&lt;p&gt;JSON（JavaScript Object Notation，JavaScript对象表示法）是一种数据格
      
    
    </summary>
    
      <category term="javaScript基础" scheme="http://yoursite.com/categories/javaScript%E5%9F%BA%E7%A1%80/"/>
    
    
  </entry>
  
  <entry>
    <title>super关键字</title>
    <link href="http://yoursite.com/2019/09/26/super%E5%85%B3%E9%94%AE%E5%AD%97/"/>
    <id>http://yoursite.com/2019/09/26/super关键字/</id>
    <published>2019-09-26T14:15:44.000Z</published>
    <updated>2019-09-26T15:12:17.036Z</updated>
    
    <content type="html"><![CDATA[<h2 id="super关键字简介"><a href="#super关键字简介" class="headerlink" title="super关键字简介"></a>super关键字简介</h2><p>super关键字用于访问和调用一个对象的父对象上的函数。</p><p><strong>注意的是：</strong></p><blockquote><p>super关键字只能访问和调用函数，而不能访问父对象上的变量</p></blockquote><p>在构造函数中使用时，super关键字作为函数调用将单独出现，并且必须在使用this关键字之前使用。super关键字也可以用来调用父对象上的函数。</p><h3 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h3><pre><code>super([arguments]); // 调用 父对象/父类 的构造函数super.functionOnParent([arguments]); // 调用 父对象/父类 上的方法</code></pre><h2 id="super作为函数调用"><a href="#super作为函数调用" class="headerlink" title="super作为函数调用"></a>super作为函数调用</h2><p>super作为函数调用时，其代表着基类的构造函数。</p><p>此时，它的内部的this指向为当前子类的<strong>实例对象</strong>。</p><p>需要注意的是：</p><ol><li>我们只能在派生类的构造函数中使用super()。如果尝试在非派生类（不是用extends声明的类）或函数中使用则会导致程序错误</li><li>在构造函数中访问this前一定要调用super()，它负责初始化this。也就是说，虽然super()代表着基类的构造函数，但是内部的作用域指向还是当前类的作用域。</li></ol><p>示例：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Father</span></span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(item) &#123;</span><br><span class="line">        <span class="keyword">this</span>.item= item;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Son</span> <span class="keyword">extends</span> <span class="title">Father</span></span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(item,name) &#123;</span><br><span class="line">        <span class="keyword">super</span>(item);</span><br><span class="line">        <span class="keyword">this</span>.name= name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> son = <span class="keyword">new</span> Son(<span class="number">123</span>,<span class="string">'ming'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(son); <span class="comment">// Son &#123; item: 123, name: 'ming' &#125;</span></span><br></pre></td></tr></table></figure><p>上述代码中的super(item)其实相当于super.constructor.call(this)</p><h2 id="super作为对象调用"><a href="#super作为对象调用" class="headerlink" title="super作为对象调用"></a>super作为对象调用</h2><p>super 作为对象时，在普通方法和构造函数中，指向父类的原型对象，在静态方法中指向父类。</p><blockquote><p>super作为对象在普通方法和构造函数中的this指向当前子类的实例对象</p></blockquote><blockquote><p>super作为对象在静态方法中的this指向当前子类，而不是当前子类的对象</p></blockquote><p>接下来验证super作为对象在普通方法中被调用指向的是父类的原型对象</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(item) &#123;</span><br><span class="line">        <span class="keyword">this</span>.item= item;</span><br><span class="line">    &#125; </span><br><span class="line">    test() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">123</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> <span class="keyword">extends</span> <span class="title">A</span></span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(item) &#123;</span><br><span class="line">        <span class="keyword">super</span>(item);</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="keyword">super</span>.test());</span><br><span class="line">    &#125;</span><br><span class="line">    test() &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="keyword">super</span>.test===A.prototype.test);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> b = <span class="keyword">new</span> B(<span class="number">123</span>); <span class="comment">// 123</span></span><br><span class="line">b.test(); <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>接下来验证super作为对象在静态方法中被调用指向的是父类，而不是父类的原型对象</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span>&#123;</span><br><span class="line">    <span class="keyword">static</span> item= <span class="string">'A'</span>;</span><br><span class="line">    <span class="keyword">constructor</span>(item) &#123;</span><br><span class="line">        <span class="keyword">this</span>.item= item;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> getItem() &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'static'</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.item;</span><br><span class="line">    &#125;</span><br><span class="line">    getItem() &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'not static'</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.item;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> <span class="keyword">extends</span> <span class="title">A</span></span>&#123;</span><br><span class="line">    <span class="keyword">static</span> item= <span class="string">'B'</span>;</span><br><span class="line">    <span class="keyword">constructor</span>(item) &#123;</span><br><span class="line">        <span class="keyword">super</span>(item);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> getItem() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.getItem();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(B.getItem()); <span class="comment">// 'static' , 'B'</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;super关键字简介&quot;&gt;&lt;a href=&quot;#super关键字简介&quot; class=&quot;headerlink&quot; title=&quot;super关键字简介&quot;&gt;&lt;/a&gt;super关键字简介&lt;/h2&gt;&lt;p&gt;super关键字用于访问和调用一个对象的父对象上的函数。&lt;/p&gt;
&lt;p&gt;&lt;s
      
    
    </summary>
    
      <category term="ES6" scheme="http://yoursite.com/categories/ES6/"/>
    
    
  </entry>
  
  <entry>
    <title>Node的模块机制</title>
    <link href="http://yoursite.com/2019/09/25/Node%E7%9A%84%E6%A8%A1%E5%9D%97%E6%9C%BA%E5%88%B6/"/>
    <id>http://yoursite.com/2019/09/25/Node的模块机制/</id>
    <published>2019-09-25T02:26:54.000Z</published>
    <updated>2019-09-25T03:15:13.075Z</updated>
    
    <content type="html"><![CDATA[<p>模块加载优先级</p><ol><li>缓存模块</li><li>核心模块</li><li>文件模块</li><li>自定义模块</li></ol><p>exports仅仅是module.exports的一个地址引用。nodejs只会导出module.exports的指向，如果exports指向变了，那就仅仅是exports不在指向module.exports，于是不会再被导出</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;模块加载优先级&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;缓存模块&lt;/li&gt;
&lt;li&gt;核心模块&lt;/li&gt;
&lt;li&gt;文件模块&lt;/li&gt;
&lt;li&gt;自定义模块&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;exports仅仅是module.exports的一个地址引用。nodejs只会导出module.expor
      
    
    </summary>
    
      <category term="Node" scheme="http://yoursite.com/categories/Node/"/>
    
    
      <category term="Node" scheme="http://yoursite.com/tags/Node/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript常见错误类型</title>
    <link href="http://yoursite.com/2019/09/24/JavaScript%E5%B8%B8%E8%A7%81%E9%94%99%E8%AF%AF%E7%B1%BB%E5%9E%8B/"/>
    <id>http://yoursite.com/2019/09/24/JavaScript常见错误类型/</id>
    <published>2019-09-24T14:24:45.000Z</published>
    <updated>2019-09-24T14:29:19.620Z</updated>
    
    <content type="html"><![CDATA[<h2 id="JavaScript常见错误类型"><a href="#JavaScript常见错误类型" class="headerlink" title="JavaScript常见错误类型"></a>JavaScript常见错误类型</h2><p>JavaScript主要包括以下几种常见错误类型</p><ol><li><p>TypeError（类型错误） 对象用来表示值的类型非预期类型时发生的错误。</p><pre><code>当传入函数的操作数或参数的类型并非操作符或函数所预期的类型时，将抛出一个 TypeError 类型错误。</code></pre></li><li><p>SyntaxError 对象代表尝试解析语法上不合法的代码的错误</p><pre><code>当Javascript语言解析代码时,Javascript引擎发现了不符合语法规范的tokens或token顺序时抛出SyntaxError.</code></pre></li><li><p>ReferenceError（引用错误） 对象代表当一个不存在的变量被引用时发生的错误。</p><pre><code>当你尝试引用一个未被定义的变量时，将会抛出一个 ReferenceError 。</code></pre></li><li><p>RangeError对象标明一个错误，当一个值不在其所允许的范围或者集合中。</p></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;JavaScript常见错误类型&quot;&gt;&lt;a href=&quot;#JavaScript常见错误类型&quot; class=&quot;headerlink&quot; title=&quot;JavaScript常见错误类型&quot;&gt;&lt;/a&gt;JavaScript常见错误类型&lt;/h2&gt;&lt;p&gt;JavaScript主要包括
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>剑指Offer-求链表中的倒数第k个节点</title>
    <link href="http://yoursite.com/2019/09/23/%E5%89%91%E6%8C%87Offer-01/"/>
    <id>http://yoursite.com/2019/09/23/剑指Offer-01/</id>
    <published>2019-09-23T14:28:29.000Z</published>
    <updated>2019-09-23T15:01:27.978Z</updated>
    
    <content type="html"><![CDATA[<h1 id="求链表中的倒数第k个节点"><a href="#求链表中的倒数第k个节点" class="headerlink" title="求链表中的倒数第k个节点"></a>求链表中的倒数第k个节点</h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>输入：输入一个链表，输出该链表中倒数第k个节点。为了符合大多数人的习惯，本题从1开始计数，即链表的尾结点是倒数第一个节点。例如，一个链表有6个节点，从头结点开始，它们的值一次是1、2、3、4、5、6。这个链表的倒数第三个节点是值为4的节点。</p><p>链表节点定义如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*function ListNode(x)&#123;</span></span><br><span class="line"><span class="comment">    this.val = x;</span></span><br><span class="line"><span class="comment">    this.next = null;</span></span><br><span class="line"><span class="comment">&#125;*/</span></span><br></pre></td></tr></table></figure><h3 id="核心思路"><a href="#核心思路" class="headerlink" title="核心思路"></a>核心思路</h3><p>我们可以设置两个双指针，cur指向头结点，anotherCur指向第k-1个节点。然后两个节点分别往下走，当anotherCur节点指向最后一个节点时，也就意味着cur指向了该链表的倒数第k个节点</p><p>但是，我们需要注意一些输入的问题以及边界情况。</p><ol><li>输入链表head为空时的处理</li><li>k值小于等于0时的处理</li><li>k值大于链表长度时的处理</li></ol><h3 id="coding实现"><a href="#coding实现" class="headerlink" title="coding实现"></a>coding实现</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*function ListNode(x)&#123;</span></span><br><span class="line"><span class="comment">    this.val = x;</span></span><br><span class="line"><span class="comment">    this.next = null;</span></span><br><span class="line"><span class="comment">&#125;*/</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">FindKthToTail</span>(<span class="params">head, k</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(head===<span class="literal">null</span>||k&lt;=<span class="number">0</span>) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">let</span> cur = head;</span><br><span class="line">    <span class="keyword">let</span> anotherCur = head;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">1</span>;i&lt;k;i++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(anotherCur.next) &#123;</span><br><span class="line">            anotherCur = anotherCur.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(anotherCur.next) &#123;</span><br><span class="line">        anotherCur = anotherCur.next;</span><br><span class="line">        cur = cur.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> cur;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    FindKthToTail : FindKthToTail</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="时空复杂度分析"><a href="#时空复杂度分析" class="headerlink" title="时空复杂度分析"></a>时空复杂度分析</h3><ol><li>时间复杂度： O(n)</li><li>空间复杂度：O(1)</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;求链表中的倒数第k个节点&quot;&gt;&lt;a href=&quot;#求链表中的倒数第k个节点&quot; class=&quot;headerlink&quot; title=&quot;求链表中的倒数第k个节点&quot;&gt;&lt;/a&gt;求链表中的倒数第k个节点&lt;/h1&gt;&lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; cla
      
    
    </summary>
    
      <category term="剑指Offer" scheme="http://yoursite.com/categories/%E5%89%91%E6%8C%87Offer/"/>
    
    
  </entry>
  
  <entry>
    <title>webpack打包学习（一）</title>
    <link href="http://yoursite.com/2019/09/23/webpack%E6%89%93%E5%8C%85%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF/"/>
    <id>http://yoursite.com/2019/09/23/webpack打包学习之路/</id>
    <published>2019-09-23T13:44:00.000Z</published>
    <updated>2019-09-23T14:11:38.983Z</updated>
    
    <content type="html"><![CDATA[<h2 id="项目的基本搭建"><a href="#项目的基本搭建" class="headerlink" title="项目的基本搭建"></a>项目的基本搭建</h2><ol><li>新建一个项目并npm init为npm项目</li><li>安装webpck的相关模块，如下<ol><li>webpack </li><li>webpack-cli(webpack的命令行工具)</li><li>style-loader(通过向 DOM 中注入 &lt;style&gt; 标签实现css效果)</li><li>css-loader(解析引入的css文件)</li><li>file-loader(处理文件包括图片文件和字体文件)</li><li>webpack-dev-server(提供一个简单的web服务器)</li></ol></li><li>新建源代码文件夹src目录</li><li>新建输出文件夹dist目录，并将index.html放入改文件夹中</li><li>新建webpack.config.js配置文件</li></ol><h2 id="在src文件夹中"><a href="#在src文件夹中" class="headerlink" title="在src文件夹中"></a>在src文件夹中</h2><p>引入css文件方式如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">'./main.css'</span></span><br></pre></td></tr></table></figure><p>模块css-loader会处理引入的css代码，而style-loader则负责将该css代码注入到Dom中</p><p>引入图片和字体文件方式如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> img <span class="keyword">from</span> <span class="string">'./image.png'</span></span><br></pre></td></tr></table></figure><p>模块file-loader会处理这些图片和字体文件并进行打包</p><h2 id="编写webpack-config-js"><a href="#编写webpack-config-js" class="headerlink" title="编写webpack.config.js"></a>编写webpack.config.js</h2><p>webpack的打包都会按照这个文件的配置进行相应的打包</p><p>以上基本的打包实现如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Node.js的原生模块，用于将相对路径转化为绝对路径</span></span><br><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 利用Common.js模块的导出语法，导出基本的配置</span></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    <span class="comment">// 打包的入口</span></span><br><span class="line">    entry: &#123;</span><br><span class="line">        main: <span class="string">'./src/main.js'</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">// 打包的出口</span></span><br><span class="line">    output: &#123;</span><br><span class="line">        filename: <span class="string">'bundle.js'</span>, <span class="comment">// 打包的出口文件名</span></span><br><span class="line">        path: path.resolve(__dirname,<span class="string">'dist'</span>)<span class="comment">// __dirname是指当前的根目录，然后利用resolve函数就可以将__dirname于dist目录进行拼接然后转化为绝对路径，作为bundle.js文件的生成目录</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">// 用来追踪错误和警告</span></span><br><span class="line">    devtool: <span class="string">"inline-source-map"</span>,</span><br><span class="line">    <span class="comment">// 服务器配置</span></span><br><span class="line">    devServer: &#123;</span><br><span class="line">        <span class="comment">// 告诉服务器，将 dist 目录下的文件，作为可访问文件。</span></span><br><span class="line">        contentBase: <span class="string">'./dist'</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="built_in">module</span>: &#123;\</span><br><span class="line">    <span class="comment">// 创建模块时，匹配请求的规则数组。这些规则能够修改模块的创建方式。这些规则能够对模块(module)应用 loader，或者修改解析器(parser)。</span></span><br><span class="line">        rules: [</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// 正则表达式匹配rule条件</span></span><br><span class="line">                test: <span class="regexp">/.css$/</span>,</span><br><span class="line">                <span class="comment">//在规则条件匹配时使用的loader</span></span><br><span class="line">                use: [<span class="string">"style-loader"</span>,<span class="string">"css-loader"</span>]</span><br><span class="line">            &#125;,</span><br><span class="line">            &#123;</span><br><span class="line">                test: <span class="regexp">/.(jpg|png|jpeg|gif)$/</span>,</span><br><span class="line">                use: [<span class="string">"file-loader"</span>]</span><br><span class="line">            &#125;</span><br><span class="line">        ]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;项目的基本搭建&quot;&gt;&lt;a href=&quot;#项目的基本搭建&quot; class=&quot;headerlink&quot; title=&quot;项目的基本搭建&quot;&gt;&lt;/a&gt;项目的基本搭建&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;新建一个项目并npm init为npm项目&lt;/li&gt;
&lt;li&gt;安装webpck的相关模块
      
    
    </summary>
    
      <category term="webpack" scheme="http://yoursite.com/categories/webpack/"/>
    
    
      <category term="webpack" scheme="http://yoursite.com/tags/webpack/"/>
    
  </entry>
  
  <entry>
    <title>Vue父子组件传值详解</title>
    <link href="http://yoursite.com/2019/09/22/Vue%E7%88%B6%E5%AD%90%E7%BB%84%E4%BB%B6%E4%BC%A0%E5%80%BC%E8%AF%A6%E8%A7%A3/"/>
    <id>http://yoursite.com/2019/09/22/Vue父子组件传值详解/</id>
    <published>2019-09-22T06:24:07.000Z</published>
    <updated>2019-09-23T08:29:36.261Z</updated>
    
    <content type="html"><![CDATA[<h2 id="父组件向子组件传值"><a href="#父组件向子组件传值" class="headerlink" title="父组件向子组件传值"></a>父组件向子组件传值</h2><h3 id="Prop"><a href="#Prop" class="headerlink" title="Prop"></a>Prop</h3><p>Prop 是你可以在组件上注册的一些自定义特性。当一个值传递给一个 prop 特性的时候，它就变成了那个组件实例的一个属性。</p><p>因此，在子组件的方法代码中，我们可以使用this.xxx来访问到它</p><p>利用Prop单向数据流来使得父组件向子组件传值的基本格式如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 父组件 App.vue</span></span><br><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div id=<span class="string">"app"</span>&gt;</span><br><span class="line">    &lt;helloWorld :msg=<span class="string">"msg"</span>&gt;&lt;/helloWorld&gt;</span><br><span class="line">  &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">&lt;/</span>template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line"><span class="keyword">import</span> helloWorld <span class="keyword">from</span> <span class="string">'@/components/HelloWorld.vue'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  data() &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      msg: <span class="number">321</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  components: &#123;</span><br><span class="line">    helloWorld</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 子组件 HelloWorld.vue</span></span><br><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div <span class="class"><span class="keyword">class</span></span>=<span class="string">"hello"</span>&gt;</span><br><span class="line">    &#123;&#123;msg&#125;&#125;</span><br><span class="line">  &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">&lt;/</span>template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  props:[<span class="string">'msg'</span>]</span><br><span class="line">&#125;</span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br></pre></td></tr></table></figure><p>在上述父组件传值的时候是通过v-bind动态赋值的，但是我们也可以传递静态prop</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;hello-world msg=<span class="string">"qwer"</span>&gt;&lt;/hello-world&gt;</span><br></pre></td></tr></table></figure><p>注意的是，除了传入静态字符串之外，在传入静态的数值型，布尔型，对象型数据时我们依旧要使用v-bind来进行数据传输，否则就有可能造成数据传输失败</p><p>例如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">:msg=<span class="string">'11111'</span> <span class="comment">//number</span></span><br><span class="line">:msg=<span class="string">'true'</span> <span class="comment">//bootlean</span></span><br><span class="line">:msg=<span class="string">'()=&gt;&#123;console.log(1)&#125; //function </span></span><br><span class="line"><span class="string">:msg='</span>&#123;<span class="attr">a</span>:<span class="number">1</span>&#125;<span class="string">' //object</span></span><br></pre></td></tr></table></figure><p>因此，我们大可以使用v-bind动态传入，因为使用v-bind我们可以将字符串内的内容视为一个表达式进行计算</p><h3 id="单向数据流"><a href="#单向数据流" class="headerlink" title="单向数据流"></a>单向数据流</h3><p>所有的 prop 都使得其父子 prop 之间形成了一个单向下行绑定：父级 prop 的更新会向下流动到子组件中，但是反过来则不行。这样会防止从子组件意外改变父级组件的状态，从而导致你的应用的数据流向难以理解。</p><p>因此，只要父组件的数据发生了更新，子组件也会获得相应的更新。无论，发生更新的原因是异步操作还是事件操作</p><h3 id="vm-watch"><a href="#vm-watch" class="headerlink" title="vm.$watch"></a>vm.$watch</h3><p>当然，我们可以使用watch方法来监听父组件数据的改变</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在父组件进行异步操作，一开始初值为undefined，经过2000毫秒后变为12345</span></span><br><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div id=<span class="string">"app"</span>&gt;</span><br><span class="line">    &lt;helloWorld :msg=<span class="string">"msg"</span>&gt;&lt;/helloWorld&gt;</span><br><span class="line">  &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">&lt;/</span>template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line"><span class="keyword">import</span> helloWorld <span class="keyword">from</span> <span class="string">'@/components/HelloWorld.vue'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  data() &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      msg: <span class="literal">undefined</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  components: &#123;</span><br><span class="line">    helloWorld</span><br><span class="line">  &#125;,</span><br><span class="line">  created() &#123;</span><br><span class="line">    setTimeout(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">      <span class="keyword">this</span>.msg=<span class="number">12345</span>;</span><br><span class="line">    &#125;,<span class="number">2000</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在子组件中利用watch方法来进行监听父组件的prop值的变化</span></span><br><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div <span class="class"><span class="keyword">class</span></span>=<span class="string">"hello"</span>&gt;</span><br><span class="line">    &#123;&#123;msg&#125;&#125;</span><br><span class="line">  &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">&lt;/</span>template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  props:[<span class="string">'msg'</span>],</span><br><span class="line">  watch: &#123;</span><br><span class="line">    msg(val,oldVal)&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(val,oldVal); <span class="comment">// 12345,undefined </span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br></pre></td></tr></table></figure><h2 id="拦截数据，过滤处理"><a href="#拦截数据，过滤处理" class="headerlink" title="拦截数据，过滤处理"></a>拦截数据，过滤处理</h2><p>有时候，我们相对从父组件传过来的数据进行一些额外操作之后再进行渲染，此时我们可以利用计算属性来实现</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">computed: &#123;</span><br><span class="line">  anotherMsg() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.msg+<span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="子组件向父组件传值"><a href="#子组件向父组件传值" class="headerlink" title="子组件向父组件传值"></a>子组件向父组件传值</h2><h3 id="vm-on与vm-emit"><a href="#vm-on与vm-emit" class="headerlink" title="vm.$on与vm.$emit"></a>vm.$on与vm.$emit</h3><p>vm.$on要与vm.$emit搭配来进行使用</p><p>vue的api文档是这么描述这两个api的</p><h4 id="vm-on-event-callback"><a href="#vm-on-event-callback" class="headerlink" title="vm.$on( event, callback )"></a>vm.$on( event, callback )</h4><p>参数：</p><ol><li>{string | Array<string>} event (数组只在 2.2.0+ 中支持)</string></li><li>{Function} callback<br>用法：</li></ol><p>监听当前实例上的自定义事件。事件可以由vm.$emit触发。回调函数会接收所有传入事件触发函数的额外参数。</p><p>示例：</p><pre><code>vm.$on(&apos;test&apos;, function (msg) {console.log(msg)})vm.$emit(&apos;test&apos;, &apos;hi&apos;)// =&gt; &quot;hi&quot;</code></pre><h4 id="vm-emit-eventName-…args"><a href="#vm-emit-eventName-…args" class="headerlink" title="vm.$emit( eventName, […args] )"></a>vm.$emit( eventName, […args] )</h4><p>参数：</p><p>{string} eventName<br>[…args]</p><p>触发当前实例上的事件。附加参数都会传给监听器回调。</p><p>因此，我们可以在同一个实例上注册on监听事件函数以及emit响应事件函数</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  created() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.msg);</span><br><span class="line">    <span class="keyword">this</span>.$on(<span class="string">'test'</span>,(v)=&gt;&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(v);</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;,</span><br><span class="line">  methods: &#123;</span><br><span class="line">    change() &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">'emit'</span>);</span><br><span class="line">      <span class="keyword">this</span>.$emit(<span class="string">'test'</span>,<span class="number">123456789</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br></pre></td></tr></table></figure><p>我们在created生命周期时注册了一个监听test事件的on函数，在事件change()发生时，我们让test事件通过emit方法也进行发生。从而，监听函数会监听到该事件的发生并进行相应的输出</p><p>但是，虽然事件监听与响应都可以完成，但是这两个方法必须在同一个实例上才可以进行使用。因此，如果要进行子组件将值传递给父组件，我们可以使用v-on与vm.$emit进行搭配使用</p><h3 id="v-on与vm-emit"><a href="#v-on与vm-emit" class="headerlink" title="v-on与vm.$emit"></a>v-on与vm.$emit</h3><p>因为父组件可以在使用子组件的引入模板直接用 v-on 来监听子组件触发的事件。因此，我们可以使用v-on和vm.$emit来使得子组件向父组件传值</p><p>例如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 父组件</span></span><br><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div id=<span class="string">"app"</span>&gt;</span><br><span class="line">  <span class="comment">// 在子组件的引入模板中使用v-on来进行监听子组件中的test事件</span></span><br><span class="line">  <span class="comment">// 注意，@后必须是在子组件中要监听的事件名，而双引号中是父组件对于监听到事件发生后做出的处理函数。对于该例中，也就是test是要监听的事件名，getSonValue是父组件的处理函数</span></span><br><span class="line">    &lt;helloWorld :msg=<span class="string">"msg"</span> @test=<span class="string">'getSonValue'</span>&gt;&lt;/helloWorld&gt;</span><br><span class="line">  &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">&lt;/</span>template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line"><span class="keyword">import</span> helloWorld <span class="keyword">from</span> <span class="string">'@/components/HelloWorld.vue'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  methods: &#123;</span><br><span class="line">    getSonValue(v) &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">'v'</span>,v);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">methods: &#123;</span><br><span class="line">  change() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'emit'</span>);</span><br><span class="line">    <span class="comment">// 发布事件test，并传入参数123456789</span></span><br><span class="line">    <span class="keyword">this</span>.$emit(<span class="string">'test'</span>,<span class="number">123456789</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="同级组件通信"><a href="#同级组件通信" class="headerlink" title="同级组件通信"></a>同级组件通信</h2><p>同级组件通信，也就是意味着某个父组件下有两个不同的子组件，这两个组件之间可以通信</p><h3 id="父组件作为中转站"><a href="#父组件作为中转站" class="headerlink" title="父组件作为中转站"></a>父组件作为中转站</h3><p>一种可行的办法，就是父组件接收其中一个组件传递的值并将该值传递给另外一个子组件</p><p>例如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 父组件</span></span><br><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div id=<span class="string">"app"</span>&gt;</span><br><span class="line">    &lt;component1 @msg=<span class="string">"getMsg"</span>&gt;&lt;/component1&gt;</span><br><span class="line">    &lt;component2 :msg=<span class="string">"msg"</span>&gt;&lt;/component2&gt;</span><br><span class="line">  &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">&lt;/</span>template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line"><span class="keyword">import</span> component1 <span class="keyword">from</span> <span class="string">'@/components/Component1'</span></span><br><span class="line"><span class="keyword">import</span> component2 <span class="keyword">from</span> <span class="string">'@/components/Component2'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  components: &#123;</span><br><span class="line">    component1,</span><br><span class="line">    component2</span><br><span class="line">  &#125;,</span><br><span class="line">  methods: &#123;</span><br><span class="line">    getMsg(v) &#123;</span><br><span class="line">      <span class="keyword">this</span>.msg=v;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  data() &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      msg: <span class="literal">undefined</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 子组件1</span></span><br><span class="line">&lt;template&gt;</span><br><span class="line">    &lt;div id=<span class="string">"component1"</span>&gt;</span><br><span class="line">        &lt;div&gt;</span><br><span class="line">            子组件<span class="number">1</span>的值为：&#123;&#123;msg&#125;&#125;</span><br><span class="line">        &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">        &lt;button @click="sendMsg"&gt;click&lt;/</span>button&gt;</span><br><span class="line">    &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">&lt;/</span>template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">    data() &#123;</span><br><span class="line">        <span class="keyword">return</span> &#123;</span><br><span class="line">            msg: <span class="number">123</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    methods: &#123;</span><br><span class="line">        sendMsg() &#123;</span><br><span class="line">            <span class="keyword">this</span>.$emit(<span class="string">'msg'</span>,<span class="keyword">this</span>.msg);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">    &lt;div id=<span class="string">"component2"</span>&gt;</span><br><span class="line">        子组件<span class="number">2</span>的值为：&#123;&#123;msg&#125;&#125;</span><br><span class="line">    &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">&lt;/</span>template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">    props: [<span class="string">'msg'</span>]</span><br><span class="line">&#125;</span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br></pre></td></tr></table></figure><p>当子组件1点击按钮后，子组件2就可以获得组件1传过来的msg值</p><h3 id="额外实例作为中央事件总线"><a href="#额外实例作为中央事件总线" class="headerlink" title="额外实例作为中央事件总线"></a>额外实例作为中央事件总线</h3><p>因为ES6的模块机制有一个特性</p><blockquote><p>当模块内部发生变化的时候，引入模块的部分同样会发生变化</p></blockquote><p>因此，我们可以创建一个额外的实例,并且在两个子组件中分别绑定vm.$emit方法进行事件发放和vm.$on方法进行事件监听</p><ol><li><p>创建额外实例</p> <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// eventBus.js</span></span><br><span class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">'vue'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">new</span> Vue();</span><br></pre></td></tr></table></figure></li><li><p>在子组件1中引入该实例，并为其绑定分发事件vm.$emit方法</p> <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">    &lt;div id=<span class="string">"component1"</span>&gt;</span><br><span class="line">        &lt;div&gt;</span><br><span class="line">            子组件<span class="number">1</span>的值为：&#123;&#123;msg&#125;&#125;</span><br><span class="line">        &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">        &lt;button @click="sendMsg"&gt;click&lt;/</span>button&gt;</span><br><span class="line">    &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">&lt;/</span>template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line"><span class="keyword">import</span> eventBus <span class="keyword">from</span> <span class="string">'@/components/eventBus.js'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">    data() &#123;</span><br><span class="line">        <span class="keyword">return</span> &#123;</span><br><span class="line">            msg: <span class="number">123</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    methods: &#123;</span><br><span class="line">        sendMsg() &#123;</span><br><span class="line">            <span class="built_in">console</span>.log(eventBus);</span><br><span class="line">            eventBus.$emit(<span class="string">'msg'</span>,<span class="keyword">this</span>.msg);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>在子组件2中引入额外实例并为其绑定监听事件vm.$on方法</p> <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">    &lt;div id=<span class="string">"component2"</span>&gt;</span><br><span class="line">        子组件<span class="number">2</span>的值为：&#123;&#123;msg&#125;&#125;</span><br><span class="line">    &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">&lt;/</span>template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line"><span class="keyword">import</span> eventBus <span class="keyword">from</span> <span class="string">'@/components/eventBus.js'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">    created() &#123;</span><br><span class="line">        eventBus.$on(<span class="string">'msg'</span>,(v)=&gt;&#123;</span><br><span class="line">            <span class="keyword">this</span>.msg=v;</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;,</span><br><span class="line">    data() &#123;</span><br><span class="line">        <span class="keyword">return</span> &#123;</span><br><span class="line">            msg: <span class="literal">undefined</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br></pre></td></tr></table></figure></li></ol><p>经过上述三步后，子组件2在created生命周期时就已经在额外实例上创建了事件监听方法。因此，当子组件1点击按钮之后就会向额外实例分发了一个事件msg;那么，额外实例就会监听到该事件的发生并作出处理函数，这样也就完成了两个同级组件之间的传值</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;父组件向子组件传值&quot;&gt;&lt;a href=&quot;#父组件向子组件传值&quot; class=&quot;headerlink&quot; title=&quot;父组件向子组件传值&quot;&gt;&lt;/a&gt;父组件向子组件传值&lt;/h2&gt;&lt;h3 id=&quot;Prop&quot;&gt;&lt;a href=&quot;#Prop&quot; class=&quot;headerli
      
    
    </summary>
    
      <category term="Vue" scheme="http://yoursite.com/categories/Vue/"/>
    
    
      <category term="Vue" scheme="http://yoursite.com/tags/Vue/"/>
    
  </entry>
  
  <entry>
    <title>nowcoder-2</title>
    <link href="http://yoursite.com/2019/09/19/nowcoder-2/"/>
    <id>http://yoursite.com/2019/09/19/nowcoder-2/</id>
    <published>2019-09-19T12:45:10.000Z</published>
    <updated>2019-09-19T12:53:11.846Z</updated>
    
    <content type="html"><![CDATA[<h1 id="数组的相对排序"><a href="#数组的相对排序" class="headerlink" title="数组的相对排序"></a>数组的相对排序</h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>请实现一个函数，将一个字符串中的每个空格替换成“%20”。例如，当字符串为We Are Happy.则经过替换之后的字符串为We%20Are%20Happy。</p><h2 id="核心思路"><a href="#核心思路" class="headerlink" title="核心思路"></a>核心思路</h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>题意很简单，就是将所有的空格转化为’%20’的格式。因此，我们可以使用replace()方法来进行替换值，当然是使用正则表达式来进行匹配</p><h2 id="Coding实现"><a href="#Coding实现" class="headerlink" title="Coding实现"></a>Coding实现</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">replaceSpace</span>(<span class="params">str</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">let</span> pattern=<span class="regexp">/\s/g</span>;</span><br><span class="line">    <span class="keyword">return</span> str.replace(pattern,<span class="string">'%20'</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    replaceSpace : replaceSpace</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="时空复杂度分析"><a href="#时空复杂度分析" class="headerlink" title="时空复杂度分析"></a>时空复杂度分析</h2><ol><li>时间复杂度：O(1)</li><li>空间复杂度：O(1)</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;数组的相对排序&quot;&gt;&lt;a href=&quot;#数组的相对排序&quot; class=&quot;headerlink&quot; title=&quot;数组的相对排序&quot;&gt;&lt;/a&gt;数组的相对排序&lt;/h1&gt;&lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; titl
      
    
    </summary>
    
      <category term="牛客网算法题刷题记录" scheme="http://yoursite.com/categories/%E7%89%9B%E5%AE%A2%E7%BD%91%E7%AE%97%E6%B3%95%E9%A2%98%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/"/>
    
    
  </entry>
  
  <entry>
    <title>leetcode-367 有效的完全平方数</title>
    <link href="http://yoursite.com/2019/09/18/leetcode-367/"/>
    <id>http://yoursite.com/2019/09/18/leetcode-367/</id>
    <published>2019-09-18T12:50:53.000Z</published>
    <updated>2019-09-18T13:03:51.969Z</updated>
    
    <content type="html"><![CDATA[<h1 id="有效的完全平方数"><a href="#有效的完全平方数" class="headerlink" title="有效的完全平方数"></a>有效的完全平方数</h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>给定一个正整数 num，编写一个函数，如果 num 是一个完全平方数，则返回 True，否则返回 False。</p><p>说明：不要使用任何内置的库函数，如  sqrt。</p><p>示例 1：</p><blockquote><p>输入：16<br>输出：True</p></blockquote><p>示例 2：</p><blockquote><p>输入：14<br>输出：False</p></blockquote><a id="more"></a><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/valid-perfect-square" target="_blank" rel="noopener">https://leetcode-cn.com/problems/valid-perfect-square</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p><h2 id="核心思路"><a href="#核心思路" class="headerlink" title="核心思路"></a>核心思路</h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>我们知道，对于大于等于4的完全平方数，它的平方根会小于或等于它的一半。因此，我们可以在2~n/2之间进行二分查找，来降低时间复杂度</p><h3 id="解题步骤"><a href="#解题步骤" class="headerlink" title="解题步骤"></a>解题步骤</h3><ol><li>如果给定的数为1，返回true</li><li>设定left为2，right为Math.floor(num/2)，mid为Math.floor((left+right)/2)；如果mid*mid===num那么返回true；如果小于，则left=mid+1;<br>否则right=mid-1;</li><li>重复步骤2知道right&gt;left</li><li>如果上述二分过程中没有返回true，那么返回false</li></ol><h2 id="Coding实现"><a href="#Coding实现" class="headerlink" title="Coding实现"></a>Coding实现</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @param &#123;number&#125; num</span></span><br><span class="line"><span class="comment"> * @return &#123;boolean&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> isPerfectSquare = <span class="function"><span class="keyword">function</span>(<span class="params">num</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(num===<span class="number">1</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">let</span> left=<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">let</span> right=<span class="built_in">Math</span>.floor(num/<span class="number">2</span>);</span><br><span class="line">    <span class="keyword">let</span> mid;</span><br><span class="line">    <span class="keyword">while</span>(left&lt;=right) &#123;</span><br><span class="line">        mid=<span class="built_in">Math</span>.floor((left+right)/<span class="number">2</span>);</span><br><span class="line">        <span class="keyword">if</span>(mid*mid===num) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(mid*mid&gt;num) &#123;</span><br><span class="line">            right=mid<span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            left=mid+<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;有效的完全平方数&quot;&gt;&lt;a href=&quot;#有效的完全平方数&quot; class=&quot;headerlink&quot; title=&quot;有效的完全平方数&quot;&gt;&lt;/a&gt;有效的完全平方数&lt;/h1&gt;&lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h2&gt;&lt;p&gt;给定一个正整数 num，编写一个函数，如果 num 是一个完全平方数，则返回 True，否则返回 False。&lt;/p&gt;
&lt;p&gt;说明：不要使用任何内置的库函数，如  sqrt。&lt;/p&gt;
&lt;p&gt;示例 1：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;输入：16&lt;br&gt;输出：True&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;示例 2：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;输入：14&lt;br&gt;输出：False&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="leetcode题解与算法" scheme="http://yoursite.com/categories/leetcode%E9%A2%98%E8%A7%A3%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="二分查找" scheme="http://yoursite.com/tags/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/"/>
    
  </entry>
  
  <entry>
    <title>nowcoder-1 二维数组中的查找</title>
    <link href="http://yoursite.com/2019/09/17/nowcoder-1/"/>
    <id>http://yoursite.com/2019/09/17/nowcoder-1/</id>
    <published>2019-09-17T14:51:49.000Z</published>
    <updated>2019-09-17T15:14:53.238Z</updated>
    
    <content type="html"><![CDATA[<h1 id="数组的相对排序"><a href="#数组的相对排序" class="headerlink" title="数组的相对排序"></a>数组的相对排序</h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>在一个二维数组中（每个一维数组的长度相同），每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。</p><h2 id="核心思路"><a href="#核心思路" class="headerlink" title="核心思路"></a>核心思路</h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><ol><li>最直接的暴力解法<br>遍历二维数组中的每一个元素，返回是否能找到给定的target值</li><li>利用ES6特性，将数组扁平化（但是牛客网并没有很好地支持flat()函数，因此我们可以使用concat()方法来实现扁平化）后使用includes()函数进行查找</li><li>巧妙一点的方法是：由于该二维数组的规律（每一行从左往右递增，每一列从上往下递增），我们可以发现二维数组的左下角总是当前行的最小值，当前列的最大值。因此，当给定值大于当前左下角的数值时，我们就将该数往右移动一位；当给定值小于当前左下角的数值时，我们就将该数往上移动一位。直到找到该值返回true，或者遍历到右上角仍然没有找到返回false</li></ol><h3 id="解题步骤"><a href="#解题步骤" class="headerlink" title="解题步骤"></a>解题步骤</h3><h2 id="Coding实现"><a href="#Coding实现" class="headerlink" title="Coding实现"></a>Coding实现</h2><p>通过concat()扁平化后利用includes()来查找</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Find</span>(<span class="params">target, array</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">let</span> arr=[].concat(...array);</span><br><span class="line">    <span class="keyword">return</span> arr.includes(target);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    Find : Find</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>左下到右上的查找</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Find</span>(<span class="params">target, array</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">let</span> column=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">let</span> row=array.length<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">let</span> num;</span><br><span class="line">    <span class="keyword">while</span>(column&lt;array[<span class="number">0</span>].length&amp;&amp;row&gt;=<span class="number">0</span>)&#123;</span><br><span class="line">        num=array[row][column];</span><br><span class="line">        <span class="keyword">if</span>(target&gt;num) &#123;</span><br><span class="line">            column++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(target&lt;num) &#123;</span><br><span class="line">            row--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    Find : Find</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;数组的相对排序&quot;&gt;&lt;a href=&quot;#数组的相对排序&quot; class=&quot;headerlink&quot; title=&quot;数组的相对排序&quot;&gt;&lt;/a&gt;数组的相对排序&lt;/h1&gt;&lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; titl
      
    
    </summary>
    
      <category term="牛客网算法题刷题记录" scheme="http://yoursite.com/categories/%E7%89%9B%E5%AE%A2%E7%BD%91%E7%AE%97%E6%B3%95%E9%A2%98%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/"/>
    
    
  </entry>
  
  <entry>
    <title>模块化</title>
    <link href="http://yoursite.com/2019/09/16/%E6%A8%A1%E5%9D%97%E5%8C%96/"/>
    <id>http://yoursite.com/2019/09/16/模块化/</id>
    <published>2019-09-16T08:28:58.000Z</published>
    <updated>2019-09-24T14:18:52.176Z</updated>
    
    <content type="html"><![CDATA[<h2 id="模块与脚本的区别"><a href="#模块与脚本的区别" class="headerlink" title="模块与脚本的区别"></a>模块与脚本的区别</h2><p>模块不会将它的顶级变量、函数和类作为全局作用域的全局变量，并且模块顶级作用域的this值为undefined</p><h2 id="为什么要模块化"><a href="#为什么要模块化" class="headerlink" title="为什么要模块化"></a>为什么要模块化</h2><p>模块化可以将一个复杂的功能拆分为几个小功能，并且功能模块之间不会互相影响。这样就可以使得代码低耦合</p><p>另外，因为每个模块声明的变量并不会影响全局作用域，因此就不会有全局变量污染以及命名冲突的问题</p><p>每个模块都是独立的，因此模块具有良好的可复用性</p><h2 id="CommonJs模块化"><a href="#CommonJs模块化" class="headerlink" title="CommonJs模块化"></a>CommonJs模块化</h2><p>Node.js是commonJS规范的主要实践者，它有四个重要的环境变量为模块化的实现提供支持：module、exports、require、global。实际使用时，用module.exports定义当前模块对外输出的接口（不推荐直接用exports），用require加载模块。</p><p>例如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义模块module.js</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> a=<span class="number">1</span>;</span><br><span class="line"><span class="built_in">module</span>.exports.test=<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(a);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义test模块并引入module模块</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> m=<span class="built_in">require</span>(<span class="string">'./test'</span>)</span><br><span class="line"></span><br><span class="line">m.test(); <span class="comment">// 1</span></span><br></pre></td></tr></table></figure><h2 id="Es6模块化"><a href="#Es6模块化" class="headerlink" title="Es6模块化"></a>Es6模块化</h2><h3 id="基本语法"><a href="#基本语法" class="headerlink" title="基本语法"></a>基本语法</h3><h4 id="导出的几种形式"><a href="#导出的几种形式" class="headerlink" title="导出的几种形式"></a>导出的几种形式</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义的同时，导出单个变量、对象、函数或类</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> a=<span class="number">1</span>；</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> b=&#123;<span class="attr">item</span>:<span class="number">1</span>&#125;;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> c=<span class="function"><span class="params">()</span>=&gt;</span><span class="number">1</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="class"><span class="keyword">class</span> <span class="title">C</span></span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(item) &#123;</span><br><span class="line">        <span class="keyword">this</span>.item=item;</span><br><span class="line">    &#125;</span><br><span class="line">    getItem()&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.item;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在定义之后导出单个变量</span></span><br><span class="line"><span class="keyword">const</span> a=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">export</span> a;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在定义之后导出多个变量</span></span><br><span class="line"><span class="keyword">const</span> a=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">const</span> b=<span class="number">2</span>;</span><br><span class="line"><span class="keyword">export</span> &#123;a,b&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 导出时重命名，使用as关键字来指定变量等在模块外应该被称为什么名称,同时需要使用大括号</span></span><br><span class="line"><span class="keyword">const</span> a=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">export</span> &#123;a <span class="keyword">as</span> itemA&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 重命名多个变量</span></span><br><span class="line"><span class="keyword">const</span> a=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">const</span> b=<span class="number">2</span>;</span><br><span class="line"><span class="keyword">export</span> &#123;a <span class="keyword">as</span> itemA,b <span class="keyword">as</span> itemB&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 导出模块的默认值，模块的默认值通过default关键字来指定。一个模块只能导出一个默认值（单个变量，函数，类，对象等）</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">    item:<span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 重新导出一个引入的绑定</span></span><br><span class="line"><span class="keyword">import</span> &#123;a&#125; <span class="keyword">from</span> <span class="string">'./m.js'</span></span><br><span class="line"><span class="keyword">export</span> &#123;a&#125;; <span class="comment">// 导出非默认值绑定</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> &#123;a&#125; <span class="keyword">from</span> <span class="string">'./m.js'</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> a; <span class="comment">// 导出默认值绑定</span></span><br></pre></td></tr></table></figure><h4 id="导入的几种形式"><a href="#导入的几种形式" class="headerlink" title="导入的几种形式"></a>导入的几种形式</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 仅为副作用而导入一个模块,整个模块仅为副作用（中性词，无贬义含义）而导入，而不导入模块中的任何内容（接口）。 这将运行模块中的全局代码, 但实际上不导入任何值。</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="keyword">from</span> <span class="string">'./test.js'</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//导入非默认值单个变量</span></span><br><span class="line"><span class="keyword">import</span> &#123;a&#125; <span class="keyword">from</span> <span class="string">'./test.js'</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 导入非默认值多个变量</span></span><br><span class="line"><span class="keyword">import</span> &#123;a,b&#125; <span class="keyword">from</span> <span class="string">'./test.js'</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 导入整个模块</span></span><br><span class="line"><span class="keyword">import</span> * <span class="keyword">from</span> <span class="string">'./test.js'</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 导入默认值时不需要大括号语法</span></span><br><span class="line"><span class="keyword">import</span> a <span class="keyword">from</span> <span class="string">'./test.js'</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 导入默认值和非默认值，注意默认值必须排在非默认值前</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> a=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">const</span> b=<span class="number">2</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> b;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> b,&#123;a&#125; <span class="keyword">from</span> <span class="string">'./test.js'</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 导入非默认值时重命名，导入默认值则无法重命名，因为默认值的导入变量命名本来就是自己定义的</span></span><br><span class="line"><span class="keyword">import</span> &#123;a <span class="keyword">as</span> itemA&#125; <span class="keyword">from</span> <span class="string">'./test.js'</span></span><br></pre></td></tr></table></figure><p>注意：导入非默认值绑定看起来像是解构对象，但事实上它不是</p><h2 id="模块化的一些注意点"><a href="#模块化的一些注意点" class="headerlink" title="模块化的一些注意点"></a>模块化的一些注意点</h2><p>以下是我们需要注意的地方</p><ol><li><p>当从另一个模块中导入一个绑定，该绑定就好像是使用const定义的一样。我们无法对它进行修改和重命名。</p> <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> b,&#123;a <span class="keyword">as</span> itemA&#125; <span class="keyword">from</span> <span class="string">'./test.js'</span></span><br><span class="line">b=<span class="number">1</span>; <span class="comment">// 报错："b" is read-only.</span></span><br><span class="line"><span class="built_in">console</span>.log(b,itemA);</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> b,&#123;a <span class="keyword">as</span> itemA&#125; <span class="keyword">from</span> <span class="string">'./test.js'</span></span><br><span class="line"><span class="keyword">let</span> b=<span class="number">1</span>; <span class="comment">// 报错： Identifier 'b' has already been declared</span></span><br><span class="line"><span class="built_in">console</span>.log(b,itemA);</span><br></pre></td></tr></table></figure></li><li><p>使用import语法时要引入的模块文件必须要加上文件后缀，例如’./test.js’；而node.js则遵循基于文件系统前缀来区分文件和包的惯例。例如，example是一个包，而example.js是一个本地文件</p></li><li><p>为了最好地兼容多个浏览器和Node.js环境，一定要在模块文件名前包含/、./或../来表示要导入的文件</p></li><li><p>模块只会执行一次，无论你多少次导入同一模块。当导入模块的代码执行后，实例化过的模块就会被保存在内存中，只要另一个import语句引用它就可以重复使用</p> <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;a&#125; <span class="keyword">from</span> <span class="string">'./test.js'</span>;  <span class="comment">// 该模块只会执行这一次</span></span><br><span class="line"><span class="keyword">import</span> &#123;b&#125; <span class="keyword">from</span> <span class="string">'./test.js'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123;c&#125; <span class="keyword">from</span> <span class="string">'./test.js'</span>;</span><br></pre></td></tr></table></figure></li><li><p>模块语法只能在当前模块顶部(也就是该模块的最外层执行环境)使用</p></li><li><p>导入模块的标识符只是本地的一个变量名称，并不等于被引入的模块中的同名变量</p></li><li><p>模块只能设置一个默认的导出值</p></li></ol><h2 id="CommonJs模块化与ES6模块化的区别"><a href="#CommonJs模块化与ES6模块化的区别" class="headerlink" title="CommonJs模块化与ES6模块化的区别"></a>CommonJs模块化与ES6模块化的区别</h2><ol><li>调用时间<ol><li>require是运行时调用，也就是只有代码运行到require命令时，才会运行和导入其他模块。所以,require可以放在代码的任何地方</li><li>import是编译时调用，因此，进入有import命令的模块时，被导入模块会第一时间被运行和导入，然后才会运行其他代码</li></ol></li></ol><p>例如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// module1.js</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'module1.js'</span>);</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">    item: <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// module2.js</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'module2.js'</span>);</span><br><span class="line"><span class="keyword">import</span> m <span class="keyword">from</span> <span class="string">'./module1.js'</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(m);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 运行module2.js结果如下：</span></span><br><span class="line"><span class="string">'module1.js'</span>,</span><br><span class="line"><span class="string">'module2.js'</span>,</span><br><span class="line">&#123;<span class="attr">item</span>:<span class="number">1</span>&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;模块与脚本的区别&quot;&gt;&lt;a href=&quot;#模块与脚本的区别&quot; class=&quot;headerlink&quot; title=&quot;模块与脚本的区别&quot;&gt;&lt;/a&gt;模块与脚本的区别&lt;/h2&gt;&lt;p&gt;模块不会将它的顶级变量、函数和类作为全局作用域的全局变量，并且模块顶级作用域的this值为u
      
    
    </summary>
    
      <category term="ES6" scheme="http://yoursite.com/categories/ES6/"/>
    
    
  </entry>
  
  <entry>
    <title>js事件循环机制 event loop</title>
    <link href="http://yoursite.com/2019/09/13/%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF%E6%9C%BA%E5%88%B6/"/>
    <id>http://yoursite.com/2019/09/13/事件循环机制/</id>
    <published>2019-09-13T12:36:20.000Z</published>
    <updated>2019-09-29T15:06:24.385Z</updated>
    
    <content type="html"><![CDATA[<h2 id="为什么js是单线程的"><a href="#为什么js是单线程的" class="headerlink" title="为什么js是单线程的"></a>为什么js是单线程的</h2><p>众所周知，JavaScript是一门单线程语言。那么，为什么js必须是单线程的呢？</p><p>因为，js主要的宿主环境就是浏览器，并且其一个重要的用途就是来操作Dom。反过来思考，如果js是多线程的，那么就会允许同一时间有多个代码块运行。那么，如果这多个代码块同时操作同一个Dom，比如，一个代码块要修改某dom元素，而另一个代码块又要删除这个元素，那么浏览器该如何处理这个元素。因此，为了避免这种复杂性，js必须是单线程的</p><h2 id="执行栈（调用栈）与任务队列"><a href="#执行栈（调用栈）与任务队列" class="headerlink" title="执行栈（调用栈）与任务队列"></a>执行栈（调用栈）与任务队列</h2><h3 id="什么是执行栈（调用栈）"><a href="#什么是执行栈（调用栈）" class="headerlink" title="什么是执行栈（调用栈）"></a>什么是执行栈（调用栈）</h3><p>执行栈，也就是“调用栈”，是一种拥有 LIFO（后进先出）数据结构的栈，被用来存储代码运行时创建的所有执行上下文（包括全局执行上下文，局部函数执行上下文以及eval函数执行上下文）。</p><p>注意，因为JavaScript是单线程的，因此，其只有一个调用栈</p><p>例如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">a</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    b();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">b</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">a();</span><br></pre></td></tr></table></figure><p>对于以上代码，执行栈里面的任务是这样依次出入栈的：</p><ol><li>进入该段整体代码 main()入栈</li><li>执行a() a()入栈</li><li>调用b b()入栈</li><li>执行b函数 console.log(1)入栈</li><li>输出完毕，console.log(1)出栈</li><li>b()出栈</li><li>a()出栈</li><li>main()出栈，代码执行完毕</li></ol><h3 id="任务"><a href="#任务" class="headerlink" title="任务"></a>任务</h3><p>众所周知，我们可以将js的任务分为两大类：</p><h4 id="同步任务"><a href="#同步任务" class="headerlink" title="同步任务"></a>同步任务</h4><p>优先级最高，运行时立刻进入主线程运行</p><h4 id="异步任务"><a href="#异步任务" class="headerlink" title="异步任务"></a>异步任务</h4><p>只有当所有同步任务执行完毕后才会去执行异步任务，异步任务的执行过程如下：</p><ol><li>异步任务进入Event Table执行，并且注册回调函数</li><li>当指定的异步任务完成时，Event Table会将这个回调函数移入Event Queue（值得注意的是，当有多个异步任务时，先执行完毕的异步任务的回调函数会先进入该任务队列）</li><li>主线程内的任务执行完毕为空，会去Event Queue读取对应的函数，进入主线程执行</li><li>上述过程会不断重复，这也是我们后面会提到的事件循环</li></ol><p>上述的event queue指的是就是任务队列，任务队列内存放的都是异步任务完成后要执行的函数</p><p>另外，我们需要注意的是，只有异步任务完成之后要执行的回调函数才会被放入任务队列，等待主线程中的所有同步代码被执行完毕之后再执行。</p><p>因此，比如在new Promise过程中不再回调函数内的代码都是同步代码，只有then()和catch()中的回调函数才是异步代码</p><p>例如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve,reject</span>)=&gt;</span>&#123; <span class="comment">// 第一行</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">1</span>);  <span class="comment">// 第二行</span></span><br><span class="line">    resolve(<span class="number">2</span>); <span class="comment">//第三行</span></span><br><span class="line">&#125;).then(<span class="function">(<span class="params">v</span>)=&gt;</span>&#123; <span class="comment">// 第四行</span></span><br><span class="line">    <span class="built_in">console</span>.log(v); <span class="comment">// 第五行</span></span><br><span class="line">&#125;) <span class="comment">// 第六行</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出结果</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">2</span></span><br></pre></td></tr></table></figure><p>其中，第1,2,3,4,6行都是同步代码，只有第5行是异步的代码</p><p>以下是任务执行过程:</p><p><img src="https://s2.ax1x.com/2019/09/28/ulg28I.png" alt></p><h4 id="宏任务与微任务"><a href="#宏任务与微任务" class="headerlink" title="宏任务与微任务"></a>宏任务与微任务</h4><p>任务也可以更加被细分为宏任务与微任务两种，具体如下</p><ol><li>宏任务(macrotask)：<br> script(整体代码)、setTimeout、setInterval、UI 渲染、 I/O、postMessage、 MessageChannel、setImmediate(Node.js 环境)、ajax、外部请求等</li><li>微任务(microtask)：<br> Promise.then/catch、 MutaionObserver、process.nextTick(Node.js环境）</li></ol><p>那么宏任务与微任务的执行顺序是怎么样的呢？</p><p>网络上有两种说法，目前我还没有看到权威文章</p><ol><li><p>如果，我们将整个script(整体代码)也算做是一个宏任务，那么执行顺序会是</p><blockquote><p>宏任务-&gt;所有微任务-&gt;下一个宏任务</p></blockquote></li><li><p>但是如果不是的话，那么就是</p><blockquote><p>所有微任务-&gt;下一个宏任务</p></blockquote></li></ol><p>总之这些并不会影响代码的执行顺序</p><p>例如：</p><p>宏任务定时器与微任务promise</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">setTimeout(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">1</span>)</span><br><span class="line">&#125;,<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve,reject</span>)=&gt;</span>&#123;</span><br><span class="line">    resolve(<span class="number">2</span>);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">3</span>);</span><br><span class="line">&#125;).then(<span class="function"><span class="params">v</span>=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(v);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">4</span>;</span><br><span class="line">&#125;).then(<span class="function"><span class="params">v</span>=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(v);</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">5</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 执行结果</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="number">5</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">4</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 执行过程</span></span><br><span class="line"><span class="number">1.</span> 先进入整体代码script这个宏任务，该任务直接进入主线程，因此要执行掉所有的同步任务</span><br><span class="line"><span class="number">2.</span> 遇到setTimeout这一宏任务，我们将其放入宏任务队列</span><br><span class="line"><span class="number">3.</span> 遇到<span class="built_in">Promise</span>构造函数，立即执行该构造函数，执行<span class="built_in">console</span>.log(<span class="number">3</span>);两个then()方法依次进入微任务队列</span><br><span class="line"><span class="number">4.</span> 执行<span class="built_in">console</span>.log(<span class="number">5</span>);</span><br><span class="line"><span class="number">5.</span> 第一个宏任务执行结束，接下来查看微任务队列是否有要解决的微任务，按照先进先出的原则执行完所有的微任务</span><br><span class="line"><span class="number">6.</span> 到这里，第一轮事件循环结束，进入下一轮事件循环</span><br><span class="line"><span class="number">7.</span> 从宏任务队列中取出下一个宏任务，也就是setTimeout的回调函数，执行它</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>宏任务ajax与微任务promise</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> axios=<span class="built_in">require</span>(<span class="string">'axios'</span>)</span><br><span class="line"></span><br><span class="line">axios.get(<span class="string">'https://www.baidu.com'</span>).then(<span class="function"><span class="params">v</span>=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">1</span>);</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve,reject</span>)=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">2</span>);</span><br><span class="line">    resolve(<span class="number">3</span>);</span><br><span class="line">&#125;).then(<span class="function"><span class="params">v</span>=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(v);</span><br><span class="line">    <span class="keyword">return</span> (<span class="number">4</span>);</span><br><span class="line">&#125;).then(<span class="function"><span class="params">v</span>=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(v);</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">5</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 运行结果</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">5</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="number">4</span></span><br><span class="line"><span class="number">1</span></span><br></pre></td></tr></table></figure><p>最后，来一段超级复杂的代码</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="string">'1'</span>);</span><br><span class="line"></span><br><span class="line">setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'2'</span>);</span><br><span class="line">    process.nextTick(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'3'</span>);</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve</span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'4'</span>);</span><br><span class="line">        resolve();</span><br><span class="line">    &#125;).then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'5'</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;)</span><br><span class="line">process.nextTick(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'6'</span>);</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'7'</span>);</span><br><span class="line">    resolve();</span><br><span class="line">&#125;).then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'8'</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'9'</span>);</span><br><span class="line">    process.nextTick(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'10'</span>);</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve</span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'11'</span>);</span><br><span class="line">        resolve();</span><br><span class="line">    &#125;).then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'12'</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">7</span></span><br><span class="line"><span class="number">6</span></span><br><span class="line"><span class="number">8</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">4</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="number">5</span></span><br><span class="line"><span class="number">9</span></span><br><span class="line"><span class="number">11</span></span><br><span class="line"><span class="number">10</span></span><br><span class="line"><span class="number">12</span></span><br></pre></td></tr></table></figure><p>另一题：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="string">'global'</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">1</span>;i &lt;= <span class="number">5</span>;i ++) &#123;</span><br><span class="line">  setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(i)</span><br><span class="line">  &#125;,i*<span class="number">1000</span>)</span><br><span class="line">  <span class="built_in">console</span>.log(i)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span> (<span class="params">resolve</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'promise1'</span>)</span><br><span class="line">  resolve()</span><br><span class="line"> &#125;).then(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'then1'</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">setTimeout(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'timeout2'</span>)</span><br><span class="line">  <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span> (<span class="params">resolve</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'timeout2_promise'</span>)</span><br><span class="line">    resolve()</span><br><span class="line">  &#125;).then(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'timeout2_then'</span>)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;, <span class="number">1000</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// global 1 2 3 4 5 promise1 then1 6 timeout2 timeout2_promise timeout2_then 6 6 6 6</span></span><br></pre></td></tr></table></figure><h2 id="事件循环"><a href="#事件循环" class="headerlink" title="事件循环"></a>事件循环</h2><p>我们可以从两个角度去考虑事件循环，不仅仅是上文已经提到的同步与异步，还可以从微任务与宏任务来考虑事件循环</p><h3 id="从同步与异步来看事件循环"><a href="#从同步与异步来看事件循环" class="headerlink" title="从同步与异步来看事件循环"></a>从同步与异步来看事件循环</h3><p>如上文提到的所述：</p><ol><li>检查每一个进入主线程的任务，如果为同步任务，那么压入主线程堆栈；如果为异步，将该任务移到event table中，当该异步任务执行完毕后，将异步任务绑定的回调函数移入事件队列（任务队列）中</li><li>Js引擎会检查调用堆栈是否为空，然后不断地去检查事件队列（任务队列）是否为空。如果为空，则继续检查；如果不为空，则将该队列的第一个回调函数压入主线程去进行执行</li></ol><p>对于，事件循环的思考：</p><blockquote><p>为什么要进行事件循环？我觉得，不断地对事件队列去判断事件队列是否有任务的原因是因为，事件队列里存放的回调函数都是异步操作完成后才加入的。我们无法知道异步操作什么时候会完成。因此，就得不断去循环。而对于主线程，我们只需简单地判断堆栈是否为空（也就是堆栈长度是否为0）即可</p></blockquote><p>以上过程可以用伪代码进行描述</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// [... some initialization ...]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// The Event Loop</span></span><br><span class="line"><span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (! EventQueue.isEmpty()) &#123;</span><br><span class="line">     event = EventQueue.pop_oldest_item();</span><br><span class="line">     event.callback(event [or some other kind <span class="keyword">of</span> args]);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// [... defer to other non-JS tasks...]</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="从微任务与宏任务看事件循环"><a href="#从微任务与宏任务看事件循环" class="headerlink" title="从微任务与宏任务看事件循环"></a>从微任务与宏任务看事件循环</h3><p>准备：</p><p>检查每一个进来的任务，如果是同步任务，那么压入主线程调用栈中；如果是微任务，那么放入微任务队列；如果是宏任务，那么放入宏任务队列</p><p>Event Loop(事件循环)中，每一次循环称为 tick, 每一次tick的任务如下：</p><ol><li>执行栈执行完主线程中的所有任务（也可以&lt;script&gt;整体代码当做一个宏任务）</li><li>检查微任务队列，查看是否存在 Microtask，如果存在则不停的执行，直至清空 microtask 队列</li><li>更新render(每一次事件循环，浏览器都可能会去更新渲染)</li><li>检查宏任务队列，查看是否存在Macrotask，如果存在则取出一个任务进行执行（执行准备阶段操作）</li><li>重复以上步骤</li></ol><p><img src="https://s2.ax1x.com/2019/09/28/ulgJUJ.jpg" alt></p><p>总结：</p><p>微任务总是在下一个宏任务之前被执行完毕</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;为什么js是单线程的&quot;&gt;&lt;a href=&quot;#为什么js是单线程的&quot; class=&quot;headerlink&quot; title=&quot;为什么js是单线程的&quot;&gt;&lt;/a&gt;为什么js是单线程的&lt;/h2&gt;&lt;p&gt;众所周知，JavaScript是一门单线程语言。那么，为什么js必须是单线程
      
    
    </summary>
    
      <category term="javaScript基础" scheme="http://yoursite.com/categories/javaScript%E5%9F%BA%E7%A1%80/"/>
    
    
  </entry>
  
  <entry>
    <title>leetcode-303 区域和检索 - 数组不可变</title>
    <link href="http://yoursite.com/2019/09/13/leetcode-303/"/>
    <id>http://yoursite.com/2019/09/13/leetcode-303/</id>
    <published>2019-09-13T11:49:46.000Z</published>
    <updated>2019-09-13T11:55:00.064Z</updated>
    
    <content type="html"><![CDATA[<h1 id="区域和检索-数组不可变"><a href="#区域和检索-数组不可变" class="headerlink" title="区域和检索 - 数组不可变"></a>区域和检索 - 数组不可变</h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>给定一个整数数组  nums，求出数组从索引 i 到 j  (i ≤ j) 范围内元素的总和，包含 i,  j 两点。</p><p>示例：</p><pre><code>给定 nums = [-2, 0, 3, -5, 2, -1]，求和函数为 sumRange()sumRange(0, 2) -&gt; 1sumRange(2, 5) -&gt; -1sumRange(0, 5) -&gt; -3</code></pre><p>说明:</p><ol><li>你可以假设数组不可变。</li><li>会多次调用 sumRange 方法。<a id="more"></a>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/range-sum-query-immutable" target="_blank" rel="noopener">https://leetcode-cn.com/problems/range-sum-query-immutable</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</li></ol><h2 id="核心思路"><a href="#核心思路" class="headerlink" title="核心思路"></a>核心思路</h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>求数组中给定范围之间的和，比如说是求i&lt;=j之间范围的和，我们可以使用前j个元素的和减去前i-1个元素的和。</p><p>题目说明会多次调用求和方法，因此，我们可以在构造函数中就将前1个元素的和到第n个元素的和保存在哈希表中</p><h3 id="解题步骤"><a href="#解题步骤" class="headerlink" title="解题步骤"></a>解题步骤</h3><ol><li>遍历数组，以当前元素下标为键名，以从第一个元素到当前元素的和作为键值来建立哈希表</li><li>返回前j个元素的和减去前i-1个元素的和</li></ol><h2 id="Coding实现"><a href="#Coding实现" class="headerlink" title="Coding实现"></a>Coding实现</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @param &#123;number[]&#125; nums</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> NumArray = <span class="function"><span class="keyword">function</span>(<span class="params">nums</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.nums=nums;</span><br><span class="line">    <span class="keyword">let</span> map=<span class="keyword">new</span> <span class="built_in">Map</span>([[<span class="number">-1</span>,<span class="number">0</span>]]),sum=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">0</span>;i&lt;nums.length;i++) &#123;</span><br><span class="line">        sum+=nums[i];</span><br><span class="line">        map.set(i,sum);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">this</span>.map=map;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** </span></span><br><span class="line"><span class="comment"> * @param &#123;number&#125; i </span></span><br><span class="line"><span class="comment"> * @param &#123;number&#125; j</span></span><br><span class="line"><span class="comment"> * @return &#123;number&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">NumArray.prototype.sumRange = <span class="function"><span class="keyword">function</span>(<span class="params">i, j</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.map.get(j)-<span class="keyword">this</span>.map.get(i<span class="number">-1</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** </span></span><br><span class="line"><span class="comment"> * Your NumArray object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * var obj = new NumArray(nums)</span></span><br><span class="line"><span class="comment"> * var param_1 = obj.sumRange(i,j)</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;区域和检索-数组不可变&quot;&gt;&lt;a href=&quot;#区域和检索-数组不可变&quot; class=&quot;headerlink&quot; title=&quot;区域和检索 - 数组不可变&quot;&gt;&lt;/a&gt;区域和检索 - 数组不可变&lt;/h1&gt;&lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h2&gt;&lt;p&gt;给定一个整数数组  nums，求出数组从索引 i 到 j  (i ≤ j) 范围内元素的总和，包含 i,  j 两点。&lt;/p&gt;
&lt;p&gt;示例：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;给定 nums = [-2, 0, 3, -5, 2, -1]，求和函数为 sumRange()

sumRange(0, 2) -&amp;gt; 1
sumRange(2, 5) -&amp;gt; -1
sumRange(0, 5) -&amp;gt; -3&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;说明:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;你可以假设数组不可变。&lt;/li&gt;
&lt;li&gt;会多次调用 sumRange 方法。
    
    </summary>
    
      <category term="leetcode题解与算法" scheme="http://yoursite.com/categories/leetcode%E9%A2%98%E8%A7%A3%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="哈希表" scheme="http://yoursite.com/tags/%E5%93%88%E5%B8%8C%E8%A1%A8/"/>
    
  </entry>
  
  <entry>
    <title>leetcode-290 单词规律</title>
    <link href="http://yoursite.com/2019/09/12/leetcode-290/"/>
    <id>http://yoursite.com/2019/09/12/leetcode-290/</id>
    <published>2019-09-12T15:02:17.000Z</published>
    <updated>2019-09-12T15:07:13.808Z</updated>
    
    <content type="html"><![CDATA[<h1 id="单词规律"><a href="#单词规律" class="headerlink" title="单词规律"></a>单词规律</h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>给定一种规律 pattern 和一个字符串 str ，判断 str 是否遵循相同的规律。</p><p>这里的 遵循 指完全匹配，例如， pattern 里的每个字母和字符串 str 中的每个非空单词之间存在着双向连接的对应规律。</p><p>示例1:</p><blockquote><p>输入: pattern = “abba”, str = “dog cat cat dog”<br>输出: true</p></blockquote><p>示例 2:</p><blockquote><p>输入:pattern = “abba”, str = “dog cat cat fish”<br>输出: false</p></blockquote><p>示例 3:</p><blockquote><p>输入: pattern = “aaaa”, str = “dog cat cat dog”<br>输出: false</p></blockquote><p>示例 4:</p><blockquote><p>输入: pattern = “abba”, str = “dog dog dog dog”<br>输出: false</p></blockquote><p>说明:<br>你可以假设 pattern 只包含小写字母， str 包含了由单个空格分隔的小写字母。 </p><a id="more"></a><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/word-pattern" target="_blank" rel="noopener">https://leetcode-cn.com/problems/word-pattern</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p><h2 id="核心思路"><a href="#核心思路" class="headerlink" title="核心思路"></a>核心思路</h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>判断两个字符串是否完全匹配，也就是二者中的每个元素要互相对应，因此，我们可以使用哈希表来进行配对与比较</p><h3 id="解题步骤"><a href="#解题步骤" class="headerlink" title="解题步骤"></a>解题步骤</h3><ol><li>将str字符串通过split(‘ ‘)方法转化为字符串数组</li><li>遍历两个字符串，以pattern元素为键名，字符串数组对应元素作为键值，如果遇到冲突那么返回false</li><li>遍历两个字符串，以字符串数组元素为键名，pattern对应元素作为键值，如果遇到冲突那么返回false</li><li>返回true</li></ol><h2 id="Coding实现"><a href="#Coding实现" class="headerlink" title="Coding实现"></a>Coding实现</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @param &#123;string&#125; pattern</span></span><br><span class="line"><span class="comment"> * @param &#123;string&#125; str</span></span><br><span class="line"><span class="comment"> * @return &#123;boolean&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> wordPattern = <span class="function"><span class="keyword">function</span>(<span class="params">pattern, str</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> strArr=str.split(<span class="string">' '</span>);</span><br><span class="line">    <span class="keyword">let</span> map=<span class="keyword">new</span> <span class="built_in">Map</span>();</span><br><span class="line">    <span class="keyword">if</span>(pattern.length!==strArr.length) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">0</span>;i&lt;pattern.length;i++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(!map.has(pattern[i])) &#123;</span><br><span class="line">            map.set(pattern[i],strArr[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span>(map.get(pattern[i])!==strArr[i]) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    map.clear();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">0</span>;i&lt;strArr.length;i++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(!map.has(strArr[i])) &#123;</span><br><span class="line">            map.set(strArr[i],pattern[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span>(map.get(strArr[i])!==pattern[i]) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;单词规律&quot;&gt;&lt;a href=&quot;#单词规律&quot; class=&quot;headerlink&quot; title=&quot;单词规律&quot;&gt;&lt;/a&gt;单词规律&lt;/h1&gt;&lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h2&gt;&lt;p&gt;给定一种规律 pattern 和一个字符串 str ，判断 str 是否遵循相同的规律。&lt;/p&gt;
&lt;p&gt;这里的 遵循 指完全匹配，例如， pattern 里的每个字母和字符串 str 中的每个非空单词之间存在着双向连接的对应规律。&lt;/p&gt;
&lt;p&gt;示例1:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;输入: pattern = “abba”, str = “dog cat cat dog”&lt;br&gt;输出: true&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;示例 2:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;输入:pattern = “abba”, str = “dog cat cat fish”&lt;br&gt;输出: false&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;示例 3:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;输入: pattern = “aaaa”, str = “dog cat cat dog”&lt;br&gt;输出: false&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;示例 4:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;输入: pattern = “abba”, str = “dog dog dog dog”&lt;br&gt;输出: false&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;说明:&lt;br&gt;你可以假设 pattern 只包含小写字母， str 包含了由单个空格分隔的小写字母。 &lt;/p&gt;
    
    </summary>
    
      <category term="leetcode题解与算法" scheme="http://yoursite.com/categories/leetcode%E9%A2%98%E8%A7%A3%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="哈希表" scheme="http://yoursite.com/tags/%E5%93%88%E5%B8%8C%E8%A1%A8/"/>
    
  </entry>
  
  <entry>
    <title>leetcode-278 第一个错误的版本</title>
    <link href="http://yoursite.com/2019/09/11/leetcode-278/"/>
    <id>http://yoursite.com/2019/09/11/leetcode-278/</id>
    <published>2019-09-11T13:00:50.000Z</published>
    <updated>2019-09-11T13:07:27.386Z</updated>
    
    <content type="html"><![CDATA[<h1 id="第一个错误的版本"><a href="#第一个错误的版本" class="headerlink" title="第一个错误的版本"></a>第一个错误的版本</h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>你是产品经理，目前正在带领一个团队开发新的产品。不幸的是，你的产品的最新版本没有通过质量检测。由于每个版本都是基于之前的版本开发的，所以错误的版本之后的所有版本都是错的。</p><p>假设你有 n 个版本 [1, 2, …, n]，你想找出导致之后所有版本出错的第一个错误的版本。</p><p>你可以通过调用 bool isBadVersion(version) 接口来判断版本号 version 是否在单元测试中出错。实现一个函数来查找第一个错误的版本。你应该尽量减少对调用 API 的次数。</p><p>示例:</p><pre><code>给定 n = 5，并且 version = 4 是第一个错误的版本。调用 isBadVersion(3) -&gt; false调用 isBadVersion(5) -&gt; true调用 isBadVersion(4) -&gt; true所以，4 是第一个错误的版本。 </code></pre><a id="more"></a><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/first-bad-version" target="_blank" rel="noopener">https://leetcode-cn.com/problems/first-bad-version</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p><h2 id="核心思路"><a href="#核心思路" class="headerlink" title="核心思路"></a>核心思路</h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>该题考查的是二分查找的思想。不过需要注意边界处理。当isBadVersion(mid)的值为false时说明，第一个坏掉的产品肯定在mid后，因此left=mid+1;注意的是：当isBadVersion(mid)的值为true时，此时的mid值可能就是那个坏掉的第一个产品，因此，right=mid，而不是right=mid-1</p><h3 id="解题步骤"><a href="#解题步骤" class="headerlink" title="解题步骤"></a>解题步骤</h3><ol><li>设立left=1,right=n</li><li>取mid=Math.floor((left+right)/2)</li><li>如果isBadVersion(mid)的值为false时则left=mid+1;</li><li>如果isBadVersion(mid)的值为true时则right=mid</li><li>重复2,3步骤直到left===right</li><li>返回left</li></ol><h2 id="Coding实现"><a href="#Coding实现" class="headerlink" title="Coding实现"></a>Coding实现</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for isBadVersion()</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * @param &#123;integer&#125; version number</span></span><br><span class="line"><span class="comment"> * @return &#123;boolean&#125; whether the version is bad</span></span><br><span class="line"><span class="comment"> * isBadVersion = function(version) &#123;</span></span><br><span class="line"><span class="comment"> *     ...</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @param &#123;function&#125; isBadVersion()</span></span><br><span class="line"><span class="comment"> * @return &#123;function&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> solution = <span class="function"><span class="keyword">function</span>(<span class="params">isBadVersion</span>) </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * @param &#123;integer&#125; n Total versions</span></span><br><span class="line"><span class="comment">     * @return &#123;integer&#125; The first bad version</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">n</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">let</span> left=<span class="number">1</span>,right=n,mid;</span><br><span class="line">        <span class="keyword">while</span>(left&lt;right) &#123;</span><br><span class="line">            mid=<span class="built_in">Math</span>.floor((left+right)/<span class="number">2</span>);</span><br><span class="line">            <span class="keyword">if</span>(isBadVersion(mid)===<span class="literal">false</span>) &#123;</span><br><span class="line">                left=mid+<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                right=mid;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> left;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;第一个错误的版本&quot;&gt;&lt;a href=&quot;#第一个错误的版本&quot; class=&quot;headerlink&quot; title=&quot;第一个错误的版本&quot;&gt;&lt;/a&gt;第一个错误的版本&lt;/h1&gt;&lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h2&gt;&lt;p&gt;你是产品经理，目前正在带领一个团队开发新的产品。不幸的是，你的产品的最新版本没有通过质量检测。由于每个版本都是基于之前的版本开发的，所以错误的版本之后的所有版本都是错的。&lt;/p&gt;
&lt;p&gt;假设你有 n 个版本 [1, 2, …, n]，你想找出导致之后所有版本出错的第一个错误的版本。&lt;/p&gt;
&lt;p&gt;你可以通过调用 bool isBadVersion(version) 接口来判断版本号 version 是否在单元测试中出错。实现一个函数来查找第一个错误的版本。你应该尽量减少对调用 API 的次数。&lt;/p&gt;
&lt;p&gt;示例:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;给定 n = 5，并且 version = 4 是第一个错误的版本。

调用 isBadVersion(3) -&amp;gt; false
调用 isBadVersion(5) -&amp;gt; true
调用 isBadVersion(4) -&amp;gt; true

所以，4 是第一个错误的版本。 &lt;/code&gt;&lt;/pre&gt;
    
    </summary>
    
      <category term="leetcode题解与算法" scheme="http://yoursite.com/categories/leetcode%E9%A2%98%E8%A7%A3%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="二分查找" scheme="http://yoursite.com/tags/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/"/>
    
  </entry>
  
  <entry>
    <title>mpvue踩坑记</title>
    <link href="http://yoursite.com/2019/09/11/mpvue%E8%B8%A9%E5%9D%91%E8%AE%B0/"/>
    <id>http://yoursite.com/2019/09/11/mpvue踩坑记/</id>
    <published>2019-09-11T08:15:57.000Z</published>
    <updated>2019-09-11T10:13:21.723Z</updated>
    
    <content type="html"><![CDATA[<h2 id="页面跳转"><a href="#页面跳转" class="headerlink" title="页面跳转"></a>页面跳转</h2><ol><li>微信官方接口</li><li>mpvue接口</li></ol><h2 id="组件传值"><a href="#组件传值" class="headerlink" title="组件传值"></a>组件传值</h2><p>当将其他子组件引入到某个父组件中的时候，那么就需要组件之间进行传值，否则父组件无法获得子组件定义的值</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;页面跳转&quot;&gt;&lt;a href=&quot;#页面跳转&quot; class=&quot;headerlink&quot; title=&quot;页面跳转&quot;&gt;&lt;/a&gt;页面跳转&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;微信官方接口&lt;/li&gt;
&lt;li&gt;mpvue接口&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&quot;组件传值&quot;&gt;&lt;a href
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Promise与异步编程</title>
    <link href="http://yoursite.com/2019/09/10/Promise%E4%B8%8E%E5%BC%82%E6%AD%A5%E7%BC%96%E7%A8%8B/"/>
    <id>http://yoursite.com/2019/09/10/Promise与异步编程/</id>
    <published>2019-09-10T05:49:09.000Z</published>
    <updated>2019-09-28T07:31:26.533Z</updated>
    
    <content type="html"><![CDATA[<h2 id="什么是异步编程"><a href="#什么是异步编程" class="headerlink" title="什么是异步编程"></a>什么是异步编程</h2><p>异步编程是什么？为什么需要异步编程；这都要从同步说起</p><p>因为JavaScript语言是一门单线程语言。我们只能在一个线程上运行任务，该线程被称之为主线程。就像下面的例子一样，代码是按照顺序执行的</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span> <span class="title">getA</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    a=<span class="number">1</span>;</span><br><span class="line">&#125;)()</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(a); <span class="comment">// 1</span></span><br></pre></td></tr></table></figure><p>显然的是，以上会先执行getA函数并设置全局变量a=1，然后就会输出a=1;</p><p>但是，我们有没有想过一个问题，如果a的值不是我们自己先行设置的，而是向某服务器请求某资源后再赋值的呢？就像下面这样：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 引入axios</span></span><br><span class="line"><span class="keyword">const</span> axios=<span class="built_in">require</span>(<span class="string">"axios"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 声明变量a</span></span><br><span class="line"><span class="keyword">let</span> a;</span><br><span class="line"></span><br><span class="line">(<span class="function"><span class="keyword">function</span> <span class="title">getA</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    axios.get(<span class="string">'http://www.baidu.com'</span>).then(<span class="function">(<span class="params">content</span>)=&gt;</span>&#123;</span><br><span class="line">        a=<span class="number">1</span>;</span><br><span class="line">    &#125;).catch(<span class="function">(<span class="params">err</span>)=&gt;</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(err);</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;)()</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(a); <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure><p>我们会发现，这时候输出并不是1，而是undefined。这是为什么呢？难道代码不是顺序执行的吗？我们尝试着分析一下以上代码，我们首先声明了变量a但未定义，之后我们进入了getA()函数，在该函数中我们利用了axios工具去请求百度站点的信息。到这里，都没有任何问题。但是，去请求资源，我们都知道网络情况是不确定的，我们不知道这一过程会花费多少时间，因此我们会将该异步任务放入另一个任务队列中，当该任务完成后（也就是请求成功或请求失败）再放入主线程队列去执行相应的函数。但是，主线程也是按照队列的顺序依次来执行的，因此只有当主线程内的所有任务执行完毕后我们才能执行异步任务返回的函数代码。</p><p>getA()函数与console.log(a)都是主线程内的任务，因此，执行顺序就会是：</p><blockquote><p>getA() -&gt; console.log(a) -&gt; 异步任务完成后要执行的操作</p></blockquote><p>这就是异步编程，我们的程序中可能会有一些要造成阻塞的代码（请求外部资源之类），如果是同步的话，那么在请求完成之前我们都无法继续执行下面的程序，但是如果异步编程。将异步任务放入一个异步任务队列，等该异步任务完成后再将其放入主线程任务队列，这样的话，在请求资源的过程中，我们仍旧可以运行后面的程序</p><h2 id="异步编程具有的几种形式"><a href="#异步编程具有的几种形式" class="headerlink" title="异步编程具有的几种形式"></a>异步编程具有的几种形式</h2><h3 id="事件监听"><a href="#事件监听" class="headerlink" title="事件监听"></a>事件监听</h3><p>在进行事件操作的时候，例如用户点击按钮就会触发一个click事件。当点击按钮之后，onclick事件所要执行的任务就会放入异步任务队列中，只有当主线程内的所有任务完成后它才会被执行</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">let</span> button=<span class="built_in">document</span>.getElementById(<span class="string">'btn'</span>);</span><br><span class="line">button.onclick=<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'Button is clicked'</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(a); </span><br><span class="line"></span><br><span class="line"><span class="comment">// 执行结果</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line">Button is clicked</span><br></pre></td></tr></table></figure><p>click单击事件一开始就会被注册，但是只有被监听到click事件发生后才会执行click需要响应的操作</p><h3 id="回调模式"><a href="#回调模式" class="headerlink" title="回调模式"></a>回调模式</h3><p>什么是回调函数？</p><p>一个回调函数，也被称为高阶函数，是一个被作为参数传递给另一个函数的函数，回调函数在另外一个函数中被调用。一个回调函数本质上是一种编程模式（为一个常见问题创建的解决方案），因此，使用回调函数也叫做回调模式。</p><p>例如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">func</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'回调函数'</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">(<span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params">a,func</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(a); <span class="comment">// 1</span></span><br><span class="line">    func(); <span class="comment">// '回调函数'</span></span><br><span class="line">&#125;)(<span class="number">1</span>,func)</span><br></pre></td></tr></table></figure><p>func函数被作为参数传递给test函数并被其调用，那么func函数就被称之为回调函数</p><p>在Node.js中有大量的异步代码，因此，会大量使用回调函数来优化异步编程</p><p>例如，下面的读取文件操作</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> fs=<span class="built_in">require</span>(<span class="string">'fs'</span>);</span><br><span class="line"></span><br><span class="line">fs.readfile(<span class="string">'example.txt'</span>,<span class="function"><span class="keyword">function</span>(<span class="params">err,contents</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(err) &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(err);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="built_in">console</span>.log(contents);</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 执行结果</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line">example.txt内的内容或者是报错内容</span><br></pre></td></tr></table></figure><p>上述代码在执行readFile()函数后，发现这是一个异步任务，那么就将该异步任务放入异步任务队列，等到执行完毕后再放入到主线程任务队列等待执行。</p><p>readFile()函数的功能：</p><p>readFile()函数执行，然后就去读取给定的文件，读取结束后会执行回调函数。如果出现错误，就会将错误对象赋值给回调函数中的err参数；如果一切正常，文件内容就会字符串的形式赋值给contents参数</p><p>可能有些人会不理解为什么在一个函数a中将另一个函数b作为参数，这个函数b会被执行。因为，这个readFile()函数是Node.js中的一个api</p><p>接口大致意思可能如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">readFile</span>(<span class="params">fileName,func</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 读取fileName文件</span></span><br><span class="line">    <span class="keyword">if</span>(success) &#123;</span><br><span class="line">        contents=<span class="string">'文件内容'</span>;</span><br><span class="line">        err=<span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> err=<span class="string">'失败原因'</span>;</span><br><span class="line">    func(err,contents);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="事件发布与订阅"><a href="#事件发布与订阅" class="headerlink" title="事件发布与订阅"></a>事件发布与订阅</h3><p>提到发布订阅模式，我们很容易会想到Vue中也有两个api来提供这种模式，分别是vm.$on和vm.$emit</p><p>那么，什么是发布订阅模式呢？</p><p>发布—订阅模式又叫观察者模式，它定义对象间的一种一对多的依赖关系，当一个对象的状态发生改变时，所有依赖于它的对象都将得到通知。</p><p>因此，我们可以利用这个特性来实现异步编程。我们可以先订阅几个事件，并注册几个事件发生后要执行的回调函数。然后，就可以开始监听订阅的事件。当事件被发布后，一开始订阅了事件的要处理的回调函数就会被执行。</p><p>接下来，我们实现一下这个发布订阅模式</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> vm = &#123;</span><br><span class="line">    <span class="comment">// events对象保存所有订阅的事件,作为事件订阅与发布的载体</span></span><br><span class="line">    events: &#123;&#125;,</span><br><span class="line">    <span class="comment">// 订阅事件，如果事件不存在，那么订阅该事件，并创建该事件的所有订阅者要执行的回调函数列表同时存入该callback；如果已存在，那么将callback添加入执行列表即可</span></span><br><span class="line">    on(event,callback) &#123;</span><br><span class="line">        <span class="keyword">if</span>(!<span class="keyword">this</span>.events[event]) &#123;</span><br><span class="line">            <span class="keyword">this</span>.events[event]=[];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">this</span>.events[event].push(callback);</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">// 发布事件，将指定的event事件发布。我们会去事件订阅中心events对象查看是否有该订阅事件，如果没有，提示没有该订阅事件；如果有该订阅事件，那么执行订阅该事件的所有订阅者要执行的callback，并传递...items给这些callback</span></span><br><span class="line">    emit(event,...items) &#123;</span><br><span class="line">        <span class="keyword">if</span>(!<span class="keyword">this</span>.events[event]) &#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">'没有订阅该事件'</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">this</span>.events[event].forEach(<span class="function"><span class="params">v</span>=&gt;</span>&#123;</span><br><span class="line">            v.call(<span class="keyword">this</span>,...items);</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">vm.on(<span class="string">'test'</span>,<span class="function"><span class="keyword">function</span>(<span class="params">...items</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'test A'</span>,...items);</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">vm.on(<span class="string">'test'</span>,<span class="function"><span class="keyword">function</span>(<span class="params">...items</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'test B'</span>,...items);</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">vm.on(<span class="string">'test1'</span>,<span class="function"><span class="keyword">function</span>(<span class="params">...items</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'test1 A'</span>,...items);</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">vm.emit(<span class="string">'test'</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>);</span><br><span class="line">vm.emit(<span class="string">'test1'</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>);</span><br><span class="line">vm.emit(<span class="string">'test2'</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 执行结果</span></span><br><span class="line">test A <span class="number">1</span> <span class="number">2</span> <span class="number">3</span></span><br><span class="line">test B <span class="number">1</span> <span class="number">2</span> <span class="number">3</span></span><br><span class="line">test1 A <span class="number">1</span> <span class="number">2</span> <span class="number">3</span></span><br><span class="line">没有订阅该事件</span><br></pre></td></tr></table></figure><h3 id="Promise"><a href="#Promise" class="headerlink" title="Promise"></a>Promise</h3><p>Promise 对象是一个代理对象（代理一个值），被代理的值在Promise对象创建时可能是未知的。它允许你为异步操作的成功和失败分别绑定相应的处理方法。 这让异步方法可以像同步方法那样返回值，但并不是立即返回最终执行结果，而是一个能代表未来出现的结果的promise对象</p><h4 id="为什么更推荐Promise"><a href="#为什么更推荐Promise" class="headerlink" title="为什么更推荐Promise"></a>为什么更推荐Promise</h4><p>在Promise出现以前，我们一般都是利用回调模式来处理异步操作。如果，我们在请求一个网络资源的时候需要另一个网络资源请求的返回结果，那么，利用回调模式我们一般会这么写</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">请求<span class="number">1</span>(<span class="function"><span class="keyword">function</span>(<span class="params">请求结果<span class="number">1</span></span>)</span>&#123;</span><br><span class="line">    请求<span class="number">2</span>(<span class="function"><span class="keyword">function</span>(<span class="params">请求结果<span class="number">2</span></span>)</span>&#123;</span><br><span class="line">        处理请求结果<span class="number">2</span></span><br><span class="line">    &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>但是，如果每一个请求都需要另一个请求的返回结果呢？</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">请求<span class="number">1</span>(<span class="function"><span class="keyword">function</span>(<span class="params">请求结果<span class="number">1</span></span>)</span>&#123;</span><br><span class="line">    请求<span class="number">2</span>(<span class="function"><span class="keyword">function</span>(<span class="params">请求结果<span class="number">2</span></span>)</span>&#123;</span><br><span class="line">        请求<span class="number">3</span>(<span class="function"><span class="keyword">function</span>(<span class="params">请求结果<span class="number">3</span></span>)</span>&#123;</span><br><span class="line">            请求<span class="number">4</span>(<span class="function"><span class="keyword">function</span>(<span class="params">请求结果<span class="number">4</span></span>)</span>&#123;</span><br><span class="line">                请求<span class="number">5</span>(<span class="function"><span class="keyword">function</span>(<span class="params">请求结果<span class="number">5</span></span>)</span>&#123;</span><br><span class="line">                    请求<span class="number">6</span>(<span class="function"><span class="keyword">function</span>(<span class="params">请求结果<span class="number">3</span></span>)</span>&#123;</span><br><span class="line">                        ...</span><br><span class="line">                    &#125;)</span><br><span class="line">                &#125;)</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>这样我们就会很容易陷入回调地狱中。回调地狱主要带来了一下一些问题：</p><ol><li>代码臃肿</li><li>可读性差</li><li>耦合度高，可维护性差</li><li>只能在回调里来处理异常</li><li>异步操作的顺序变更时，需要大规模的代码重构。</li><li>回调函数基本都是匿名函数，bug 追踪困难。</li></ol><p>那么，Promise呢，Promise允许我们使用同步的方式来去处理异步代码，如下</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(请求<span class="number">1</span>)</span><br><span class="line">    .then(请求<span class="number">2</span>(请求结果<span class="number">1</span>))</span><br><span class="line">    .then(请求<span class="number">3</span>(请求结果<span class="number">2</span>))</span><br><span class="line">    .then(请求<span class="number">4</span>(请求结果<span class="number">3</span>))</span><br><span class="line">    .then(请求<span class="number">5</span>(请求结果<span class="number">4</span>))</span><br><span class="line">    .catch(处理异常(异常信息))</span><br></pre></td></tr></table></figure><p>除了同步的方式之外，我们还可以在Promise链的最外层来捕获异步函数的异常信息</p><h4 id="Promise的生命周期"><a href="#Promise的生命周期" class="headerlink" title="Promise的生命周期"></a>Promise的生命周期</h4><p>promise对象的生命周期包括以下三种：</p><ol><li>进行中 pending</li><li>已完成 fulfilled/resolved</li><li>被拒绝(未能成功完成) rejected</li></ol><h4 id="Promise构造函数创建promise"><a href="#Promise构造函数创建promise" class="headerlink" title="Promise构造函数创建promise"></a>Promise构造函数创建promise</h4><p>用Promise构造函数可以创建一个promise，构造函数只接受一个参数，也就是包含初始化Promise代码的执行器函数。Promise构造函数运行时会立刻调用该执行器函数。执行器函数接受两个参数，分别是resolve函数和rejected函数。</p><p>执行器函数内部通常会执行一些异步操作，当异步操作成功完成时需要调用resolve()函数来将promise的状态改为fulfilled/resolved；当异步操作失败时，需要调用reject()函数来将promise的状态改为rejected。如果在执行器函数中抛出了一个错误，那么该promise的状态就会被直接修改为rejected</p><p>例如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> fs=<span class="built_in">require</span>(<span class="string">'fs'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 异步读取文件内容</span></span><br><span class="line"><span class="keyword">let</span> promise=<span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve,reject</span>)=&gt;</span>&#123;</span><br><span class="line">    fs.readFile(<span class="string">'test.js'</span>,<span class="string">'utf8'</span>,(err,contents)=&gt;&#123;</span><br><span class="line">        <span class="keyword">if</span>(err) &#123;</span><br><span class="line">            reject(err);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            resolve(contents);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">promise.then(<span class="function"><span class="params">contents</span>=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(contents); <span class="comment">// test</span></span><br><span class="line">&#125;,err=&gt;&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(err);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>通过Promise构造函数创建了一个promise对象，之后便会执行执行器函数，同时异步操作开始。当异步操作结束后，会调用异步操作中的回调函数，如果操作成功那么将成功获得的数据作为参数传递给resolved函数，如果失败那么将失败信息传递给rejected函数。</p><p>promise对象调用then()方法和catch()方法时，会创建一个新任务放入一个任务队列中，只有监听到promise被解决后才会被执行</p><h4 id="then-与catch"><a href="#then-与catch" class="headerlink" title="then()与catch()"></a>then()与catch()</h4><p>then() 方法返回一个  Promise 。它最多需要有两个参数：Promise 的成功和失败情况的回调函数。当promise的状态发生改变后就会执行相应的resolved/fulfilled状态的回调函数或者是相应的rejectd状态的回调函数。</p><blockquote><p>如果，没有提供某个状态的处理函数。那么，then()方法将会丢失该状态的回调函数信息，但是并不会产生错误。如果恰好promise的状态是没有提供回调函数信息的状态，那么then()方法将会创建一个没有经过该状态回调函数处理的新promise对象，这个新 Promise 只是简单地接受调用这个 then 的原 Promise 的终态作为它的终态。</p></blockquote><p>例如:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> promise = <span class="built_in">Promise</span>.reject(<span class="string">'error'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// then()方法只具有fulfilled状态的回调函数，那么当promise的状态为rejected时，then()方法不会调用任何回调函数，只是创建一个新的promise对象，该对象的状态与原promise对象状态相同，并且传入的参数一致</span></span><br><span class="line">promise.then(<span class="function"><span class="params">content</span>=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'成功'</span>,content);</span><br><span class="line">&#125;).catch(<span class="function"><span class="params">err</span>=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'失败'</span>,err); <span class="comment">// 'error'</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>catch() 方法返回一个  Promise 。它接受一个参数：失败情况的回调函数。</p><p>then()方法和catch()方法一起使用才更加方便和清晰地处理异步操作结果</p><p>例如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> fs=<span class="built_in">require</span>(<span class="string">'fs'</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> promise=<span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve,reject</span>)=&gt;</span>&#123;</span><br><span class="line">    fs.readFile(<span class="string">'test.js'</span>,<span class="string">'utf8'</span>,(err,contents)=&gt;&#123;</span><br><span class="line">        <span class="keyword">if</span>(err) &#123;</span><br><span class="line">            reject(err);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            resolve(contents);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">promise.then(<span class="function"><span class="params">contents</span>=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(contents);</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">promise.catch(<span class="function"><span class="params">err</span>=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(err);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h4 id="Promise-resolve-和Promise-reject-创建已处理的promise"><a href="#Promise-resolve-和Promise-reject-创建已处理的promise" class="headerlink" title="Promise.resolve()和Promise.reject()创建已处理的promise"></a>Promise.resolve()和Promise.reject()创建已处理的promise</h4><p>我们可以使用Promise.resolve()来创建已处理的成功完成的promise</p><blockquote><p>Promise.resolve(value)方法返回一个以给定值解析后的Promise 对象。如果该值为promise，返回这个promise；如果这个值是thenable（即带有”then” 方法)），返回的promise会“跟随”这个thenable的对象，采用它的最终状态；否则返回的promise将以此值完成。此函数将类promise对象的多层嵌套展平。</p></blockquote><p>我们也可以使用Promise.reject()来创建已处理的拒绝态的promise</p><p>例如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 返回给定的promise对象</span></span><br><span class="line"><span class="keyword">let</span> promise=<span class="built_in">Promise</span>.resolve(<span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve,reject</span>)=&gt;</span>&#123;</span><br><span class="line">    resolve(<span class="number">1</span>);</span><br><span class="line">&#125;))</span><br><span class="line"></span><br><span class="line">promise.then(<span class="function"><span class="params">v</span>=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(v); <span class="comment">// 1</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h4 id="执行器错误"><a href="#执行器错误" class="headerlink" title="执行器错误"></a>执行器错误</h4><p>如果执行器函数内部发生错误，那么promise的拒绝处理程序就会被调用。</p><p>例如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> promise=<span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve,reject</span>)=&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'err'</span>);</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">promise.catch(<span class="function"><span class="params">err</span>=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(err); <span class="comment">// 'err'</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>因为，每个执行器函数中都隐含着一个try…catch块，所以所有的错误都会被捕获并传入拒绝处理程序,以上示例相当于：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> promise=<span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve,reject</span>)=&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'err'</span>); </span><br><span class="line">    &#125; <span class="keyword">catch</span> (err) &#123;</span><br><span class="line">        reject(err);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">promise.catch(<span class="function"><span class="params">err</span>=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(err); <span class="comment">// 'err'</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h4 id="串联Promise"><a href="#串联Promise" class="headerlink" title="串联Promise"></a>串联Promise</h4><p>前面提到过每次调用then()方法或者catch()方法都会创建并返回了另一个Promise，只有当第一个promise完成或被拒绝后才会去解决之后的promise</p><p>调用then()方法返回的promise按照以下规则被创建：<br>当一个Promise完成（fulfilled）或者失败（rejected），返回函数将被异步调用（由当前的线程循环来调度完成）。具体的返回值依据以下规则返回：</p><ol><li>如果then中的回调函数返回一个值，那么then返回的Promise将会成为接受状态，并且将返回的值作为接受状态的回调函数的参数值。</li><li>如果then中的回调函数没有返回值，那么then返回的Promise将会成为接受状态，并且该接受状态的回调函数的参数值为 undefined。</li><li>如果then中的回调函数抛出一个错误，那么then返回的Promise将会成为拒绝状态，并且将抛出的错误作为拒绝状态的回调函数的参数值。</li><li>如果then中的回调函数返回一个已经是接受状态的Promise，那么then返回的Promise也会成为接受状态，并且将那个Promise的接受状态的回调函数的参数值作为该被返回的Promise的接受状态回调函数的参数值。</li><li>如果then中的回调函数返回一个已经是拒绝状态的Promise，那么then返回的Promise也会成为拒绝状态，并且将那个Promise的拒绝状态的回调函数的参数值作为该被返回的Promise的拒绝状态回调函数的参数值。</li><li>如果then中的回调函数返回一个未定状态（pending）的Promise，那么then返回Promise的状态也是未定的，并且它的终态与那个Promise的终态相同；同时，它变为终态时调用的回调函数参数与那个Promise变为终态时的回调函数的参数是相同的。</li></ol><p>调用catch()方法返回的是一个带有错误原因的promise</p><p>例如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建一个已处理的promise</span></span><br><span class="line"><span class="keyword">let</span> promise=<span class="built_in">Promise</span>.resolve(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 不返回任何值</span></span><br><span class="line">promise.then(<span class="function"><span class="params">v</span>=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(v); <span class="comment">// 1</span></span><br><span class="line">&#125;).then(<span class="function"><span class="params">v</span>=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(v); <span class="comment">// undefined</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回一个值</span></span><br><span class="line">promise.then(<span class="function"><span class="params">v</span>=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(v); <span class="comment">// 1</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">&#125;).then(<span class="function"><span class="params">v</span>=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(v); <span class="comment">// 2</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 抛出错误在promise链的下一个拒绝处理程序中捕获</span></span><br><span class="line">promise.then(<span class="function"><span class="params">v</span>=&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'err'</span>);</span><br><span class="line">&#125;).catch(<span class="function"><span class="params">v</span>=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(v); <span class="comment">// err</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>就像上述的第三个例子，在已完成处理程序中抛出了错误，我们可以使用then…catch来捕获错误。因此，在实际编程时，为了防止某些未知的错误而造成程序崩溃，我们要使用then…catch来捕获未知错误</p><h5 id="promise链中传递数据"><a href="#promise链中传递数据" class="headerlink" title="promise链中传递数据"></a>promise链中传递数据</h5><p>在上面提过，在调用then()方法和catch()方法的处理程序中，如果return某些值，是会作为返回的promise对象的执行函数的参数值，因此，我们可以在promise链中往下游传递数据</p><p>例如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> promise=<span class="built_in">Promise</span>.resolve(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">promise.then(<span class="function"><span class="params">v</span>=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(v); <span class="comment">// 1</span></span><br><span class="line">    <span class="keyword">return</span> v+<span class="number">1</span>; <span class="comment">// 返回一个值</span></span><br><span class="line">&#125;).then(<span class="function"><span class="params">v</span>=&gt;</span>&#123; <span class="comment">// 接收到这个值</span></span><br><span class="line">    <span class="built_in">console</span>.log(v); <span class="comment">// 2</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h4 id="在处理程序中return一个promise"><a href="#在处理程序中return一个promise" class="headerlink" title="在处理程序中return一个promise"></a>在处理程序中return一个promise</h4><ol><li>如果then中的回调函数返回一个已经是接受状态的Promise，那么then返回的Promise也会成为接受状态，并且将那个Promise的接受状态的回调函数的参数值作为该被返回的Promise的接受状态回调函数的参数值。</li><li>如果then中的回调函数返回一个已经是拒绝状态的Promise，那么then返回的Promise也会成为拒绝状态，并且将那个Promise的拒绝状态的回调函数的参数值作为该被返回的Promise的拒绝状态回调函数的参数值。</li><li>如果then中的回调函数返回一个未定状态（pending）的Promise，那么then返回Promise的状态也是未定的，并且它的终态与那个Promise的终态相同；同时，它变为终态时调用的回调函数参数与那个Promise变为终态时的回调函数的参数是相同的。</li></ol><p>例如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> p1=<span class="built_in">Promise</span>.resolve(<span class="number">1</span>);</span><br><span class="line"><span class="keyword">let</span> p2=<span class="built_in">Promise</span>.reject(<span class="string">'err'</span>);</span><br><span class="line"></span><br><span class="line">p1.then(<span class="function"><span class="params">v</span>=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(v); <span class="comment">// 1</span></span><br><span class="line">    <span class="keyword">return</span> p2; <span class="comment">// 返回一个拒绝态的promise</span></span><br><span class="line">&#125;).catch(<span class="function"><span class="params">v</span>=&gt;</span>&#123; <span class="comment">// 接收到拒绝态promise传过来的错误原因</span></span><br><span class="line">    <span class="built_in">console</span>.log(v); <span class="comment">// 'err'</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h4 id="响应多个Promise"><a href="#响应多个Promise" class="headerlink" title="响应多个Promise"></a>响应多个Promise</h4><h5 id="Promise-all"><a href="#Promise-all" class="headerlink" title="Promise.all()"></a>Promise.all()</h5><p>Promise.all()方法接受一个参数并返回一个promise，该参数是一个含有多个受监视Promise的可迭代对象（例如，一个数组），只有可迭代对象中的所有promise被成功解决(resolved/fulfilled态)后返回的promise才会被解决</p><p>注意：</p><ol><li>如果传入的可迭代对象为空，Promise.all 会同步地返回一个已完成（resolved）状态的promise。</li><li>如果传入的参数不包含任何 promise，则返回一个异步完成（asynchronously resolved） Promise。</li><li>其它情况下返回一个处理中（pending）的Promise。这个返回的 promise 之后会在所有的 promise 都完成或有一个 promise 失败时异步地变为完成或失败。</li></ol><p>更加需要注意的是：</p><blockquote><p>返回值将会按照参数内的promise顺序排列，而不是由调用的promise的完成顺序来决定</p></blockquote><p>例如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> promise1 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve,reject</span>)=&gt;</span>&#123;</span><br><span class="line">  setTimeout(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">      resolve(<span class="number">1</span>);</span><br><span class="line">  &#125;,<span class="number">3000</span>)  </span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> promise2 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve,reject</span>)=&gt;</span>&#123;</span><br><span class="line">    setTimeout(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">        resolve(<span class="number">2</span>);</span><br><span class="line">    &#125;,<span class="number">2000</span>)  </span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> promise3 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve,reject</span>)=&gt;</span>&#123;</span><br><span class="line">setTimeout(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">    resolve(<span class="number">3</span>);</span><br><span class="line">&#125;,<span class="number">1000</span>)  </span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 值得注意的是，此时当所有的promise都全部成功返回后，返回值的顺序是按照传递给Promise.all()方法的参数数组内的排列顺序决定，而不是根据promise完成的先后顺序</span></span><br><span class="line"><span class="built_in">Promise</span>.all([promise2,promise1,promise3]).then(<span class="function"><span class="params">v</span>=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(v); <span class="comment">// [2,1,3]</span></span><br><span class="line">&#125;).catch(<span class="function"><span class="params">err</span>=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(err);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>当然，只要所有传入的promise对象中有一个被拒绝，那么Promise.all()方法返回的promise对象就会被立刻拒绝</p><p>拒绝处理程序总是接受一个值而非数组，该值来自于被拒绝promise的拒绝值</p><p>例如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> p1=<span class="built_in">Promise</span>.resolve(<span class="number">1</span>);</span><br><span class="line"><span class="keyword">let</span> p2=<span class="built_in">Promise</span>.resolve(<span class="number">2</span>);</span><br><span class="line"><span class="comment">// 拒绝态promise</span></span><br><span class="line"><span class="keyword">let</span> p3=<span class="built_in">Promise</span>.reject(<span class="number">3</span>);</span><br><span class="line"><span class="keyword">let</span> p4=<span class="built_in">Promise</span>.resolve(<span class="number">4</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="keyword">set</span>=new Set([p1,p2,p3,p4]);</span><br><span class="line"></span><br><span class="line">Promise.all(<span class="keyword">set</span>).then(v=&gt;&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(v);</span><br><span class="line">&#125;).catch(<span class="function"><span class="params">err</span>=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(err); <span class="comment">// 3</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h5 id="Promise-race"><a href="#Promise-race" class="headerlink" title="Promise.race()"></a>Promise.race()</h5><p>Promise.race()同样也是接受一个包含多个promise的可迭代对象，但是，一旦迭代器中的某个promise解决或拒绝，返回的 promise就会解决或拒绝。</p><blockquote><p>一个待定的 Promise 只要给定的迭代中的一个promise解决或拒绝，返回的promise就采用第一个promise的值作为它的值，从而异步地解析或拒绝</p></blockquote><p>例如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// p1在2000毫秒后成为已成功处理的promise</span></span><br><span class="line"><span class="keyword">let</span> p1=<span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve,reject</span>)=&gt;</span>&#123;</span><br><span class="line">    setTimeout(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">        resolve(<span class="number">1</span>);</span><br><span class="line">    &#125;,<span class="number">2000</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建已完成拒绝态promise</span></span><br><span class="line"><span class="keyword">let</span> p2=<span class="built_in">Promise</span>.reject(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建已完成resolved态promise</span></span><br><span class="line"><span class="keyword">let</span> p3=<span class="built_in">Promise</span>.resolve(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">Promise</span>.race([p1,p3,p2]).then(<span class="function"><span class="params">v</span>=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(v);</span><br><span class="line">&#125;).catch(<span class="function"><span class="params">err</span>=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(err); <span class="comment">// 3</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>因为，p1在2000毫秒后才会成为已成功处理的promise,p2,p3都是已完成处理程序，但是在传递给Promise.race()方法的参数数组中p3的顺序先于p2</p><blockquote><p>需要注意的是，可迭代对象中promise的顺序也可能会对结果产生影响</p></blockquote><h3 id="实现一个Promise"><a href="#实现一个Promise" class="headerlink" title="实现一个Promise"></a>实现一个Promise</h3><p>因为Promise中的方法众多，因此，我们一个方法一个方法进行实现</p><h4 id="Promise-1"><a href="#Promise-1" class="headerlink" title="Promise"></a>Promise</h4><h3 id="async-await"><a href="#async-await" class="headerlink" title="async/await"></a>async/await</h3><ol><li><p>async function 用来定义一个返回 AsyncFunction 对象的异步函数。异步函数是指通过事件循环异步执行的函数，它会通过一个隐式的 Promise 返回其结果。</p></li><li><p>await  操作符用于等待一个Promise 对象。它只能在异步函数 async function 中使用。</p></li><li><p>async 函数返回一个 Promise 对象</p></li><li><p>async 函数内部 return 返回的值。会成为 then 方法回调函数的参数。</p></li></ol><p>例如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">await</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve,reject</span>)=&gt;</span>&#123;</span><br><span class="line">        resolve(<span class="number">1</span>);</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">f().then(<span class="function"><span class="params">v</span>=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(v); <span class="comment">// 1</span></span><br><span class="line">&#125;).catch(<span class="function"><span class="params">err</span>=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(err);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;什么是异步编程&quot;&gt;&lt;a href=&quot;#什么是异步编程&quot; class=&quot;headerlink&quot; title=&quot;什么是异步编程&quot;&gt;&lt;/a&gt;什么是异步编程&lt;/h2&gt;&lt;p&gt;异步编程是什么？为什么需要异步编程；这都要从同步说起&lt;/p&gt;
&lt;p&gt;因为JavaScript语言是一
      
    
    </summary>
    
      <category term="ES6" scheme="http://yoursite.com/categories/ES6/"/>
    
    
  </entry>
  
  <entry>
    <title>数组创建的改进</title>
    <link href="http://yoursite.com/2019/09/09/%E6%95%B0%E7%BB%84%E5%88%9B%E5%BB%BA%E7%9A%84%E6%94%B9%E8%BF%9B/"/>
    <id>http://yoursite.com/2019/09/09/数组创建的改进/</id>
    <published>2019-09-09T08:05:36.000Z</published>
    <updated>2019-09-19T12:55:07.388Z</updated>
    
    <content type="html"><![CDATA[<h2 id="ES6之前数组创建的一些问题"><a href="#ES6之前数组创建的一些问题" class="headerlink" title="ES6之前数组创建的一些问题"></a>ES6之前数组创建的一些问题</h2><p>在ES6之前，数组的创建具有以下的一些问题</p><ol><li>通过Array构造函数创建数组时具有一些怪异的行为</li><li>没有现成的方法可以将类数组对象（具有数值型索引和length属性的对象）和可迭代对象转化为数组</li></ol><h3 id="Array构造函数的一些怪异行为"><a href="#Array构造函数的一些怪异行为" class="headerlink" title="Array构造函数的一些怪异行为"></a>Array构造函数的一些怪异行为</h3><p>Array构造函数具有以下怪异行为</p><ol><li><p>如果给Array构造函数传入一个数值型的值，此时，并不是创建一个包含该数值的数组，而是创建一个数组，将该数组的length属性设置为该值。那么显然数组内的所有元素都会是undefined</p> <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr=<span class="keyword">new</span> <span class="built_in">Array</span>(<span class="number">2</span>);</span><br><span class="line"><span class="built_in">console</span>.log(arr); <span class="comment">// [undefined,undefined]</span></span><br><span class="line"><span class="built_in">console</span>.log(arr.length); <span class="comment">// 2</span></span><br></pre></td></tr></table></figure></li><li><p>相对于上一点，如果传入一个非数值类型的值，那么就符合常规的想法，会创建一个包含该值的数组</p> <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr=<span class="keyword">new</span> <span class="built_in">Array</span>(<span class="string">'man'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(arr); <span class="comment">// ['man']</span></span><br><span class="line"><span class="built_in">console</span>.log(arr.length); <span class="comment">// 1</span></span><br></pre></td></tr></table></figure></li><li><p>最后，如果传入了多个值，那么不管这些值中是否有数值类型，所有的值都会变为创建的数组的元素</p> <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr=<span class="keyword">new</span> <span class="built_in">Array</span>(<span class="number">2</span>,<span class="string">'man'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(arr); <span class="comment">// [2,'man']</span></span><br><span class="line"><span class="built_in">console</span>.log(arr.length); <span class="comment">// 2</span></span><br></pre></td></tr></table></figure></li></ol><p>因为Array构造函数具有以上的一些怪异特性，因此ES6通过引入Array.of()方法来解决这个问题</p><h3 id="ES5实现将类数组对象转化为数组对象"><a href="#ES5实现将类数组对象转化为数组对象" class="headerlink" title="ES5实现将类数组对象转化为数组对象"></a>ES5实现将类数组对象转化为数组对象</h3><p>对于类数组对象，在ES5中我们可以采用以下的方式来将其转化为数组对象</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a=&#123;</span><br><span class="line">    <span class="number">0</span>:<span class="number">1</span>,</span><br><span class="line">    <span class="number">1</span>:<span class="number">2</span>,</span><br><span class="line">    length:<span class="number">2</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getArray</span>(<span class="params">obj</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> ans=[];</span><br><span class="line">    <span class="comment">// 类数组对象具有数值型索引和length属性</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">0</span>;i&lt;obj.length;i++) &#123;</span><br><span class="line">        ans.push(obj[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(getArray(a)); <span class="comment">// [1,2]</span></span><br></pre></td></tr></table></figure><p>除此之外，我们还可以利用数组方法slice()的一个特性：</p><blockquote><p>slice 方法可以用来将一个类数组（Array-like）对象/集合转换成一个新数组。</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a=&#123;</span><br><span class="line">    <span class="number">0</span>:<span class="number">1</span>,</span><br><span class="line">    <span class="number">1</span>:<span class="number">2</span>,</span><br><span class="line">    length:<span class="number">2</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getArray</span>(<span class="params">obj</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Array</span>.prototype.slice.call(obj);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(getArray(a)); <span class="comment">// [1,2]</span></span><br></pre></td></tr></table></figure><h2 id="ES6对于数组创建的改进"><a href="#ES6对于数组创建的改进" class="headerlink" title="ES6对于数组创建的改进"></a>ES6对于数组创建的改进</h2><h3 id="Array-of-方法对于Array构造函数的改进"><a href="#Array-of-方法对于Array构造函数的改进" class="headerlink" title="Array.of()方法对于Array构造函数的改进"></a>Array.of()方法对于Array构造函数的改进</h3><p>ES6通过引入Array.of()方法来解决Array构造函数出现的一些怪异行为</p><h4 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h4><p>Array.of() 方法创建一个具有可变数量参数的新数组实例，而不考虑参数的数量或类型。</p><p> Array.of() 和 Array 构造函数之间的区别在于处理整数参数：Array.of(7) 创建一个具有单个元素 7 的数组，而 Array(7) 创建一个长度为7的空数组（注意：这是指一个有7个空位(empty)的数组，而不是由7个undefined组成的数组）。</p><h4 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h4><blockquote><p>Array.of(element0[, element1[, …[, elementN]]])</p></blockquote><p>参数</p><p>elementN:任意个参数，将按顺序成为返回数组中的元素。</p><p>返回值</p><p>新的 Array 实例。</p><h4 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用Array构造函数并传入一个数值类型值</span></span><br><span class="line"><span class="keyword">let</span> arr=<span class="keyword">new</span> <span class="built_in">Array</span>(<span class="number">2</span>);</span><br><span class="line"><span class="built_in">console</span>.log(arr); <span class="comment">// [undefined,undefined]</span></span><br><span class="line"><span class="built_in">console</span>.log(arr.length); <span class="comment">// 2</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用Array.of()方法并传入一个数值类型值</span></span><br><span class="line"><span class="keyword">let</span> array=<span class="built_in">Array</span>.of(<span class="number">2</span>);</span><br><span class="line"><span class="built_in">console</span>.log(array); <span class="comment">// [2]</span></span><br><span class="line"><span class="built_in">console</span>.log(array.length); <span class="comment">// 1</span></span><br></pre></td></tr></table></figure><h3 id="Array-from-方法将非数组对象转化为数组对象"><a href="#Array-from-方法将非数组对象转化为数组对象" class="headerlink" title="Array.from()方法将非数组对象转化为数组对象"></a>Array.from()方法将非数组对象转化为数组对象</h3><h4 id="概述-1"><a href="#概述-1" class="headerlink" title="概述"></a>概述</h4><p>Array.from() 方法从一个类似数组或可迭代对象中创建一个新的，浅拷贝的数组实例。</p><h4 id="语法-1"><a href="#语法-1" class="headerlink" title="语法"></a>语法</h4><blockquote><p>Array.from(arrayLike[, mapFn[, thisArg]])</p></blockquote><p><strong>参数</strong></p><p>arrayLike<br>    想要转换成数组的伪数组对象或可迭代对象。</p><p>mapFn (可选参数)<br>    如果指定了该参数，新数组中的每个元素会执行该回调函数。</p><p>thisArg (可选参数)<br>    可选参数，执行回调函数 mapFn 时 this 对象。</p><p><strong>返回值</strong></p><p>一个新的数组实例</p><h4 id="例子-1"><a href="#例子-1" class="headerlink" title="例子"></a>例子</h4><p>使用Array.from()方法将类数组对象转化为数组对象</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a=&#123;</span><br><span class="line">    <span class="number">0</span>:<span class="number">1</span>,</span><br><span class="line">    <span class="number">1</span>:<span class="number">2</span>,</span><br><span class="line">    length:<span class="number">2</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用Array.from()方法将类数组对象转化为数组对象</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> arr=<span class="built_in">Array</span>.from(a);</span><br><span class="line"><span class="built_in">console</span>.log(arr); <span class="comment">// [1,2]</span></span><br></pre></td></tr></table></figure><p>使用Array.from()方法将可迭代对象转化为数组对象</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 将字符串转化为数组</span></span><br><span class="line"><span class="keyword">let</span> str=<span class="string">'hello'</span>;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Array</span>.from(str)); <span class="comment">// ['h','e','l','l','o']</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 将Set集合转化为数组</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Array</span>.from(<span class="keyword">new</span> <span class="built_in">Set</span>([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]))); <span class="comment">// [1,2,3]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 将Map集合转化为数组</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Array</span>.from(<span class="keyword">new</span> <span class="built_in">Map</span>([[<span class="string">'a'</span>,<span class="number">1</span>],[<span class="string">'b'</span>,<span class="number">2</span>],[<span class="string">'c'</span>,<span class="number">3</span>]]))); <span class="comment">// [['a',1],['b',2],['c',3]]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 将普通自定义对象利用生成器转化为可迭代对象之后再转化为数组</span></span><br><span class="line"><span class="keyword">let</span> test=&#123;</span><br><span class="line">    a:<span class="string">'a'</span>,</span><br><span class="line">    c:<span class="string">'c'</span>,</span><br><span class="line">    *[<span class="built_in">Symbol</span>.iterator]() &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">let</span> i <span class="keyword">in</span> test) &#123;</span><br><span class="line">            <span class="keyword">yield</span> test[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Array</span>.from(test)); <span class="comment">// ['a','c']</span></span><br></pre></td></tr></table></figure><p>映射转化：使用Array.from()的第二个参数将被转化对象的每一个值转化为其他形式</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> test=&#123;</span><br><span class="line">    a:<span class="string">'a'</span>,</span><br><span class="line">    c:<span class="string">'c'</span>,</span><br><span class="line">    *[<span class="built_in">Symbol</span>.iterator]() &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">let</span> i <span class="keyword">in</span> test) &#123;</span><br><span class="line">            <span class="keyword">yield</span> test[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Array</span>.from(test,(v)=&gt;<span class="string">'hello '</span>+v)); <span class="comment">// ['hello a','hello c']</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;ES6之前数组创建的一些问题&quot;&gt;&lt;a href=&quot;#ES6之前数组创建的一些问题&quot; class=&quot;headerlink&quot; title=&quot;ES6之前数组创建的一些问题&quot;&gt;&lt;/a&gt;ES6之前数组创建的一些问题&lt;/h2&gt;&lt;p&gt;在ES6之前，数组的创建具有以下的一些问题&lt;
      
    
    </summary>
    
      <category term="ES6" scheme="http://yoursite.com/categories/ES6/"/>
    
    
  </entry>
  
</feed>
