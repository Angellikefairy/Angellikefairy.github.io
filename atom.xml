<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Hexo</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2019-10-17T14:34:19.629Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>Angel</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Generator与async+await</title>
    <link href="http://yoursite.com/2019/10/16/%E5%BC%82%E6%AD%A5%E7%9A%84%E7%BB%88%E6%9E%81%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88async-await/"/>
    <id>http://yoursite.com/2019/10/16/异步的终极解决方案async-await/</id>
    <published>2019-10-16T07:19:34.000Z</published>
    <updated>2019-10-17T14:34:19.629Z</updated>
    
    <content type="html"><![CDATA[<h2 id="异步操作的发展"><a href="#异步操作的发展" class="headerlink" title="异步操作的发展"></a>异步操作的发展</h2><p>有一个场景，要先读取a文件，当a文件成功读取完毕后再去读取b文件，我们看一下各种异步操作是如何进行的？</p><h3 id="回调函数"><a href="#回调函数" class="headerlink" title="回调函数"></a>回调函数</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 采用回调函数方式，很容易造成回调地狱</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">readFile</span>(<span class="params">err,data</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(err) <span class="keyword">throw</span> err;</span><br><span class="line">    <span class="built_in">console</span>.log(data);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fs.readFile(<span class="string">'./a.js'</span>,<span class="string">'utf-8'</span>,(err,data)=&gt;&#123;</span><br><span class="line">    <span class="keyword">if</span>(err) <span class="keyword">throw</span> err;</span><br><span class="line">    <span class="built_in">console</span>.log(data);</span><br><span class="line">    fs.readFile(<span class="string">'./b.js'</span>,<span class="string">'utf-8'</span>,(err,data)=&gt;&#123;</span><br><span class="line">        <span class="keyword">if</span>(err) <span class="keyword">throw</span> err;</span><br><span class="line">        <span class="built_in">console</span>.log(data);</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h3 id="Promise"><a href="#Promise" class="headerlink" title="Promise"></a>Promise</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 采用promise方式，但问题是容易造成代码冗余，并且一堆then导致代码不够清晰</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getPromise</span>(<span class="params">file</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve,reject</span>)=&gt;</span>&#123;</span><br><span class="line">        fs.readFile(file,<span class="string">'utf-8'</span>,(err,data)=&gt;&#123;</span><br><span class="line">            <span class="keyword">if</span>(err) reject(err);</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                resolve(data);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">getPromise(<span class="string">'./a.js'</span>).then(<span class="function"><span class="params">v</span>=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(v);</span><br><span class="line">    <span class="keyword">return</span> getPromise(<span class="string">'./b.js'</span>);</span><br><span class="line">&#125;).then(<span class="function"><span class="params">v</span>=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(v);</span><br><span class="line">&#125;).catch(<span class="function"><span class="params">err</span>=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(err);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="Generator"><a href="#Generator" class="headerlink" title="Generator"></a>Generator</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Generator生成器模式，利用每当执行完一条yield语句后函数会自动停止执行的特性，从而通过调用next()方法来使异步操作看起来同步化</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">read</span>(<span class="params">file</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve,reject</span>)=&gt;</span>&#123;</span><br><span class="line">        fs.readFile(file,<span class="string">'utf-8'</span>,(err,data)=&gt;&#123;</span><br><span class="line">            <span class="keyword">if</span>(err) reject(err);</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                resolve(data);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> *<span class="title">readFile</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">yield</span> read(<span class="string">'./a.js'</span>);</span><br><span class="line">    <span class="keyword">yield</span> read(<span class="string">'./b.js'</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> file = readFile();</span><br><span class="line"><span class="keyword">let</span> value,done;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>((&#123;value,done&#125; = file.next())&amp;&amp;!done) &#123;</span><br><span class="line">    value.then(<span class="function"><span class="params">v</span>=&gt;</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(v);</span><br><span class="line">    &#125;).catch(<span class="function"><span class="params">err</span>=&gt;</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(err);</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="async-await"><a href="#async-await" class="headerlink" title="async+await"></a>async+await</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// async+await</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">read</span>(<span class="params">fileName</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve,reject</span>)=&gt;</span>&#123;</span><br><span class="line">        fs.readFile(fileName,<span class="string">'utf-8'</span>,(err,data)=&gt;&#123;</span><br><span class="line">            <span class="keyword">if</span>(err) &#123;</span><br><span class="line">                reject(err);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                resolve(data);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">readFile</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> fileA = <span class="keyword">await</span> read(<span class="string">'./a.js'</span>);</span><br><span class="line">    <span class="keyword">let</span> fileB = <span class="keyword">await</span> read(<span class="string">'./b.js'</span>);</span><br><span class="line">    <span class="built_in">console</span>.log(fileA);</span><br><span class="line">    <span class="built_in">console</span>.log(fileB); </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">readFile();</span><br></pre></td></tr></table></figure><h2 id="Generator函数"><a href="#Generator函数" class="headerlink" title="Generator函数"></a>Generator函数</h2><h3 id="简单任务执行器"><a href="#简单任务执行器" class="headerlink" title="简单任务执行器"></a>简单任务执行器</h3><p>由于执行yield语句会暂停当前函数的执行过程并等待下一次调用next()方法，那么我们能否做到设置一个简单任务执行器自动执行所有的任务呢？</p><p>例如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 设置三个简单任务</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> *<span class="title">tasks</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">yield</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">yield</span> <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">yield</span> <span class="number">3</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 简单任务执行器函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">run</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> task = tasks();</span><br><span class="line">    <span class="keyword">let</span> result = task.next();</span><br><span class="line">  </span><br><span class="line">    <span class="comment">// 通过递归的方式，不断检测迭代器的done属性判断迭代器是否迭代完全</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">step</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!result.done) &#123;</span><br><span class="line">            <span class="built_in">console</span>.log(result.value);</span><br><span class="line">            result = task.next();</span><br><span class="line">            step();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    step();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">run();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出结果</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">3</span></span><br></pre></td></tr></table></figure><h3 id="向任务执行器传递函数"><a href="#向任务执行器传递函数" class="headerlink" title="向任务执行器传递函数"></a>向任务执行器传递函数</h3><p>我们再深入一点：如果，那些任务之间是有关联的呢？比如说后执行的任务需要先执行的任务的返回值</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> *<span class="title">tasks</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> value = <span class="keyword">yield</span> <span class="number">1</span>;</span><br><span class="line">    value = <span class="keyword">yield</span> value + <span class="number">1</span>;</span><br><span class="line">    value = <span class="keyword">yield</span> value + <span class="number">2</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那么，我们就可以利用可以向next()方法传递参数的特性。因为这个参数的值就会代替生成器内部上一条yield语句的返回值。</p><p>对于上述生成器函数tasks，如果，没有向next()方法中传入参数，那么yield就不会有返回值（或者默认返回undefined）</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">run</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> task = tasks();</span><br><span class="line">    <span class="keyword">let</span> result = task.next();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">step</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!result.done) &#123;</span><br><span class="line">            <span class="built_in">console</span>.log(result.value);</span><br><span class="line">            result = task.next(result.value);</span><br><span class="line">            step();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    step();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">run();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出结果</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">4</span></span><br></pre></td></tr></table></figure><h3 id="异步任务执行器"><a href="#异步任务执行器" class="headerlink" title="异步任务执行器"></a>异步任务执行器</h3><h4 id="Thunk函数"><a href="#Thunk函数" class="headerlink" title="Thunk函数"></a>Thunk函数</h4><p>任何函数，只要参数有回调函数，就能写成 Thunk 函数的形式</p><p>thunk函数的作用就是将一个函数的执行参数（除回调函数外，一般是回调函数之前定义的参数）和回调函数分成两个函数。</p><p>比如:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fn(args,callback) = &gt; thunk(fn)(args)(callback)</span><br></pre></td></tr></table></figure><p>thunk函数转化器</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> Thunk = <span class="function"><span class="keyword">function</span>(<span class="params">fn</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params">...args</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params">callback</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> fn.call(<span class="keyword">this</span>, ...args, callback);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="Thunk函数与Generator"><a href="#Thunk函数与Generator" class="headerlink" title="Thunk函数与Generator"></a>Thunk函数与Generator</h4><p>因为thunk函数可以将回调函数与执行函数分开，因此，我们就可以在一个地方执行执行函数，而在另一个地方来执行回调函数。</p><p>我们再去思考一些常用的异步操作，例如文件读取、例如Ajax。我们都是从回调函数中获取数据</p><p>因此，我们就可以得到下列的异步处理流程：</p><blockquote><p>执行函数执行 –&gt;等待回调函数传回数据 –&gt; 操作获取的数据</p></blockquote><p>这样，我们就可以将异步代码变得同步化。就像这样</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">let v = fs.readFile(&apos;./a.js&apos;); // 异步操作读取文件</span><br><span class="line">console.log(v); // 操作数据</span><br><span class="line"></span><br><span class="line">readFileThunk(callback); // 在另一个地方执行回调，得到数据并传回数据</span><br></pre></td></tr></table></figure><p>那么，怎么传回数据呢？在前文提到过，我们可以在迭代器中的next()方法中传入参数，来使得该参数成为Generator函数中上一条yield语句的返回值</p><h4 id="以fs-readFile-为例"><a href="#以fs-readFile-为例" class="headerlink" title="以fs.readFile()为例"></a>以fs.readFile()为例</h4><p>假如我们要读取a文件和b文件，那么结合Generator和Thunk函数，我们可以这样写：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Thunk函数转化器</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">thunkify</span>(<span class="params">fn</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">...args</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">callback</span>) </span>&#123;</span><br><span class="line">            fn.call(<span class="keyword">this</span>,...args,callback);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> readFile = thunkify(fs.readFile);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> *<span class="title">read</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 执行函数以及操作数据</span></span><br><span class="line">    <span class="keyword">let</span> value = <span class="keyword">yield</span> readFile(<span class="string">'./a.js'</span>,<span class="string">'utf-8'</span>);</span><br><span class="line">    <span class="built_in">console</span>.log(value);</span><br><span class="line">    value = <span class="keyword">yield</span> readFile(<span class="string">'./b.js'</span>,<span class="string">'utf-8'</span>);</span><br><span class="line">    <span class="built_in">console</span>.log(value);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">run</span>(<span class="params">generator</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> iterator = generator();</span><br><span class="line">    <span class="keyword">let</span> file = iterator.next();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 回调函数执行，以及将获取的数据回传</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">step</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!file.done) &#123;</span><br><span class="line">            file.value(<span class="function">(<span class="params">err,data</span>)=&gt;</span>&#123;</span><br><span class="line">                <span class="keyword">if</span>(err) <span class="keyword">return</span> err;</span><br><span class="line">                file = iterator.next(data);</span><br><span class="line">                step();</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    step();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">run(read);</span><br></pre></td></tr></table></figure><h2 id="async函数"><a href="#async函数" class="headerlink" title="async函数"></a>async函数</h2><p>async的引入可以说是异步操作的终极解决方案。</p><p>那么,async函数是什么呢？</p><blockquote><p>async function 用来定义一个返回 AsyncFunction 对象的异步函数。异步函数是指通过事件循环异步执行的函数，它会通过一个隐式的 Promise 返回其结果。如果你在代码中使用了异步函数，就会发现它的语法和结构会更像是标准的同步函数。</p></blockquote><p>事实上,async函数其实就是Generator函数的语法糖。使用async来表示这是一个异步函数，函数内部使用await来表示一个异步操作</p><p>例如，读取两个文件</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">readFile</span>(<span class="params">fileName,encode</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve,reject</span>)=&gt;</span>&#123;</span><br><span class="line">        fs.readFile(fileName,encode,(err,data)=&gt;&#123;</span><br><span class="line">            <span class="keyword">if</span>(err) &#123;</span><br><span class="line">                reject(err);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> resolve(data);</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">read</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> value = <span class="keyword">await</span> readFile(<span class="string">'./a.js'</span>,<span class="string">'utf-8'</span>);</span><br><span class="line">    <span class="built_in">console</span>.log(value);</span><br><span class="line">    value = <span class="keyword">await</span> readFile(<span class="string">'./b.js'</span>,<span class="string">'utf-8'</span>);</span><br><span class="line">    <span class="built_in">console</span>.log(value);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">read();</span><br></pre></td></tr></table></figure><p>但是，相比于Generator函数，async函数主要有以下的改进</p><ol><li><p>内置执行器</p><p> 在前文提到过，Generator函数会返回一个迭代器。但若想要迭代器自动执行，我们就需要设置一个执行器函数来帮助操作。但是，async函数只需要直接调用就可以自动执行</p></li><li><p>更好的语义化</p><p> async和await，比起星号和yield，语义更清楚了。async表示函数里有异步操作，await表示紧跟在后面的表达式需要等待结果。</p></li><li><p>更广的实用性</p><p> co模块约定，yield命令后面只能是 Thunk 函数或 Promise 对象，而async函数的await命令后面，可以是 Promise 对象和原始类型的值（数值、字符串和布尔值，但这时会自动转成立即 resolved 的 Promise 对象）。</p></li><li><p>返回值是Promise</p><p> async函数的返回值是 Promise 对象，这比 Generator 函数的返回值是 Iterator 对象方便多了。你可以用then方法指定下一步的操作。</p></li></ol><h3 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h3><p>因为async是用来定义一个异步函数的。因此，函数的所有写法都可以在前面加上async定义</p><p>例如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 函数声明</span></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数表达式</span></span><br><span class="line"><span class="keyword">let</span> test = <span class="keyword">async</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 作为对象的方法</span></span><br><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">    <span class="keyword">async</span> test() &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//  作为类的方法</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">T</span></span>&#123;</span><br><span class="line">    <span class="keyword">async</span> test() &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 箭头函数</span></span><br><span class="line"><span class="keyword">let</span> test = <span class="keyword">async</span> ()=&gt;&#123;&#125;</span><br></pre></td></tr></table></figure><h3 id="async函数的返回值"><a href="#async函数的返回值" class="headerlink" title="async函数的返回值"></a>async函数的返回值</h3><p>async会返回一个Promise对象，其会运行执行(resolve)异步函数的返回结果，或者运行拒绝(reject)——如果异步函数抛出异常的话。</p><p>async函数内部的返回值会成为返回的promise对象的回调函数的参数</p><p>例如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">test().then(<span class="function"><span class="params">v</span>=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(v); <span class="comment">// 1</span></span><br><span class="line">&#125;).catch(<span class="function"><span class="params">err</span>=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(err);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>当然，如果async函数内部抛出了错误，就会导致返回的Promsie对象变为reject状态。并且出错的原因会作为promise对象的拒绝处理程序的参数</p><p>例如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'err'</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">test().then(<span class="function"><span class="params">v</span>=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(v);</span><br><span class="line">&#125;).catch(<span class="function"><span class="params">err</span>=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(err); <span class="comment">// Error: 'err'</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="async函数对于多个异步操作的简化"><a href="#async函数对于多个异步操作的简化" class="headerlink" title="async函数对于多个异步操作的简化"></a>async函数对于多个异步操作的简化</h3><p>async/await的目的是简化使用多个 promise 时的同步行为，并对一组 Promises执行某些操作。</p><p>async函数返回的Promise对象必须要等到内部所有的await命令后面的Promise全部执行完，才会将自身的状态从pending（运行态）转化为resolved（fulfilled已完成）或rejected（已拒绝）</p><p>例如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> v1 = <span class="keyword">await</span> <span class="built_in">Promise</span>.resolve(<span class="number">1</span>);</span><br><span class="line">    <span class="built_in">console</span>.log(v1); <span class="comment">// 1</span></span><br><span class="line">    <span class="keyword">let</span> v2 = <span class="keyword">await</span> <span class="built_in">Promise</span>.resolve(<span class="number">2</span>);</span><br><span class="line">    <span class="built_in">console</span>.log(v2); <span class="comment">// 2</span></span><br><span class="line">    <span class="keyword">return</span> v1+v2;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">test().then(<span class="function"><span class="params">v</span>=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(v); <span class="comment">// 3</span></span><br><span class="line">&#125;).catch(<span class="function"><span class="params">err</span>=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(err);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>值得注意的是，如果await命令后面的Promise对象如果变为reject状态，那么整个async函数就会中断运行，并且，async函数返回的promise就会变为拒绝态，并且出错的原因会作为promise对象的拒绝处理程序的参数</p><p>例如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> v1 = <span class="keyword">await</span> <span class="built_in">Promise</span>.resolve(<span class="number">1</span>);</span><br><span class="line">    <span class="built_in">console</span>.log(v1); <span class="comment">// 1</span></span><br><span class="line">    <span class="keyword">let</span> v2 = <span class="keyword">await</span> <span class="built_in">Promise</span>.reject(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// async在这里停止运行</span></span><br><span class="line">    <span class="built_in">console</span>.log(v2);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">test().then(<span class="function"><span class="params">v</span>=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(v);</span><br><span class="line">&#125;).catch(<span class="function"><span class="params">err</span>=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(err); <span class="comment">// 2</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="错误处理"><a href="#错误处理" class="headerlink" title="错误处理"></a>错误处理</h3><p>我们在前面提到过，只要await命令后的一个promise是rejected态的，那么整个async函数就会停止运行。那么，为了防止某个promise错误影响后面的promise执行，我们需要有错误处理机制。</p><p>我们可以使用try…catch…来处理</p><p>例如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> v1 = <span class="keyword">await</span> <span class="built_in">Promise</span>.reject(<span class="string">'err'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span>(e)&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(e); <span class="comment">// 'err'</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">let</span> v2 = <span class="keyword">await</span> <span class="built_in">Promise</span>.resolve(<span class="number">1</span>);</span><br><span class="line">    <span class="built_in">console</span>.log(v2); <span class="comment">// 1</span></span><br><span class="line">    <span class="keyword">return</span> v2;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">test().then(<span class="function"><span class="params">v</span>=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(v); <span class="comment">// 1</span></span><br><span class="line">&#125;).catch(<span class="function"><span class="params">err</span>=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(err);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>如果有多个await命令，我们可以统一放在try…catch结构里</p><p>例如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> v1 = <span class="keyword">await</span> <span class="built_in">Promise</span>.resolve(<span class="number">1</span>);</span><br><span class="line">        <span class="built_in">console</span>.log(v1); <span class="comment">// 1</span></span><br><span class="line">        <span class="keyword">let</span> v2 = <span class="keyword">await</span> <span class="built_in">Promise</span>.reject(<span class="string">'err'</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 抛出错误，try后续部分不再执行</span></span><br><span class="line">        <span class="built_in">console</span>.log(v2);</span><br><span class="line">        <span class="keyword">let</span> v3 = <span class="built_in">Promise</span>.resolve(<span class="number">3</span>);</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="number">3</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span>(e) &#123;</span><br><span class="line">        <span class="comment">// 捕获错误</span></span><br><span class="line">        <span class="built_in">console</span>.log(e); <span class="comment">// 'err'</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">test();</span><br></pre></td></tr></table></figure><h3 id="继发与并发"><a href="#继发与并发" class="headerlink" title="继发与并发"></a>继发与并发</h3><p>继发是执行完一个异步操作之后才会去执行下一个异步操作</p><p>例如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">await</span> <span class="built_in">Promise</span>.resolve(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">await</span> <span class="built_in">Promise</span>.reject(<span class="string">'err'</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">test();</span><br></pre></td></tr></table></figure><p>如果，函数内部的异步操作没有继发关系。也就是每个异步操作是相互独立的，那么让所有的异步操作同时触发会节省程序的执行时间</p><p>我们可以通过Promsie.all()来实现</p><p>例如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> [v1,v2] = <span class="keyword">await</span> <span class="built_in">Promise</span>.all([<span class="built_in">Promise</span>.resolve(<span class="number">1</span>),<span class="built_in">Promise</span>.resolve(<span class="number">2</span>)]);</span><br><span class="line">    <span class="keyword">return</span> [v1,v2];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">test().then(<span class="function"><span class="params">v</span>=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(v); <span class="comment">// [1,2]</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>是的，我们很容易可以想到。如果并发的多个异步操作中有些抛出错误了怎么办？</p><p>我们可以使用try…catch来处理。因此，在使用async函数时请尽量要确保有错误处理机制。</p><p>例如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">try</span>&#123;</span><br><span class="line">        <span class="keyword">let</span> [v1,v2] = <span class="keyword">await</span> <span class="built_in">Promise</span>.all([<span class="built_in">Promise</span>.resolve(<span class="number">1</span>),<span class="built_in">Promise</span>.reject(<span class="number">2</span>)]);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 停止运行</span></span><br><span class="line">        <span class="keyword">return</span> [v1,v2];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span>(e) &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'err'</span>,e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="async函数可以保留运行堆栈"><a href="#async函数可以保留运行堆栈" class="headerlink" title="async函数可以保留运行堆栈"></a>async函数可以保留运行堆栈</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> a() &#123;</span><br><span class="line">    b().then(<span class="function"><span class="params">()</span>=&gt;</span>c())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述代码中，函数a内部运行了一个异步任务b()。当b运行的时候，函数a()不会中断，而是会继续执行，也就是说，当异步操作b()结束后，可能a()早已经结束了。那么，b()所在的上下文环境就会消失</p><p>但是，对于async异步函数</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">await</span> b();</span><br><span class="line">    c();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>b()异步操作在运行的时候,a函数是暂停运行的。因此，对于b()函数，其上下文环境都仍旧保存着。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;异步操作的发展&quot;&gt;&lt;a href=&quot;#异步操作的发展&quot; class=&quot;headerlink&quot; title=&quot;异步操作的发展&quot;&gt;&lt;/a&gt;异步操作的发展&lt;/h2&gt;&lt;p&gt;有一个场景，要先读取a文件，当a文件成功读取完毕后再去读取b文件，我们看一下各种异步操作是如何进行的
      
    
    </summary>
    
      <category term="ES6" scheme="http://yoursite.com/categories/ES6/"/>
    
    
  </entry>
  
  <entry>
    <title>node项目的分层思考</title>
    <link href="http://yoursite.com/2019/10/15/node%E9%A1%B9%E7%9B%AE%E7%9A%84%E5%88%86%E5%B1%82%E6%80%9D%E8%80%83/"/>
    <id>http://yoursite.com/2019/10/15/node项目的分层思考/</id>
    <published>2019-10-15T11:08:26.000Z</published>
    <updated>2019-10-15T11:24:59.425Z</updated>
    
    <content type="html"><![CDATA[<h2 id="路由层（controll）"><a href="#路由层（controll）" class="headerlink" title="路由层（controll）"></a>路由层（controll）</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">app.get(<span class="string">'/'</span>,<span class="keyword">async</span> (ctx,next)=&gt;&#123;</span><br><span class="line">    </span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>## </p><h2 id="controller层"><a href="#controller层" class="headerlink" title="controller层"></a>controller层</h2><p>业务逻辑层，处理业务</p><h2 id="Model层"><a href="#Model层" class="headerlink" title="Model层"></a>Model层</h2><p>实体层，比如说movie这一实体的基本属性和基本方法</p><h2 id="dao层"><a href="#dao层" class="headerlink" title="dao层"></a>dao层</h2><p>数据库相关操作</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;路由层（controll）&quot;&gt;&lt;a href=&quot;#路由层（controll）&quot; class=&quot;headerlink&quot; title=&quot;路由层（controll）&quot;&gt;&lt;/a&gt;路由层（controll）&lt;/h2&gt;&lt;figure class=&quot;highlight java
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>事件机制</title>
    <link href="http://yoursite.com/2019/10/11/%E4%BA%8B%E4%BB%B6%E6%9C%BA%E5%88%B6/"/>
    <id>http://yoursite.com/2019/10/11/事件机制/</id>
    <published>2019-10-11T07:15:04.000Z</published>
    <updated>2019-10-12T09:34:05.195Z</updated>
    
    <content type="html"><![CDATA[<h2 id="事件流"><a href="#事件流" class="headerlink" title="事件流"></a>事件流</h2><p>事件流描述的是从页面中接收事件的顺序。IE提出的事件流是事件冒泡流，而网景提出的事件流是事件捕获流</p><h3 id="事件冒泡"><a href="#事件冒泡" class="headerlink" title="事件冒泡"></a>事件冒泡</h3><p>事件冒泡指代的是，事件开始时是由最具体的元素接收，然后逐级向上传播到较为不具体的节点</p><p>例如：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">head</span>&gt;</span><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">p</span>&gt;</span>hello<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>当你单击了P元素，那么这个事件就会按照如下顺序传播：</p><ol><li>&lt;p&gt;</li><li>&lt;div&gt;</li><li>&lt;body&gt;</li><li>&lt;html&gt;</li><li>document</li></ol><h3 id="事件捕获"><a href="#事件捕获" class="headerlink" title="事件捕获"></a>事件捕获</h3><p>事件捕获的思想是不大具体的节点应该更早接收到事件，而最具体的节点应该最后接收到事件。事件捕获的用意在于在事件到达预定目标之前捕获它</p><p>那么上述例子如果采用事件捕获的话，那么传播顺序就会是这样的：</p><ol><li>document</li><li>&lt;html&gt;</li><li>&lt;body&gt;</li><li>&lt;div&gt;</li><li>&lt;p&gt;</li></ol><h3 id="DOM事件流"><a href="#DOM事件流" class="headerlink" title="DOM事件流"></a>DOM事件流</h3><p>“DOM2级事件”规定的事件流包括三个阶段：</p><ol><li>事件捕获阶段</li><li>处于目标阶段</li><li>事件冒泡阶段</li></ol><p>首先发生的是事件捕获，为截获事件提供了机会。然后是实际的目标接收到事件。最后一个阶段是冒泡阶段，可以在这个阶段对事件做出响应</p><p>值得注意的是：</p><blockquote><p>捕获阶段是不包括实际的目标元素的。这也意味着对于上述的例子，再捕获阶段，事件从document -&gt; &lt;div&gt;后就停止了。然后，处于目标阶段就会响应该目标注册的事件。并在事件处理中被看做事件冒泡阶段的一部分进入事件冒泡阶段</p></blockquote><p>这有一个例子：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">&lt;html&gt;</span><br><span class="line">    &lt;head&gt;<span class="xml"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span></span><br><span class="line">    &lt;body&gt;</span><br><span class="line">        &lt;div style=<span class="string">"width: 100px;height: 100px;border: 1px solid black;"</span>&gt;</span><br><span class="line">            &lt;p style=<span class="string">"width: 50px;height: 20px;border: 1px solid red;margin: 10px 20px"</span>&gt;</span><br><span class="line">                hello</span><br><span class="line">            &lt;<span class="regexp">/p&gt;</span></span><br><span class="line"><span class="regexp">        &lt;/</span>div&gt;</span><br><span class="line">        </span><br><span class="line">        &lt;script&gt;</span><br><span class="line">            <span class="keyword">let</span> div = <span class="built_in">document</span>.getElementsByTagName(<span class="string">'div'</span>)[<span class="number">0</span>];</span><br><span class="line">            div.addEventListener(<span class="string">"click"</span>,(e)=&gt;&#123;</span><br><span class="line">                <span class="built_in">console</span>.log(<span class="string">'冒泡'</span>);</span><br><span class="line">            &#125;,<span class="literal">false</span>);</span><br><span class="line">            div.addEventListener(<span class="string">"click"</span>,(e)=&gt;&#123;</span><br><span class="line">                <span class="built_in">console</span>.log(<span class="string">'捕获'</span>);</span><br><span class="line">            &#125;,<span class="literal">true</span>);</span><br><span class="line">        &lt;<span class="regexp">/script&gt;</span></span><br><span class="line"><span class="regexp">    &lt;/</span>body&gt;</span><br><span class="line">&lt;<span class="regexp">/html&gt;</span></span><br></pre></td></tr></table></figure><p>我们为div元素注册了两个事件，一个要求在冒泡阶段被调用，一个是要求在捕获阶段被调用</p><p>根据DOM事件流的三个阶段，当我们点击&lt;p&gt;元素时，会看到先输出”捕获”再输出”冒泡”。因为，我们点击的目标元素是&lt;p&gt;元素，会经历以下三个阶段。</p><ol><li>在捕获阶段（document-&gt; &lt;html&gt; -&gt; &lt;body&gt; -&gt; &lt;div&gt;），我们捕获到了div注册的要在捕获阶段调用的事件，那么触发它。</li><li>处于目标阶段，没有目标注册的事件</li><li>冒泡阶段（&lt;div&gt; -&gt; &lt;body&gt; -&gt; &lt;html&gt; -&gt; document）响应了div注册的要在冒泡阶段调用的事件</li></ol><p>但是，当我们点击的&lt;div&gt;元素的时候，会看到先输出”捕获”再输出”冒泡”，根据DOM事件流的三个阶段</p><ol><li>在捕获阶段（document-&gt; &lt;html&gt; -&gt; &lt;body&gt;），我们没有捕获到div注册的任何事件。</li><li>处于目标阶段，那么触发目标注册的事件，因为目标注册了两个事件，那么按照顺序依次触发它们，依次输出”冒泡”、”捕获”</li><li>冒泡阶段（ 发生的事件 -&gt; &lt;body&gt; -&gt; &lt;html&gt; -&gt; document）没有捕获到div注册的任何事件</li></ol><h2 id="事件注册"><a href="#事件注册" class="headerlink" title="事件注册"></a>事件注册</h2><h3 id="DOM0级事件处理程序"><a href="#DOM0级事件处理程序" class="headerlink" title="DOM0级事件处理程序"></a>DOM0级事件处理程序</h3><p>每个元素都有自己的事件处理程序属性，这些属性通常全部<strong>小写</strong>，将这种属性的值设置为一个函数，就可以指定事件处理程序</p><p>因为，使用该方法指定的事件处理程序被认为是元素的方法。因此，这时候的事件处理程序是在当前元素的作用域内运行的。也就是说，处理函数中的this指向当前元素</p><p>例如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> element = <span class="built_in">document</span>.getElementById(<span class="string">'ele'</span>);</span><br><span class="line">element.onclick = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.id); <span class="comment">// 'ele'</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们可以将事件处理程序属性的值设为null来删除指定的事件处理程序</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">element.onclick = <span class="literal">null</span>;</span><br></pre></td></tr></table></figure><blockquote><p>注意：DOM0级处理程序默认在冒泡阶段被调用</p></blockquote><h3 id="DOM2级事件处理程序"><a href="#DOM2级事件处理程序" class="headerlink" title="DOM2级事件处理程序"></a>DOM2级事件处理程序</h3><p>DOM2级提供了两个方法来添加和删除事件处理程序</p><ol><li>addEventListener()</li><li>removeEventListener()</li></ol><p>这两个方法都接受三个参数：</p><ol><li>要处理的事件名</li><li>作为事件处理程序的函数</li><li>布尔值（true表示在捕获阶段调用函数；false表示在冒泡阶段调用函数）</li></ol><p>例如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> element = <span class="built_in">document</span>.getElementById(<span class="string">'ele'</span>);</span><br><span class="line"></span><br><span class="line">element.addEventListener(<span class="string">'click'</span>,(e)=&gt;&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'捕获'</span>)</span><br><span class="line">&#125;,<span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">element.addEventListener(<span class="string">'click'</span>,(e)=&gt;&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'冒泡'</span>)</span><br><span class="line">&#125;,<span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">element.removeEventListener(<span class="string">'click'</span>,(e)=&gt;&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'捕获'</span>)</span><br><span class="line">&#125;,<span class="literal">true</span>);</span><br></pre></td></tr></table></figure><p>我们可以看到，使用DOM2级注册方式的主要好处是可以添加多个事件处理程序</p><p>值得注意的是：</p><blockquote><p>通过addEventListener()方法注册的事件处理程序只能通过removeEventListener()方法来移除。并且，移除时传入的三个参数必须与添加时的三个参数一致。因此，通过addEventListener()添加的匿名函数无法被移除（参数必须完全一致，也就是说第二个参数函数也要是同一个函数）</p></blockquote><p>例如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> element = <span class="built_in">document</span>.getElementById(<span class="string">'ele'</span>);</span><br><span class="line"></span><br><span class="line">element.addEventListener(<span class="string">'click'</span>,(e)=&gt;&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'捕获'</span>)</span><br><span class="line">&#125;,<span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">element.addEventListener(<span class="string">'click'</span>,(e)=&gt;&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'冒泡'</span>)</span><br><span class="line">&#125;,<span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">element.removeEventListener(<span class="string">'click'</span>,(e)=&gt;&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'捕获'</span>)</span><br><span class="line">&#125;,<span class="literal">true</span>);</span><br></pre></td></tr></table></figure><p>点击<div>后的输出结果会是’捕获’与’冒泡’，也就是说事件移除方法没有生效。原因就在于事件移除方法中的第二个参数与添加时的那个函数不是同一个函数</div></p><p>我们可以将函数单独提出来赋予给一个变量，从而可以达到目标</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> element = <span class="built_in">document</span>.getElementById(<span class="string">'ele'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> handle = <span class="function">(<span class="params">e</span>)=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'捕获'</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">element.addEventListener(<span class="string">'click'</span>,handle,<span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">element.addEventListener(<span class="string">'click'</span>,(e)=&gt;&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'冒泡'</span>)</span><br><span class="line">&#125;,<span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">element.removeEventListener(<span class="string">'click'</span>,handle,<span class="literal">true</span>);</span><br></pre></td></tr></table></figure><p>此时的输出结果就会是’冒泡’，也就是说事件移除程序生效了</p><p>另外，类似DOM0级方法，使用addEventListener()方法添加的事件处理程序内部的this值也指向当前绑定的元素，但要注意箭头函数的情况。因为箭头函数内部的this是由其外层代码作用域决定的</p><p>例如：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"ele"</span>&gt;</span>hello<span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> div = <span class="built_in">document</span>.getElementsByTagName(<span class="string">'div'</span>)[<span class="number">0</span>];</span><br><span class="line">div.addEventListener(<span class="string">'click'</span>,<span class="function"><span class="keyword">function</span>(<span class="params">e</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.id); <span class="comment">// ele</span></span><br><span class="line">&#125;)</span><br><span class="line">div.addEventListener(<span class="string">'click'</span>,(e)=&gt;&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.id,<span class="keyword">this</span>); <span class="comment">// undefined,window &#123;&#125;</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>可以看到，在非箭头函数中this指向当前事件绑定的对象；而在箭头函数中this指向了window全局对象（因为该箭头函数外层代码作用域为window全局作用域，因此this也指向了window全局对象）</p><h2 id="事件对象"><a href="#事件对象" class="headerlink" title="事件对象"></a>事件对象</h2><p>在触发DOM上的某个事件时，会产生一个事件对象event。这个对象包含着所有与事件有关的信息。</p><h3 id="事件对象的常用属性："><a href="#事件对象的常用属性：" class="headerlink" title="事件对象的常用属性："></a>事件对象的常用属性：</h3><table><thead><tr><th>属性</th><th>类型</th><th>说明</th></tr></thead><tbody><tr><td>target</td><td>Element</td><td>事件的目标，也就是当前事件发生的目标。比如说点击的那个元素</td></tr><tr><td>currentTarget</td><td>Element</td><td>当前事件绑定的那个元素</td></tr><tr><td>type</td><td>String</td><td>被触发的事件类型</td></tr><tr><td>eventPhase</td><td>Integer</td><td>调用时间处理程序的阶段：1表示捕获阶段，2表示处于目标阶段，3表示冒泡阶段</td></tr></tbody></table><p>值得注意的是，在事件处理程序内部（非匿名函数），对象中this的值始终等于event.currentTarget的值，而不一定等于event.target</p><p>例如：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">"height:100px;width:100px;border:1px solid red;"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span> <span class="attr">style</span>=<span class="string">"height:50px;width:50px;border:1px solid black;"</span>&gt;</span>hello<span class="tag">&lt;/<span class="name">p</span>&gt;</span>    </span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> div = <span class="built_in">document</span>.getElementsByTagName(<span class="string">'div'</span>)[<span class="number">0</span>];</span><br><span class="line">div.addEventListener(<span class="string">'click'</span>,(event)=&gt;&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(event.target);</span><br><span class="line">    <span class="built_in">console</span>.log(event.currentTarget);</span><br><span class="line">    <span class="built_in">console</span>.log(event.type);</span><br><span class="line">    <span class="built_in">console</span>.log(event.eventPhase);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>当我们点击div元素时，输出结果如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;div&gt;...&lt;/div&gt;</span><br><span class="line">&lt;div&gt;...&lt;/div&gt;</span><br><span class="line">click</span><br><span class="line">2</span><br></pre></td></tr></table></figure><p>当我们点击p元素时，输出结果如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;p&gt;...&lt;/p&gt;</span><br><span class="line">&lt;div&gt;...&lt;/div&gt;</span><br><span class="line">click</span><br><span class="line">3</span><br></pre></td></tr></table></figure><p>很明显可以发现，event.target指向你点击的那个元素；而event.currentTarget指向该事件绑定的那个元素</p><h3 id="事件对象的常用方法"><a href="#事件对象的常用方法" class="headerlink" title="事件对象的常用方法"></a>事件对象的常用方法</h3><table><thead><tr><th>方法</th><th>类型</th><th>说明</th></tr></thead><tbody><tr><td>preventDefault()</td><td>Function</td><td>取消事件的默认行为。如果camcelable是true，则可以使用该方法</td></tr><tr><td>stopPropagation()</td><td>Function</td><td>取消事件的进一步捕获或冒泡</td></tr><tr><td>stopImmediatePropagation()</td><td>Function</td><td>取消事件的进一步捕获或冒泡，同时阻止相同事件的其他侦听器被调用</td></tr></tbody></table><h4 id="preventDefault"><a href="#preventDefault" class="headerlink" title="preventDefault()"></a>preventDefault()</h4><p>要阻止特定事件的默认行为，我们就可以使用preventDefault()方法。比如，链接的默认行为就是在被单击时会导航到其href特性指定的URL。如果想要阻止该默认行为，我们可以这样做</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a = <span class="built_in">document</span>.getElementsByTagName(<span class="string">'a'</span>);</span><br><span class="line">a.addEventListener(<span class="string">'click'</span>,<span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line">    event.preventDefault();</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>这样的话，我们点击链接后就不会进行跳转</p><h4 id="stopPropagation"><a href="#stopPropagation" class="headerlink" title="stopPropagation()"></a>stopPropagation()</h4><p>stopPropagation()方法可以立即停止事件在DOM层次中的传播，即取消进一步的事件捕获或冒泡</p><p>例如，我们在一个元素上的绑定两个事件处理程序，一个在捕获阶段执行，一个在冒泡阶段执行；并且我们在要在捕获阶段调用的函数添加event.stopPropagation()方法</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span>hello<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> div = <span class="built_in">document</span>.getElementsByTagName(<span class="string">'div'</span>)[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">div.addEventListener(<span class="string">'click'</span>,<span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'捕获'</span>,event.eventPhase);</span><br><span class="line">    <span class="comment">// 添加event.stopPropagation()方法来阻止事件的进一步传播</span></span><br><span class="line">    event.stopPropagation();</span><br><span class="line">&#125;,<span class="literal">true</span>)</span><br><span class="line"></span><br><span class="line">div.addEventListener(<span class="string">'click'</span>,<span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'冒泡'</span>,event.eventPhase);</span><br><span class="line">&#125;,<span class="literal">false</span>)</span><br></pre></td></tr></table></figure><p>此时我们会看到输出结果是：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&apos;捕获&apos; 2</span><br><span class="line">&apos;冒泡&apos; 2</span><br></pre></td></tr></table></figure><p>为什么event.stopPropagation()没有阻止事件的进一步传播？</p><p>我们可以看到，两个事件处理程序输出的eventPhase值都是2，也就是这两个函数在处于目标阶段被调用。回忆，前文提到的，DOM事件流的三个阶段，捕获阶段和冒泡阶段是不会包括目标元素的。</p><p>因此，我们可以将事件绑定到document上</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">document</span>.addEventListener(<span class="string">'click'</span>,<span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'捕获'</span>,event.eventPhase);</span><br><span class="line">    <span class="comment">// 添加event.stopPropagation()方法来阻止事件的进一步传播</span></span><br><span class="line">    event.stopPropagation();</span><br><span class="line">&#125;,<span class="literal">true</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">document</span>.addEventListener(<span class="string">'click'</span>,<span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'冒泡'</span>,event.eventPhase);</span><br><span class="line">&#125;,<span class="literal">false</span>)</span><br></pre></td></tr></table></figure><p>这样输出结果就符合预期，输出如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&apos;捕获&apos; 1</span><br></pre></td></tr></table></figure><h2 id="事件委托（事件代理）"><a href="#事件委托（事件代理）" class="headerlink" title="事件委托（事件代理）"></a>事件委托（事件代理）</h2><p>事件委托是将一个或多个元素响应事件的函数委托给它们的外层元素来解决事件处理程序过多的问题。</p><p>例如，有一个列表</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span> <span class="attr">id</span>=<span class="string">"li-1"</span>&gt;</span>1<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span> <span class="attr">id</span>=<span class="string">"li-2"</span>&gt;</span>2<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span> <span class="attr">id</span>=<span class="string">"li-3"</span>&gt;</span>3<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br></pre></td></tr></table></figure><p>如果我们想要在点击每一个列表项时可以输出列表项的内容</p><p>传统做法会为每个li绑定事件处理程序：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">handle</span>(<span class="params">e</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.innerHTML);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">document</span>.getElementById(<span class="string">'li-1'</span>).addEventListener(<span class="string">'click'</span>,handle);</span><br><span class="line"></span><br><span class="line"><span class="built_in">document</span>.getElementById(<span class="string">'li-2'</span>).addEventListener(<span class="string">'click'</span>,handle);</span><br><span class="line"></span><br><span class="line"><span class="built_in">document</span>.getElementById(<span class="string">'li-3'</span>).addEventListener(<span class="string">'click'</span>,handle);</span><br></pre></td></tr></table></figure><p>使用事件委托（事件代理）,我们可以将事件处理程序绑定到li的外层元素ul上</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> ul = <span class="built_in">document</span>.getElementsByTagName(<span class="string">'ul'</span>)[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">ul.addEventListener(<span class="string">'click'</span>,<span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(event.target.innerHTML);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>此时，当我们点击列表项时，DOM事件流会在第三个阶段（冒泡阶段）触发事件处理程序。我们通过event.target来获得实际点击的元素来输出列表项内容。</p><p>因此，与传统方法相比，如果每一个列表项需要绑定的是不同的事件处理程序。那么，我们可以想象，如果，列表足够长，那么我们需要定义的函数对象就会非常多，因此，也会非常占用内存造成性能变差。而事件委托机制则可以很好的解决这个问题</p><h3 id="事件委托（事件代理）的优点"><a href="#事件委托（事件代理）的优点" class="headerlink" title="事件委托（事件代理）的优点"></a>事件委托（事件代理）的优点</h3><ol><li><p>减少内存消耗，提升效率</p></li><li><p>可以动态地绑定事件</p><p> 例如：使用传统方法，当我们动态地添加一个节点时，我们就另外需要为该节点绑定一个事件。但是，如果采用事件委托，我们就可以避免这种情况。因为事件是绑定在父层的，和目标元素的增减是没有关系的，执行到目标元素是在真正响应执行事件函数的过程中去匹配的；</p></li></ol><p>例如：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span> <span class="attr">id</span>=<span class="string">"li-1"</span>&gt;</span>1<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span> <span class="attr">id</span>=<span class="string">"li-2"</span>&gt;</span>2<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span> <span class="attr">id</span>=<span class="string">"li-3"</span>&gt;</span>3<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br></pre></td></tr></table></figure><p>当我们需要动态添加一个节点比如说li-4，采用传统方式的话，创建完之后我们还需要额外绑定事件</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> li_4 = <span class="built_in">document</span>.createElment(<span class="string">'li'</span>);</span><br><span class="line"></span><br><span class="line">li_4.addEventListener(<span class="string">'click'</span>,<span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.innerHTML);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>如果，我们采用事件委托（事件代理）的话，就可以避免这个问题</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ul.addEventListener(<span class="string">'click'</span>,<span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(event.target.innerHTML);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>这样的话，无论添加多少个节点或是删除多少个节点，只要在父节点内的节点都可以有相应的事件</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;事件流&quot;&gt;&lt;a href=&quot;#事件流&quot; class=&quot;headerlink&quot; title=&quot;事件流&quot;&gt;&lt;/a&gt;事件流&lt;/h2&gt;&lt;p&gt;事件流描述的是从页面中接收事件的顺序。IE提出的事件流是事件冒泡流，而网景提出的事件流是事件捕获流&lt;/p&gt;
&lt;h3 id=&quot;事件冒泡
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>跨域与解决方案</title>
    <link href="http://yoursite.com/2019/10/07/%E8%B7%A8%E5%9F%9F%E4%B8%8E%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/"/>
    <id>http://yoursite.com/2019/10/07/跨域与解决方案/</id>
    <published>2019-10-07T08:11:53.000Z</published>
    <updated>2019-10-11T07:16:44.071Z</updated>
    
    <content type="html"><![CDATA[<h2 id="什么是跨域"><a href="#什么是跨域" class="headerlink" title="什么是跨域"></a>什么是跨域</h2><p>通过XHR对象来实现Ajax通信的一个主要限制，来源于跨域安全策略。在默认的情况下，XHR对象只能访问与包含它的页面位于同一个域中的资源。</p><p>那么，什么样的情况算是同一个域，什么样的情况算是不同的域呢？</p><h3 id="同源"><a href="#同源" class="headerlink" title="同源"></a>同源</h3><p>所谓同源（即指在同一个域）就是两个页面具有相同的协议（包括HTTP和HTTPS），主机（host）和端口号（port）</p><h3 id="跨域"><a href="#跨域" class="headerlink" title="跨域"></a>跨域</h3><p>当一个请求url的协议、域名、端口三者之间任意一个与当前页面url不同即为跨域</p><h3 id="域名层次"><a href="#域名层次" class="headerlink" title="域名层次"></a>域名层次</h3><h4 id="域名语法"><a href="#域名语法" class="headerlink" title="域名语法"></a>域名语法</h4><p>域名由一或多个部分组成，这些部分通常连接在一起，并由点分隔，例如zh.wikipedia.org。最右边的一个标签是顶级域名，例如zh.wikipedia.org的顶级域名是org。一个域名的层次结构，从右侧到左侧隔一个点依次下降一层。</p><h4 id="顶级域名"><a href="#顶级域名" class="headerlink" title="顶级域名"></a>顶级域名</h4><p>顶级域名是域名中最高的一级，每个域名都以顶级域名结尾。</p><h4 id="子域名"><a href="#子域名" class="headerlink" title="子域名"></a>子域名</h4><p>子域名将顶级域名进一步细分。域名层次结构中，顶级域名下面是二级域名，它位于顶级域名的左侧。例如，在zh.wikipedia.org中，wikipedia是二级域名。w3.org中，w3也是二级域名，与前例中的wikipedia属于一个层面。</p><p>二级域名下面是三级域名，它位于二级域名的左侧。例如，在zh.wikipedia.org中，zh是三级域名；zh-classical.wikipedia.org（文言文维基大典的域名）中，zh-classical也是三级域名，与前例中的zh属于一个层面。从右侧到左侧，隔一个点依次下降一层。</p><h3 id="常见跨域场景"><a href="#常见跨域场景" class="headerlink" title="常见跨域场景"></a>常见跨域场景</h3><table><thead><tr><th>当前页面URL</th><th>请求页面URL</th><th>是否跨域</th><th>原因</th></tr></thead><tbody><tr><td><a href="http://www.example.com/a.js" target="_blank" rel="noopener">http://www.example.com/a.js</a></td><td><a href="http://www.example.com/b.js" target="_blank" rel="noopener">http://www.example.com/b.js</a></td><td>否</td><td>协议、域名、端口号均相同</td></tr><tr><td><a href="http://www.example.com/a.js" target="_blank" rel="noopener">http://www.example.com/a.js</a></td><td><a href="https://www.example.com/b.js" target="_blank" rel="noopener">https://www.example.com/b.js</a></td><td>是</td><td>协议不同（http与https）</td></tr><tr><td><a href="http://www.example.com/a.js" target="_blank" rel="noopener">http://www.example.com/a.js</a></td><td><a href="http://www.test.com/b.js" target="_blank" rel="noopener">http://www.test.com/b.js</a></td><td>是</td><td>域名不同</td></tr><tr><td><a href="http://www.example.com/a.js" target="_blank" rel="noopener">http://www.example.com/a.js</a></td><td><a href="http://www.blog.example.com/b.js" target="_blank" rel="noopener">http://www.blog.example.com/b.js</a></td><td>是</td><td>主域名相同，但子域名不同</td></tr><tr><td><a href="http://www.example.com/a.js" target="_blank" rel="noopener">http://www.example.com/a.js</a></td><td><a href="http://192.168.56.1/b.js" target="_blank" rel="noopener">http://192.168.56.1/b.js</a></td><td>是</td><td>域名与其对应ip地址之间的请求也算跨域</td></tr><tr><td><a href="http://www.example.com" target="_blank" rel="noopener">http://www.example.com</a></td><td><a href="http://www.example.com:8888/b.js" target="_blank" rel="noopener">http://www.example.com:8888/b.js</a></td><td>是</td><td>端口不同</td></tr></tbody></table><h2 id="跨域解决方案"><a href="#跨域解决方案" class="headerlink" title="跨域解决方案"></a>跨域解决方案</h2><h3 id="JSONP"><a href="#JSONP" class="headerlink" title="JSONP"></a>JSONP</h3><h4 id="什么是JSONP"><a href="#什么是JSONP" class="headerlink" title="什么是JSONP"></a>什么是JSONP</h4><p>JSONP是JSON with padding（填充式JSON或参数是JSON）的简写，是应用JSON的一种新方法。JSONP看起来与JSON差不多，只不过是被包含在函数调用中的JSON，例如</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">callback(&#123;<span class="string">"name"</span>:<span class="string">"Ming"</span>&#125;)</span><br></pre></td></tr></table></figure><p>JSONP由两部分组成：回调函数以及传递给回调函数的参数JSON字符串</p><h4 id="JSONP的原理及具体实现过程"><a href="#JSONP的原理及具体实现过程" class="headerlink" title="JSONP的原理及具体实现过程"></a>JSONP的原理及具体实现过程</h4><ol><li><p>因为&lt;script&gt;元素可以不受限制地从其他域加载资源。因此<br>我们可以在web端通过动态&lt;script&gt;来实现一个JSONP请求，例如</p> <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> script = <span class="built_in">document</span>.createElement(<span class="string">'script'</span>);</span><br><span class="line">script.src = <span class="string">'http://localhost:8888/getTestData?callback=handle'</span></span><br></pre></td></tr></table></figure></li><li><p>通过上一步，我们就可以引入<a href="http://localhost:8888/getTestData?callback=handle该文件，同时将参数callback发送给服务器" target="_blank" rel="noopener">http://localhost:8888/getTestData?callback=handle该文件，同时将参数callback发送给服务器</a></p></li><li><p>因为script标签内需要可执行的javascript代码，因此我们可以知道使用JSONP是需要后端配合的，后端需要返回一个javascript类型数据才可以。我们通过express来模拟返回一下数据</p> <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> express = <span class="built_in">require</span>(<span class="string">'express'</span>);</span><br><span class="line"><span class="keyword">let</span> app = express();</span><br><span class="line"></span><br><span class="line">app.listen(<span class="number">8888</span>);</span><br><span class="line"></span><br><span class="line">app.get(<span class="string">'/getTestData'</span>,<span class="function"><span class="keyword">function</span>(<span class="params">req,res,next</span>) </span>&#123;</span><br><span class="line"><span class="keyword">let</span> _callback = req.query.callback;</span><br><span class="line"><span class="keyword">let</span> _data = &#123;</span><br><span class="line">    <span class="string">"code"</span>: <span class="number">0</span>,</span><br><span class="line">    <span class="string">"msg"</span>: <span class="string">'hello world'</span></span><br><span class="line">&#125;;</span><br><span class="line">res.type(<span class="string">'text/javascript'</span>);</span><br><span class="line">res.send(_callback+<span class="string">'('</span>+<span class="built_in">JSON</span>.stringify(_data)+<span class="string">')'</span>);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p> 我们可以看到，服务器会接收到我们请求的参数，也就是回调函数名callback；接着，服务器生成_data数据，将其序列化后作为参数传入callback函数并返回给前端（注意的是，返回的内容类型是javascript代码）</p></li><li><p>收到服务器返回的javascript代码，也就是一个准备执行的已传入参数的函数。（需要注意的是，script标签内的代码会成为全局代码，也就是该函数会成为全局函数）</p></li><li><p>因此，如果我们在使用模块化开发的时候，模块内的代码都是局部代码，因此，我们需要注册一个全局的callback函数让服务器返回的Javascript代码可以执行。同时，我们的业务逻辑也就可以写在这个callback函数中。例如：</p> <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">window</span>.handle = <span class="function"><span class="keyword">function</span>(<span class="params">res</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(res);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>捕获错误：我们可以使用onerror事件处理程序来确定JSONP请求是否成功</p> <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">script.onerror = <span class="function"><span class="keyword">function</span> (<span class="params">err</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'error'</span>,err);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h4 id="JSONP的前后端代码示例"><a href="#JSONP的前后端代码示例" class="headerlink" title="JSONP的前后端代码示例"></a>JSONP的前后端代码示例</h4><h5 id="前端代码"><a href="#前端代码" class="headerlink" title="前端代码"></a>前端代码</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> script = <span class="built_in">document</span>.createElement(<span class="string">'script'</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">window</span>.handle = <span class="function"><span class="keyword">function</span> (<span class="params">res</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.console.log(res.code);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">script.src = <span class="string">'http://localhost:8888/getTestData?callback=handle'</span>;</span><br><span class="line">script.onerror = <span class="function"><span class="keyword">function</span> (<span class="params">err</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'error'</span>,err);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">document</span>.body.appendChild(script);</span><br></pre></td></tr></table></figure><h5 id="Node-js代码"><a href="#Node-js代码" class="headerlink" title="Node.js代码"></a>Node.js代码</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> express = <span class="built_in">require</span>(<span class="string">'express'</span>);</span><br><span class="line"><span class="keyword">let</span> app = express();</span><br><span class="line"></span><br><span class="line">app.listen(<span class="number">8888</span>);</span><br><span class="line"></span><br><span class="line">app.get(<span class="string">'/getTestData'</span>,<span class="function"><span class="keyword">function</span>(<span class="params">req,res,next</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> _callback = req.query.callback;</span><br><span class="line">  <span class="keyword">let</span> _data = &#123;</span><br><span class="line">    code: <span class="number">0</span>,</span><br><span class="line">    msg: <span class="string">'hello world'</span></span><br><span class="line">  &#125;;</span><br><span class="line">  res.type(<span class="string">'text/javascript'</span>);</span><br><span class="line">  res.send(_callback+<span class="string">'('</span>+<span class="built_in">JSON</span>.stringify(_data)+<span class="string">')'</span>);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h4 id="JSONP的一些个人思考"><a href="#JSONP的一些个人思考" class="headerlink" title="JSONP的一些个人思考"></a>JSONP的一些个人思考</h4><ol><li>为什么后端返回的javascript代码中传给函数的参数是JSON而不是javascript对象？<br>关于这个，我们要记住，JSON数据是我们的要获取的东西（json易于人阅读和编写，也易于机器解析和生成，相对网络传输速率较高，因此，进行数据交换我们一般使用JSON），而JSONP是我们获取JSON数据的手段。</li><li>JSONP能够直接访问响应文本，并且支持在浏览器与服务器之间双向通信</li><li>可以看到，JSONP只支持GET请求</li></ol><h3 id="CORS"><a href="#CORS" class="headerlink" title="CORS"></a>CORS</h3><p>CORS （Cross-Origin Resource Sharing，跨域资源共享）是一个系统，它由一系列传输的HTTP头组成，这些HTTP头决定浏览器是否阻止前端 JavaScript 代码获取跨域请求的响应。</p><p>同源安全策略 默认阻止“跨域”获取资源。但是 CORS 给了web服务器这样的权限，即服务器可以选择，允许跨域请求访问到它们的资源。</p><h4 id="简单请求"><a href="#简单请求" class="headerlink" title="简单请求"></a>简单请求</h4><p>某些请求不会触发CORS预检请求，这样的请求被视为简单请求。</p><p>满足以下条件之一就被视为简单请求</p><ol><li><p>使用下列方法之一：</p><p> GET<br> HEAD<br> POST</p></li><li><p>Content-Type 的值仅限于下列三者之一：</p><p> text/plain<br> multipart/form-data<br> application/x-www-form-urlencoded</p></li></ol><p>目前浏览器基本都实现了XHR对象对CORS的原生支持。因此，对于简单请求，浏览器就会直接发出CORS请求，具体来说，就是会在请求的头信息中，增加一个Origin字段来表示请求源</p><p>我们查看一下请求报文就可以发现，在请求报文中会多出一个字段origin来说明请求的源；在响应报文中会多出一个字段Access-Control-Allow-Origin:*来允许所有的源进行跨域；当然也可以设置这个字段只允许一个或几个域才可以跨域</p><p><strong>请求报文与响应报文</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">GET /resources/public-data/ HTTP/1.1</span><br><span class="line">Host: bar.other</span><br><span class="line">User-Agent: Mozilla/5.0 (Macintosh; U; Intel Mac OS X 10.5; en-US; rv:1.9.1b3pre) Gecko/20081130 Minefield/3.1b3pre</span><br><span class="line">Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8</span><br><span class="line">Accept-Language: en-us,en;q=0.5</span><br><span class="line">Accept-Encoding: gzip,deflate</span><br><span class="line">Accept-Charset: ISO-8859-1,utf-8;q=0.7,*;q=0.7</span><br><span class="line">Connection: keep-alive</span><br><span class="line">Referer: http://foo.example/examples/access-control/simpleXSInvocation.html</span><br><span class="line"></span><br><span class="line">// origin</span><br><span class="line">Origin: http://foo.example</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">HTTP/1.1 200 OK</span><br><span class="line">Date: Mon, 01 Dec 2008 00:23:53 GMT</span><br><span class="line">Server: Apache/2.0.61</span><br><span class="line"></span><br><span class="line">// Access-Control-Allow-Origin</span><br><span class="line">Access-Control-Allow-Origin: *</span><br><span class="line">Keep-Alive: timeout=2, max=100</span><br><span class="line">Connection: Keep-Alive</span><br><span class="line">Transfer-Encoding: chunked</span><br><span class="line">Content-Type: application/xml</span><br><span class="line"></span><br><span class="line">[XML Data]</span><br></pre></td></tr></table></figure><h4 id="非简单请求（预检请求）"><a href="#非简单请求（预检请求）" class="headerlink" title="非简单请求（预检请求）"></a>非简单请求（预检请求）</h4><p>与简单请求不同，非简单请求（预检请求）会要求使用OPTIONS方法预先发送一个预检请求给服务器，以货值服务器是否允许该实际请求。预检请求的使用，可以一定程度上来避免跨域请求对服务器的用户数据产生未预期的影响</p><p>当请求满足以下任一条件时，就会发送预检请求</p><ol><li><p>使用了下面任一HTTP方法</p><ol><li>PUT</li><li>DELETE</li><li>CONNECT</li><li>OPTIONS</li><li>TRACE</li><li>PATCH</li></ol></li><li><p>人为设置了对 CORS 安全的首部字段集合之外的其他首部字段。该集合为：</p><p> Accept<br> Accept-Language<br> Content-Language<br> Content-Type (需要注意额外的限制)<br> DPR<br> Downlink<br> Save-Data<br> Viewport-Width<br> Width</p></li><li><p>Content-Type 的值不属于下列之一:</p><ol><li>application/ x-www-form-urlencoded</li><li>multipart/form-data</li><li>text/plain</li></ol></li></ol><p>非简单请求（预检请求）的示意图如下：</p><p><img src="https://mdn.mozillademos.org/files/16753/preflight_correct.png" alt></p><h3 id="node中间件代理"><a href="#node中间件代理" class="headerlink" title="node中间件代理"></a>node中间件代理</h3><p>node中间件实现跨域代理，是通过启一个代理服务器，实现数据的转发</p><p>前端所在的域与node代理服务器处在同一个域上，所有发送给代理服务器的请求都会被该服务器代理并转发给预先设定的服务器地址</p><h4 id="前端请求"><a href="#前端请求" class="headerlink" title="前端请求"></a>前端请求</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> xhr = <span class="keyword">new</span> XMLHttpRequest();</span><br><span class="line">xhr.onreadystatechange = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(xhr.readyState===<span class="number">4</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span>(xhr.status&gt;=<span class="number">200</span>&amp;&amp;xhr.status&lt;<span class="number">300</span>) &#123;</span><br><span class="line">            <span class="built_in">console</span>.log(xhr.responseText);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">'error'</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">xhr.open(<span class="string">'get'</span>,<span class="string">'http://localhost:3000'</span>,<span class="literal">true</span>);</span><br><span class="line">xhr.send(<span class="literal">null</span>);</span><br></pre></td></tr></table></figure><h4 id="node代理服务器"><a href="#node代理服务器" class="headerlink" title="node代理服务器"></a>node代理服务器</h4><p>利用http-proxy-middleware该中间件实现代理服务器</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> express = <span class="built_in">require</span>(<span class="string">'express'</span>);</span><br><span class="line"><span class="keyword">const</span> proxy = <span class="built_in">require</span>(<span class="string">'http-proxy-middleware'</span>)</span><br><span class="line"><span class="keyword">let</span> app = express();</span><br><span class="line"></span><br><span class="line">app.use(<span class="string">'/'</span>,proxy(&#123;</span><br><span class="line">  target: <span class="string">'http://localhost:3000'</span>,</span><br><span class="line">  changeOrigin: <span class="literal">true</span></span><br><span class="line">&#125;))</span><br><span class="line"></span><br><span class="line">app.listen(<span class="number">8080</span>,<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'8080端口已打开'</span>);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h4 id="node-js后端"><a href="#node-js后端" class="headerlink" title="node.js后端"></a>node.js后端</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> express = <span class="built_in">require</span>(<span class="string">'express'</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> app = express();</span><br><span class="line"></span><br><span class="line">app.get(<span class="string">'/'</span>,(req,res)=&gt;&#123;</span><br><span class="line">    res.send(<span class="string">'hello'</span>);</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">app.listen(<span class="number">3000</span>,<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'3000端口已打开'</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>这样我们就可以通过代理服务器进行跨域请求</p><h3 id="webpack配置跨域"><a href="#webpack配置跨域" class="headerlink" title="webpack配置跨域"></a>webpack配置跨域</h3><p>类似Vue这些框架都会用webpack进行打包。webpack中可以引入webpack-dev-server来进行服务器相关的配置。</p><p>与上述node中间件使用http-proxy-middleware 包一样，该dev-server也使用了该包，因此语法也是一样的</p><p>我们可以在webpack.config.js进行跨域相关的配置</p><p>webpack.config.js的跨域配置</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">devServer : &#123;</span><br><span class="line">    proxy: &#123;</span><br><span class="line">        <span class="string">"/api"</span>: &#123;</span><br><span class="line">            target: <span class="string">"http://localhost:3000"</span>,</span><br><span class="line">            pathRewrite: &#123;<span class="string">"^/api"</span>: <span class="string">""</span>&#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>前端请求</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> xhr = <span class="keyword">new</span> XMLHttpRequest();</span><br><span class="line">xhr.onreadystatechange = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(xhr.readyState===<span class="number">4</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span>(xhr.status&gt;=<span class="number">200</span>&amp;&amp;xhr.status&lt;<span class="number">300</span>) &#123;</span><br><span class="line">            <span class="built_in">console</span>.log(xhr.responseText);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">'error'</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">xhr.open(<span class="string">'get'</span>,<span class="string">'/api/hello'</span>,<span class="literal">true</span>);</span><br><span class="line">xhr.send(<span class="literal">null</span>);</span><br></pre></td></tr></table></figure><p>后端node接口</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> express = <span class="built_in">require</span>(<span class="string">'express'</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> app = express();</span><br><span class="line"></span><br><span class="line">app.get(<span class="string">'/hello'</span>,(req,res)=&gt;&#123;</span><br><span class="line">    res.setHeader(<span class="string">'Content-type'</span>,<span class="string">'application/json'</span>);</span><br><span class="line">    res.send(<span class="string">'hello'</span>);</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">app.listen(<span class="number">3000</span>,<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'3000端口已打开'</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>此时，请求”/api/hello”就会被代理到”<a href="http://localhost:3000/hello&quot;" target="_blank" rel="noopener">http://localhost:3000/hello&quot;</a></p><h4 id="配置中的主要参数说明"><a href="#配置中的主要参数说明" class="headerlink" title="配置中的主要参数说明"></a>配置中的主要参数说明</h4><ol><li><p>‘/api’</p><p> 如果请求中有该字符串’/api’，那么就会开始匹配代理。比如，api请求’/api/hello’，就会被代理到请求’<a href="http://localhost:3000/api/hello&#39;" target="_blank" rel="noopener">http://localhost:3000/api/hello&#39;</a></p></li><li><p>target</p><p> 代理的API地址。地址可以是域名也可以是IP地址，如果是域名就需要额外添加一个参数changeOrigin: true</p></li><li><p>pathRewrite</p><p> 路径重写，也就是说会修改最终请求的API路径。设置pathRewrite:{‘^/api’:’’}后，最终代理访问的路径就会是’<a href="http://localhost:3000/hello&#39;" target="_blank" rel="noopener">http://localhost:3000/hello&#39;</a></p></li><li><p>changeOrigin</p><p> 该参数可以让target参数是域名</p></li><li><p>secure</p><p> secure: false，不检查安全问题；设置后，可以接受运行在https上，可以使用无效证书的后端服务器</p></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;什么是跨域&quot;&gt;&lt;a href=&quot;#什么是跨域&quot; class=&quot;headerlink&quot; title=&quot;什么是跨域&quot;&gt;&lt;/a&gt;什么是跨域&lt;/h2&gt;&lt;p&gt;通过XHR对象来实现Ajax通信的一个主要限制，来源于跨域安全策略。在默认的情况下，XHR对象只能访问与包含它的页面
      
    
    </summary>
    
      <category term="浏览器" scheme="http://yoursite.com/categories/%E6%B5%8F%E8%A7%88%E5%99%A8/"/>
    
    
  </entry>
  
  <entry>
    <title>Ajax</title>
    <link href="http://yoursite.com/2019/09/30/Ajax/"/>
    <id>http://yoursite.com/2019/09/30/Ajax/</id>
    <published>2019-09-30T10:39:26.000Z</published>
    <updated>2019-10-01T11:28:00.474Z</updated>
    
    <content type="html"><![CDATA[<h2 id="什么是Ajax"><a href="#什么是Ajax" class="headerlink" title="什么是Ajax"></a>什么是Ajax</h2><p>AJAX即“Asynchronous JavaScript and XML”（异步的JavaScript与XML技术）。使用Ajax可以无需刷新页面就可以从服务器取得数据</p><h2 id="Ajax的核心–XMLHttpRequest对象"><a href="#Ajax的核心–XMLHttpRequest对象" class="headerlink" title="Ajax的核心–XMLHttpRequest对象"></a>Ajax的核心–XMLHttpRequest对象</h2><p>如果不考虑IE7以前的版本，那么对于所有的标准浏览器我们都可以使用如下来创建一个XHR对象</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> xhr = <span class="keyword">new</span> XMLHttpRequest();</span><br></pre></td></tr></table></figure><h3 id="XHR对象的一些属性"><a href="#XHR对象的一些属性" class="headerlink" title="XHR对象的一些属性"></a>XHR对象的一些属性</h3><table><thead><tr><th>属性名</th><th>作用</th></tr></thead><tbody><tr><td>status</td><td>响应的HTTP状态码</td></tr><tr><td>statusText</td><td>HTTP状态码的说明</td></tr><tr><td>responseText</td><td>作为响应主体被返回的文本</td></tr><tr><td>responseXml</td><td>对请求的响应，解析为 XML 并作为 Document 对象返回</td></tr><tr><td>readyState</td><td>请求/响应过程的当前活动状态</td></tr><tr><td>onreadystatechange()</td><td>readyState属性值改变触发的readystatechange事件的绑定函数</td></tr></tbody></table><p>readyState属性的说明：<br>属性可取值|名称|说明<br>–|–|–<br>0|未初始化|尚未调用open()方法<br>1|启动|已经调用open()方法，但尚未调用send()方法<br>2|发送|已经调用send()方法，但尚未接收到响应<br>3|接收|已经接收到部分响应数据<br>4|完成|已经接收到全部响应数据</p><p>status（HTTP常见状态码）<br>状态码|名称|说明<br>–|–|–<br>200|OK|请求成功，信息在返回的响应报文中<br>301|Moved Permanently|请求的对象已经被永久转移了，新的URL定义在响应报文的Location: 首部行中。客户软件将自动获取新的URL<br>304|Not Modified|未修改。所请求的资源未修改，服务器返回此状态码时，不会返回任何资源。客户端通常会缓存访问过的资源，通过提供一个头信息指出客户端希望只返回在指定日期之后修改的资源<br>400|Bad Request|一个通用差错代码，指示该请求不能被服务器理解<br>404|Not Found|请求的资源不存在<br>500|Internal Server Error|内部服务器错误<br>505|HTTP Version Not Supported|服务器不支持请求报文使用的HTTP协议版本</p><p>HTTP状态码分类</p><table><thead><tr><th>状态码</th><th>名称</th><th>说明</th></tr></thead><tbody><tr><td>1**</td><td>信息</td><td>服务器收到请求，需要请求者继续执行操作</td></tr><tr><td>2**</td><td>成功</td><td>操作被成功接收并处理</td></tr><tr><td>3**</td><td>重定向</td><td>需要进一步的操作以完成请求</td></tr><tr><td>4**</td><td>客户端错误</td><td>请求包含语法错误或无法完成请求</td></tr><tr><td>5**</td><td>服务器错误</td><td>服务器在处理请求的过程中发生了错误</td></tr></tbody></table><h3 id="XHR对象的一些方法"><a href="#XHR对象的一些方法" class="headerlink" title="XHR对象的一些方法"></a>XHR对象的一些方法</h3><h4 id="open"><a href="#open" class="headerlink" title="open()"></a>open()</h4><p>参数：</p><p>method<br>    要使用的HTTP方法，比如「GET」、「POST」、「PUT」、「DELETE」、等。对于非HTTP(S) URL被忽略。</p><p>url<br>    一个DOMString表示要向其发送请求的URL。</p><p>async 可选<br>    一个可选的布尔参数，默认为true，表示要不要异步执行操作。如果值为false（表示同步执行），send()方法直到收到答复前不会返回。如果true（表示异步执行），已完成事务的通知可供事件监听器使用。</p><pre><code>注意：主线程上的同步请求很容易破坏用户体验，应该避免；实际上，许多浏览器已完全弃用主线程上的同步XHR支持。在 Worker中允许同步请求</code></pre><p>user 可选<br>    可选的用户名用于认证用途；默认为null。</p><p>password 可选<br>    可选的密码用于认证用途，默认为null。 </p><h4 id="send"><a href="#send" class="headerlink" title="send()"></a>send()</h4><p>XMLHttpRequest.send() 方法接受一个可选的参数，其作为请求主体；如果请求方法是 GET 或者 HEAD，则应将请求主体设置为 null。（注：在HTTP请求报文中，使用GET方法时，请求实体为空，而是用POST方法时传输的内容保存在该请求实体中）</p><h4 id="setRequestHeader"><a href="#setRequestHeader" class="headerlink" title="setRequestHeader"></a>setRequestHeader</h4><p>XMLHttpRequest.setRequestHeader() 是设置HTTP请求头部的方法。此方法必须在  open() 方法和 send()   之间调用。如果多次对同一个请求头赋值，只会生成一个合并了多个值的请求头。</p><h4 id="abort"><a href="#abort" class="headerlink" title="abort()"></a>abort()</h4><p>如果该请求已被发出，XMLHttpRequest.abort() 方法将终止该请求。当一个请求被终止，它的 readyState 属性将被置为0（ UNSENT )。</p><h3 id="使用XHR对象进行同步请求"><a href="#使用XHR对象进行同步请求" class="headerlink" title="使用XHR对象进行同步请求"></a>使用XHR对象进行同步请求</h3><p>对于同步请求，也就是意味着该次请求是阻塞的。因此，之后的代码会等到服务器响应之后才会执行。</p><p>在收到响应后，响应的数据会自动填充到XHR对象的属性</p><p>例如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> xhr = <span class="keyword">new</span> XMLHttpRequest();</span><br><span class="line"><span class="comment">// 使用同步请求时，open()方法的第三个参数设置为false</span></span><br><span class="line">xhr.open(<span class="string">"get"</span>,<span class="string">"https://www.baidu.com"</span>,<span class="literal">false</span>);</span><br><span class="line">xhr.send(<span class="literal">null</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>((xhr.status&gt;=<span class="number">200</span>&amp;&amp;xhr.status&lt;<span class="number">300</span>)||xhr.status===<span class="number">304</span>) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(xhr.responseText);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"Request was failed"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="使用XHR对象进行异步请求"><a href="#使用XHR对象进行异步请求" class="headerlink" title="使用XHR对象进行异步请求"></a>使用XHR对象进行异步请求</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> xhr = <span class="keyword">new</span> XMLHttpRequest();</span><br><span class="line">xhr.onreadystatechange=<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(xhr.readyState===<span class="number">4</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span>((xhr.status&gt;=<span class="number">200</span>&amp;&amp;xhr.status&lt;<span class="number">300</span>)||xhr.status===<span class="number">304</span>) &#123;</span><br><span class="line">            <span class="built_in">console</span>.log(xhr.responseText);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">"Request was failed"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 使用异步请求时，open()方法的第三个参数设置为true</span></span><br><span class="line">xhr.open(<span class="string">"get"</span>,<span class="string">"https://www.baidu.com"</span>,<span class="literal">true</span>);</span><br><span class="line">xhr.send(<span class="literal">null</span>);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'异步请求'</span>);</span><br></pre></td></tr></table></figure><blockquote><p>注意：我们必须在调用open()方法之前指定onreadystatechange事件处理程序才能确保跨浏览器兼容性</p></blockquote><h3 id="GET请求"><a href="#GET请求" class="headerlink" title="GET请求"></a>GET请求</h3><p>对于GET请求，我们经常将查询字符串参数追加到URL的末尾，以便将信息发送给服务器</p><p>但是，我们经常会遇到URL的编码问题（查询字符串的格式有问题，例如在传递中文字符的时候）。因此，我们需要将每个参数的名称和值使用encodeURIComponent()进行编码，然后才能放到URL的末尾</p><p>encodeURIComponent()是对统一资源标识符（URI）的组成部分进行编码的方法。它使用一到四个转义序列来表示字符串中的每个字符的UTF-8编码。它会转义除了字母、数字、(、)、.、!、~、*、’、-和_之外的所有字符。</p><p>decodeURIComponent() 方法用于解码由 encodeURIComponent 方法或者其它类似方法编码的部分统一资源标识符（URI）。</p><p>因此，我们利用一个函数，将每个参数的键与值进行编码后加入到URL的末尾</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">addURLParam</span>(<span class="params">url,key,value</span>) </span>&#123;</span><br><span class="line">    url+=url.indexOf(<span class="string">'?'</span>)&lt;<span class="number">0</span>?<span class="string">'?'</span>:<span class="string">'&amp;'</span>;</span><br><span class="line">    <span class="comment">// 编码参数</span></span><br><span class="line">    url+=<span class="built_in">encodeURIComponent</span>(key)+<span class="string">'='</span>+<span class="built_in">encodeURIComponent</span>(value);</span><br><span class="line">    <span class="keyword">return</span> url;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> url = addURLParam(<span class="string">'https://www.baidu.com'</span>,<span class="string">'a'</span>,<span class="string">'天'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(url);</span><br><span class="line"><span class="keyword">let</span> url1 = addURLParam(url,<span class="string">'b'</span>,<span class="string">'才'</span>);</span><br><span class="line"><span class="comment">// 解码URL</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">decodeURIComponent</span>(url1));</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">https://www.baidu.com?a=%E5%A4%A9</span></span><br><span class="line"><span class="comment">https://www.baidu.com?a=天&amp;b=才</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h3 id="POST请求"><a href="#POST请求" class="headerlink" title="POST请求"></a>POST请求</h3><p>POST请求的内容不会明文出现在URL上，它会存放在请求的实体部分进行传递。值得注意的是，POST请求的主体可包含非常多的数据，而且格式不限</p><p>注意，在使用POST请求提交数据的时候，我们需要将请求头设置一下</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">xhr.setRequestHeader(<span class="string">"Content-Type"</span>,<span class="string">"application/x-www-form-urlencoded"</span>);</span><br></pre></td></tr></table></figure><p>POST完整请求示例</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> xhr = <span class="keyword">new</span> XMLHttpRequest();</span><br><span class="line">xhr.onreadystatechange=<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(xhr.readyState===<span class="number">4</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span>(xhr.status&gt;=<span class="number">200</span>&amp;&amp;xhr.status&lt;<span class="number">300</span>) &#123;</span><br><span class="line">            <span class="built_in">console</span>.log(xhr.responseText);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">'error'</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">xhr.open(<span class="string">"post"</span>,<span class="string">"https://www.baidu.com"</span>,<span class="string">"true"</span>);</span><br><span class="line">xhr.setRequestHeader(<span class="string">"Content-Type"</span>,<span class="string">"x-www-from-urlencoded"</span>);</span><br><span class="line">xhr.send(<span class="string">'123'</span>);</span><br></pre></td></tr></table></figure><h3 id="XMLHttpRequest-2级"><a href="#XMLHttpRequest-2级" class="headerlink" title="XMLHttpRequest 2级"></a>XMLHttpRequest 2级</h3><h4 id="FormData"><a href="#FormData" class="headerlink" title="FormData"></a>FormData</h4><p>在上面提到过，使用POST请求进行传输时，我们需要明确地设置请求头</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">xhr.setRequestHeader(<span class="string">"Content-Type"</span>,<span class="string">"x-www-from-urlencoded"</span>);</span><br></pre></td></tr></table></figure><p>但是，如果使用FormData的话，我们就不要进行设置。因为，XHR对象能够识别传入的数据类型是FormData的实例，并配置适当的头部信息</p><p>例如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建FormData实例</span></span><br><span class="line"><span class="keyword">let</span> data = <span class="keyword">new</span> FormData();</span><br><span class="line"><span class="comment">// 向对象添加数据，append()方法接受两个参数：键和值</span></span><br><span class="line">data.append(<span class="string">"name"</span>,<span class="string">"Ming"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 我们可以看到没有设置POST请求头</span></span><br><span class="line"><span class="keyword">let</span> xhr = <span class="keyword">new</span> XMLHttpRequest();</span><br><span class="line">xhr.onreadystatechange=<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(xhr.readyState===<span class="number">4</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span>(xhr.status&gt;=<span class="number">200</span>&amp;&amp;xhr.status&lt;<span class="number">300</span>) &#123;</span><br><span class="line">            <span class="built_in">console</span>.log(xhr.responseText);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">'error'</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">xhr.open(<span class="string">"post"</span>,<span class="string">"https://www.baidu.com"</span>,<span class="literal">true</span>);</span><br><span class="line">xhr.send(data);</span><br></pre></td></tr></table></figure><h4 id="进度事件"><a href="#进度事件" class="headerlink" title="进度事件"></a>进度事件</h4><p>我们可以利用进度事件来实现一个进度指示器</p><p>progress事件会在浏览器接收新数据期间周期性地触发。而onprogress事件处理程序就会接收到一个events对象，其有三个关于进度的属性：lengthComputable(表示进度信息是否可用),position(表示已经接受的字节数),totalSize(表示总字节数)</p><p>例如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> xhr = <span class="keyword">new</span> XMLHttpRequest();</span><br><span class="line">xhr.onprogress=<span class="function"><span class="keyword">function</span>(<span class="params">events</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(events.lengthComputable)&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(events.position+<span class="string">"/"</span>+events.totalSize);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">xhr.open(<span class="string">"get"</span>,<span class="string">"https://www.baidu.com"</span>,<span class="literal">true</span>);</span><br><span class="line">xhr.send(<span class="literal">null</span>);</span><br></pre></td></tr></table></figure><h3 id="Ajax的一些知识点总结"><a href="#Ajax的一些知识点总结" class="headerlink" title="Ajax的一些知识点总结"></a>Ajax的一些知识点总结</h3><h4 id="原生Js-Ajax请求有几个步骤"><a href="#原生Js-Ajax请求有几个步骤" class="headerlink" title="原生Js Ajax请求有几个步骤"></a>原生Js Ajax请求有几个步骤</h4><p>我们以步骤最多的POST请求为例</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1. 创建XHR对象</span></span><br><span class="line"><span class="keyword">let</span> xhr = <span class="keyword">new</span> XMLHttpRequest();</span><br><span class="line"><span class="comment">// 响应服务器返回的数据</span></span><br><span class="line">xhr.onreadystatechange=<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(xhr.readyState===<span class="number">4</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span>(xhr.status&gt;=<span class="number">200</span>&amp;&amp;xhr.status&lt;<span class="number">300</span>) &#123;</span><br><span class="line">            <span class="built_in">console</span>.log(xhr.responseText);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">'error'</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 2. 准备一个请求，规定请求的类型、URL 以及是否异步处理请求</span></span><br><span class="line">xhr.open(<span class="string">"post"</span>,<span class="string">"https://www.baidu.com"</span>,<span class="string">"true"</span>);</span><br><span class="line"><span class="comment">// 3. 设置请求头中的Content-type</span></span><br><span class="line">xhr.setRequestHeader(<span class="string">"Content-Type"</span>,<span class="string">"x-www-from-urlencoded"</span>);</span><br><span class="line"><span class="comment">// 发送请求</span></span><br><span class="line">xhr.send(<span class="string">'123'</span>);</span><br></pre></td></tr></table></figure><h4 id="Ajax有哪几种请求方式"><a href="#Ajax有哪几种请求方式" class="headerlink" title="Ajax有哪几种请求方式"></a>Ajax有哪几种请求方式</h4><p>常用的有GET,POST,DELETE,PUT。</p><h4 id="POST请求与GET请求的区别"><a href="#POST请求与GET请求的区别" class="headerlink" title="POST请求与GET请求的区别"></a>POST请求与GET请求的区别</h4><ol><li>POST请求更加安全，因为POST请求将参数存放在请求实体中，而GET请求参数在URL上</li><li>GET请求传输速度更快。因为post通过请求体传参，后台通过数据流接收。速度稍微慢一些。而get通过url传参可以直接获取</li><li>POST请求没有数据量的限制</li><li>POST请求的参数内容没有格式限制</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;什么是Ajax&quot;&gt;&lt;a href=&quot;#什么是Ajax&quot; class=&quot;headerlink&quot; title=&quot;什么是Ajax&quot;&gt;&lt;/a&gt;什么是Ajax&lt;/h2&gt;&lt;p&gt;AJAX即“Asynchronous JavaScript and XML”（异步的JavaScri
      
    
    </summary>
    
      <category term="javaScript基础" scheme="http://yoursite.com/categories/javaScript%E5%9F%BA%E7%A1%80/"/>
    
    
  </entry>
  
  <entry>
    <title>JSON的解析与序列化</title>
    <link href="http://yoursite.com/2019/09/30/JSON%E7%9A%84%E8%A7%A3%E6%9E%90%E4%B8%8E%E5%BA%8F%E5%88%97%E5%8C%96/"/>
    <id>http://yoursite.com/2019/09/30/JSON的解析与序列化/</id>
    <published>2019-09-30T06:51:09.000Z</published>
    <updated>2019-09-30T08:49:03.754Z</updated>
    
    <content type="html"><![CDATA[<h2 id="JSON简介"><a href="#JSON简介" class="headerlink" title="JSON简介"></a>JSON简介</h2><p>JSON（JavaScript Object Notation，JavaScript对象表示法）是一种数据格式，而不是一种编程语言。</p><p>我们可以使用JSON来通过网络进行数据交互和处理。</p><h3 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h3><p>JSON的语法可以表示一下三种类型的值：</p><ol><li>简单值：可以在JSON中表示字符串、数值、布尔值和null。但JSON不支持undefined</li><li>对象： 对象作为一种复杂数据类型，表示的是一组无序的键值对儿</li><li>数组</li></ol><p>值得注意的是：<br>除了undefined，JSON也不支持变量、函数或对象实例</p><p>另外，JSON字符串必须使用双引号（单引号会导致语法错误）</p><p>例如：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"name"</span>: <span class="string">"Ming"</span>,</span><br><span class="line">    <span class="attr">"age"</span>: <span class="number">18</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="解析与序列化"><a href="#解析与序列化" class="headerlink" title="解析与序列化"></a>解析与序列化</h2><h3 id="JavaScript对象序列化为JSON字符串"><a href="#JavaScript对象序列化为JSON字符串" class="headerlink" title="JavaScript对象序列化为JSON字符串"></a>JavaScript对象序列化为JSON字符串</h3><p>JSON.stringify() 方法是将一个JavaScript值(对象或者数组)转换为一个 JSON字符串，如果指定了replacer是一个函数，则可以选择性的替换值，或者如果指定了replacer是一个数组，可选择性的仅包含数组指定的属性。</p><p>语法</p><p>JSON.stringify(value[, replacer [, space]])</p><p>参数</p><p>value<br>    将要序列化成 一个JSON 字符串的值。</p><p>replacer 可选<br>    如果该参数是一个函数（传入的函数接受连个参数，属性名和属性值），则在序列化过程中，被序列化的值的每个属性都会经过该函数的转换和处理（值得注意的是，如果过滤器函数没有返回值或者显示返回undefined，那么相应的属性就会被忽略；因为JSON语法默认不支持undefined）；如果该参数是一个数组，则只有包含在这个数组中的属性名才会被序列化到最终的 JSON 字符串中；如果该参数为null或者未提供，则对象所有的属性都会被序列化；</p><p>space 可选<br>    指定缩进用的空白字符串，用于美化输出（pretty-print）；如果参数是个数字，它代表有多少的空格；上限为10。该值若小于1，则意味着没有空格；如果该参数为字符串(字符串的前十个字母)，该字符串将被作为空格；如果该参数没有提供（或者为null）将没有空格。</p><p>返回值 </p><p>一个表示给定值的JSON字符串。</p><p>例如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> test = &#123;</span><br><span class="line">    name: <span class="string">'Ming'</span>,</span><br><span class="line">    age: <span class="number">18</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 未传入过滤数组或过滤函数</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">JSON</span>.stringify(test,<span class="literal">null</span>,<span class="number">4</span>));</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">&#123;</span></span><br><span class="line"><span class="comment">    "name": "Ming",</span></span><br><span class="line"><span class="comment">    "age": 18</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 传入过滤数组</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">JSON</span>.stringify(test,[<span class="string">"name"</span>],<span class="number">4</span>));</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">&#123;</span></span><br><span class="line"><span class="comment">    "name": "Ming"</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 传入过滤函数</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">JSON</span>.stringify(test,<span class="function"><span class="keyword">function</span> (<span class="params">key,value</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(key===<span class="string">"name"</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"My name is"</span>+value;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> value;</span><br><span class="line">&#125;,<span class="number">4</span>))</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">&#123;</span></span><br><span class="line"><span class="comment">    "name": "My name isMing",</span></span><br><span class="line"><span class="comment">    "age": 18</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 值得注意的是，如果过滤器函数没有返回值或者显示返回undefined，那么相应的属性就会被忽略</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">JSON</span>.stringify(test,<span class="function"><span class="keyword">function</span>(<span class="params">key,value</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(key===<span class="string">"name"</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> value;</span><br><span class="line">&#125;,<span class="number">4</span>))</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">&#123;</span></span><br><span class="line"><span class="comment">    "age": 18</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h3 id="JSON字符串解析成原生JavaScript值"><a href="#JSON字符串解析成原生JavaScript值" class="headerlink" title="JSON字符串解析成原生JavaScript值"></a>JSON字符串解析成原生JavaScript值</h3><p>JSON.parse() 方法用来解析JSON字符串，构造由字符串描述的JavaScript值或对象。提供可选的reviver函数用以在返回之前对所得到的对象执行变换(操作)。</p><p>语法</p><p>JSON.parse(text[, reviver])</p><p>参数</p><p>text<br>    要被解析成JavaScript值的字符串，关于JSON的语法格式。</p><p>reviver 可选<br>    转换器, 如果传入该参数(函数)，可以用来修改解析生成的原始值。如果还原函数返回undefined，则表示要从结果中删除相应的键。（因为JSON语法默认不支持undefined）</p><p>返回值</p><p>Object类型, 对应给定JSON文本的对象/值。</p><p>异常</p><p>若传入的字符串不符合 JSON 规范，则会抛出 SyntaxError 异常。</p><h4 id="不传入还原函数"><a href="#不传入还原函数" class="headerlink" title="不传入还原函数"></a>不传入还原函数</h4><p>我们将JSON.parse()的第二个函数参数称之为还原参数</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> text = &#123;</span><br><span class="line">  name: <span class="string">'Ming'</span>,</span><br><span class="line">  age: <span class="number">18</span>,</span><br><span class="line">  friends: [</span><br><span class="line">      &#123;</span><br><span class="line">          name: <span class="string">'Lin'</span>,</span><br><span class="line">          age: <span class="number">19</span></span><br><span class="line">      &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> jsonText = <span class="built_in">JSON</span>.stringify(text,<span class="literal">null</span>,<span class="number">4</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> textCopy = <span class="built_in">JSON</span>.parse(jsonText);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(textCopy); <span class="comment">// &#123; name: 'Ming', age: 18, friends: [ &#123; name: 'Lin', age: 19 &#125; ] &#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(textCopy <span class="keyword">instanceof</span> <span class="built_in">Object</span>); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(textCopy===text); <span class="comment">// false</span></span><br><span class="line"><span class="built_in">console</span>.log(textCopy.friends[<span class="number">0</span>]===text.friends[<span class="number">0</span>]); <span class="comment">// false</span></span><br></pre></td></tr></table></figure><p>因此，我们经常使用JSON.parse(JSON.stringify(example))来深拷贝一个对象（注意：JSON语法不支持undefined与函数…）</p><h4 id="传入还原函数"><a href="#传入还原函数" class="headerlink" title="传入还原函数"></a>传入还原函数</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> text = &#123;</span><br><span class="line">    name: <span class="string">'Ming'</span>,</span><br><span class="line">    age: <span class="number">18</span>,</span><br><span class="line">    friends: [</span><br><span class="line">        &#123;</span><br><span class="line">            name: <span class="string">'Lin'</span>,</span><br><span class="line">            age: <span class="number">19</span></span><br><span class="line">        &#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> jsonText = <span class="built_in">JSON</span>.stringify(text,<span class="literal">null</span>,<span class="number">4</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> textCopy = <span class="built_in">JSON</span>.parse(jsonText,<span class="function"><span class="keyword">function</span>(<span class="params">key,value</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(key===<span class="string">"name"</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"My name is"</span>+value;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> value;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(textCopy);</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">&#123;</span></span><br><span class="line"><span class="comment">  name: 'My name isMing',</span></span><br><span class="line"><span class="comment">  age: 18,</span></span><br><span class="line"><span class="comment">  friends: [ &#123; name: 'My name isLin', age: 19 &#125; ]</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;JSON简介&quot;&gt;&lt;a href=&quot;#JSON简介&quot; class=&quot;headerlink&quot; title=&quot;JSON简介&quot;&gt;&lt;/a&gt;JSON简介&lt;/h2&gt;&lt;p&gt;JSON（JavaScript Object Notation，JavaScript对象表示法）是一种数据格
      
    
    </summary>
    
      <category term="javaScript基础" scheme="http://yoursite.com/categories/javaScript%E5%9F%BA%E7%A1%80/"/>
    
    
  </entry>
  
  <entry>
    <title>super关键字</title>
    <link href="http://yoursite.com/2019/09/26/super%E5%85%B3%E9%94%AE%E5%AD%97/"/>
    <id>http://yoursite.com/2019/09/26/super关键字/</id>
    <published>2019-09-26T14:15:44.000Z</published>
    <updated>2019-09-26T15:12:17.036Z</updated>
    
    <content type="html"><![CDATA[<h2 id="super关键字简介"><a href="#super关键字简介" class="headerlink" title="super关键字简介"></a>super关键字简介</h2><p>super关键字用于访问和调用一个对象的父对象上的函数。</p><p><strong>注意的是：</strong></p><blockquote><p>super关键字只能访问和调用函数，而不能访问父对象上的变量</p></blockquote><p>在构造函数中使用时，super关键字作为函数调用将单独出现，并且必须在使用this关键字之前使用。super关键字也可以用来调用父对象上的函数。</p><h3 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h3><pre><code>super([arguments]); // 调用 父对象/父类 的构造函数super.functionOnParent([arguments]); // 调用 父对象/父类 上的方法</code></pre><h2 id="super作为函数调用"><a href="#super作为函数调用" class="headerlink" title="super作为函数调用"></a>super作为函数调用</h2><p>super作为函数调用时，其代表着基类的构造函数。</p><p>此时，它的内部的this指向为当前子类的<strong>实例对象</strong>。</p><p>需要注意的是：</p><ol><li>我们只能在派生类的构造函数中使用super()。如果尝试在非派生类（不是用extends声明的类）或函数中使用则会导致程序错误</li><li>在构造函数中访问this前一定要调用super()，它负责初始化this。也就是说，虽然super()代表着基类的构造函数，但是内部的作用域指向还是当前类的作用域。</li></ol><p>示例：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Father</span></span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(item) &#123;</span><br><span class="line">        <span class="keyword">this</span>.item= item;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Son</span> <span class="keyword">extends</span> <span class="title">Father</span></span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(item,name) &#123;</span><br><span class="line">        <span class="keyword">super</span>(item);</span><br><span class="line">        <span class="keyword">this</span>.name= name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> son = <span class="keyword">new</span> Son(<span class="number">123</span>,<span class="string">'ming'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(son); <span class="comment">// Son &#123; item: 123, name: 'ming' &#125;</span></span><br></pre></td></tr></table></figure><p>上述代码中的super(item)其实相当于super.constructor.call(this)</p><h2 id="super作为对象调用"><a href="#super作为对象调用" class="headerlink" title="super作为对象调用"></a>super作为对象调用</h2><p>super 作为对象时，在普通方法和构造函数中，指向父类的原型对象，在静态方法中指向父类。</p><blockquote><p>super作为对象在普通方法和构造函数中的this指向当前子类的实例对象</p></blockquote><blockquote><p>super作为对象在静态方法中的this指向当前子类，而不是当前子类的对象</p></blockquote><p>接下来验证super作为对象在普通方法中被调用指向的是父类的原型对象</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(item) &#123;</span><br><span class="line">        <span class="keyword">this</span>.item= item;</span><br><span class="line">    &#125; </span><br><span class="line">    test() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">123</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> <span class="keyword">extends</span> <span class="title">A</span></span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(item) &#123;</span><br><span class="line">        <span class="keyword">super</span>(item);</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="keyword">super</span>.test());</span><br><span class="line">    &#125;</span><br><span class="line">    test() &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="keyword">super</span>.test===A.prototype.test);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> b = <span class="keyword">new</span> B(<span class="number">123</span>); <span class="comment">// 123</span></span><br><span class="line">b.test(); <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>接下来验证super作为对象在静态方法中被调用指向的是父类，而不是父类的原型对象</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span>&#123;</span><br><span class="line">    <span class="keyword">static</span> item= <span class="string">'A'</span>;</span><br><span class="line">    <span class="keyword">constructor</span>(item) &#123;</span><br><span class="line">        <span class="keyword">this</span>.item= item;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> getItem() &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'static'</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.item;</span><br><span class="line">    &#125;</span><br><span class="line">    getItem() &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'not static'</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.item;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> <span class="keyword">extends</span> <span class="title">A</span></span>&#123;</span><br><span class="line">    <span class="keyword">static</span> item= <span class="string">'B'</span>;</span><br><span class="line">    <span class="keyword">constructor</span>(item) &#123;</span><br><span class="line">        <span class="keyword">super</span>(item);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> getItem() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.getItem();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(B.getItem()); <span class="comment">// 'static' , 'B'</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;super关键字简介&quot;&gt;&lt;a href=&quot;#super关键字简介&quot; class=&quot;headerlink&quot; title=&quot;super关键字简介&quot;&gt;&lt;/a&gt;super关键字简介&lt;/h2&gt;&lt;p&gt;super关键字用于访问和调用一个对象的父对象上的函数。&lt;/p&gt;
&lt;p&gt;&lt;s
      
    
    </summary>
    
      <category term="ES6" scheme="http://yoursite.com/categories/ES6/"/>
    
    
  </entry>
  
  <entry>
    <title>Node的模块机制</title>
    <link href="http://yoursite.com/2019/09/25/Node%E7%9A%84%E6%A8%A1%E5%9D%97%E6%9C%BA%E5%88%B6/"/>
    <id>http://yoursite.com/2019/09/25/Node的模块机制/</id>
    <published>2019-09-25T02:26:54.000Z</published>
    <updated>2019-09-25T03:15:13.075Z</updated>
    
    <content type="html"><![CDATA[<p>模块加载优先级</p><ol><li>缓存模块</li><li>核心模块</li><li>文件模块</li><li>自定义模块</li></ol><p>exports仅仅是module.exports的一个地址引用。nodejs只会导出module.exports的指向，如果exports指向变了，那就仅仅是exports不在指向module.exports，于是不会再被导出</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;模块加载优先级&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;缓存模块&lt;/li&gt;
&lt;li&gt;核心模块&lt;/li&gt;
&lt;li&gt;文件模块&lt;/li&gt;
&lt;li&gt;自定义模块&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;exports仅仅是module.exports的一个地址引用。nodejs只会导出module.expor
      
    
    </summary>
    
      <category term="Node" scheme="http://yoursite.com/categories/Node/"/>
    
    
      <category term="Node" scheme="http://yoursite.com/tags/Node/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript常见错误类型</title>
    <link href="http://yoursite.com/2019/09/24/JavaScript%E5%B8%B8%E8%A7%81%E9%94%99%E8%AF%AF%E7%B1%BB%E5%9E%8B/"/>
    <id>http://yoursite.com/2019/09/24/JavaScript常见错误类型/</id>
    <published>2019-09-24T14:24:45.000Z</published>
    <updated>2019-09-24T14:29:19.620Z</updated>
    
    <content type="html"><![CDATA[<h2 id="JavaScript常见错误类型"><a href="#JavaScript常见错误类型" class="headerlink" title="JavaScript常见错误类型"></a>JavaScript常见错误类型</h2><p>JavaScript主要包括以下几种常见错误类型</p><ol><li><p>TypeError（类型错误） 对象用来表示值的类型非预期类型时发生的错误。</p><pre><code>当传入函数的操作数或参数的类型并非操作符或函数所预期的类型时，将抛出一个 TypeError 类型错误。</code></pre></li><li><p>SyntaxError 对象代表尝试解析语法上不合法的代码的错误</p><pre><code>当Javascript语言解析代码时,Javascript引擎发现了不符合语法规范的tokens或token顺序时抛出SyntaxError.</code></pre></li><li><p>ReferenceError（引用错误） 对象代表当一个不存在的变量被引用时发生的错误。</p><pre><code>当你尝试引用一个未被定义的变量时，将会抛出一个 ReferenceError 。</code></pre></li><li><p>RangeError对象标明一个错误，当一个值不在其所允许的范围或者集合中。</p></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;JavaScript常见错误类型&quot;&gt;&lt;a href=&quot;#JavaScript常见错误类型&quot; class=&quot;headerlink&quot; title=&quot;JavaScript常见错误类型&quot;&gt;&lt;/a&gt;JavaScript常见错误类型&lt;/h2&gt;&lt;p&gt;JavaScript主要包括
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>剑指Offer-求链表中的倒数第k个节点</title>
    <link href="http://yoursite.com/2019/09/23/%E5%89%91%E6%8C%87Offer-01/"/>
    <id>http://yoursite.com/2019/09/23/剑指Offer-01/</id>
    <published>2019-09-23T14:28:29.000Z</published>
    <updated>2019-09-23T15:01:27.978Z</updated>
    
    <content type="html"><![CDATA[<h1 id="求链表中的倒数第k个节点"><a href="#求链表中的倒数第k个节点" class="headerlink" title="求链表中的倒数第k个节点"></a>求链表中的倒数第k个节点</h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>输入：输入一个链表，输出该链表中倒数第k个节点。为了符合大多数人的习惯，本题从1开始计数，即链表的尾结点是倒数第一个节点。例如，一个链表有6个节点，从头结点开始，它们的值一次是1、2、3、4、5、6。这个链表的倒数第三个节点是值为4的节点。</p><p>链表节点定义如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*function ListNode(x)&#123;</span></span><br><span class="line"><span class="comment">    this.val = x;</span></span><br><span class="line"><span class="comment">    this.next = null;</span></span><br><span class="line"><span class="comment">&#125;*/</span></span><br></pre></td></tr></table></figure><h3 id="核心思路"><a href="#核心思路" class="headerlink" title="核心思路"></a>核心思路</h3><p>我们可以设置两个双指针，cur指向头结点，anotherCur指向第k-1个节点。然后两个节点分别往下走，当anotherCur节点指向最后一个节点时，也就意味着cur指向了该链表的倒数第k个节点</p><p>但是，我们需要注意一些输入的问题以及边界情况。</p><ol><li>输入链表head为空时的处理</li><li>k值小于等于0时的处理</li><li>k值大于链表长度时的处理</li></ol><h3 id="coding实现"><a href="#coding实现" class="headerlink" title="coding实现"></a>coding实现</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*function ListNode(x)&#123;</span></span><br><span class="line"><span class="comment">    this.val = x;</span></span><br><span class="line"><span class="comment">    this.next = null;</span></span><br><span class="line"><span class="comment">&#125;*/</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">FindKthToTail</span>(<span class="params">head, k</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(head===<span class="literal">null</span>||k&lt;=<span class="number">0</span>) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">let</span> cur = head;</span><br><span class="line">    <span class="keyword">let</span> anotherCur = head;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">1</span>;i&lt;k;i++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(anotherCur.next) &#123;</span><br><span class="line">            anotherCur = anotherCur.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(anotherCur.next) &#123;</span><br><span class="line">        anotherCur = anotherCur.next;</span><br><span class="line">        cur = cur.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> cur;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    FindKthToTail : FindKthToTail</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="时空复杂度分析"><a href="#时空复杂度分析" class="headerlink" title="时空复杂度分析"></a>时空复杂度分析</h3><ol><li>时间复杂度： O(n)</li><li>空间复杂度：O(1)</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;求链表中的倒数第k个节点&quot;&gt;&lt;a href=&quot;#求链表中的倒数第k个节点&quot; class=&quot;headerlink&quot; title=&quot;求链表中的倒数第k个节点&quot;&gt;&lt;/a&gt;求链表中的倒数第k个节点&lt;/h1&gt;&lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; cla
      
    
    </summary>
    
      <category term="剑指Offer" scheme="http://yoursite.com/categories/%E5%89%91%E6%8C%87Offer/"/>
    
    
  </entry>
  
  <entry>
    <title>webpack打包学习（一）</title>
    <link href="http://yoursite.com/2019/09/23/webpack%E6%89%93%E5%8C%85%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF/"/>
    <id>http://yoursite.com/2019/09/23/webpack打包学习之路/</id>
    <published>2019-09-23T13:44:00.000Z</published>
    <updated>2019-09-23T14:11:38.983Z</updated>
    
    <content type="html"><![CDATA[<h2 id="项目的基本搭建"><a href="#项目的基本搭建" class="headerlink" title="项目的基本搭建"></a>项目的基本搭建</h2><ol><li>新建一个项目并npm init为npm项目</li><li>安装webpck的相关模块，如下<ol><li>webpack </li><li>webpack-cli(webpack的命令行工具)</li><li>style-loader(通过向 DOM 中注入 &lt;style&gt; 标签实现css效果)</li><li>css-loader(解析引入的css文件)</li><li>file-loader(处理文件包括图片文件和字体文件)</li><li>webpack-dev-server(提供一个简单的web服务器)</li></ol></li><li>新建源代码文件夹src目录</li><li>新建输出文件夹dist目录，并将index.html放入改文件夹中</li><li>新建webpack.config.js配置文件</li></ol><h2 id="在src文件夹中"><a href="#在src文件夹中" class="headerlink" title="在src文件夹中"></a>在src文件夹中</h2><p>引入css文件方式如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">'./main.css'</span></span><br></pre></td></tr></table></figure><p>模块css-loader会处理引入的css代码，而style-loader则负责将该css代码注入到Dom中</p><p>引入图片和字体文件方式如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> img <span class="keyword">from</span> <span class="string">'./image.png'</span></span><br></pre></td></tr></table></figure><p>模块file-loader会处理这些图片和字体文件并进行打包</p><h2 id="编写webpack-config-js"><a href="#编写webpack-config-js" class="headerlink" title="编写webpack.config.js"></a>编写webpack.config.js</h2><p>webpack的打包都会按照这个文件的配置进行相应的打包</p><p>以上基本的打包实现如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Node.js的原生模块，用于将相对路径转化为绝对路径</span></span><br><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 利用Common.js模块的导出语法，导出基本的配置</span></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    <span class="comment">// 打包的入口</span></span><br><span class="line">    entry: &#123;</span><br><span class="line">        main: <span class="string">'./src/main.js'</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">// 打包的出口</span></span><br><span class="line">    output: &#123;</span><br><span class="line">        filename: <span class="string">'bundle.js'</span>, <span class="comment">// 打包的出口文件名</span></span><br><span class="line">        path: path.resolve(__dirname,<span class="string">'dist'</span>)<span class="comment">// __dirname是指当前的根目录，然后利用resolve函数就可以将__dirname于dist目录进行拼接然后转化为绝对路径，作为bundle.js文件的生成目录</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">// 用来追踪错误和警告</span></span><br><span class="line">    devtool: <span class="string">"inline-source-map"</span>,</span><br><span class="line">    <span class="comment">// 服务器配置</span></span><br><span class="line">    devServer: &#123;</span><br><span class="line">        <span class="comment">// 告诉服务器，将 dist 目录下的文件，作为可访问文件。</span></span><br><span class="line">        contentBase: <span class="string">'./dist'</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="built_in">module</span>: &#123;\</span><br><span class="line">    <span class="comment">// 创建模块时，匹配请求的规则数组。这些规则能够修改模块的创建方式。这些规则能够对模块(module)应用 loader，或者修改解析器(parser)。</span></span><br><span class="line">        rules: [</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// 正则表达式匹配rule条件</span></span><br><span class="line">                test: <span class="regexp">/.css$/</span>,</span><br><span class="line">                <span class="comment">//在规则条件匹配时使用的loader</span></span><br><span class="line">                use: [<span class="string">"style-loader"</span>,<span class="string">"css-loader"</span>]</span><br><span class="line">            &#125;,</span><br><span class="line">            &#123;</span><br><span class="line">                test: <span class="regexp">/.(jpg|png|jpeg|gif)$/</span>,</span><br><span class="line">                use: [<span class="string">"file-loader"</span>]</span><br><span class="line">            &#125;</span><br><span class="line">        ]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;项目的基本搭建&quot;&gt;&lt;a href=&quot;#项目的基本搭建&quot; class=&quot;headerlink&quot; title=&quot;项目的基本搭建&quot;&gt;&lt;/a&gt;项目的基本搭建&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;新建一个项目并npm init为npm项目&lt;/li&gt;
&lt;li&gt;安装webpck的相关模块
      
    
    </summary>
    
      <category term="webpack" scheme="http://yoursite.com/categories/webpack/"/>
    
    
      <category term="webpack" scheme="http://yoursite.com/tags/webpack/"/>
    
  </entry>
  
  <entry>
    <title>Vue父子组件传值详解</title>
    <link href="http://yoursite.com/2019/09/22/Vue%E7%88%B6%E5%AD%90%E7%BB%84%E4%BB%B6%E4%BC%A0%E5%80%BC%E8%AF%A6%E8%A7%A3/"/>
    <id>http://yoursite.com/2019/09/22/Vue父子组件传值详解/</id>
    <published>2019-09-22T06:24:07.000Z</published>
    <updated>2019-09-23T08:29:36.261Z</updated>
    
    <content type="html"><![CDATA[<h2 id="父组件向子组件传值"><a href="#父组件向子组件传值" class="headerlink" title="父组件向子组件传值"></a>父组件向子组件传值</h2><h3 id="Prop"><a href="#Prop" class="headerlink" title="Prop"></a>Prop</h3><p>Prop 是你可以在组件上注册的一些自定义特性。当一个值传递给一个 prop 特性的时候，它就变成了那个组件实例的一个属性。</p><p>因此，在子组件的方法代码中，我们可以使用this.xxx来访问到它</p><p>利用Prop单向数据流来使得父组件向子组件传值的基本格式如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 父组件 App.vue</span></span><br><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div id=<span class="string">"app"</span>&gt;</span><br><span class="line">    &lt;helloWorld :msg=<span class="string">"msg"</span>&gt;&lt;/helloWorld&gt;</span><br><span class="line">  &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">&lt;/</span>template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line"><span class="keyword">import</span> helloWorld <span class="keyword">from</span> <span class="string">'@/components/HelloWorld.vue'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  data() &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      msg: <span class="number">321</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  components: &#123;</span><br><span class="line">    helloWorld</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 子组件 HelloWorld.vue</span></span><br><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div <span class="class"><span class="keyword">class</span></span>=<span class="string">"hello"</span>&gt;</span><br><span class="line">    &#123;&#123;msg&#125;&#125;</span><br><span class="line">  &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">&lt;/</span>template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  props:[<span class="string">'msg'</span>]</span><br><span class="line">&#125;</span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br></pre></td></tr></table></figure><p>在上述父组件传值的时候是通过v-bind动态赋值的，但是我们也可以传递静态prop</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;hello-world msg=<span class="string">"qwer"</span>&gt;&lt;/hello-world&gt;</span><br></pre></td></tr></table></figure><p>注意的是，除了传入静态字符串之外，在传入静态的数值型，布尔型，对象型数据时我们依旧要使用v-bind来进行数据传输，否则就有可能造成数据传输失败</p><p>例如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">:msg=<span class="string">'11111'</span> <span class="comment">//number</span></span><br><span class="line">:msg=<span class="string">'true'</span> <span class="comment">//bootlean</span></span><br><span class="line">:msg=<span class="string">'()=&gt;&#123;console.log(1)&#125; //function </span></span><br><span class="line"><span class="string">:msg='</span>&#123;<span class="attr">a</span>:<span class="number">1</span>&#125;<span class="string">' //object</span></span><br></pre></td></tr></table></figure><p>因此，我们大可以使用v-bind动态传入，因为使用v-bind我们可以将字符串内的内容视为一个表达式进行计算</p><h3 id="单向数据流"><a href="#单向数据流" class="headerlink" title="单向数据流"></a>单向数据流</h3><p>所有的 prop 都使得其父子 prop 之间形成了一个单向下行绑定：父级 prop 的更新会向下流动到子组件中，但是反过来则不行。这样会防止从子组件意外改变父级组件的状态，从而导致你的应用的数据流向难以理解。</p><p>因此，只要父组件的数据发生了更新，子组件也会获得相应的更新。无论，发生更新的原因是异步操作还是事件操作</p><h3 id="vm-watch"><a href="#vm-watch" class="headerlink" title="vm.$watch"></a>vm.$watch</h3><p>当然，我们可以使用watch方法来监听父组件数据的改变</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在父组件进行异步操作，一开始初值为undefined，经过2000毫秒后变为12345</span></span><br><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div id=<span class="string">"app"</span>&gt;</span><br><span class="line">    &lt;helloWorld :msg=<span class="string">"msg"</span>&gt;&lt;/helloWorld&gt;</span><br><span class="line">  &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">&lt;/</span>template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line"><span class="keyword">import</span> helloWorld <span class="keyword">from</span> <span class="string">'@/components/HelloWorld.vue'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  data() &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      msg: <span class="literal">undefined</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  components: &#123;</span><br><span class="line">    helloWorld</span><br><span class="line">  &#125;,</span><br><span class="line">  created() &#123;</span><br><span class="line">    setTimeout(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">      <span class="keyword">this</span>.msg=<span class="number">12345</span>;</span><br><span class="line">    &#125;,<span class="number">2000</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在子组件中利用watch方法来进行监听父组件的prop值的变化</span></span><br><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div <span class="class"><span class="keyword">class</span></span>=<span class="string">"hello"</span>&gt;</span><br><span class="line">    &#123;&#123;msg&#125;&#125;</span><br><span class="line">  &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">&lt;/</span>template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  props:[<span class="string">'msg'</span>],</span><br><span class="line">  watch: &#123;</span><br><span class="line">    msg(val,oldVal)&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(val,oldVal); <span class="comment">// 12345,undefined </span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br></pre></td></tr></table></figure><h2 id="拦截数据，过滤处理"><a href="#拦截数据，过滤处理" class="headerlink" title="拦截数据，过滤处理"></a>拦截数据，过滤处理</h2><p>有时候，我们相对从父组件传过来的数据进行一些额外操作之后再进行渲染，此时我们可以利用计算属性来实现</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">computed: &#123;</span><br><span class="line">  anotherMsg() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.msg+<span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="子组件向父组件传值"><a href="#子组件向父组件传值" class="headerlink" title="子组件向父组件传值"></a>子组件向父组件传值</h2><h3 id="vm-on与vm-emit"><a href="#vm-on与vm-emit" class="headerlink" title="vm.$on与vm.$emit"></a>vm.$on与vm.$emit</h3><p>vm.$on要与vm.$emit搭配来进行使用</p><p>vue的api文档是这么描述这两个api的</p><h4 id="vm-on-event-callback"><a href="#vm-on-event-callback" class="headerlink" title="vm.$on( event, callback )"></a>vm.$on( event, callback )</h4><p>参数：</p><ol><li>{string | Array<string>} event (数组只在 2.2.0+ 中支持)</string></li><li>{Function} callback<br>用法：</li></ol><p>监听当前实例上的自定义事件。事件可以由vm.$emit触发。回调函数会接收所有传入事件触发函数的额外参数。</p><p>示例：</p><pre><code>vm.$on(&apos;test&apos;, function (msg) {console.log(msg)})vm.$emit(&apos;test&apos;, &apos;hi&apos;)// =&gt; &quot;hi&quot;</code></pre><h4 id="vm-emit-eventName-…args"><a href="#vm-emit-eventName-…args" class="headerlink" title="vm.$emit( eventName, […args] )"></a>vm.$emit( eventName, […args] )</h4><p>参数：</p><p>{string} eventName<br>[…args]</p><p>触发当前实例上的事件。附加参数都会传给监听器回调。</p><p>因此，我们可以在同一个实例上注册on监听事件函数以及emit响应事件函数</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  created() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.msg);</span><br><span class="line">    <span class="keyword">this</span>.$on(<span class="string">'test'</span>,(v)=&gt;&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(v);</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;,</span><br><span class="line">  methods: &#123;</span><br><span class="line">    change() &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">'emit'</span>);</span><br><span class="line">      <span class="keyword">this</span>.$emit(<span class="string">'test'</span>,<span class="number">123456789</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br></pre></td></tr></table></figure><p>我们在created生命周期时注册了一个监听test事件的on函数，在事件change()发生时，我们让test事件通过emit方法也进行发生。从而，监听函数会监听到该事件的发生并进行相应的输出</p><p>但是，虽然事件监听与响应都可以完成，但是这两个方法必须在同一个实例上才可以进行使用。因此，如果要进行子组件将值传递给父组件，我们可以使用v-on与vm.$emit进行搭配使用</p><h3 id="v-on与vm-emit"><a href="#v-on与vm-emit" class="headerlink" title="v-on与vm.$emit"></a>v-on与vm.$emit</h3><p>因为父组件可以在使用子组件的引入模板直接用 v-on 来监听子组件触发的事件。因此，我们可以使用v-on和vm.$emit来使得子组件向父组件传值</p><p>例如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 父组件</span></span><br><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div id=<span class="string">"app"</span>&gt;</span><br><span class="line">  <span class="comment">// 在子组件的引入模板中使用v-on来进行监听子组件中的test事件</span></span><br><span class="line">  <span class="comment">// 注意，@后必须是在子组件中要监听的事件名，而双引号中是父组件对于监听到事件发生后做出的处理函数。对于该例中，也就是test是要监听的事件名，getSonValue是父组件的处理函数</span></span><br><span class="line">    &lt;helloWorld :msg=<span class="string">"msg"</span> @test=<span class="string">'getSonValue'</span>&gt;&lt;/helloWorld&gt;</span><br><span class="line">  &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">&lt;/</span>template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line"><span class="keyword">import</span> helloWorld <span class="keyword">from</span> <span class="string">'@/components/HelloWorld.vue'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  methods: &#123;</span><br><span class="line">    getSonValue(v) &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">'v'</span>,v);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">methods: &#123;</span><br><span class="line">  change() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'emit'</span>);</span><br><span class="line">    <span class="comment">// 发布事件test，并传入参数123456789</span></span><br><span class="line">    <span class="keyword">this</span>.$emit(<span class="string">'test'</span>,<span class="number">123456789</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="同级组件通信"><a href="#同级组件通信" class="headerlink" title="同级组件通信"></a>同级组件通信</h2><p>同级组件通信，也就是意味着某个父组件下有两个不同的子组件，这两个组件之间可以通信</p><h3 id="父组件作为中转站"><a href="#父组件作为中转站" class="headerlink" title="父组件作为中转站"></a>父组件作为中转站</h3><p>一种可行的办法，就是父组件接收其中一个组件传递的值并将该值传递给另外一个子组件</p><p>例如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 父组件</span></span><br><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div id=<span class="string">"app"</span>&gt;</span><br><span class="line">    &lt;component1 @msg=<span class="string">"getMsg"</span>&gt;&lt;/component1&gt;</span><br><span class="line">    &lt;component2 :msg=<span class="string">"msg"</span>&gt;&lt;/component2&gt;</span><br><span class="line">  &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">&lt;/</span>template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line"><span class="keyword">import</span> component1 <span class="keyword">from</span> <span class="string">'@/components/Component1'</span></span><br><span class="line"><span class="keyword">import</span> component2 <span class="keyword">from</span> <span class="string">'@/components/Component2'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  components: &#123;</span><br><span class="line">    component1,</span><br><span class="line">    component2</span><br><span class="line">  &#125;,</span><br><span class="line">  methods: &#123;</span><br><span class="line">    getMsg(v) &#123;</span><br><span class="line">      <span class="keyword">this</span>.msg=v;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  data() &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      msg: <span class="literal">undefined</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 子组件1</span></span><br><span class="line">&lt;template&gt;</span><br><span class="line">    &lt;div id=<span class="string">"component1"</span>&gt;</span><br><span class="line">        &lt;div&gt;</span><br><span class="line">            子组件<span class="number">1</span>的值为：&#123;&#123;msg&#125;&#125;</span><br><span class="line">        &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">        &lt;button @click="sendMsg"&gt;click&lt;/</span>button&gt;</span><br><span class="line">    &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">&lt;/</span>template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">    data() &#123;</span><br><span class="line">        <span class="keyword">return</span> &#123;</span><br><span class="line">            msg: <span class="number">123</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    methods: &#123;</span><br><span class="line">        sendMsg() &#123;</span><br><span class="line">            <span class="keyword">this</span>.$emit(<span class="string">'msg'</span>,<span class="keyword">this</span>.msg);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">    &lt;div id=<span class="string">"component2"</span>&gt;</span><br><span class="line">        子组件<span class="number">2</span>的值为：&#123;&#123;msg&#125;&#125;</span><br><span class="line">    &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">&lt;/</span>template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">    props: [<span class="string">'msg'</span>]</span><br><span class="line">&#125;</span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br></pre></td></tr></table></figure><p>当子组件1点击按钮后，子组件2就可以获得组件1传过来的msg值</p><h3 id="额外实例作为中央事件总线"><a href="#额外实例作为中央事件总线" class="headerlink" title="额外实例作为中央事件总线"></a>额外实例作为中央事件总线</h3><p>因为ES6的模块机制有一个特性</p><blockquote><p>当模块内部发生变化的时候，引入模块的部分同样会发生变化</p></blockquote><p>因此，我们可以创建一个额外的实例,并且在两个子组件中分别绑定vm.$emit方法进行事件发放和vm.$on方法进行事件监听</p><ol><li><p>创建额外实例</p> <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// eventBus.js</span></span><br><span class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">'vue'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">new</span> Vue();</span><br></pre></td></tr></table></figure></li><li><p>在子组件1中引入该实例，并为其绑定分发事件vm.$emit方法</p> <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">    &lt;div id=<span class="string">"component1"</span>&gt;</span><br><span class="line">        &lt;div&gt;</span><br><span class="line">            子组件<span class="number">1</span>的值为：&#123;&#123;msg&#125;&#125;</span><br><span class="line">        &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">        &lt;button @click="sendMsg"&gt;click&lt;/</span>button&gt;</span><br><span class="line">    &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">&lt;/</span>template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line"><span class="keyword">import</span> eventBus <span class="keyword">from</span> <span class="string">'@/components/eventBus.js'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">    data() &#123;</span><br><span class="line">        <span class="keyword">return</span> &#123;</span><br><span class="line">            msg: <span class="number">123</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    methods: &#123;</span><br><span class="line">        sendMsg() &#123;</span><br><span class="line">            <span class="built_in">console</span>.log(eventBus);</span><br><span class="line">            eventBus.$emit(<span class="string">'msg'</span>,<span class="keyword">this</span>.msg);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>在子组件2中引入额外实例并为其绑定监听事件vm.$on方法</p> <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">    &lt;div id=<span class="string">"component2"</span>&gt;</span><br><span class="line">        子组件<span class="number">2</span>的值为：&#123;&#123;msg&#125;&#125;</span><br><span class="line">    &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">&lt;/</span>template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line"><span class="keyword">import</span> eventBus <span class="keyword">from</span> <span class="string">'@/components/eventBus.js'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">    created() &#123;</span><br><span class="line">        eventBus.$on(<span class="string">'msg'</span>,(v)=&gt;&#123;</span><br><span class="line">            <span class="keyword">this</span>.msg=v;</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;,</span><br><span class="line">    data() &#123;</span><br><span class="line">        <span class="keyword">return</span> &#123;</span><br><span class="line">            msg: <span class="literal">undefined</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br></pre></td></tr></table></figure></li></ol><p>经过上述三步后，子组件2在created生命周期时就已经在额外实例上创建了事件监听方法。因此，当子组件1点击按钮之后就会向额外实例分发了一个事件msg;那么，额外实例就会监听到该事件的发生并作出处理函数，这样也就完成了两个同级组件之间的传值</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;父组件向子组件传值&quot;&gt;&lt;a href=&quot;#父组件向子组件传值&quot; class=&quot;headerlink&quot; title=&quot;父组件向子组件传值&quot;&gt;&lt;/a&gt;父组件向子组件传值&lt;/h2&gt;&lt;h3 id=&quot;Prop&quot;&gt;&lt;a href=&quot;#Prop&quot; class=&quot;headerli
      
    
    </summary>
    
      <category term="Vue" scheme="http://yoursite.com/categories/Vue/"/>
    
    
      <category term="Vue" scheme="http://yoursite.com/tags/Vue/"/>
    
  </entry>
  
  <entry>
    <title>nowcoder-2</title>
    <link href="http://yoursite.com/2019/09/19/nowcoder-2/"/>
    <id>http://yoursite.com/2019/09/19/nowcoder-2/</id>
    <published>2019-09-19T12:45:10.000Z</published>
    <updated>2019-09-19T12:53:11.846Z</updated>
    
    <content type="html"><![CDATA[<h1 id="数组的相对排序"><a href="#数组的相对排序" class="headerlink" title="数组的相对排序"></a>数组的相对排序</h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>请实现一个函数，将一个字符串中的每个空格替换成“%20”。例如，当字符串为We Are Happy.则经过替换之后的字符串为We%20Are%20Happy。</p><h2 id="核心思路"><a href="#核心思路" class="headerlink" title="核心思路"></a>核心思路</h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>题意很简单，就是将所有的空格转化为’%20’的格式。因此，我们可以使用replace()方法来进行替换值，当然是使用正则表达式来进行匹配</p><h2 id="Coding实现"><a href="#Coding实现" class="headerlink" title="Coding实现"></a>Coding实现</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">replaceSpace</span>(<span class="params">str</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">let</span> pattern=<span class="regexp">/\s/g</span>;</span><br><span class="line">    <span class="keyword">return</span> str.replace(pattern,<span class="string">'%20'</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    replaceSpace : replaceSpace</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="时空复杂度分析"><a href="#时空复杂度分析" class="headerlink" title="时空复杂度分析"></a>时空复杂度分析</h2><ol><li>时间复杂度：O(1)</li><li>空间复杂度：O(1)</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;数组的相对排序&quot;&gt;&lt;a href=&quot;#数组的相对排序&quot; class=&quot;headerlink&quot; title=&quot;数组的相对排序&quot;&gt;&lt;/a&gt;数组的相对排序&lt;/h1&gt;&lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; titl
      
    
    </summary>
    
      <category term="牛客网算法题刷题记录" scheme="http://yoursite.com/categories/%E7%89%9B%E5%AE%A2%E7%BD%91%E7%AE%97%E6%B3%95%E9%A2%98%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/"/>
    
    
  </entry>
  
  <entry>
    <title>leetcode-367 有效的完全平方数</title>
    <link href="http://yoursite.com/2019/09/18/leetcode-367/"/>
    <id>http://yoursite.com/2019/09/18/leetcode-367/</id>
    <published>2019-09-18T12:50:53.000Z</published>
    <updated>2019-09-18T13:03:51.969Z</updated>
    
    <content type="html"><![CDATA[<h1 id="有效的完全平方数"><a href="#有效的完全平方数" class="headerlink" title="有效的完全平方数"></a>有效的完全平方数</h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>给定一个正整数 num，编写一个函数，如果 num 是一个完全平方数，则返回 True，否则返回 False。</p><p>说明：不要使用任何内置的库函数，如  sqrt。</p><p>示例 1：</p><blockquote><p>输入：16<br>输出：True</p></blockquote><p>示例 2：</p><blockquote><p>输入：14<br>输出：False</p></blockquote><a id="more"></a><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/valid-perfect-square" target="_blank" rel="noopener">https://leetcode-cn.com/problems/valid-perfect-square</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p><h2 id="核心思路"><a href="#核心思路" class="headerlink" title="核心思路"></a>核心思路</h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>我们知道，对于大于等于4的完全平方数，它的平方根会小于或等于它的一半。因此，我们可以在2~n/2之间进行二分查找，来降低时间复杂度</p><h3 id="解题步骤"><a href="#解题步骤" class="headerlink" title="解题步骤"></a>解题步骤</h3><ol><li>如果给定的数为1，返回true</li><li>设定left为2，right为Math.floor(num/2)，mid为Math.floor((left+right)/2)；如果mid*mid===num那么返回true；如果小于，则left=mid+1;<br>否则right=mid-1;</li><li>重复步骤2知道right&gt;left</li><li>如果上述二分过程中没有返回true，那么返回false</li></ol><h2 id="Coding实现"><a href="#Coding实现" class="headerlink" title="Coding实现"></a>Coding实现</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @param &#123;number&#125; num</span></span><br><span class="line"><span class="comment"> * @return &#123;boolean&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> isPerfectSquare = <span class="function"><span class="keyword">function</span>(<span class="params">num</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(num===<span class="number">1</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">let</span> left=<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">let</span> right=<span class="built_in">Math</span>.floor(num/<span class="number">2</span>);</span><br><span class="line">    <span class="keyword">let</span> mid;</span><br><span class="line">    <span class="keyword">while</span>(left&lt;=right) &#123;</span><br><span class="line">        mid=<span class="built_in">Math</span>.floor((left+right)/<span class="number">2</span>);</span><br><span class="line">        <span class="keyword">if</span>(mid*mid===num) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(mid*mid&gt;num) &#123;</span><br><span class="line">            right=mid<span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            left=mid+<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;有效的完全平方数&quot;&gt;&lt;a href=&quot;#有效的完全平方数&quot; class=&quot;headerlink&quot; title=&quot;有效的完全平方数&quot;&gt;&lt;/a&gt;有效的完全平方数&lt;/h1&gt;&lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h2&gt;&lt;p&gt;给定一个正整数 num，编写一个函数，如果 num 是一个完全平方数，则返回 True，否则返回 False。&lt;/p&gt;
&lt;p&gt;说明：不要使用任何内置的库函数，如  sqrt。&lt;/p&gt;
&lt;p&gt;示例 1：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;输入：16&lt;br&gt;输出：True&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;示例 2：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;输入：14&lt;br&gt;输出：False&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="leetcode题解与算法" scheme="http://yoursite.com/categories/leetcode%E9%A2%98%E8%A7%A3%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="二分查找" scheme="http://yoursite.com/tags/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/"/>
    
  </entry>
  
  <entry>
    <title>nowcoder-1 二维数组中的查找</title>
    <link href="http://yoursite.com/2019/09/17/nowcoder-1/"/>
    <id>http://yoursite.com/2019/09/17/nowcoder-1/</id>
    <published>2019-09-17T14:51:49.000Z</published>
    <updated>2019-09-17T15:14:53.238Z</updated>
    
    <content type="html"><![CDATA[<h1 id="数组的相对排序"><a href="#数组的相对排序" class="headerlink" title="数组的相对排序"></a>数组的相对排序</h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>在一个二维数组中（每个一维数组的长度相同），每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。</p><h2 id="核心思路"><a href="#核心思路" class="headerlink" title="核心思路"></a>核心思路</h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><ol><li>最直接的暴力解法<br>遍历二维数组中的每一个元素，返回是否能找到给定的target值</li><li>利用ES6特性，将数组扁平化（但是牛客网并没有很好地支持flat()函数，因此我们可以使用concat()方法来实现扁平化）后使用includes()函数进行查找</li><li>巧妙一点的方法是：由于该二维数组的规律（每一行从左往右递增，每一列从上往下递增），我们可以发现二维数组的左下角总是当前行的最小值，当前列的最大值。因此，当给定值大于当前左下角的数值时，我们就将该数往右移动一位；当给定值小于当前左下角的数值时，我们就将该数往上移动一位。直到找到该值返回true，或者遍历到右上角仍然没有找到返回false</li></ol><h3 id="解题步骤"><a href="#解题步骤" class="headerlink" title="解题步骤"></a>解题步骤</h3><h2 id="Coding实现"><a href="#Coding实现" class="headerlink" title="Coding实现"></a>Coding实现</h2><p>通过concat()扁平化后利用includes()来查找</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Find</span>(<span class="params">target, array</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">let</span> arr=[].concat(...array);</span><br><span class="line">    <span class="keyword">return</span> arr.includes(target);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    Find : Find</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>左下到右上的查找</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Find</span>(<span class="params">target, array</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">let</span> column=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">let</span> row=array.length<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">let</span> num;</span><br><span class="line">    <span class="keyword">while</span>(column&lt;array[<span class="number">0</span>].length&amp;&amp;row&gt;=<span class="number">0</span>)&#123;</span><br><span class="line">        num=array[row][column];</span><br><span class="line">        <span class="keyword">if</span>(target&gt;num) &#123;</span><br><span class="line">            column++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(target&lt;num) &#123;</span><br><span class="line">            row--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    Find : Find</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;数组的相对排序&quot;&gt;&lt;a href=&quot;#数组的相对排序&quot; class=&quot;headerlink&quot; title=&quot;数组的相对排序&quot;&gt;&lt;/a&gt;数组的相对排序&lt;/h1&gt;&lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; titl
      
    
    </summary>
    
      <category term="牛客网算法题刷题记录" scheme="http://yoursite.com/categories/%E7%89%9B%E5%AE%A2%E7%BD%91%E7%AE%97%E6%B3%95%E9%A2%98%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/"/>
    
    
  </entry>
  
  <entry>
    <title>模块化</title>
    <link href="http://yoursite.com/2019/09/16/%E6%A8%A1%E5%9D%97%E5%8C%96/"/>
    <id>http://yoursite.com/2019/09/16/模块化/</id>
    <published>2019-09-16T08:28:58.000Z</published>
    <updated>2019-09-24T14:18:52.176Z</updated>
    
    <content type="html"><![CDATA[<h2 id="模块与脚本的区别"><a href="#模块与脚本的区别" class="headerlink" title="模块与脚本的区别"></a>模块与脚本的区别</h2><p>模块不会将它的顶级变量、函数和类作为全局作用域的全局变量，并且模块顶级作用域的this值为undefined</p><h2 id="为什么要模块化"><a href="#为什么要模块化" class="headerlink" title="为什么要模块化"></a>为什么要模块化</h2><p>模块化可以将一个复杂的功能拆分为几个小功能，并且功能模块之间不会互相影响。这样就可以使得代码低耦合</p><p>另外，因为每个模块声明的变量并不会影响全局作用域，因此就不会有全局变量污染以及命名冲突的问题</p><p>每个模块都是独立的，因此模块具有良好的可复用性</p><h2 id="CommonJs模块化"><a href="#CommonJs模块化" class="headerlink" title="CommonJs模块化"></a>CommonJs模块化</h2><p>Node.js是commonJS规范的主要实践者，它有四个重要的环境变量为模块化的实现提供支持：module、exports、require、global。实际使用时，用module.exports定义当前模块对外输出的接口（不推荐直接用exports），用require加载模块。</p><p>例如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义模块module.js</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> a=<span class="number">1</span>;</span><br><span class="line"><span class="built_in">module</span>.exports.test=<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(a);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义test模块并引入module模块</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> m=<span class="built_in">require</span>(<span class="string">'./test'</span>)</span><br><span class="line"></span><br><span class="line">m.test(); <span class="comment">// 1</span></span><br></pre></td></tr></table></figure><h2 id="Es6模块化"><a href="#Es6模块化" class="headerlink" title="Es6模块化"></a>Es6模块化</h2><h3 id="基本语法"><a href="#基本语法" class="headerlink" title="基本语法"></a>基本语法</h3><h4 id="导出的几种形式"><a href="#导出的几种形式" class="headerlink" title="导出的几种形式"></a>导出的几种形式</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义的同时，导出单个变量、对象、函数或类</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> a=<span class="number">1</span>；</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> b=&#123;<span class="attr">item</span>:<span class="number">1</span>&#125;;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> c=<span class="function"><span class="params">()</span>=&gt;</span><span class="number">1</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="class"><span class="keyword">class</span> <span class="title">C</span></span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(item) &#123;</span><br><span class="line">        <span class="keyword">this</span>.item=item;</span><br><span class="line">    &#125;</span><br><span class="line">    getItem()&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.item;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在定义之后导出单个变量</span></span><br><span class="line"><span class="keyword">const</span> a=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">export</span> a;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在定义之后导出多个变量</span></span><br><span class="line"><span class="keyword">const</span> a=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">const</span> b=<span class="number">2</span>;</span><br><span class="line"><span class="keyword">export</span> &#123;a,b&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 导出时重命名，使用as关键字来指定变量等在模块外应该被称为什么名称,同时需要使用大括号</span></span><br><span class="line"><span class="keyword">const</span> a=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">export</span> &#123;a <span class="keyword">as</span> itemA&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 重命名多个变量</span></span><br><span class="line"><span class="keyword">const</span> a=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">const</span> b=<span class="number">2</span>;</span><br><span class="line"><span class="keyword">export</span> &#123;a <span class="keyword">as</span> itemA,b <span class="keyword">as</span> itemB&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 导出模块的默认值，模块的默认值通过default关键字来指定。一个模块只能导出一个默认值（单个变量，函数，类，对象等）</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">    item:<span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 重新导出一个引入的绑定</span></span><br><span class="line"><span class="keyword">import</span> &#123;a&#125; <span class="keyword">from</span> <span class="string">'./m.js'</span></span><br><span class="line"><span class="keyword">export</span> &#123;a&#125;; <span class="comment">// 导出非默认值绑定</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> &#123;a&#125; <span class="keyword">from</span> <span class="string">'./m.js'</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> a; <span class="comment">// 导出默认值绑定</span></span><br></pre></td></tr></table></figure><h4 id="导入的几种形式"><a href="#导入的几种形式" class="headerlink" title="导入的几种形式"></a>导入的几种形式</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 仅为副作用而导入一个模块,整个模块仅为副作用（中性词，无贬义含义）而导入，而不导入模块中的任何内容（接口）。 这将运行模块中的全局代码, 但实际上不导入任何值。</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="keyword">from</span> <span class="string">'./test.js'</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//导入非默认值单个变量</span></span><br><span class="line"><span class="keyword">import</span> &#123;a&#125; <span class="keyword">from</span> <span class="string">'./test.js'</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 导入非默认值多个变量</span></span><br><span class="line"><span class="keyword">import</span> &#123;a,b&#125; <span class="keyword">from</span> <span class="string">'./test.js'</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 导入整个模块</span></span><br><span class="line"><span class="keyword">import</span> * <span class="keyword">from</span> <span class="string">'./test.js'</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 导入默认值时不需要大括号语法</span></span><br><span class="line"><span class="keyword">import</span> a <span class="keyword">from</span> <span class="string">'./test.js'</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 导入默认值和非默认值，注意默认值必须排在非默认值前</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> a=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">const</span> b=<span class="number">2</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> b;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> b,&#123;a&#125; <span class="keyword">from</span> <span class="string">'./test.js'</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 导入非默认值时重命名，导入默认值则无法重命名，因为默认值的导入变量命名本来就是自己定义的</span></span><br><span class="line"><span class="keyword">import</span> &#123;a <span class="keyword">as</span> itemA&#125; <span class="keyword">from</span> <span class="string">'./test.js'</span></span><br></pre></td></tr></table></figure><p>注意：导入非默认值绑定看起来像是解构对象，但事实上它不是</p><h2 id="模块化的一些注意点"><a href="#模块化的一些注意点" class="headerlink" title="模块化的一些注意点"></a>模块化的一些注意点</h2><p>以下是我们需要注意的地方</p><ol><li><p>当从另一个模块中导入一个绑定，该绑定就好像是使用const定义的一样。我们无法对它进行修改和重命名。</p> <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> b,&#123;a <span class="keyword">as</span> itemA&#125; <span class="keyword">from</span> <span class="string">'./test.js'</span></span><br><span class="line">b=<span class="number">1</span>; <span class="comment">// 报错："b" is read-only.</span></span><br><span class="line"><span class="built_in">console</span>.log(b,itemA);</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> b,&#123;a <span class="keyword">as</span> itemA&#125; <span class="keyword">from</span> <span class="string">'./test.js'</span></span><br><span class="line"><span class="keyword">let</span> b=<span class="number">1</span>; <span class="comment">// 报错： Identifier 'b' has already been declared</span></span><br><span class="line"><span class="built_in">console</span>.log(b,itemA);</span><br></pre></td></tr></table></figure></li><li><p>使用import语法时要引入的模块文件必须要加上文件后缀，例如’./test.js’；而node.js则遵循基于文件系统前缀来区分文件和包的惯例。例如，example是一个包，而example.js是一个本地文件</p></li><li><p>为了最好地兼容多个浏览器和Node.js环境，一定要在模块文件名前包含/、./或../来表示要导入的文件</p></li><li><p>模块只会执行一次，无论你多少次导入同一模块。当导入模块的代码执行后，实例化过的模块就会被保存在内存中，只要另一个import语句引用它就可以重复使用</p> <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;a&#125; <span class="keyword">from</span> <span class="string">'./test.js'</span>;  <span class="comment">// 该模块只会执行这一次</span></span><br><span class="line"><span class="keyword">import</span> &#123;b&#125; <span class="keyword">from</span> <span class="string">'./test.js'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123;c&#125; <span class="keyword">from</span> <span class="string">'./test.js'</span>;</span><br></pre></td></tr></table></figure></li><li><p>模块语法只能在当前模块顶部(也就是该模块的最外层执行环境)使用</p></li><li><p>导入模块的标识符只是本地的一个变量名称，并不等于被引入的模块中的同名变量</p></li><li><p>模块只能设置一个默认的导出值</p></li></ol><h2 id="CommonJs模块化与ES6模块化的区别"><a href="#CommonJs模块化与ES6模块化的区别" class="headerlink" title="CommonJs模块化与ES6模块化的区别"></a>CommonJs模块化与ES6模块化的区别</h2><ol><li>调用时间<ol><li>require是运行时调用，也就是只有代码运行到require命令时，才会运行和导入其他模块。所以,require可以放在代码的任何地方</li><li>import是编译时调用，因此，进入有import命令的模块时，被导入模块会第一时间被运行和导入，然后才会运行其他代码</li></ol></li></ol><p>例如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// module1.js</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'module1.js'</span>);</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">    item: <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// module2.js</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'module2.js'</span>);</span><br><span class="line"><span class="keyword">import</span> m <span class="keyword">from</span> <span class="string">'./module1.js'</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(m);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 运行module2.js结果如下：</span></span><br><span class="line"><span class="string">'module1.js'</span>,</span><br><span class="line"><span class="string">'module2.js'</span>,</span><br><span class="line">&#123;<span class="attr">item</span>:<span class="number">1</span>&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;模块与脚本的区别&quot;&gt;&lt;a href=&quot;#模块与脚本的区别&quot; class=&quot;headerlink&quot; title=&quot;模块与脚本的区别&quot;&gt;&lt;/a&gt;模块与脚本的区别&lt;/h2&gt;&lt;p&gt;模块不会将它的顶级变量、函数和类作为全局作用域的全局变量，并且模块顶级作用域的this值为u
      
    
    </summary>
    
      <category term="ES6" scheme="http://yoursite.com/categories/ES6/"/>
    
    
  </entry>
  
  <entry>
    <title>js事件循环机制 event loop</title>
    <link href="http://yoursite.com/2019/09/13/%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF%E6%9C%BA%E5%88%B6/"/>
    <id>http://yoursite.com/2019/09/13/事件循环机制/</id>
    <published>2019-09-13T12:36:20.000Z</published>
    <updated>2019-09-29T15:06:24.385Z</updated>
    
    <content type="html"><![CDATA[<h2 id="为什么js是单线程的"><a href="#为什么js是单线程的" class="headerlink" title="为什么js是单线程的"></a>为什么js是单线程的</h2><p>众所周知，JavaScript是一门单线程语言。那么，为什么js必须是单线程的呢？</p><p>因为，js主要的宿主环境就是浏览器，并且其一个重要的用途就是来操作Dom。反过来思考，如果js是多线程的，那么就会允许同一时间有多个代码块运行。那么，如果这多个代码块同时操作同一个Dom，比如，一个代码块要修改某dom元素，而另一个代码块又要删除这个元素，那么浏览器该如何处理这个元素。因此，为了避免这种复杂性，js必须是单线程的</p><h2 id="执行栈（调用栈）与任务队列"><a href="#执行栈（调用栈）与任务队列" class="headerlink" title="执行栈（调用栈）与任务队列"></a>执行栈（调用栈）与任务队列</h2><h3 id="什么是执行栈（调用栈）"><a href="#什么是执行栈（调用栈）" class="headerlink" title="什么是执行栈（调用栈）"></a>什么是执行栈（调用栈）</h3><p>执行栈，也就是“调用栈”，是一种拥有 LIFO（后进先出）数据结构的栈，被用来存储代码运行时创建的所有执行上下文（包括全局执行上下文，局部函数执行上下文以及eval函数执行上下文）。</p><p>注意，因为JavaScript是单线程的，因此，其只有一个调用栈</p><p>例如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">a</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    b();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">b</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">a();</span><br></pre></td></tr></table></figure><p>对于以上代码，执行栈里面的任务是这样依次出入栈的：</p><ol><li>进入该段整体代码 main()入栈</li><li>执行a() a()入栈</li><li>调用b b()入栈</li><li>执行b函数 console.log(1)入栈</li><li>输出完毕，console.log(1)出栈</li><li>b()出栈</li><li>a()出栈</li><li>main()出栈，代码执行完毕</li></ol><h3 id="任务"><a href="#任务" class="headerlink" title="任务"></a>任务</h3><p>众所周知，我们可以将js的任务分为两大类：</p><h4 id="同步任务"><a href="#同步任务" class="headerlink" title="同步任务"></a>同步任务</h4><p>优先级最高，运行时立刻进入主线程运行</p><h4 id="异步任务"><a href="#异步任务" class="headerlink" title="异步任务"></a>异步任务</h4><p>只有当所有同步任务执行完毕后才会去执行异步任务，异步任务的执行过程如下：</p><ol><li>异步任务进入Event Table执行，并且注册回调函数</li><li>当指定的异步任务完成时，Event Table会将这个回调函数移入Event Queue（值得注意的是，当有多个异步任务时，先执行完毕的异步任务的回调函数会先进入该任务队列）</li><li>主线程内的任务执行完毕为空，会去Event Queue读取对应的函数，进入主线程执行</li><li>上述过程会不断重复，这也是我们后面会提到的事件循环</li></ol><p>上述的event queue指的是就是任务队列，任务队列内存放的都是异步任务完成后要执行的函数</p><p>另外，我们需要注意的是，只有异步任务完成之后要执行的回调函数才会被放入任务队列，等待主线程中的所有同步代码被执行完毕之后再执行。</p><p>因此，比如在new Promise过程中不再回调函数内的代码都是同步代码，只有then()和catch()中的回调函数才是异步代码</p><p>例如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve,reject</span>)=&gt;</span>&#123; <span class="comment">// 第一行</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">1</span>);  <span class="comment">// 第二行</span></span><br><span class="line">    resolve(<span class="number">2</span>); <span class="comment">//第三行</span></span><br><span class="line">&#125;).then(<span class="function">(<span class="params">v</span>)=&gt;</span>&#123; <span class="comment">// 第四行</span></span><br><span class="line">    <span class="built_in">console</span>.log(v); <span class="comment">// 第五行</span></span><br><span class="line">&#125;) <span class="comment">// 第六行</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出结果</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">2</span></span><br></pre></td></tr></table></figure><p>其中，第1,2,3,4,6行都是同步代码，只有第5行是异步的代码</p><p>以下是任务执行过程:</p><p><img src="https://s2.ax1x.com/2019/09/28/ulg28I.png" alt></p><h4 id="宏任务与微任务"><a href="#宏任务与微任务" class="headerlink" title="宏任务与微任务"></a>宏任务与微任务</h4><p>任务也可以更加被细分为宏任务与微任务两种，具体如下</p><ol><li>宏任务(macrotask)：<br> script(整体代码)、setTimeout、setInterval、UI 渲染、 I/O、postMessage、 MessageChannel、setImmediate(Node.js 环境)、ajax、外部请求等</li><li>微任务(microtask)：<br> Promise.then/catch、 MutaionObserver、process.nextTick(Node.js环境）</li></ol><p>那么宏任务与微任务的执行顺序是怎么样的呢？</p><p>网络上有两种说法，目前我还没有看到权威文章</p><ol><li><p>如果，我们将整个script(整体代码)也算做是一个宏任务，那么执行顺序会是</p><blockquote><p>宏任务-&gt;所有微任务-&gt;下一个宏任务</p></blockquote></li><li><p>但是如果不是的话，那么就是</p><blockquote><p>所有微任务-&gt;下一个宏任务</p></blockquote></li></ol><p>总之这些并不会影响代码的执行顺序</p><p>例如：</p><p>宏任务定时器与微任务promise</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">setTimeout(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">1</span>)</span><br><span class="line">&#125;,<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve,reject</span>)=&gt;</span>&#123;</span><br><span class="line">    resolve(<span class="number">2</span>);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">3</span>);</span><br><span class="line">&#125;).then(<span class="function"><span class="params">v</span>=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(v);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">4</span>;</span><br><span class="line">&#125;).then(<span class="function"><span class="params">v</span>=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(v);</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">5</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 执行结果</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="number">5</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">4</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 执行过程</span></span><br><span class="line"><span class="number">1.</span> 先进入整体代码script这个宏任务，该任务直接进入主线程，因此要执行掉所有的同步任务</span><br><span class="line"><span class="number">2.</span> 遇到setTimeout这一宏任务，我们将其放入宏任务队列</span><br><span class="line"><span class="number">3.</span> 遇到<span class="built_in">Promise</span>构造函数，立即执行该构造函数，执行<span class="built_in">console</span>.log(<span class="number">3</span>);两个then()方法依次进入微任务队列</span><br><span class="line"><span class="number">4.</span> 执行<span class="built_in">console</span>.log(<span class="number">5</span>);</span><br><span class="line"><span class="number">5.</span> 第一个宏任务执行结束，接下来查看微任务队列是否有要解决的微任务，按照先进先出的原则执行完所有的微任务</span><br><span class="line"><span class="number">6.</span> 到这里，第一轮事件循环结束，进入下一轮事件循环</span><br><span class="line"><span class="number">7.</span> 从宏任务队列中取出下一个宏任务，也就是setTimeout的回调函数，执行它</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>宏任务ajax与微任务promise</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> axios=<span class="built_in">require</span>(<span class="string">'axios'</span>)</span><br><span class="line"></span><br><span class="line">axios.get(<span class="string">'https://www.baidu.com'</span>).then(<span class="function"><span class="params">v</span>=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">1</span>);</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve,reject</span>)=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">2</span>);</span><br><span class="line">    resolve(<span class="number">3</span>);</span><br><span class="line">&#125;).then(<span class="function"><span class="params">v</span>=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(v);</span><br><span class="line">    <span class="keyword">return</span> (<span class="number">4</span>);</span><br><span class="line">&#125;).then(<span class="function"><span class="params">v</span>=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(v);</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">5</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 运行结果</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">5</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="number">4</span></span><br><span class="line"><span class="number">1</span></span><br></pre></td></tr></table></figure><p>最后，来一段超级复杂的代码</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="string">'1'</span>);</span><br><span class="line"></span><br><span class="line">setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'2'</span>);</span><br><span class="line">    process.nextTick(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'3'</span>);</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve</span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'4'</span>);</span><br><span class="line">        resolve();</span><br><span class="line">    &#125;).then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'5'</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;)</span><br><span class="line">process.nextTick(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'6'</span>);</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'7'</span>);</span><br><span class="line">    resolve();</span><br><span class="line">&#125;).then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'8'</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'9'</span>);</span><br><span class="line">    process.nextTick(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'10'</span>);</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve</span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'11'</span>);</span><br><span class="line">        resolve();</span><br><span class="line">    &#125;).then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'12'</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">7</span></span><br><span class="line"><span class="number">6</span></span><br><span class="line"><span class="number">8</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">4</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="number">5</span></span><br><span class="line"><span class="number">9</span></span><br><span class="line"><span class="number">11</span></span><br><span class="line"><span class="number">10</span></span><br><span class="line"><span class="number">12</span></span><br></pre></td></tr></table></figure><p>另一题：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="string">'global'</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">1</span>;i &lt;= <span class="number">5</span>;i ++) &#123;</span><br><span class="line">  setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(i)</span><br><span class="line">  &#125;,i*<span class="number">1000</span>)</span><br><span class="line">  <span class="built_in">console</span>.log(i)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span> (<span class="params">resolve</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'promise1'</span>)</span><br><span class="line">  resolve()</span><br><span class="line"> &#125;).then(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'then1'</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">setTimeout(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'timeout2'</span>)</span><br><span class="line">  <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span> (<span class="params">resolve</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'timeout2_promise'</span>)</span><br><span class="line">    resolve()</span><br><span class="line">  &#125;).then(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'timeout2_then'</span>)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;, <span class="number">1000</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// global 1 2 3 4 5 promise1 then1 6 timeout2 timeout2_promise timeout2_then 6 6 6 6</span></span><br></pre></td></tr></table></figure><h2 id="事件循环"><a href="#事件循环" class="headerlink" title="事件循环"></a>事件循环</h2><p>我们可以从两个角度去考虑事件循环，不仅仅是上文已经提到的同步与异步，还可以从微任务与宏任务来考虑事件循环</p><h3 id="从同步与异步来看事件循环"><a href="#从同步与异步来看事件循环" class="headerlink" title="从同步与异步来看事件循环"></a>从同步与异步来看事件循环</h3><p>如上文提到的所述：</p><ol><li>检查每一个进入主线程的任务，如果为同步任务，那么压入主线程堆栈；如果为异步，将该任务移到event table中，当该异步任务执行完毕后，将异步任务绑定的回调函数移入事件队列（任务队列）中</li><li>Js引擎会检查调用堆栈是否为空，然后不断地去检查事件队列（任务队列）是否为空。如果为空，则继续检查；如果不为空，则将该队列的第一个回调函数压入主线程去进行执行</li></ol><p>对于，事件循环的思考：</p><blockquote><p>为什么要进行事件循环？我觉得，不断地对事件队列去判断事件队列是否有任务的原因是因为，事件队列里存放的回调函数都是异步操作完成后才加入的。我们无法知道异步操作什么时候会完成。因此，就得不断去循环。而对于主线程，我们只需简单地判断堆栈是否为空（也就是堆栈长度是否为0）即可</p></blockquote><p>以上过程可以用伪代码进行描述</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// [... some initialization ...]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// The Event Loop</span></span><br><span class="line"><span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (! EventQueue.isEmpty()) &#123;</span><br><span class="line">     event = EventQueue.pop_oldest_item();</span><br><span class="line">     event.callback(event [or some other kind <span class="keyword">of</span> args]);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// [... defer to other non-JS tasks...]</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="从微任务与宏任务看事件循环"><a href="#从微任务与宏任务看事件循环" class="headerlink" title="从微任务与宏任务看事件循环"></a>从微任务与宏任务看事件循环</h3><p>准备：</p><p>检查每一个进来的任务，如果是同步任务，那么压入主线程调用栈中；如果是微任务，那么放入微任务队列；如果是宏任务，那么放入宏任务队列</p><p>Event Loop(事件循环)中，每一次循环称为 tick, 每一次tick的任务如下：</p><ol><li>执行栈执行完主线程中的所有任务（也可以&lt;script&gt;整体代码当做一个宏任务）</li><li>检查微任务队列，查看是否存在 Microtask，如果存在则不停的执行，直至清空 microtask 队列</li><li>更新render(每一次事件循环，浏览器都可能会去更新渲染)</li><li>检查宏任务队列，查看是否存在Macrotask，如果存在则取出一个任务进行执行（执行准备阶段操作）</li><li>重复以上步骤</li></ol><p><img src="https://s2.ax1x.com/2019/09/28/ulgJUJ.jpg" alt></p><p>总结：</p><p>微任务总是在下一个宏任务之前被执行完毕</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;为什么js是单线程的&quot;&gt;&lt;a href=&quot;#为什么js是单线程的&quot; class=&quot;headerlink&quot; title=&quot;为什么js是单线程的&quot;&gt;&lt;/a&gt;为什么js是单线程的&lt;/h2&gt;&lt;p&gt;众所周知，JavaScript是一门单线程语言。那么，为什么js必须是单线程
      
    
    </summary>
    
      <category term="javaScript基础" scheme="http://yoursite.com/categories/javaScript%E5%9F%BA%E7%A1%80/"/>
    
    
  </entry>
  
  <entry>
    <title>leetcode-303 区域和检索 - 数组不可变</title>
    <link href="http://yoursite.com/2019/09/13/leetcode-303/"/>
    <id>http://yoursite.com/2019/09/13/leetcode-303/</id>
    <published>2019-09-13T11:49:46.000Z</published>
    <updated>2019-09-13T11:55:00.064Z</updated>
    
    <content type="html"><![CDATA[<h1 id="区域和检索-数组不可变"><a href="#区域和检索-数组不可变" class="headerlink" title="区域和检索 - 数组不可变"></a>区域和检索 - 数组不可变</h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>给定一个整数数组  nums，求出数组从索引 i 到 j  (i ≤ j) 范围内元素的总和，包含 i,  j 两点。</p><p>示例：</p><pre><code>给定 nums = [-2, 0, 3, -5, 2, -1]，求和函数为 sumRange()sumRange(0, 2) -&gt; 1sumRange(2, 5) -&gt; -1sumRange(0, 5) -&gt; -3</code></pre><p>说明:</p><ol><li>你可以假设数组不可变。</li><li>会多次调用 sumRange 方法。<a id="more"></a>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/range-sum-query-immutable" target="_blank" rel="noopener">https://leetcode-cn.com/problems/range-sum-query-immutable</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</li></ol><h2 id="核心思路"><a href="#核心思路" class="headerlink" title="核心思路"></a>核心思路</h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>求数组中给定范围之间的和，比如说是求i&lt;=j之间范围的和，我们可以使用前j个元素的和减去前i-1个元素的和。</p><p>题目说明会多次调用求和方法，因此，我们可以在构造函数中就将前1个元素的和到第n个元素的和保存在哈希表中</p><h3 id="解题步骤"><a href="#解题步骤" class="headerlink" title="解题步骤"></a>解题步骤</h3><ol><li>遍历数组，以当前元素下标为键名，以从第一个元素到当前元素的和作为键值来建立哈希表</li><li>返回前j个元素的和减去前i-1个元素的和</li></ol><h2 id="Coding实现"><a href="#Coding实现" class="headerlink" title="Coding实现"></a>Coding实现</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @param &#123;number[]&#125; nums</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> NumArray = <span class="function"><span class="keyword">function</span>(<span class="params">nums</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.nums=nums;</span><br><span class="line">    <span class="keyword">let</span> map=<span class="keyword">new</span> <span class="built_in">Map</span>([[<span class="number">-1</span>,<span class="number">0</span>]]),sum=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">0</span>;i&lt;nums.length;i++) &#123;</span><br><span class="line">        sum+=nums[i];</span><br><span class="line">        map.set(i,sum);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">this</span>.map=map;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** </span></span><br><span class="line"><span class="comment"> * @param &#123;number&#125; i </span></span><br><span class="line"><span class="comment"> * @param &#123;number&#125; j</span></span><br><span class="line"><span class="comment"> * @return &#123;number&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">NumArray.prototype.sumRange = <span class="function"><span class="keyword">function</span>(<span class="params">i, j</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.map.get(j)-<span class="keyword">this</span>.map.get(i<span class="number">-1</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** </span></span><br><span class="line"><span class="comment"> * Your NumArray object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * var obj = new NumArray(nums)</span></span><br><span class="line"><span class="comment"> * var param_1 = obj.sumRange(i,j)</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;区域和检索-数组不可变&quot;&gt;&lt;a href=&quot;#区域和检索-数组不可变&quot; class=&quot;headerlink&quot; title=&quot;区域和检索 - 数组不可变&quot;&gt;&lt;/a&gt;区域和检索 - 数组不可变&lt;/h1&gt;&lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h2&gt;&lt;p&gt;给定一个整数数组  nums，求出数组从索引 i 到 j  (i ≤ j) 范围内元素的总和，包含 i,  j 两点。&lt;/p&gt;
&lt;p&gt;示例：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;给定 nums = [-2, 0, 3, -5, 2, -1]，求和函数为 sumRange()

sumRange(0, 2) -&amp;gt; 1
sumRange(2, 5) -&amp;gt; -1
sumRange(0, 5) -&amp;gt; -3&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;说明:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;你可以假设数组不可变。&lt;/li&gt;
&lt;li&gt;会多次调用 sumRange 方法。
    
    </summary>
    
      <category term="leetcode题解与算法" scheme="http://yoursite.com/categories/leetcode%E9%A2%98%E8%A7%A3%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="哈希表" scheme="http://yoursite.com/tags/%E5%93%88%E5%B8%8C%E8%A1%A8/"/>
    
  </entry>
  
  <entry>
    <title>leetcode-290 单词规律</title>
    <link href="http://yoursite.com/2019/09/12/leetcode-290/"/>
    <id>http://yoursite.com/2019/09/12/leetcode-290/</id>
    <published>2019-09-12T15:02:17.000Z</published>
    <updated>2019-09-12T15:07:13.808Z</updated>
    
    <content type="html"><![CDATA[<h1 id="单词规律"><a href="#单词规律" class="headerlink" title="单词规律"></a>单词规律</h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>给定一种规律 pattern 和一个字符串 str ，判断 str 是否遵循相同的规律。</p><p>这里的 遵循 指完全匹配，例如， pattern 里的每个字母和字符串 str 中的每个非空单词之间存在着双向连接的对应规律。</p><p>示例1:</p><blockquote><p>输入: pattern = “abba”, str = “dog cat cat dog”<br>输出: true</p></blockquote><p>示例 2:</p><blockquote><p>输入:pattern = “abba”, str = “dog cat cat fish”<br>输出: false</p></blockquote><p>示例 3:</p><blockquote><p>输入: pattern = “aaaa”, str = “dog cat cat dog”<br>输出: false</p></blockquote><p>示例 4:</p><blockquote><p>输入: pattern = “abba”, str = “dog dog dog dog”<br>输出: false</p></blockquote><p>说明:<br>你可以假设 pattern 只包含小写字母， str 包含了由单个空格分隔的小写字母。 </p><a id="more"></a><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/word-pattern" target="_blank" rel="noopener">https://leetcode-cn.com/problems/word-pattern</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p><h2 id="核心思路"><a href="#核心思路" class="headerlink" title="核心思路"></a>核心思路</h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>判断两个字符串是否完全匹配，也就是二者中的每个元素要互相对应，因此，我们可以使用哈希表来进行配对与比较</p><h3 id="解题步骤"><a href="#解题步骤" class="headerlink" title="解题步骤"></a>解题步骤</h3><ol><li>将str字符串通过split(‘ ‘)方法转化为字符串数组</li><li>遍历两个字符串，以pattern元素为键名，字符串数组对应元素作为键值，如果遇到冲突那么返回false</li><li>遍历两个字符串，以字符串数组元素为键名，pattern对应元素作为键值，如果遇到冲突那么返回false</li><li>返回true</li></ol><h2 id="Coding实现"><a href="#Coding实现" class="headerlink" title="Coding实现"></a>Coding实现</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @param &#123;string&#125; pattern</span></span><br><span class="line"><span class="comment"> * @param &#123;string&#125; str</span></span><br><span class="line"><span class="comment"> * @return &#123;boolean&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> wordPattern = <span class="function"><span class="keyword">function</span>(<span class="params">pattern, str</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> strArr=str.split(<span class="string">' '</span>);</span><br><span class="line">    <span class="keyword">let</span> map=<span class="keyword">new</span> <span class="built_in">Map</span>();</span><br><span class="line">    <span class="keyword">if</span>(pattern.length!==strArr.length) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">0</span>;i&lt;pattern.length;i++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(!map.has(pattern[i])) &#123;</span><br><span class="line">            map.set(pattern[i],strArr[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span>(map.get(pattern[i])!==strArr[i]) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    map.clear();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">0</span>;i&lt;strArr.length;i++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(!map.has(strArr[i])) &#123;</span><br><span class="line">            map.set(strArr[i],pattern[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span>(map.get(strArr[i])!==pattern[i]) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;单词规律&quot;&gt;&lt;a href=&quot;#单词规律&quot; class=&quot;headerlink&quot; title=&quot;单词规律&quot;&gt;&lt;/a&gt;单词规律&lt;/h1&gt;&lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h2&gt;&lt;p&gt;给定一种规律 pattern 和一个字符串 str ，判断 str 是否遵循相同的规律。&lt;/p&gt;
&lt;p&gt;这里的 遵循 指完全匹配，例如， pattern 里的每个字母和字符串 str 中的每个非空单词之间存在着双向连接的对应规律。&lt;/p&gt;
&lt;p&gt;示例1:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;输入: pattern = “abba”, str = “dog cat cat dog”&lt;br&gt;输出: true&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;示例 2:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;输入:pattern = “abba”, str = “dog cat cat fish”&lt;br&gt;输出: false&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;示例 3:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;输入: pattern = “aaaa”, str = “dog cat cat dog”&lt;br&gt;输出: false&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;示例 4:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;输入: pattern = “abba”, str = “dog dog dog dog”&lt;br&gt;输出: false&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;说明:&lt;br&gt;你可以假设 pattern 只包含小写字母， str 包含了由单个空格分隔的小写字母。 &lt;/p&gt;
    
    </summary>
    
      <category term="leetcode题解与算法" scheme="http://yoursite.com/categories/leetcode%E9%A2%98%E8%A7%A3%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="哈希表" scheme="http://yoursite.com/tags/%E5%93%88%E5%B8%8C%E8%A1%A8/"/>
    
  </entry>
  
  <entry>
    <title>leetcode-278 第一个错误的版本</title>
    <link href="http://yoursite.com/2019/09/11/leetcode-278/"/>
    <id>http://yoursite.com/2019/09/11/leetcode-278/</id>
    <published>2019-09-11T13:00:50.000Z</published>
    <updated>2019-09-11T13:07:27.386Z</updated>
    
    <content type="html"><![CDATA[<h1 id="第一个错误的版本"><a href="#第一个错误的版本" class="headerlink" title="第一个错误的版本"></a>第一个错误的版本</h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>你是产品经理，目前正在带领一个团队开发新的产品。不幸的是，你的产品的最新版本没有通过质量检测。由于每个版本都是基于之前的版本开发的，所以错误的版本之后的所有版本都是错的。</p><p>假设你有 n 个版本 [1, 2, …, n]，你想找出导致之后所有版本出错的第一个错误的版本。</p><p>你可以通过调用 bool isBadVersion(version) 接口来判断版本号 version 是否在单元测试中出错。实现一个函数来查找第一个错误的版本。你应该尽量减少对调用 API 的次数。</p><p>示例:</p><pre><code>给定 n = 5，并且 version = 4 是第一个错误的版本。调用 isBadVersion(3) -&gt; false调用 isBadVersion(5) -&gt; true调用 isBadVersion(4) -&gt; true所以，4 是第一个错误的版本。 </code></pre><a id="more"></a><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/first-bad-version" target="_blank" rel="noopener">https://leetcode-cn.com/problems/first-bad-version</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p><h2 id="核心思路"><a href="#核心思路" class="headerlink" title="核心思路"></a>核心思路</h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>该题考查的是二分查找的思想。不过需要注意边界处理。当isBadVersion(mid)的值为false时说明，第一个坏掉的产品肯定在mid后，因此left=mid+1;注意的是：当isBadVersion(mid)的值为true时，此时的mid值可能就是那个坏掉的第一个产品，因此，right=mid，而不是right=mid-1</p><h3 id="解题步骤"><a href="#解题步骤" class="headerlink" title="解题步骤"></a>解题步骤</h3><ol><li>设立left=1,right=n</li><li>取mid=Math.floor((left+right)/2)</li><li>如果isBadVersion(mid)的值为false时则left=mid+1;</li><li>如果isBadVersion(mid)的值为true时则right=mid</li><li>重复2,3步骤直到left===right</li><li>返回left</li></ol><h2 id="Coding实现"><a href="#Coding实现" class="headerlink" title="Coding实现"></a>Coding实现</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for isBadVersion()</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * @param &#123;integer&#125; version number</span></span><br><span class="line"><span class="comment"> * @return &#123;boolean&#125; whether the version is bad</span></span><br><span class="line"><span class="comment"> * isBadVersion = function(version) &#123;</span></span><br><span class="line"><span class="comment"> *     ...</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @param &#123;function&#125; isBadVersion()</span></span><br><span class="line"><span class="comment"> * @return &#123;function&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> solution = <span class="function"><span class="keyword">function</span>(<span class="params">isBadVersion</span>) </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * @param &#123;integer&#125; n Total versions</span></span><br><span class="line"><span class="comment">     * @return &#123;integer&#125; The first bad version</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">n</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">let</span> left=<span class="number">1</span>,right=n,mid;</span><br><span class="line">        <span class="keyword">while</span>(left&lt;right) &#123;</span><br><span class="line">            mid=<span class="built_in">Math</span>.floor((left+right)/<span class="number">2</span>);</span><br><span class="line">            <span class="keyword">if</span>(isBadVersion(mid)===<span class="literal">false</span>) &#123;</span><br><span class="line">                left=mid+<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                right=mid;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> left;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;第一个错误的版本&quot;&gt;&lt;a href=&quot;#第一个错误的版本&quot; class=&quot;headerlink&quot; title=&quot;第一个错误的版本&quot;&gt;&lt;/a&gt;第一个错误的版本&lt;/h1&gt;&lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h2&gt;&lt;p&gt;你是产品经理，目前正在带领一个团队开发新的产品。不幸的是，你的产品的最新版本没有通过质量检测。由于每个版本都是基于之前的版本开发的，所以错误的版本之后的所有版本都是错的。&lt;/p&gt;
&lt;p&gt;假设你有 n 个版本 [1, 2, …, n]，你想找出导致之后所有版本出错的第一个错误的版本。&lt;/p&gt;
&lt;p&gt;你可以通过调用 bool isBadVersion(version) 接口来判断版本号 version 是否在单元测试中出错。实现一个函数来查找第一个错误的版本。你应该尽量减少对调用 API 的次数。&lt;/p&gt;
&lt;p&gt;示例:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;给定 n = 5，并且 version = 4 是第一个错误的版本。

调用 isBadVersion(3) -&amp;gt; false
调用 isBadVersion(5) -&amp;gt; true
调用 isBadVersion(4) -&amp;gt; true

所以，4 是第一个错误的版本。 &lt;/code&gt;&lt;/pre&gt;
    
    </summary>
    
      <category term="leetcode题解与算法" scheme="http://yoursite.com/categories/leetcode%E9%A2%98%E8%A7%A3%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="二分查找" scheme="http://yoursite.com/tags/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/"/>
    
  </entry>
  
</feed>
