<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Hexo</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2019-09-23T15:01:27.978Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>Angel</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>剑指Offer-求链表中的倒数第k个节点</title>
    <link href="http://yoursite.com/2019/09/23/%E5%89%91%E6%8C%87Offer-01/"/>
    <id>http://yoursite.com/2019/09/23/剑指Offer-01/</id>
    <published>2019-09-23T14:28:29.000Z</published>
    <updated>2019-09-23T15:01:27.978Z</updated>
    
    <content type="html"><![CDATA[<h1 id="求链表中的倒数第k个节点"><a href="#求链表中的倒数第k个节点" class="headerlink" title="求链表中的倒数第k个节点"></a>求链表中的倒数第k个节点</h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>输入：输入一个链表，输出该链表中倒数第k个节点。为了符合大多数人的习惯，本题从1开始计数，即链表的尾结点是倒数第一个节点。例如，一个链表有6个节点，从头结点开始，它们的值一次是1、2、3、4、5、6。这个链表的倒数第三个节点是值为4的节点。</p><p>链表节点定义如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*function ListNode(x)&#123;</span></span><br><span class="line"><span class="comment">    this.val = x;</span></span><br><span class="line"><span class="comment">    this.next = null;</span></span><br><span class="line"><span class="comment">&#125;*/</span></span><br></pre></td></tr></table></figure><h3 id="核心思路"><a href="#核心思路" class="headerlink" title="核心思路"></a>核心思路</h3><p>我们可以设置两个双指针，cur指向头结点，anotherCur指向第k-1个节点。然后两个节点分别往下走，当anotherCur节点指向最后一个节点时，也就意味着cur指向了该链表的倒数第k个节点</p><p>但是，我们需要注意一些输入的问题以及边界情况。</p><ol><li>输入链表head为空时的处理</li><li>k值小于等于0时的处理</li><li>k值大于链表长度时的处理</li></ol><h3 id="coding实现"><a href="#coding实现" class="headerlink" title="coding实现"></a>coding实现</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*function ListNode(x)&#123;</span></span><br><span class="line"><span class="comment">    this.val = x;</span></span><br><span class="line"><span class="comment">    this.next = null;</span></span><br><span class="line"><span class="comment">&#125;*/</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">FindKthToTail</span>(<span class="params">head, k</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(head===<span class="literal">null</span>||k&lt;=<span class="number">0</span>) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">let</span> cur = head;</span><br><span class="line">    <span class="keyword">let</span> anotherCur = head;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">1</span>;i&lt;k;i++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(anotherCur.next) &#123;</span><br><span class="line">            anotherCur = anotherCur.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(anotherCur.next) &#123;</span><br><span class="line">        anotherCur = anotherCur.next;</span><br><span class="line">        cur = cur.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> cur;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    FindKthToTail : FindKthToTail</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="时空复杂度分析"><a href="#时空复杂度分析" class="headerlink" title="时空复杂度分析"></a>时空复杂度分析</h3><ol><li>时间复杂度： O(n)</li><li>空间复杂度：O(1)</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;求链表中的倒数第k个节点&quot;&gt;&lt;a href=&quot;#求链表中的倒数第k个节点&quot; class=&quot;headerlink&quot; title=&quot;求链表中的倒数第k个节点&quot;&gt;&lt;/a&gt;求链表中的倒数第k个节点&lt;/h1&gt;&lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; cla
      
    
    </summary>
    
      <category term="剑指Offer" scheme="http://yoursite.com/categories/%E5%89%91%E6%8C%87Offer/"/>
    
    
  </entry>
  
  <entry>
    <title>webpack打包学习（一）</title>
    <link href="http://yoursite.com/2019/09/23/webpack%E6%89%93%E5%8C%85%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF/"/>
    <id>http://yoursite.com/2019/09/23/webpack打包学习之路/</id>
    <published>2019-09-23T13:44:00.000Z</published>
    <updated>2019-09-23T14:11:38.983Z</updated>
    
    <content type="html"><![CDATA[<h2 id="项目的基本搭建"><a href="#项目的基本搭建" class="headerlink" title="项目的基本搭建"></a>项目的基本搭建</h2><ol><li>新建一个项目并npm init为npm项目</li><li>安装webpck的相关模块，如下<ol><li>webpack </li><li>webpack-cli(webpack的命令行工具)</li><li>style-loader(通过向 DOM 中注入 &lt;style&gt; 标签实现css效果)</li><li>css-loader(解析引入的css文件)</li><li>file-loader(处理文件包括图片文件和字体文件)</li><li>webpack-dev-server(提供一个简单的web服务器)</li></ol></li><li>新建源代码文件夹src目录</li><li>新建输出文件夹dist目录，并将index.html放入改文件夹中</li><li>新建webpack.config.js配置文件</li></ol><h2 id="在src文件夹中"><a href="#在src文件夹中" class="headerlink" title="在src文件夹中"></a>在src文件夹中</h2><p>引入css文件方式如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">'./main.css'</span></span><br></pre></td></tr></table></figure><p>模块css-loader会处理引入的css代码，而style-loader则负责将该css代码注入到Dom中</p><p>引入图片和字体文件方式如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> img <span class="keyword">from</span> <span class="string">'./image.png'</span></span><br></pre></td></tr></table></figure><p>模块file-loader会处理这些图片和字体文件并进行打包</p><h2 id="编写webpack-config-js"><a href="#编写webpack-config-js" class="headerlink" title="编写webpack.config.js"></a>编写webpack.config.js</h2><p>webpack的打包都会按照这个文件的配置进行相应的打包</p><p>以上基本的打包实现如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Node.js的原生模块，用于将相对路径转化为绝对路径</span></span><br><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 利用Common.js模块的导出语法，导出基本的配置</span></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    <span class="comment">// 打包的入口</span></span><br><span class="line">    entry: &#123;</span><br><span class="line">        main: <span class="string">'./src/main.js'</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">// 打包的出口</span></span><br><span class="line">    output: &#123;</span><br><span class="line">        filename: <span class="string">'bundle.js'</span>, <span class="comment">// 打包的出口文件名</span></span><br><span class="line">        path: path.resolve(__dirname,<span class="string">'dist'</span>)<span class="comment">// __dirname是指当前的根目录，然后利用resolve函数就可以将__dirname于dist目录进行拼接然后转化为绝对路径，作为bundle.js文件的生成目录</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">// 用来追踪错误和警告</span></span><br><span class="line">    devtool: <span class="string">"inline-source-map"</span>,</span><br><span class="line">    <span class="comment">// 服务器配置</span></span><br><span class="line">    devServer: &#123;</span><br><span class="line">        <span class="comment">// 告诉服务器，将 dist 目录下的文件，作为可访问文件。</span></span><br><span class="line">        contentBase: <span class="string">'./dist'</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="built_in">module</span>: &#123;\</span><br><span class="line">    <span class="comment">// 创建模块时，匹配请求的规则数组。这些规则能够修改模块的创建方式。这些规则能够对模块(module)应用 loader，或者修改解析器(parser)。</span></span><br><span class="line">        rules: [</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// 正则表达式匹配rule条件</span></span><br><span class="line">                test: <span class="regexp">/.css$/</span>,</span><br><span class="line">                <span class="comment">//在规则条件匹配时使用的loader</span></span><br><span class="line">                use: [<span class="string">"style-loader"</span>,<span class="string">"css-loader"</span>]</span><br><span class="line">            &#125;,</span><br><span class="line">            &#123;</span><br><span class="line">                test: <span class="regexp">/.(jpg|png|jpeg|gif)$/</span>,</span><br><span class="line">                use: [<span class="string">"file-loader"</span>]</span><br><span class="line">            &#125;</span><br><span class="line">        ]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;项目的基本搭建&quot;&gt;&lt;a href=&quot;#项目的基本搭建&quot; class=&quot;headerlink&quot; title=&quot;项目的基本搭建&quot;&gt;&lt;/a&gt;项目的基本搭建&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;新建一个项目并npm init为npm项目&lt;/li&gt;
&lt;li&gt;安装webpck的相关模块
      
    
    </summary>
    
      <category term="webpack" scheme="http://yoursite.com/categories/webpack/"/>
    
    
      <category term="webpack" scheme="http://yoursite.com/tags/webpack/"/>
    
  </entry>
  
  <entry>
    <title>Vue父子组件传值详解</title>
    <link href="http://yoursite.com/2019/09/22/Vue%E7%88%B6%E5%AD%90%E7%BB%84%E4%BB%B6%E4%BC%A0%E5%80%BC%E8%AF%A6%E8%A7%A3/"/>
    <id>http://yoursite.com/2019/09/22/Vue父子组件传值详解/</id>
    <published>2019-09-22T06:24:07.000Z</published>
    <updated>2019-09-23T08:29:36.261Z</updated>
    
    <content type="html"><![CDATA[<h2 id="父组件向子组件传值"><a href="#父组件向子组件传值" class="headerlink" title="父组件向子组件传值"></a>父组件向子组件传值</h2><h3 id="Prop"><a href="#Prop" class="headerlink" title="Prop"></a>Prop</h3><p>Prop 是你可以在组件上注册的一些自定义特性。当一个值传递给一个 prop 特性的时候，它就变成了那个组件实例的一个属性。</p><p>因此，在子组件的方法代码中，我们可以使用this.xxx来访问到它</p><p>利用Prop单向数据流来使得父组件向子组件传值的基本格式如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 父组件 App.vue</span></span><br><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div id=<span class="string">"app"</span>&gt;</span><br><span class="line">    &lt;helloWorld :msg=<span class="string">"msg"</span>&gt;&lt;/helloWorld&gt;</span><br><span class="line">  &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">&lt;/</span>template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line"><span class="keyword">import</span> helloWorld <span class="keyword">from</span> <span class="string">'@/components/HelloWorld.vue'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  data() &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      msg: <span class="number">321</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  components: &#123;</span><br><span class="line">    helloWorld</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 子组件 HelloWorld.vue</span></span><br><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div <span class="class"><span class="keyword">class</span></span>=<span class="string">"hello"</span>&gt;</span><br><span class="line">    &#123;&#123;msg&#125;&#125;</span><br><span class="line">  &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">&lt;/</span>template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  props:[<span class="string">'msg'</span>]</span><br><span class="line">&#125;</span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br></pre></td></tr></table></figure><p>在上述父组件传值的时候是通过v-bind动态赋值的，但是我们也可以传递静态prop</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;hello-world msg=<span class="string">"qwer"</span>&gt;&lt;/hello-world&gt;</span><br></pre></td></tr></table></figure><p>注意的是，除了传入静态字符串之外，在传入静态的数值型，布尔型，对象型数据时我们依旧要使用v-bind来进行数据传输，否则就有可能造成数据传输失败</p><p>例如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">:msg=<span class="string">'11111'</span> <span class="comment">//number</span></span><br><span class="line">:msg=<span class="string">'true'</span> <span class="comment">//bootlean</span></span><br><span class="line">:msg=<span class="string">'()=&gt;&#123;console.log(1)&#125; //function </span></span><br><span class="line"><span class="string">:msg='</span>&#123;<span class="attr">a</span>:<span class="number">1</span>&#125;<span class="string">' //object</span></span><br></pre></td></tr></table></figure><p>因此，我们大可以使用v-bind动态传入，因为使用v-bind我们可以将字符串内的内容视为一个表达式进行计算</p><h3 id="单向数据流"><a href="#单向数据流" class="headerlink" title="单向数据流"></a>单向数据流</h3><p>所有的 prop 都使得其父子 prop 之间形成了一个单向下行绑定：父级 prop 的更新会向下流动到子组件中，但是反过来则不行。这样会防止从子组件意外改变父级组件的状态，从而导致你的应用的数据流向难以理解。</p><p>因此，只要父组件的数据发生了更新，子组件也会获得相应的更新。无论，发生更新的原因是异步操作还是事件操作</p><h3 id="vm-watch"><a href="#vm-watch" class="headerlink" title="vm.$watch"></a>vm.$watch</h3><p>当然，我们可以使用watch方法来监听父组件数据的改变</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在父组件进行异步操作，一开始初值为undefined，经过2000毫秒后变为12345</span></span><br><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div id=<span class="string">"app"</span>&gt;</span><br><span class="line">    &lt;helloWorld :msg=<span class="string">"msg"</span>&gt;&lt;/helloWorld&gt;</span><br><span class="line">  &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">&lt;/</span>template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line"><span class="keyword">import</span> helloWorld <span class="keyword">from</span> <span class="string">'@/components/HelloWorld.vue'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  data() &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      msg: <span class="literal">undefined</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  components: &#123;</span><br><span class="line">    helloWorld</span><br><span class="line">  &#125;,</span><br><span class="line">  created() &#123;</span><br><span class="line">    setTimeout(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">      <span class="keyword">this</span>.msg=<span class="number">12345</span>;</span><br><span class="line">    &#125;,<span class="number">2000</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在子组件中利用watch方法来进行监听父组件的prop值的变化</span></span><br><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div <span class="class"><span class="keyword">class</span></span>=<span class="string">"hello"</span>&gt;</span><br><span class="line">    &#123;&#123;msg&#125;&#125;</span><br><span class="line">  &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">&lt;/</span>template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  props:[<span class="string">'msg'</span>],</span><br><span class="line">  watch: &#123;</span><br><span class="line">    msg(val,oldVal)&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(val,oldVal); <span class="comment">// 12345,undefined </span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br></pre></td></tr></table></figure><h2 id="拦截数据，过滤处理"><a href="#拦截数据，过滤处理" class="headerlink" title="拦截数据，过滤处理"></a>拦截数据，过滤处理</h2><p>有时候，我们相对从父组件传过来的数据进行一些额外操作之后再进行渲染，此时我们可以利用计算属性来实现</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">computed: &#123;</span><br><span class="line">  anotherMsg() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.msg+<span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="子组件向父组件传值"><a href="#子组件向父组件传值" class="headerlink" title="子组件向父组件传值"></a>子组件向父组件传值</h2><h3 id="vm-on与vm-emit"><a href="#vm-on与vm-emit" class="headerlink" title="vm.$on与vm.$emit"></a>vm.$on与vm.$emit</h3><p>vm.$on要与vm.$emit搭配来进行使用</p><p>vue的api文档是这么描述这两个api的</p><h4 id="vm-on-event-callback"><a href="#vm-on-event-callback" class="headerlink" title="vm.$on( event, callback )"></a>vm.$on( event, callback )</h4><p>参数：</p><ol><li>{string | Array<string>} event (数组只在 2.2.0+ 中支持)</string></li><li>{Function} callback<br>用法：</li></ol><p>监听当前实例上的自定义事件。事件可以由vm.$emit触发。回调函数会接收所有传入事件触发函数的额外参数。</p><p>示例：</p><pre><code>vm.$on(&apos;test&apos;, function (msg) {console.log(msg)})vm.$emit(&apos;test&apos;, &apos;hi&apos;)// =&gt; &quot;hi&quot;</code></pre><h4 id="vm-emit-eventName-…args"><a href="#vm-emit-eventName-…args" class="headerlink" title="vm.$emit( eventName, […args] )"></a>vm.$emit( eventName, […args] )</h4><p>参数：</p><p>{string} eventName<br>[…args]</p><p>触发当前实例上的事件。附加参数都会传给监听器回调。</p><p>因此，我们可以在同一个实例上注册on监听事件函数以及emit响应事件函数</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  created() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.msg);</span><br><span class="line">    <span class="keyword">this</span>.$on(<span class="string">'test'</span>,(v)=&gt;&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(v);</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;,</span><br><span class="line">  methods: &#123;</span><br><span class="line">    change() &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">'emit'</span>);</span><br><span class="line">      <span class="keyword">this</span>.$emit(<span class="string">'test'</span>,<span class="number">123456789</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br></pre></td></tr></table></figure><p>我们在created生命周期时注册了一个监听test事件的on函数，在事件change()发生时，我们让test事件通过emit方法也进行发生。从而，监听函数会监听到该事件的发生并进行相应的输出</p><p>但是，虽然事件监听与响应都可以完成，但是这两个方法必须在同一个实例上才可以进行使用。因此，如果要进行子组件将值传递给父组件，我们可以使用v-on与vm.$emit进行搭配使用</p><h3 id="v-on与vm-emit"><a href="#v-on与vm-emit" class="headerlink" title="v-on与vm.$emit"></a>v-on与vm.$emit</h3><p>因为父组件可以在使用子组件的引入模板直接用 v-on 来监听子组件触发的事件。因此，我们可以使用v-on和vm.$emit来使得子组件向父组件传值</p><p>例如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 父组件</span></span><br><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div id=<span class="string">"app"</span>&gt;</span><br><span class="line">  <span class="comment">// 在子组件的引入模板中使用v-on来进行监听子组件中的test事件</span></span><br><span class="line">  <span class="comment">// 注意，@后必须是在子组件中要监听的事件名，而双引号中是父组件对于监听到事件发生后做出的处理函数。对于该例中，也就是test是要监听的事件名，getSonValue是父组件的处理函数</span></span><br><span class="line">    &lt;helloWorld :msg=<span class="string">"msg"</span> @test=<span class="string">'getSonValue'</span>&gt;&lt;/helloWorld&gt;</span><br><span class="line">  &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">&lt;/</span>template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line"><span class="keyword">import</span> helloWorld <span class="keyword">from</span> <span class="string">'@/components/HelloWorld.vue'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  methods: &#123;</span><br><span class="line">    getSonValue(v) &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">'v'</span>,v);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">methods: &#123;</span><br><span class="line">  change() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'emit'</span>);</span><br><span class="line">    <span class="comment">// 发布事件test，并传入参数123456789</span></span><br><span class="line">    <span class="keyword">this</span>.$emit(<span class="string">'test'</span>,<span class="number">123456789</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="同级组件通信"><a href="#同级组件通信" class="headerlink" title="同级组件通信"></a>同级组件通信</h2><p>同级组件通信，也就是意味着某个父组件下有两个不同的子组件，这两个组件之间可以通信</p><h3 id="父组件作为中转站"><a href="#父组件作为中转站" class="headerlink" title="父组件作为中转站"></a>父组件作为中转站</h3><p>一种可行的办法，就是父组件接收其中一个组件传递的值并将该值传递给另外一个子组件</p><p>例如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 父组件</span></span><br><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div id=<span class="string">"app"</span>&gt;</span><br><span class="line">    &lt;component1 @msg=<span class="string">"getMsg"</span>&gt;&lt;/component1&gt;</span><br><span class="line">    &lt;component2 :msg=<span class="string">"msg"</span>&gt;&lt;/component2&gt;</span><br><span class="line">  &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">&lt;/</span>template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line"><span class="keyword">import</span> component1 <span class="keyword">from</span> <span class="string">'@/components/Component1'</span></span><br><span class="line"><span class="keyword">import</span> component2 <span class="keyword">from</span> <span class="string">'@/components/Component2'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  components: &#123;</span><br><span class="line">    component1,</span><br><span class="line">    component2</span><br><span class="line">  &#125;,</span><br><span class="line">  methods: &#123;</span><br><span class="line">    getMsg(v) &#123;</span><br><span class="line">      <span class="keyword">this</span>.msg=v;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  data() &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      msg: <span class="literal">undefined</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 子组件1</span></span><br><span class="line">&lt;template&gt;</span><br><span class="line">    &lt;div id=<span class="string">"component1"</span>&gt;</span><br><span class="line">        &lt;div&gt;</span><br><span class="line">            子组件<span class="number">1</span>的值为：&#123;&#123;msg&#125;&#125;</span><br><span class="line">        &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">        &lt;button @click="sendMsg"&gt;click&lt;/</span>button&gt;</span><br><span class="line">    &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">&lt;/</span>template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">    data() &#123;</span><br><span class="line">        <span class="keyword">return</span> &#123;</span><br><span class="line">            msg: <span class="number">123</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    methods: &#123;</span><br><span class="line">        sendMsg() &#123;</span><br><span class="line">            <span class="keyword">this</span>.$emit(<span class="string">'msg'</span>,<span class="keyword">this</span>.msg);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">    &lt;div id=<span class="string">"component2"</span>&gt;</span><br><span class="line">        子组件<span class="number">2</span>的值为：&#123;&#123;msg&#125;&#125;</span><br><span class="line">    &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">&lt;/</span>template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">    props: [<span class="string">'msg'</span>]</span><br><span class="line">&#125;</span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br></pre></td></tr></table></figure><p>当子组件1点击按钮后，子组件2就可以获得组件1传过来的msg值</p><h3 id="额外实例作为中央事件总线"><a href="#额外实例作为中央事件总线" class="headerlink" title="额外实例作为中央事件总线"></a>额外实例作为中央事件总线</h3><p>因为ES6的模块机制有一个特性</p><blockquote><p>当模块内部发生变化的时候，引入模块的部分同样会发生变化</p></blockquote><p>因此，我们可以创建一个额外的实例,并且在两个子组件中分别绑定vm.$emit方法进行事件发放和vm.$on方法进行事件监听</p><ol><li><p>创建额外实例</p> <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// eventBus.js</span></span><br><span class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">'vue'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">new</span> Vue();</span><br></pre></td></tr></table></figure></li><li><p>在子组件1中引入该实例，并为其绑定分发事件vm.$emit方法</p> <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">    &lt;div id=<span class="string">"component1"</span>&gt;</span><br><span class="line">        &lt;div&gt;</span><br><span class="line">            子组件<span class="number">1</span>的值为：&#123;&#123;msg&#125;&#125;</span><br><span class="line">        &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">        &lt;button @click="sendMsg"&gt;click&lt;/</span>button&gt;</span><br><span class="line">    &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">&lt;/</span>template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line"><span class="keyword">import</span> eventBus <span class="keyword">from</span> <span class="string">'@/components/eventBus.js'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">    data() &#123;</span><br><span class="line">        <span class="keyword">return</span> &#123;</span><br><span class="line">            msg: <span class="number">123</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    methods: &#123;</span><br><span class="line">        sendMsg() &#123;</span><br><span class="line">            <span class="built_in">console</span>.log(eventBus);</span><br><span class="line">            eventBus.$emit(<span class="string">'msg'</span>,<span class="keyword">this</span>.msg);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>在子组件2中引入额外实例并为其绑定监听事件vm.$on方法</p> <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">    &lt;div id=<span class="string">"component2"</span>&gt;</span><br><span class="line">        子组件<span class="number">2</span>的值为：&#123;&#123;msg&#125;&#125;</span><br><span class="line">    &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">&lt;/</span>template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line"><span class="keyword">import</span> eventBus <span class="keyword">from</span> <span class="string">'@/components/eventBus.js'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">    created() &#123;</span><br><span class="line">        eventBus.$on(<span class="string">'msg'</span>,(v)=&gt;&#123;</span><br><span class="line">            <span class="keyword">this</span>.msg=v;</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;,</span><br><span class="line">    data() &#123;</span><br><span class="line">        <span class="keyword">return</span> &#123;</span><br><span class="line">            msg: <span class="literal">undefined</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br></pre></td></tr></table></figure></li></ol><p>经过上述三步后，子组件2在created生命周期时就已经在额外实例上创建了事件监听方法。因此，当子组件1点击按钮之后就会向额外实例分发了一个事件msg;那么，额外实例就会监听到该事件的发生并作出处理函数，这样也就完成了两个同级组件之间的传值</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;父组件向子组件传值&quot;&gt;&lt;a href=&quot;#父组件向子组件传值&quot; class=&quot;headerlink&quot; title=&quot;父组件向子组件传值&quot;&gt;&lt;/a&gt;父组件向子组件传值&lt;/h2&gt;&lt;h3 id=&quot;Prop&quot;&gt;&lt;a href=&quot;#Prop&quot; class=&quot;headerli
      
    
    </summary>
    
      <category term="Vue" scheme="http://yoursite.com/categories/Vue/"/>
    
    
      <category term="Vue" scheme="http://yoursite.com/tags/Vue/"/>
    
  </entry>
  
  <entry>
    <title>nowcoder-2</title>
    <link href="http://yoursite.com/2019/09/19/nowcoder-2/"/>
    <id>http://yoursite.com/2019/09/19/nowcoder-2/</id>
    <published>2019-09-19T12:45:10.000Z</published>
    <updated>2019-09-19T12:53:11.846Z</updated>
    
    <content type="html"><![CDATA[<h1 id="数组的相对排序"><a href="#数组的相对排序" class="headerlink" title="数组的相对排序"></a>数组的相对排序</h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>请实现一个函数，将一个字符串中的每个空格替换成“%20”。例如，当字符串为We Are Happy.则经过替换之后的字符串为We%20Are%20Happy。</p><h2 id="核心思路"><a href="#核心思路" class="headerlink" title="核心思路"></a>核心思路</h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>题意很简单，就是将所有的空格转化为’%20’的格式。因此，我们可以使用replace()方法来进行替换值，当然是使用正则表达式来进行匹配</p><h2 id="Coding实现"><a href="#Coding实现" class="headerlink" title="Coding实现"></a>Coding实现</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">replaceSpace</span>(<span class="params">str</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">let</span> pattern=<span class="regexp">/\s/g</span>;</span><br><span class="line">    <span class="keyword">return</span> str.replace(pattern,<span class="string">'%20'</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    replaceSpace : replaceSpace</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="时空复杂度分析"><a href="#时空复杂度分析" class="headerlink" title="时空复杂度分析"></a>时空复杂度分析</h2><ol><li>时间复杂度：O(1)</li><li>空间复杂度：O(1)</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;数组的相对排序&quot;&gt;&lt;a href=&quot;#数组的相对排序&quot; class=&quot;headerlink&quot; title=&quot;数组的相对排序&quot;&gt;&lt;/a&gt;数组的相对排序&lt;/h1&gt;&lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; titl
      
    
    </summary>
    
      <category term="牛客网算法题刷题记录" scheme="http://yoursite.com/categories/%E7%89%9B%E5%AE%A2%E7%BD%91%E7%AE%97%E6%B3%95%E9%A2%98%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/"/>
    
    
  </entry>
  
  <entry>
    <title>leetcode-367 有效的完全平方数</title>
    <link href="http://yoursite.com/2019/09/18/leetcode-367/"/>
    <id>http://yoursite.com/2019/09/18/leetcode-367/</id>
    <published>2019-09-18T12:50:53.000Z</published>
    <updated>2019-09-18T13:03:51.969Z</updated>
    
    <content type="html"><![CDATA[<h1 id="有效的完全平方数"><a href="#有效的完全平方数" class="headerlink" title="有效的完全平方数"></a>有效的完全平方数</h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>给定一个正整数 num，编写一个函数，如果 num 是一个完全平方数，则返回 True，否则返回 False。</p><p>说明：不要使用任何内置的库函数，如  sqrt。</p><p>示例 1：</p><blockquote><p>输入：16<br>输出：True</p></blockquote><p>示例 2：</p><blockquote><p>输入：14<br>输出：False</p></blockquote><a id="more"></a><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/valid-perfect-square" target="_blank" rel="noopener">https://leetcode-cn.com/problems/valid-perfect-square</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p><h2 id="核心思路"><a href="#核心思路" class="headerlink" title="核心思路"></a>核心思路</h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>我们知道，对于大于等于4的完全平方数，它的平方根会小于或等于它的一半。因此，我们可以在2~n/2之间进行二分查找，来降低时间复杂度</p><h3 id="解题步骤"><a href="#解题步骤" class="headerlink" title="解题步骤"></a>解题步骤</h3><ol><li>如果给定的数为1，返回true</li><li>设定left为2，right为Math.floor(num/2)，mid为Math.floor((left+right)/2)；如果mid*mid===num那么返回true；如果小于，则left=mid+1;<br>否则right=mid-1;</li><li>重复步骤2知道right&gt;left</li><li>如果上述二分过程中没有返回true，那么返回false</li></ol><h2 id="Coding实现"><a href="#Coding实现" class="headerlink" title="Coding实现"></a>Coding实现</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @param &#123;number&#125; num</span></span><br><span class="line"><span class="comment"> * @return &#123;boolean&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> isPerfectSquare = <span class="function"><span class="keyword">function</span>(<span class="params">num</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(num===<span class="number">1</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">let</span> left=<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">let</span> right=<span class="built_in">Math</span>.floor(num/<span class="number">2</span>);</span><br><span class="line">    <span class="keyword">let</span> mid;</span><br><span class="line">    <span class="keyword">while</span>(left&lt;=right) &#123;</span><br><span class="line">        mid=<span class="built_in">Math</span>.floor((left+right)/<span class="number">2</span>);</span><br><span class="line">        <span class="keyword">if</span>(mid*mid===num) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(mid*mid&gt;num) &#123;</span><br><span class="line">            right=mid<span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            left=mid+<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;有效的完全平方数&quot;&gt;&lt;a href=&quot;#有效的完全平方数&quot; class=&quot;headerlink&quot; title=&quot;有效的完全平方数&quot;&gt;&lt;/a&gt;有效的完全平方数&lt;/h1&gt;&lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h2&gt;&lt;p&gt;给定一个正整数 num，编写一个函数，如果 num 是一个完全平方数，则返回 True，否则返回 False。&lt;/p&gt;
&lt;p&gt;说明：不要使用任何内置的库函数，如  sqrt。&lt;/p&gt;
&lt;p&gt;示例 1：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;输入：16&lt;br&gt;输出：True&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;示例 2：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;输入：14&lt;br&gt;输出：False&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="leetcode题解与算法" scheme="http://yoursite.com/categories/leetcode%E9%A2%98%E8%A7%A3%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="二分查找" scheme="http://yoursite.com/tags/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/"/>
    
  </entry>
  
  <entry>
    <title>nowcoder-1 二维数组中的查找</title>
    <link href="http://yoursite.com/2019/09/17/nowcoder-1/"/>
    <id>http://yoursite.com/2019/09/17/nowcoder-1/</id>
    <published>2019-09-17T14:51:49.000Z</published>
    <updated>2019-09-17T15:14:53.238Z</updated>
    
    <content type="html"><![CDATA[<h1 id="数组的相对排序"><a href="#数组的相对排序" class="headerlink" title="数组的相对排序"></a>数组的相对排序</h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>在一个二维数组中（每个一维数组的长度相同），每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。</p><h2 id="核心思路"><a href="#核心思路" class="headerlink" title="核心思路"></a>核心思路</h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><ol><li>最直接的暴力解法<br>遍历二维数组中的每一个元素，返回是否能找到给定的target值</li><li>利用ES6特性，将数组扁平化（但是牛客网并没有很好地支持flat()函数，因此我们可以使用concat()方法来实现扁平化）后使用includes()函数进行查找</li><li>巧妙一点的方法是：由于该二维数组的规律（每一行从左往右递增，每一列从上往下递增），我们可以发现二维数组的左下角总是当前行的最小值，当前列的最大值。因此，当给定值大于当前左下角的数值时，我们就将该数往右移动一位；当给定值小于当前左下角的数值时，我们就将该数往上移动一位。直到找到该值返回true，或者遍历到右上角仍然没有找到返回false</li></ol><h3 id="解题步骤"><a href="#解题步骤" class="headerlink" title="解题步骤"></a>解题步骤</h3><h2 id="Coding实现"><a href="#Coding实现" class="headerlink" title="Coding实现"></a>Coding实现</h2><p>通过concat()扁平化后利用includes()来查找</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Find</span>(<span class="params">target, array</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">let</span> arr=[].concat(...array);</span><br><span class="line">    <span class="keyword">return</span> arr.includes(target);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    Find : Find</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>左下到右上的查找</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Find</span>(<span class="params">target, array</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">let</span> column=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">let</span> row=array.length<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">let</span> num;</span><br><span class="line">    <span class="keyword">while</span>(column&lt;array[<span class="number">0</span>].length&amp;&amp;row&gt;=<span class="number">0</span>)&#123;</span><br><span class="line">        num=array[row][column];</span><br><span class="line">        <span class="keyword">if</span>(target&gt;num) &#123;</span><br><span class="line">            column++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(target&lt;num) &#123;</span><br><span class="line">            row--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    Find : Find</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;数组的相对排序&quot;&gt;&lt;a href=&quot;#数组的相对排序&quot; class=&quot;headerlink&quot; title=&quot;数组的相对排序&quot;&gt;&lt;/a&gt;数组的相对排序&lt;/h1&gt;&lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; titl
      
    
    </summary>
    
      <category term="牛客网算法题刷题记录" scheme="http://yoursite.com/categories/%E7%89%9B%E5%AE%A2%E7%BD%91%E7%AE%97%E6%B3%95%E9%A2%98%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/"/>
    
    
  </entry>
  
  <entry>
    <title>模块化</title>
    <link href="http://yoursite.com/2019/09/16/%E6%A8%A1%E5%9D%97%E5%8C%96/"/>
    <id>http://yoursite.com/2019/09/16/模块化/</id>
    <published>2019-09-16T08:28:58.000Z</published>
    <updated>2019-09-19T12:55:41.944Z</updated>
    
    <content type="html"><![CDATA[<h2 id="模块与脚本的区别"><a href="#模块与脚本的区别" class="headerlink" title="模块与脚本的区别"></a>模块与脚本的区别</h2><p>模块不会将它的顶级变量、函数和类作为全局作用域的全局变量，并且模块顶级作用域的this值为undefined</p><h2 id="为什么要模块化"><a href="#为什么要模块化" class="headerlink" title="为什么要模块化"></a>为什么要模块化</h2><p>模块化可以将一个复杂的功能拆分为几个小功能，并且功能模块之间不会互相影响。这样就可以使得代码低耦合</p><p>另外，因为每个模块声明的变量并不会影响全局作用域，因此就不会有全局变量污染以及命名冲突的问题</p><p>每个模块都是独立的，因此模块具有良好的可复用性</p><h2 id="CommonJs模块化"><a href="#CommonJs模块化" class="headerlink" title="CommonJs模块化"></a>CommonJs模块化</h2><p>Node.js是commonJS规范的主要实践者，它有四个重要的环境变量为模块化的实现提供支持：module、exports、require、global。实际使用时，用module.exports定义当前模块对外输出的接口（不推荐直接用exports），用require加载模块。</p><p>例如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义模块module.js</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> a=<span class="number">1</span>;</span><br><span class="line"><span class="built_in">module</span>.exports.test=<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(a);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义test模块并引入module模块</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> m=<span class="built_in">require</span>(<span class="string">'./test'</span>)</span><br><span class="line"></span><br><span class="line">m.test(); <span class="comment">// 1</span></span><br></pre></td></tr></table></figure><h2 id="Es6模块化"><a href="#Es6模块化" class="headerlink" title="Es6模块化"></a>Es6模块化</h2><h3 id="基本语法"><a href="#基本语法" class="headerlink" title="基本语法"></a>基本语法</h3><h4 id="导出的几种形式"><a href="#导出的几种形式" class="headerlink" title="导出的几种形式"></a>导出的几种形式</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义的同时，导出单个变量、对象、函数或类</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> a=<span class="number">1</span>；</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> b=&#123;<span class="attr">item</span>:<span class="number">1</span>&#125;;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> c=<span class="function"><span class="params">()</span>=&gt;</span><span class="number">1</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="class"><span class="keyword">class</span> <span class="title">C</span></span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(item) &#123;</span><br><span class="line">        <span class="keyword">this</span>.item=item;</span><br><span class="line">    &#125;</span><br><span class="line">    getItem()&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.item;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在定义之后导出单个变量</span></span><br><span class="line"><span class="keyword">const</span> a=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">export</span> a;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在定义之后导出多个变量</span></span><br><span class="line"><span class="keyword">const</span> a=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">const</span> b=<span class="number">2</span>;</span><br><span class="line"><span class="keyword">export</span> &#123;a,b&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 导出时重命名，使用as关键字来指定变量等在模块外应该被称为什么名称,同时需要使用大括号</span></span><br><span class="line"><span class="keyword">const</span> a=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">export</span> &#123;a <span class="keyword">as</span> itemA&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 重命名多个变量</span></span><br><span class="line"><span class="keyword">const</span> a=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">const</span> b=<span class="number">2</span>;</span><br><span class="line"><span class="keyword">export</span> &#123;a <span class="keyword">as</span> itemA,b <span class="keyword">as</span> itemB&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 导出模块的默认值，模块的默认值通过default关键字来指定。一个模块只能导出一个默认值（单个变量，函数，类，对象等）</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">    item:<span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 重新导出一个引入的绑定</span></span><br><span class="line"><span class="keyword">import</span> &#123;a&#125; <span class="keyword">from</span> <span class="string">'./m.js'</span></span><br><span class="line"><span class="keyword">export</span> &#123;a&#125;; <span class="comment">// 导出非默认值绑定</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> &#123;a&#125; <span class="keyword">from</span> <span class="string">'./m.js'</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> a; <span class="comment">// 导出默认值绑定</span></span><br></pre></td></tr></table></figure><h4 id="导入的几种形式"><a href="#导入的几种形式" class="headerlink" title="导入的几种形式"></a>导入的几种形式</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//导入非默认值单个变量</span></span><br><span class="line"><span class="keyword">import</span> &#123;a&#125; <span class="keyword">from</span> <span class="string">'./test.js'</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 导入非默认值多个变量</span></span><br><span class="line"><span class="keyword">import</span> &#123;a,b&#125; <span class="keyword">from</span> <span class="string">'./test.js'</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 导入整个模块</span></span><br><span class="line"><span class="keyword">import</span> * <span class="keyword">from</span> <span class="string">'./test.js'</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 导入默认值时不需要大括号语法</span></span><br><span class="line"><span class="keyword">import</span> a <span class="keyword">from</span> <span class="string">'./test.js'</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 导入默认值和非默认值，注意默认值必须排在非默认值前</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> a=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">const</span> b=<span class="number">2</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> b;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> b,&#123;a&#125; <span class="keyword">from</span> <span class="string">'./test.js'</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 导入非默认值时重命名，导入默认值则无法重命名，因为默认值的导入变量命名本来就是自己定义的</span></span><br><span class="line"><span class="keyword">import</span> &#123;a <span class="keyword">as</span> itemA&#125; <span class="keyword">from</span> <span class="string">'./test.js'</span></span><br></pre></td></tr></table></figure><p>注意：导入非默认值绑定看起来像是解构对象，但事实上它不是</p><h2 id="模块化的一些注意点"><a href="#模块化的一些注意点" class="headerlink" title="模块化的一些注意点"></a>模块化的一些注意点</h2><p>以下是我们需要注意的地方</p><ol><li><p>当从另一个模块中导入一个绑定，该绑定就好像是使用const定义的一样。我们无法对它进行修改和重命名。</p> <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> b,&#123;a <span class="keyword">as</span> itemA&#125; <span class="keyword">from</span> <span class="string">'./test.js'</span></span><br><span class="line">b=<span class="number">1</span>; <span class="comment">// 报错："b" is read-only.</span></span><br><span class="line"><span class="built_in">console</span>.log(b,itemA);</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> b,&#123;a <span class="keyword">as</span> itemA&#125; <span class="keyword">from</span> <span class="string">'./test.js'</span></span><br><span class="line"><span class="keyword">let</span> b=<span class="number">1</span>; <span class="comment">// 报错： Identifier 'b' has already been declared</span></span><br><span class="line"><span class="built_in">console</span>.log(b,itemA);</span><br></pre></td></tr></table></figure></li><li><p>使用import语法时要引入的模块文件必须要加上文件后缀，例如’./test.js’；而node.js则遵循基于文件系统前缀来区分文件和包的惯例。例如，example是一个包，而example.js是一个本地文件</p></li><li><p>为了最好地兼容多个浏览器和Node.js环境，一定要在模块文件名前包含/、./或../来表示要导入的文件</p></li><li><p>模块只会执行一次，无论你多少次导入同一模块。当导入模块的代码执行后，实例化过的模块就会被保存在内存中，只要另一个import语句引用它就可以重复使用</p> <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;a&#125; <span class="keyword">from</span> <span class="string">'./test.js'</span>;  <span class="comment">// 该模块只会执行这一次</span></span><br><span class="line"><span class="keyword">import</span> &#123;b&#125; <span class="keyword">from</span> <span class="string">'./test.js'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123;c&#125; <span class="keyword">from</span> <span class="string">'./test.js'</span>;</span><br></pre></td></tr></table></figure></li><li><p>模块语法只能在当前模块顶部(也就是该模块的最外层执行环境)使用</p></li><li><p>导入模块的标识符只是本地的一个变量名称，并不等于被引入的模块中的同名变量</p></li><li><p>模块只能设置一个默认的导出值</p></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;模块与脚本的区别&quot;&gt;&lt;a href=&quot;#模块与脚本的区别&quot; class=&quot;headerlink&quot; title=&quot;模块与脚本的区别&quot;&gt;&lt;/a&gt;模块与脚本的区别&lt;/h2&gt;&lt;p&gt;模块不会将它的顶级变量、函数和类作为全局作用域的全局变量，并且模块顶级作用域的this值为u
      
    
    </summary>
    
      <category term="ES6" scheme="http://yoursite.com/categories/ES6/"/>
    
    
  </entry>
  
  <entry>
    <title>js事件循环机制 event loop</title>
    <link href="http://yoursite.com/2019/09/13/%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF%E6%9C%BA%E5%88%B6/"/>
    <id>http://yoursite.com/2019/09/13/事件循环机制/</id>
    <published>2019-09-13T12:36:20.000Z</published>
    <updated>2019-09-19T13:18:59.343Z</updated>
    
    <content type="html"><![CDATA[<h2 id="为什么js是单线程的"><a href="#为什么js是单线程的" class="headerlink" title="为什么js是单线程的"></a>为什么js是单线程的</h2><p>众所周知，JavaScript是一门单线程语言。那么，为什么js必须是单线程的呢？</p><p>因为，js主要的宿主环境就是浏览器，并且其一个重要的用途就是来操作Dom。反过来思考，如果js是多线程的，那么就会允许同一时间有多个代码块运行。那么，如果这多个代码块同时操作同一个Dom，比如，一个代码块要修改某dom元素，而另一个代码块又要删除这个元素，那么浏览器该如何处理这个元素。因此，为了避免这种复杂性，js必须是单线程的</p><h2 id="执行栈与任务队列"><a href="#执行栈与任务队列" class="headerlink" title="执行栈与任务队列"></a>执行栈与任务队列</h2><h3 id="什么是执行栈"><a href="#什么是执行栈" class="headerlink" title="什么是执行栈"></a>什么是执行栈</h3><p>执行栈，也就是“调用栈”，是一种拥有 LIFO（后进先出）数据结构的栈，被用来存储代码运行时创建的所有执行上下文（包括全局执行上下文，局部函数执行上下文以及eval函数执行上下文）。</p><h3 id="任务"><a href="#任务" class="headerlink" title="任务"></a>任务</h3><p>众所周知，我们可以将js的任务分为两大类：</p><h4 id="同步任务"><a href="#同步任务" class="headerlink" title="同步任务"></a>同步任务</h4><p>优先级最高，运行时立刻进入主线程运行</p><h4 id="异步任务"><a href="#异步任务" class="headerlink" title="异步任务"></a>异步任务</h4><p>只有当所有同步任务执行完毕后才会去执行异步任务，异步任务的执行过程如下：</p><ol><li>异步任务进入Event Table执行，并且注册回调函数</li><li>当指定的异步任务完成时，Event Table会将这个回调函数移入Event Queue</li><li>主线程内的任务执行完毕为空，会去Event Queue读取对应的函数，进入主线程执行</li><li>上述过程会不断重复，也就是常说的Event Loop(事件循环)</li></ol><p>上述的event queue指的是就是任务队列，任务队列内存放的都是异步任务完成后要执行的函数</p><p>另外，我们需要注意的是，只有异步任务完成之后要执行的回调函数才会被放入任务队列，等待主线程中的所有同步代码被执行完毕之后再执行。</p><p>因此，比如在new Promise过程中不再回调函数内的代码都是同步代码，只有then()和catch()中的回调函数才是异步代码</p><p>例如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve,reject</span>)=&gt;</span>&#123; <span class="comment">// 第一行</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">1</span>);  <span class="comment">// 第二行</span></span><br><span class="line">    resolve(<span class="number">2</span>); <span class="comment">//第三行</span></span><br><span class="line">&#125;).then(<span class="function">(<span class="params">v</span>)=&gt;</span>&#123; <span class="comment">// 第四行</span></span><br><span class="line">    <span class="built_in">console</span>.log(v); <span class="comment">// 第五行</span></span><br><span class="line">&#125;) <span class="comment">// 第六行</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出结果</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">2</span></span><br></pre></td></tr></table></figure><p>其中，第1,2,3,4,6行都是同步代码，只有第5行是异步的代码</p><p>以下是任务执行过程:</p><p><img src="https://user-gold-cdn.xitu.io/2017/11/21/15fdd88994142347?imageView2/0/w/1280/h/960/ignore-error/1" alt></p><h4 id="宏任务与微任务"><a href="#宏任务与微任务" class="headerlink" title="宏任务与微任务"></a>宏任务与微任务</h4><p>任务也可以更加被细分为宏任务与微任务两种，具体如下</p><ol><li>宏任务(macrotask)：<br> script(整体代码)、setTimeout、setInterval、UI 渲染、 I/O、postMessage、 MessageChannel、setImmediate(Node.js 环境)、ajax、外部请求等</li><li>微任务(microtask)：<br> Promise.then/catch、 MutaionObserver、process.nextTick(Node.js环境）</li></ol><p>那么宏任务与微任务的执行顺序是怎么样的呢？</p><p>网络上有两种说法，目前我还没有看到权威文章</p><ol><li><p>如果，我们将整个script(整体代码)也算做是一个宏任务，那么执行顺序会是</p><blockquote><p>宏任务-&gt;所有微任务-&gt;下一个宏任务</p></blockquote></li><li><p>但是如果不是的话，那么就是</p><blockquote><p>所有微任务-&gt;下一个宏任务</p></blockquote></li></ol><p>总之这些并不会影响代码的执行顺序</p><p>例如：</p><p>宏任务定时器与微任务promise</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">setTimeout(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">1</span>)</span><br><span class="line">&#125;,<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve,reject</span>)=&gt;</span>&#123;</span><br><span class="line">    resolve(<span class="number">2</span>);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">3</span>);</span><br><span class="line">&#125;).then(<span class="function"><span class="params">v</span>=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(v);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">4</span>;</span><br><span class="line">&#125;).then(<span class="function"><span class="params">v</span>=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(v);</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">5</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 执行结果</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="number">5</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">4</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 执行过程</span></span><br><span class="line"><span class="number">1.</span> 先进入整体代码script这个宏任务，该任务直接进入主线程，因此要执行掉所有的同步任务</span><br><span class="line"><span class="number">2.</span> 遇到setTimeout这一宏任务，我们将其放入宏任务队列</span><br><span class="line"><span class="number">3.</span> 遇到<span class="built_in">Promise</span>构造函数，立即执行该构造函数，执行<span class="built_in">console</span>.log(<span class="number">3</span>);两个then()方法依次进入微任务队列</span><br><span class="line"><span class="number">4.</span> 执行<span class="built_in">console</span>.log(<span class="number">5</span>);</span><br><span class="line"><span class="number">5.</span> 第一个宏任务执行结束，接下来查看微任务队列是否有要解决的微任务，按照先进先出的原则执行完所有的微任务</span><br><span class="line"><span class="number">6.</span> 到这里，第一轮事件循环结束，进入下一轮事件循环</span><br><span class="line"><span class="number">7.</span> 从宏任务队列中取出下一个宏任务，也就是setTimeout的回调函数，执行它</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>宏任务ajax与微任务promise</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> axios=<span class="built_in">require</span>(<span class="string">'axios'</span>)</span><br><span class="line"></span><br><span class="line">axios.get(<span class="string">'https://www.baidu.com'</span>).then(<span class="function"><span class="params">v</span>=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">1</span>);</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve,reject</span>)=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">2</span>);</span><br><span class="line">    resolve(<span class="number">3</span>);</span><br><span class="line">&#125;).then(<span class="function"><span class="params">v</span>=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(v);</span><br><span class="line">    <span class="keyword">return</span> (<span class="number">4</span>);</span><br><span class="line">&#125;).then(<span class="function"><span class="params">v</span>=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(v);</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">5</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 运行结果</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">5</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="number">4</span></span><br><span class="line"><span class="number">1</span></span><br></pre></td></tr></table></figure><p>最后，来一段超级复杂的代码</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="string">'1'</span>);</span><br><span class="line"></span><br><span class="line">setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'2'</span>);</span><br><span class="line">    process.nextTick(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'3'</span>);</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve</span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'4'</span>);</span><br><span class="line">        resolve();</span><br><span class="line">    &#125;).then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'5'</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;)</span><br><span class="line">process.nextTick(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'6'</span>);</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'7'</span>);</span><br><span class="line">    resolve();</span><br><span class="line">&#125;).then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'8'</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'9'</span>);</span><br><span class="line">    process.nextTick(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'10'</span>);</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve</span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'11'</span>);</span><br><span class="line">        resolve();</span><br><span class="line">    &#125;).then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'12'</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">7</span></span><br><span class="line"><span class="number">6</span></span><br><span class="line"><span class="number">8</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">4</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="number">5</span></span><br><span class="line"><span class="number">9</span></span><br><span class="line"><span class="number">11</span></span><br><span class="line"><span class="number">10</span></span><br><span class="line"><span class="number">12</span></span><br></pre></td></tr></table></figure><h2 id="事件循环"><a href="#事件循环" class="headerlink" title="事件循环"></a>事件循环</h2><ol><li>所有同步任务都在主线程上执行，形成一个执行栈</li><li>主线程之外，还存在一个”消息队列”。只要异步操作执行完成，就到消息队列中排队</li><li>一旦执行栈中的所有同步任务执行完毕，系统就会按次序读取消息队列中的异步任务，于是被读取的异步任务结束等待状态，进入执行栈，开始执行</li><li>主线程不断重复上面的第三步</li></ol><p>由于主线程不断的重复获得消息、执行消息、再取消息、再执行。所以，这种机制被称为事件循环</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;为什么js是单线程的&quot;&gt;&lt;a href=&quot;#为什么js是单线程的&quot; class=&quot;headerlink&quot; title=&quot;为什么js是单线程的&quot;&gt;&lt;/a&gt;为什么js是单线程的&lt;/h2&gt;&lt;p&gt;众所周知，JavaScript是一门单线程语言。那么，为什么js必须是单线程
      
    
    </summary>
    
      <category term="javaScript基础" scheme="http://yoursite.com/categories/javaScript%E5%9F%BA%E7%A1%80/"/>
    
    
  </entry>
  
  <entry>
    <title>leetcode-303 区域和检索 - 数组不可变</title>
    <link href="http://yoursite.com/2019/09/13/leetcode-303/"/>
    <id>http://yoursite.com/2019/09/13/leetcode-303/</id>
    <published>2019-09-13T11:49:46.000Z</published>
    <updated>2019-09-13T11:55:00.064Z</updated>
    
    <content type="html"><![CDATA[<h1 id="区域和检索-数组不可变"><a href="#区域和检索-数组不可变" class="headerlink" title="区域和检索 - 数组不可变"></a>区域和检索 - 数组不可变</h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>给定一个整数数组  nums，求出数组从索引 i 到 j  (i ≤ j) 范围内元素的总和，包含 i,  j 两点。</p><p>示例：</p><pre><code>给定 nums = [-2, 0, 3, -5, 2, -1]，求和函数为 sumRange()sumRange(0, 2) -&gt; 1sumRange(2, 5) -&gt; -1sumRange(0, 5) -&gt; -3</code></pre><p>说明:</p><ol><li>你可以假设数组不可变。</li><li>会多次调用 sumRange 方法。<a id="more"></a>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/range-sum-query-immutable" target="_blank" rel="noopener">https://leetcode-cn.com/problems/range-sum-query-immutable</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</li></ol><h2 id="核心思路"><a href="#核心思路" class="headerlink" title="核心思路"></a>核心思路</h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>求数组中给定范围之间的和，比如说是求i&lt;=j之间范围的和，我们可以使用前j个元素的和减去前i-1个元素的和。</p><p>题目说明会多次调用求和方法，因此，我们可以在构造函数中就将前1个元素的和到第n个元素的和保存在哈希表中</p><h3 id="解题步骤"><a href="#解题步骤" class="headerlink" title="解题步骤"></a>解题步骤</h3><ol><li>遍历数组，以当前元素下标为键名，以从第一个元素到当前元素的和作为键值来建立哈希表</li><li>返回前j个元素的和减去前i-1个元素的和</li></ol><h2 id="Coding实现"><a href="#Coding实现" class="headerlink" title="Coding实现"></a>Coding实现</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @param &#123;number[]&#125; nums</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> NumArray = <span class="function"><span class="keyword">function</span>(<span class="params">nums</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.nums=nums;</span><br><span class="line">    <span class="keyword">let</span> map=<span class="keyword">new</span> <span class="built_in">Map</span>([[<span class="number">-1</span>,<span class="number">0</span>]]),sum=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">0</span>;i&lt;nums.length;i++) &#123;</span><br><span class="line">        sum+=nums[i];</span><br><span class="line">        map.set(i,sum);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">this</span>.map=map;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** </span></span><br><span class="line"><span class="comment"> * @param &#123;number&#125; i </span></span><br><span class="line"><span class="comment"> * @param &#123;number&#125; j</span></span><br><span class="line"><span class="comment"> * @return &#123;number&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">NumArray.prototype.sumRange = <span class="function"><span class="keyword">function</span>(<span class="params">i, j</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.map.get(j)-<span class="keyword">this</span>.map.get(i<span class="number">-1</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** </span></span><br><span class="line"><span class="comment"> * Your NumArray object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * var obj = new NumArray(nums)</span></span><br><span class="line"><span class="comment"> * var param_1 = obj.sumRange(i,j)</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;区域和检索-数组不可变&quot;&gt;&lt;a href=&quot;#区域和检索-数组不可变&quot; class=&quot;headerlink&quot; title=&quot;区域和检索 - 数组不可变&quot;&gt;&lt;/a&gt;区域和检索 - 数组不可变&lt;/h1&gt;&lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h2&gt;&lt;p&gt;给定一个整数数组  nums，求出数组从索引 i 到 j  (i ≤ j) 范围内元素的总和，包含 i,  j 两点。&lt;/p&gt;
&lt;p&gt;示例：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;给定 nums = [-2, 0, 3, -5, 2, -1]，求和函数为 sumRange()

sumRange(0, 2) -&amp;gt; 1
sumRange(2, 5) -&amp;gt; -1
sumRange(0, 5) -&amp;gt; -3&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;说明:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;你可以假设数组不可变。&lt;/li&gt;
&lt;li&gt;会多次调用 sumRange 方法。
    
    </summary>
    
      <category term="leetcode题解与算法" scheme="http://yoursite.com/categories/leetcode%E9%A2%98%E8%A7%A3%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="哈希表" scheme="http://yoursite.com/tags/%E5%93%88%E5%B8%8C%E8%A1%A8/"/>
    
  </entry>
  
  <entry>
    <title>leetcode-290 单词规律</title>
    <link href="http://yoursite.com/2019/09/12/leetcode-290/"/>
    <id>http://yoursite.com/2019/09/12/leetcode-290/</id>
    <published>2019-09-12T15:02:17.000Z</published>
    <updated>2019-09-12T15:07:13.808Z</updated>
    
    <content type="html"><![CDATA[<h1 id="单词规律"><a href="#单词规律" class="headerlink" title="单词规律"></a>单词规律</h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>给定一种规律 pattern 和一个字符串 str ，判断 str 是否遵循相同的规律。</p><p>这里的 遵循 指完全匹配，例如， pattern 里的每个字母和字符串 str 中的每个非空单词之间存在着双向连接的对应规律。</p><p>示例1:</p><blockquote><p>输入: pattern = “abba”, str = “dog cat cat dog”<br>输出: true</p></blockquote><p>示例 2:</p><blockquote><p>输入:pattern = “abba”, str = “dog cat cat fish”<br>输出: false</p></blockquote><p>示例 3:</p><blockquote><p>输入: pattern = “aaaa”, str = “dog cat cat dog”<br>输出: false</p></blockquote><p>示例 4:</p><blockquote><p>输入: pattern = “abba”, str = “dog dog dog dog”<br>输出: false</p></blockquote><p>说明:<br>你可以假设 pattern 只包含小写字母， str 包含了由单个空格分隔的小写字母。 </p><a id="more"></a><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/word-pattern" target="_blank" rel="noopener">https://leetcode-cn.com/problems/word-pattern</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p><h2 id="核心思路"><a href="#核心思路" class="headerlink" title="核心思路"></a>核心思路</h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>判断两个字符串是否完全匹配，也就是二者中的每个元素要互相对应，因此，我们可以使用哈希表来进行配对与比较</p><h3 id="解题步骤"><a href="#解题步骤" class="headerlink" title="解题步骤"></a>解题步骤</h3><ol><li>将str字符串通过split(‘ ‘)方法转化为字符串数组</li><li>遍历两个字符串，以pattern元素为键名，字符串数组对应元素作为键值，如果遇到冲突那么返回false</li><li>遍历两个字符串，以字符串数组元素为键名，pattern对应元素作为键值，如果遇到冲突那么返回false</li><li>返回true</li></ol><h2 id="Coding实现"><a href="#Coding实现" class="headerlink" title="Coding实现"></a>Coding实现</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @param &#123;string&#125; pattern</span></span><br><span class="line"><span class="comment"> * @param &#123;string&#125; str</span></span><br><span class="line"><span class="comment"> * @return &#123;boolean&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> wordPattern = <span class="function"><span class="keyword">function</span>(<span class="params">pattern, str</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> strArr=str.split(<span class="string">' '</span>);</span><br><span class="line">    <span class="keyword">let</span> map=<span class="keyword">new</span> <span class="built_in">Map</span>();</span><br><span class="line">    <span class="keyword">if</span>(pattern.length!==strArr.length) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">0</span>;i&lt;pattern.length;i++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(!map.has(pattern[i])) &#123;</span><br><span class="line">            map.set(pattern[i],strArr[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span>(map.get(pattern[i])!==strArr[i]) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    map.clear();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">0</span>;i&lt;strArr.length;i++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(!map.has(strArr[i])) &#123;</span><br><span class="line">            map.set(strArr[i],pattern[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span>(map.get(strArr[i])!==pattern[i]) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;单词规律&quot;&gt;&lt;a href=&quot;#单词规律&quot; class=&quot;headerlink&quot; title=&quot;单词规律&quot;&gt;&lt;/a&gt;单词规律&lt;/h1&gt;&lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h2&gt;&lt;p&gt;给定一种规律 pattern 和一个字符串 str ，判断 str 是否遵循相同的规律。&lt;/p&gt;
&lt;p&gt;这里的 遵循 指完全匹配，例如， pattern 里的每个字母和字符串 str 中的每个非空单词之间存在着双向连接的对应规律。&lt;/p&gt;
&lt;p&gt;示例1:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;输入: pattern = “abba”, str = “dog cat cat dog”&lt;br&gt;输出: true&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;示例 2:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;输入:pattern = “abba”, str = “dog cat cat fish”&lt;br&gt;输出: false&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;示例 3:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;输入: pattern = “aaaa”, str = “dog cat cat dog”&lt;br&gt;输出: false&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;示例 4:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;输入: pattern = “abba”, str = “dog dog dog dog”&lt;br&gt;输出: false&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;说明:&lt;br&gt;你可以假设 pattern 只包含小写字母， str 包含了由单个空格分隔的小写字母。 &lt;/p&gt;
    
    </summary>
    
      <category term="leetcode题解与算法" scheme="http://yoursite.com/categories/leetcode%E9%A2%98%E8%A7%A3%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="哈希表" scheme="http://yoursite.com/tags/%E5%93%88%E5%B8%8C%E8%A1%A8/"/>
    
  </entry>
  
  <entry>
    <title>leetcode-278 第一个错误的版本</title>
    <link href="http://yoursite.com/2019/09/11/leetcode-278/"/>
    <id>http://yoursite.com/2019/09/11/leetcode-278/</id>
    <published>2019-09-11T13:00:50.000Z</published>
    <updated>2019-09-11T13:07:27.386Z</updated>
    
    <content type="html"><![CDATA[<h1 id="第一个错误的版本"><a href="#第一个错误的版本" class="headerlink" title="第一个错误的版本"></a>第一个错误的版本</h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>你是产品经理，目前正在带领一个团队开发新的产品。不幸的是，你的产品的最新版本没有通过质量检测。由于每个版本都是基于之前的版本开发的，所以错误的版本之后的所有版本都是错的。</p><p>假设你有 n 个版本 [1, 2, …, n]，你想找出导致之后所有版本出错的第一个错误的版本。</p><p>你可以通过调用 bool isBadVersion(version) 接口来判断版本号 version 是否在单元测试中出错。实现一个函数来查找第一个错误的版本。你应该尽量减少对调用 API 的次数。</p><p>示例:</p><pre><code>给定 n = 5，并且 version = 4 是第一个错误的版本。调用 isBadVersion(3) -&gt; false调用 isBadVersion(5) -&gt; true调用 isBadVersion(4) -&gt; true所以，4 是第一个错误的版本。 </code></pre><a id="more"></a><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/first-bad-version" target="_blank" rel="noopener">https://leetcode-cn.com/problems/first-bad-version</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p><h2 id="核心思路"><a href="#核心思路" class="headerlink" title="核心思路"></a>核心思路</h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>该题考查的是二分查找的思想。不过需要注意边界处理。当isBadVersion(mid)的值为false时说明，第一个坏掉的产品肯定在mid后，因此left=mid+1;注意的是：当isBadVersion(mid)的值为true时，此时的mid值可能就是那个坏掉的第一个产品，因此，right=mid，而不是right=mid-1</p><h3 id="解题步骤"><a href="#解题步骤" class="headerlink" title="解题步骤"></a>解题步骤</h3><ol><li>设立left=1,right=n</li><li>取mid=Math.floor((left+right)/2)</li><li>如果isBadVersion(mid)的值为false时则left=mid+1;</li><li>如果isBadVersion(mid)的值为true时则right=mid</li><li>重复2,3步骤直到left===right</li><li>返回left</li></ol><h2 id="Coding实现"><a href="#Coding实现" class="headerlink" title="Coding实现"></a>Coding实现</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for isBadVersion()</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * @param &#123;integer&#125; version number</span></span><br><span class="line"><span class="comment"> * @return &#123;boolean&#125; whether the version is bad</span></span><br><span class="line"><span class="comment"> * isBadVersion = function(version) &#123;</span></span><br><span class="line"><span class="comment"> *     ...</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @param &#123;function&#125; isBadVersion()</span></span><br><span class="line"><span class="comment"> * @return &#123;function&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> solution = <span class="function"><span class="keyword">function</span>(<span class="params">isBadVersion</span>) </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * @param &#123;integer&#125; n Total versions</span></span><br><span class="line"><span class="comment">     * @return &#123;integer&#125; The first bad version</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">n</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">let</span> left=<span class="number">1</span>,right=n,mid;</span><br><span class="line">        <span class="keyword">while</span>(left&lt;right) &#123;</span><br><span class="line">            mid=<span class="built_in">Math</span>.floor((left+right)/<span class="number">2</span>);</span><br><span class="line">            <span class="keyword">if</span>(isBadVersion(mid)===<span class="literal">false</span>) &#123;</span><br><span class="line">                left=mid+<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                right=mid;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> left;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;第一个错误的版本&quot;&gt;&lt;a href=&quot;#第一个错误的版本&quot; class=&quot;headerlink&quot; title=&quot;第一个错误的版本&quot;&gt;&lt;/a&gt;第一个错误的版本&lt;/h1&gt;&lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h2&gt;&lt;p&gt;你是产品经理，目前正在带领一个团队开发新的产品。不幸的是，你的产品的最新版本没有通过质量检测。由于每个版本都是基于之前的版本开发的，所以错误的版本之后的所有版本都是错的。&lt;/p&gt;
&lt;p&gt;假设你有 n 个版本 [1, 2, …, n]，你想找出导致之后所有版本出错的第一个错误的版本。&lt;/p&gt;
&lt;p&gt;你可以通过调用 bool isBadVersion(version) 接口来判断版本号 version 是否在单元测试中出错。实现一个函数来查找第一个错误的版本。你应该尽量减少对调用 API 的次数。&lt;/p&gt;
&lt;p&gt;示例:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;给定 n = 5，并且 version = 4 是第一个错误的版本。

调用 isBadVersion(3) -&amp;gt; false
调用 isBadVersion(5) -&amp;gt; true
调用 isBadVersion(4) -&amp;gt; true

所以，4 是第一个错误的版本。 &lt;/code&gt;&lt;/pre&gt;
    
    </summary>
    
      <category term="leetcode题解与算法" scheme="http://yoursite.com/categories/leetcode%E9%A2%98%E8%A7%A3%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="二分查找" scheme="http://yoursite.com/tags/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/"/>
    
  </entry>
  
  <entry>
    <title>mpvue踩坑记</title>
    <link href="http://yoursite.com/2019/09/11/mpvue%E8%B8%A9%E5%9D%91%E8%AE%B0/"/>
    <id>http://yoursite.com/2019/09/11/mpvue踩坑记/</id>
    <published>2019-09-11T08:15:57.000Z</published>
    <updated>2019-09-11T10:13:21.723Z</updated>
    
    <content type="html"><![CDATA[<h2 id="页面跳转"><a href="#页面跳转" class="headerlink" title="页面跳转"></a>页面跳转</h2><ol><li>微信官方接口</li><li>mpvue接口</li></ol><h2 id="组件传值"><a href="#组件传值" class="headerlink" title="组件传值"></a>组件传值</h2><p>当将其他子组件引入到某个父组件中的时候，那么就需要组件之间进行传值，否则父组件无法获得子组件定义的值</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;页面跳转&quot;&gt;&lt;a href=&quot;#页面跳转&quot; class=&quot;headerlink&quot; title=&quot;页面跳转&quot;&gt;&lt;/a&gt;页面跳转&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;微信官方接口&lt;/li&gt;
&lt;li&gt;mpvue接口&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&quot;组件传值&quot;&gt;&lt;a href
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Promise与异步编程</title>
    <link href="http://yoursite.com/2019/09/10/Promise%E4%B8%8E%E5%BC%82%E6%AD%A5%E7%BC%96%E7%A8%8B/"/>
    <id>http://yoursite.com/2019/09/10/Promise与异步编程/</id>
    <published>2019-09-10T05:49:09.000Z</published>
    <updated>2019-09-19T12:53:42.181Z</updated>
    
    <content type="html"><![CDATA[<h2 id="什么是异步编程"><a href="#什么是异步编程" class="headerlink" title="什么是异步编程"></a>什么是异步编程</h2><p>异步编程是什么？为什么需要异步编程；这都要从同步说起</p><p>因为JavaScript语言是一门单线程语言。我们只能在一个线程上运行任务，该线程被称之为主线程。就像下面的例子一样，代码是按照顺序执行的</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span> <span class="title">getA</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    a=<span class="number">1</span>;</span><br><span class="line">&#125;)()</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(a); <span class="comment">// 1</span></span><br></pre></td></tr></table></figure><p>显然的是，以上会先执行getA函数并设置全局变量a=1，然后就会输出a=1;</p><p>但是，我们有没有想过一个问题，如果a的值不是我们自己先行设置的，而是向某服务器请求某资源后再赋值的呢？就像下面这样：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 引入axios</span></span><br><span class="line"><span class="keyword">const</span> axios=<span class="built_in">require</span>(<span class="string">"axios"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 声明变量a</span></span><br><span class="line"><span class="keyword">let</span> a;</span><br><span class="line"></span><br><span class="line">(<span class="function"><span class="keyword">function</span> <span class="title">getA</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    axios.get(<span class="string">'http://www.baidu.com'</span>).then(<span class="function">(<span class="params">content</span>)=&gt;</span>&#123;</span><br><span class="line">        a=<span class="number">1</span>;</span><br><span class="line">    &#125;).catch(<span class="function">(<span class="params">err</span>)=&gt;</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(err);</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;)()</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(a); <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure><p>我们会发现，这时候输出并不是1，而是undefined。这是为什么呢？难道代码不是顺序执行的吗？我们尝试着分析一下以上代码，我们首先声明了变量a但未定义，之后我们进入了getA()函数，在该函数中我们利用了axios工具去请求百度站点的信息。到这里，都没有任何问题。但是，去请求资源，我们都知道网络情况是不确定的，我们不知道这一过程会花费多少时间，因此我们会将该异步任务放入另一个任务队列中，当该任务完成后（也就是请求成功或请求失败）再放入主线程队列去执行相应的函数。但是，主线程也是按照队列的顺序依次来执行的，因此只有当主线程内的所有任务执行完毕后我们才能执行异步任务返回的函数代码。</p><p>getA()函数与console.log(a)都是主线程内的任务，因此，执行顺序就会是：</p><blockquote><p>getA() -&gt; console.log(a) -&gt; 异步任务完成后要执行的操作</p></blockquote><p>这就是异步编程，我们的程序中可能会有一些要造成阻塞的代码（请求外部资源之类），如果是同步的话，那么在请求完成之前我们都无法继续执行下面的程序，但是如果异步编程。将异步任务放入一个异步任务队列，等该异步任务完成后再将其放入主线程任务队列，这样的话，在请求资源的过程中，我们仍旧可以运行后面的程序</p><h2 id="异步编程具有的几种形式"><a href="#异步编程具有的几种形式" class="headerlink" title="异步编程具有的几种形式"></a>异步编程具有的几种形式</h2><h3 id="事件监听"><a href="#事件监听" class="headerlink" title="事件监听"></a>事件监听</h3><p>在进行事件操作的时候，例如用户点击按钮就会触发一个click事件。当点击按钮之后，onclick事件所要执行的任务就会放入异步任务队列中，只有当主线程内的所有任务完成后它才会被执行</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">let</span> button=<span class="built_in">document</span>.getElementById(<span class="string">'btn'</span>);</span><br><span class="line">button.onclick=<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'Button is clicked'</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(a); </span><br><span class="line"></span><br><span class="line"><span class="comment">// 执行结果</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line">Button is clicked</span><br></pre></td></tr></table></figure><p>click单击事件一开始就会被注册，但是只有被监听到click事件发生后才会执行click需要响应的操作</p><h3 id="回调模式"><a href="#回调模式" class="headerlink" title="回调模式"></a>回调模式</h3><p>什么是回调函数？</p><p>一个回调函数，也被称为高阶函数，是一个被作为参数传递给另一个函数的函数，回调函数在另外一个函数中被调用。一个回调函数本质上是一种编程模式（为一个常见问题创建的解决方案），因此，使用回调函数也叫做回调模式。</p><p>例如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">func</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'回调函数'</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">(<span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params">a,func</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(a); <span class="comment">// 1</span></span><br><span class="line">    func(); <span class="comment">// '回调函数'</span></span><br><span class="line">&#125;)(<span class="number">1</span>,func)</span><br></pre></td></tr></table></figure><p>func函数被作为参数传递给test函数并被其调用，那么func函数就被称之为回调函数</p><p>在Node.js中有大量的异步代码，因此，会大量使用回调函数来优化异步编程</p><p>例如，下面的读取文件操作</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> fs=<span class="built_in">require</span>(<span class="string">'fs'</span>);</span><br><span class="line"></span><br><span class="line">fs.readfile(<span class="string">'example.txt'</span>,<span class="function"><span class="keyword">function</span>(<span class="params">err,contents</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(err) &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(err);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="built_in">console</span>.log(contents);</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 执行结果</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line">example.txt内的内容或者是报错内容</span><br></pre></td></tr></table></figure><p>上述代码在执行readFile()函数后，发现这是一个异步任务，那么就将该异步任务放入异步任务队列，等到执行完毕后再放入到主线程任务队列等待执行。</p><p>readFile()函数的功能：</p><p>readFile()函数执行，然后就去读取给定的文件，读取结束后会执行回调函数。如果出现错误，就会将错误对象赋值给回调函数中的err参数；如果一切正常，文件内容就会字符串的形式赋值给contents参数</p><p>可能有些人会不理解为什么在一个函数a中将另一个函数b作为参数，这个函数b会被执行。因为，这个readFile()函数是Node.js中的一个api</p><p>接口大致意思可能如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">readFile</span>(<span class="params">fileName,func</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 读取fileName文件</span></span><br><span class="line">    <span class="keyword">if</span>(success) &#123;</span><br><span class="line">        contents=<span class="string">'文件内容'</span>;</span><br><span class="line">        err=<span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> err=<span class="string">'失败原因'</span>;</span><br><span class="line">    func(err,contents);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="事件发布与订阅"><a href="#事件发布与订阅" class="headerlink" title="事件发布与订阅"></a>事件发布与订阅</h3><h3 id="Promise"><a href="#Promise" class="headerlink" title="Promise"></a>Promise</h3><p>Promise 对象是一个代理对象（代理一个值），被代理的值在Promise对象创建时可能是未知的。它允许你为异步操作的成功和失败分别绑定相应的处理方法。 这让异步方法可以像同步方法那样返回值，但并不是立即返回最终执行结果，而是一个能代表未来出现的结果的promise对象</p><h4 id="Promise的生命周期"><a href="#Promise的生命周期" class="headerlink" title="Promise的生命周期"></a>Promise的生命周期</h4><p>promise对象的生命周期包括以下三种：</p><ol><li>进行中 pending</li><li>已完成 fulfilled/resolved</li><li>被拒绝(未能成功完成) rejected</li></ol><h4 id="Promise构造函数创建promise"><a href="#Promise构造函数创建promise" class="headerlink" title="Promise构造函数创建promise"></a>Promise构造函数创建promise</h4><p>用Promise构造函数可以创建一个promise，构造函数只接受一个参数，也就是包含初始化Promise代码的执行器函数。该执行器函数接受两个参数，分别是resolve函数和rejected函数。执行器成功完成时调用resolve函数，失败时调用reject函数</p><p>例如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> fs=<span class="built_in">require</span>(<span class="string">'fs'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 异步读取文件内容</span></span><br><span class="line"><span class="keyword">let</span> promise=<span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve,reject</span>)=&gt;</span>&#123;</span><br><span class="line">    fs.readFile(<span class="string">'test.js'</span>,<span class="string">'utf8'</span>,(err,contents)=&gt;&#123;</span><br><span class="line">        <span class="keyword">if</span>(err) &#123;</span><br><span class="line">            reject(err);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            resolve(contents);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">promise.then(<span class="function"><span class="params">contents</span>=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(contents); <span class="comment">// test</span></span><br><span class="line">&#125;,err=&gt;&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(err);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>通过Promise构造函数创建了一个promise对象，之后便会执行执行器函数，同时异步操作开始。当异步操作结束后，会调用异步操作中的回调函数，如果操作成功那么将成功获得的数据作为参数传递给resolved函数，如果失败那么将失败信息传递给rejected函数。</p><p>promise对象调用then()方法和catch()方法时，会创建一个新任务放入一个任务队列中，只有监听到promise被解决后才会被执行</p><h4 id="then-与catch"><a href="#then-与catch" class="headerlink" title="then()与catch()"></a>then()与catch()</h4><p>then() 方法返回一个  Promise 。它最多需要有两个参数：Promise 的成功和失败情况的回调函数。</p><p>catch() 方法返回一个  Promise 。它接受一个参数：失败情况的回调函数。</p><p>then()方法和catch()方法一起使用才更加方便和清晰地处理异步操作结果</p><p>例如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> fs=<span class="built_in">require</span>(<span class="string">'fs'</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> promise=<span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve,reject</span>)=&gt;</span>&#123;</span><br><span class="line">    fs.readFile(<span class="string">'test.js'</span>,<span class="string">'utf8'</span>,(err,contents)=&gt;&#123;</span><br><span class="line">        <span class="keyword">if</span>(err) &#123;</span><br><span class="line">            reject(err);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            resolve(contents);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">promise.then(<span class="function"><span class="params">contents</span>=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(contents);</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">promise.catch(<span class="function"><span class="params">err</span>=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(err);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h4 id="Promise-resolve-和Promise-reject-创建已处理的promise"><a href="#Promise-resolve-和Promise-reject-创建已处理的promise" class="headerlink" title="Promise.resolve()和Promise.reject()创建已处理的promise"></a>Promise.resolve()和Promise.reject()创建已处理的promise</h4><p>我们可以使用Promise.resolve()来创建已处理的成功完成的promise</p><blockquote><p>Promise.resolve(value)方法返回一个以给定值解析后的Promise 对象。如果该值为promise，返回这个promise；如果这个值是thenable（即带有”then” 方法)），返回的promise会“跟随”这个thenable的对象，采用它的最终状态；否则返回的promise将以此值完成。此函数将类promise对象的多层嵌套展平。</p></blockquote><p>我们也可以使用Promise.reject()来创建已处理的拒绝态的promise</p><p>例如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 返回给定的promise对象</span></span><br><span class="line"><span class="keyword">let</span> promise=<span class="built_in">Promise</span>.resolve(<span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve,reject</span>)=&gt;</span>&#123;</span><br><span class="line">    resolve(<span class="number">1</span>);</span><br><span class="line">&#125;))</span><br><span class="line"></span><br><span class="line">promise.then(<span class="function"><span class="params">v</span>=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(v); <span class="comment">// 1</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h4 id="执行器错误"><a href="#执行器错误" class="headerlink" title="执行器错误"></a>执行器错误</h4><p>如果执行器函数内部发生错误，那么promise的拒绝处理程序就会被调用。</p><p>例如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> promise=<span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve,reject</span>)=&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'err'</span>);</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">promise.catch(<span class="function"><span class="params">err</span>=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(err); <span class="comment">// 'err'</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>因为，每个执行器函数中都隐含着一个try…catch块，所以所有的错误都会被捕获并传入拒绝处理程序,以上示例相当于：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> promise=<span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve,reject</span>)=&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'err'</span>); </span><br><span class="line">    &#125; <span class="keyword">catch</span> (err) &#123;</span><br><span class="line">        reject(err);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">promise.catch(<span class="function"><span class="params">err</span>=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(err); <span class="comment">// 'err'</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h4 id="串联Promise"><a href="#串联Promise" class="headerlink" title="串联Promise"></a>串联Promise</h4><p>前面提到过每次调用then()方法或者catch()方法都会创建并返回了另一个Promise，只有当第一个promise完成或被拒绝后才会去解决之后的promise</p><p>调用then()方法返回的promise按照以下规则被创建：<br>当一个Promise完成（fulfilled）或者失败（rejected），返回函数将被异步调用（由当前的线程循环来调度完成）。具体的返回值依据以下规则返回：</p><ol><li>如果then中的回调函数返回一个值，那么then返回的Promise将会成为接受状态，并且将返回的值作为接受状态的回调函数的参数值。</li><li>如果then中的回调函数没有返回值，那么then返回的Promise将会成为接受状态，并且该接受状态的回调函数的参数值为 undefined。</li><li>如果then中的回调函数抛出一个错误，那么then返回的Promise将会成为拒绝状态，并且将抛出的错误作为拒绝状态的回调函数的参数值。</li><li>如果then中的回调函数返回一个已经是接受状态的Promise，那么then返回的Promise也会成为接受状态，并且将那个Promise的接受状态的回调函数的参数值作为该被返回的Promise的接受状态回调函数的参数值。</li><li>如果then中的回调函数返回一个已经是拒绝状态的Promise，那么then返回的Promise也会成为拒绝状态，并且将那个Promise的拒绝状态的回调函数的参数值作为该被返回的Promise的拒绝状态回调函数的参数值。</li><li>如果then中的回调函数返回一个未定状态（pending）的Promise，那么then返回Promise的状态也是未定的，并且它的终态与那个Promise的终态相同；同时，它变为终态时调用的回调函数参数与那个Promise变为终态时的回调函数的参数是相同的。</li></ol><p>调用catch()方法返回的是一个带有错误原因的promise</p><p>例如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建一个已处理的promise</span></span><br><span class="line"><span class="keyword">let</span> promise=<span class="built_in">Promise</span>.resolve(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 不返回任何值</span></span><br><span class="line">promise.then(<span class="function"><span class="params">v</span>=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(v); <span class="comment">// 1</span></span><br><span class="line">&#125;).then(<span class="function"><span class="params">v</span>=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(v); <span class="comment">// undefined</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回一个值</span></span><br><span class="line">promise.then(<span class="function"><span class="params">v</span>=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(v); <span class="comment">// 1</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">&#125;).then(<span class="function"><span class="params">v</span>=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(v); <span class="comment">// 2</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 抛出错误在promise链的下一个拒绝处理程序中捕获</span></span><br><span class="line">promise.then(<span class="function"><span class="params">v</span>=&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'err'</span>);</span><br><span class="line">&#125;).catch(<span class="function"><span class="params">v</span>=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(v); <span class="comment">// err</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>就像上述的第三个例子，在已完成处理程序中抛出了错误，我们可以使用then…catch来捕获错误。因此，在实际编程时，为了防止某些未知的错误而造成程序崩溃，我们要使用then…catch来捕获未知错误</p><h5 id="promise链中传递数据"><a href="#promise链中传递数据" class="headerlink" title="promise链中传递数据"></a>promise链中传递数据</h5><p>在上面提过，在调用then()方法和catch()方法的处理程序中，如果return某些值，是会作为返回的promise对象的执行函数的参数值，因此，我们可以在promise链中往下游传递数据</p><p>例如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> promise=<span class="built_in">Promise</span>.resolve(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">promise.then(<span class="function"><span class="params">v</span>=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(v); <span class="comment">// 1</span></span><br><span class="line">    <span class="keyword">return</span> v+<span class="number">1</span>; <span class="comment">// 返回一个值</span></span><br><span class="line">&#125;).then(<span class="function"><span class="params">v</span>=&gt;</span>&#123; <span class="comment">// 接收到这个值</span></span><br><span class="line">    <span class="built_in">console</span>.log(v); <span class="comment">// 2</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h4 id="在处理程序中return一个promise"><a href="#在处理程序中return一个promise" class="headerlink" title="在处理程序中return一个promise"></a>在处理程序中return一个promise</h4><ol><li>如果then中的回调函数返回一个已经是接受状态的Promise，那么then返回的Promise也会成为接受状态，并且将那个Promise的接受状态的回调函数的参数值作为该被返回的Promise的接受状态回调函数的参数值。</li><li>如果then中的回调函数返回一个已经是拒绝状态的Promise，那么then返回的Promise也会成为拒绝状态，并且将那个Promise的拒绝状态的回调函数的参数值作为该被返回的Promise的拒绝状态回调函数的参数值。</li><li>如果then中的回调函数返回一个未定状态（pending）的Promise，那么then返回Promise的状态也是未定的，并且它的终态与那个Promise的终态相同；同时，它变为终态时调用的回调函数参数与那个Promise变为终态时的回调函数的参数是相同的。</li></ol><p>例如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> p1=<span class="built_in">Promise</span>.resolve(<span class="number">1</span>);</span><br><span class="line"><span class="keyword">let</span> p2=<span class="built_in">Promise</span>.reject(<span class="string">'err'</span>);</span><br><span class="line"></span><br><span class="line">p1.then(<span class="function"><span class="params">v</span>=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(v); <span class="comment">// 1</span></span><br><span class="line">    <span class="keyword">return</span> p2; <span class="comment">// 返回一个拒绝态的promise</span></span><br><span class="line">&#125;).catch(<span class="function"><span class="params">v</span>=&gt;</span>&#123; <span class="comment">// 接收到拒绝态promise传过来的错误原因</span></span><br><span class="line">    <span class="built_in">console</span>.log(v); <span class="comment">// 'err'</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h4 id="响应多个Promise"><a href="#响应多个Promise" class="headerlink" title="响应多个Promise"></a>响应多个Promise</h4><h5 id="Promise-all"><a href="#Promise-all" class="headerlink" title="Promise.all()"></a>Promise.all()</h5><p>Promise.all()方法接受一个参数并返回一个promise，该参数是一个含有多个受监视Promise的可迭代对象（例如，一个数组），只有可迭代对象中的所有promise被成功解决(resolved态)后返回的promise才会被解决</p><p>注意：</p><ol><li>如果传入的可迭代对象为空，Promise.all 会同步地返回一个已完成（resolved）状态的promise。</li><li>在任何情况下，Promise.all 返回的 promise 的完成状态的结果都是一个数组，它包含所有的传入迭代参数对象的值（也包括非 promise 值）。</li></ol><p>例如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> p1=<span class="built_in">Promise</span>.resolve(<span class="number">1</span>);</span><br><span class="line"><span class="keyword">let</span> p2=<span class="built_in">Promise</span>.resolve(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">Promise</span>.all([p1,p2]).then(<span class="function"><span class="params">v</span>=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(v); <span class="comment">// [1,2]</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>当然，只要所有传入的promise对象中有一个被拒绝，那么Promise.all()方法返回的promise对象就会被立刻拒绝</p><p>拒绝处理程序总是接受一个值而非数组，该值来自于被拒绝promise的拒绝值</p><p>例如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> p1=<span class="built_in">Promise</span>.resolve(<span class="number">1</span>);</span><br><span class="line"><span class="keyword">let</span> p2=<span class="built_in">Promise</span>.resolve(<span class="number">2</span>);</span><br><span class="line"><span class="comment">// 拒绝态promise</span></span><br><span class="line"><span class="keyword">let</span> p3=<span class="built_in">Promise</span>.reject(<span class="number">3</span>);</span><br><span class="line"><span class="keyword">let</span> p4=<span class="built_in">Promise</span>.resolve(<span class="number">4</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="keyword">set</span>=new Set([p1,p2,p3,p4]);</span><br><span class="line"></span><br><span class="line">Promise.all(<span class="keyword">set</span>).then(v=&gt;&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(v);</span><br><span class="line">&#125;).catch(<span class="function"><span class="params">err</span>=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(err); <span class="comment">// 3</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h5 id="Promise-race"><a href="#Promise-race" class="headerlink" title="Promise.race()"></a>Promise.race()</h5><p>Promise.race()同样也是接受一个包含多个promise的可迭代对象，但是，一旦迭代器中的某个promise解决或拒绝，返回的 promise就会解决或拒绝。</p><blockquote><p>一个待定的 Promise 只要给定的迭代中的一个promise解决或拒绝，返回的promise就采用第一个promise的值作为它的值，从而异步地解析或拒绝</p></blockquote><p>例如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// p1在2000毫秒后成为已成功处理的promise</span></span><br><span class="line"><span class="keyword">let</span> p1=<span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve,reject</span>)=&gt;</span>&#123;</span><br><span class="line">    setTimeout(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">        resolve(<span class="number">1</span>);</span><br><span class="line">    &#125;,<span class="number">2000</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建已完成拒绝态promise</span></span><br><span class="line"><span class="keyword">let</span> p2=<span class="built_in">Promise</span>.reject(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建已完成resolved态promise</span></span><br><span class="line"><span class="keyword">let</span> p3=<span class="built_in">Promise</span>.resolve(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">Promise</span>.race([p1,p2,p3]).then(<span class="function"><span class="params">v</span>=&gt;</span>&#123;</span><br><span class="line">    consoel.log(v);</span><br><span class="line">&#125;).catch(<span class="function"><span class="params">err</span>=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(err); <span class="comment">// 2</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>因为，p1在2000毫秒后才会成为已成功处理的promise,p2,p3都是已完成处理程序，但是p2先于p3被添加到处理队列中</p><p>需要注意的是，可迭代对象中promise的顺序也可能会对结果产生影响</p><p>例如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> p1=<span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve,reject</span>)=&gt;</span>&#123;</span><br><span class="line">    setTimeout(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">        resolve(<span class="number">1</span>);</span><br><span class="line">    &#125;,<span class="number">2000</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> p2=<span class="built_in">Promise</span>.reject(<span class="number">2</span>);</span><br><span class="line"><span class="keyword">let</span> p3=<span class="built_in">Promise</span>.resolve(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调换p2,p3的先后顺序</span></span><br><span class="line"><span class="built_in">Promise</span>.race([p1,p3,p2]).then(<span class="function"><span class="params">v</span>=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(v); <span class="comment">// 3</span></span><br><span class="line">&#125;).catch(<span class="function"><span class="params">err</span>=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(err);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="async-await"><a href="#async-await" class="headerlink" title="async/await"></a>async/await</h3><ol><li><p>async function 用来定义一个返回 AsyncFunction 对象的异步函数。异步函数是指通过事件循环异步执行的函数，它会通过一个隐式的 Promise 返回其结果。</p></li><li><p>await  操作符用于等待一个Promise 对象。它只能在异步函数 async function 中使用。</p></li><li><p>async 函数返回一个 Promise 对象</p></li><li><p>async 函数内部 return 返回的值。会成为 then 方法回调函数的参数。</p></li></ol><p>例如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">await</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve,reject</span>)=&gt;</span>&#123;</span><br><span class="line">        resolve(<span class="number">1</span>);</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">f().then(<span class="function"><span class="params">v</span>=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(v); <span class="comment">// 1</span></span><br><span class="line">&#125;).catch(<span class="function"><span class="params">err</span>=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(err);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;什么是异步编程&quot;&gt;&lt;a href=&quot;#什么是异步编程&quot; class=&quot;headerlink&quot; title=&quot;什么是异步编程&quot;&gt;&lt;/a&gt;什么是异步编程&lt;/h2&gt;&lt;p&gt;异步编程是什么？为什么需要异步编程；这都要从同步说起&lt;/p&gt;
&lt;p&gt;因为JavaScript语言是一
      
    
    </summary>
    
      <category term="ES6" scheme="http://yoursite.com/categories/ES6/"/>
    
    
  </entry>
  
  <entry>
    <title>数组创建的改进</title>
    <link href="http://yoursite.com/2019/09/09/%E6%95%B0%E7%BB%84%E5%88%9B%E5%BB%BA%E7%9A%84%E6%94%B9%E8%BF%9B/"/>
    <id>http://yoursite.com/2019/09/09/数组创建的改进/</id>
    <published>2019-09-09T08:05:36.000Z</published>
    <updated>2019-09-19T12:55:07.388Z</updated>
    
    <content type="html"><![CDATA[<h2 id="ES6之前数组创建的一些问题"><a href="#ES6之前数组创建的一些问题" class="headerlink" title="ES6之前数组创建的一些问题"></a>ES6之前数组创建的一些问题</h2><p>在ES6之前，数组的创建具有以下的一些问题</p><ol><li>通过Array构造函数创建数组时具有一些怪异的行为</li><li>没有现成的方法可以将类数组对象（具有数值型索引和length属性的对象）和可迭代对象转化为数组</li></ol><h3 id="Array构造函数的一些怪异行为"><a href="#Array构造函数的一些怪异行为" class="headerlink" title="Array构造函数的一些怪异行为"></a>Array构造函数的一些怪异行为</h3><p>Array构造函数具有以下怪异行为</p><ol><li><p>如果给Array构造函数传入一个数值型的值，此时，并不是创建一个包含该数值的数组，而是创建一个数组，将该数组的length属性设置为该值。那么显然数组内的所有元素都会是undefined</p> <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr=<span class="keyword">new</span> <span class="built_in">Array</span>(<span class="number">2</span>);</span><br><span class="line"><span class="built_in">console</span>.log(arr); <span class="comment">// [undefined,undefined]</span></span><br><span class="line"><span class="built_in">console</span>.log(arr.length); <span class="comment">// 2</span></span><br></pre></td></tr></table></figure></li><li><p>相对于上一点，如果传入一个非数值类型的值，那么就符合常规的想法，会创建一个包含该值的数组</p> <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr=<span class="keyword">new</span> <span class="built_in">Array</span>(<span class="string">'man'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(arr); <span class="comment">// ['man']</span></span><br><span class="line"><span class="built_in">console</span>.log(arr.length); <span class="comment">// 1</span></span><br></pre></td></tr></table></figure></li><li><p>最后，如果传入了多个值，那么不管这些值中是否有数值类型，所有的值都会变为创建的数组的元素</p> <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr=<span class="keyword">new</span> <span class="built_in">Array</span>(<span class="number">2</span>,<span class="string">'man'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(arr); <span class="comment">// [2,'man']</span></span><br><span class="line"><span class="built_in">console</span>.log(arr.length); <span class="comment">// 2</span></span><br></pre></td></tr></table></figure></li></ol><p>因为Array构造函数具有以上的一些怪异特性，因此ES6通过引入Array.of()方法来解决这个问题</p><h3 id="ES5实现将类数组对象转化为数组对象"><a href="#ES5实现将类数组对象转化为数组对象" class="headerlink" title="ES5实现将类数组对象转化为数组对象"></a>ES5实现将类数组对象转化为数组对象</h3><p>对于类数组对象，在ES5中我们可以采用以下的方式来将其转化为数组对象</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a=&#123;</span><br><span class="line">    <span class="number">0</span>:<span class="number">1</span>,</span><br><span class="line">    <span class="number">1</span>:<span class="number">2</span>,</span><br><span class="line">    length:<span class="number">2</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getArray</span>(<span class="params">obj</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> ans=[];</span><br><span class="line">    <span class="comment">// 类数组对象具有数值型索引和length属性</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">0</span>;i&lt;obj.length;i++) &#123;</span><br><span class="line">        ans.push(obj[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(getArray(a)); <span class="comment">// [1,2]</span></span><br></pre></td></tr></table></figure><p>除此之外，我们还可以利用数组方法slice()的一个特性：</p><blockquote><p>slice 方法可以用来将一个类数组（Array-like）对象/集合转换成一个新数组。</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a=&#123;</span><br><span class="line">    <span class="number">0</span>:<span class="number">1</span>,</span><br><span class="line">    <span class="number">1</span>:<span class="number">2</span>,</span><br><span class="line">    length:<span class="number">2</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getArray</span>(<span class="params">obj</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Array</span>.prototype.slice.call(obj);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(getArray(a)); <span class="comment">// [1,2]</span></span><br></pre></td></tr></table></figure><h2 id="ES6对于数组创建的改进"><a href="#ES6对于数组创建的改进" class="headerlink" title="ES6对于数组创建的改进"></a>ES6对于数组创建的改进</h2><h3 id="Array-of-方法对于Array构造函数的改进"><a href="#Array-of-方法对于Array构造函数的改进" class="headerlink" title="Array.of()方法对于Array构造函数的改进"></a>Array.of()方法对于Array构造函数的改进</h3><p>ES6通过引入Array.of()方法来解决Array构造函数出现的一些怪异行为</p><h4 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h4><p>Array.of() 方法创建一个具有可变数量参数的新数组实例，而不考虑参数的数量或类型。</p><p> Array.of() 和 Array 构造函数之间的区别在于处理整数参数：Array.of(7) 创建一个具有单个元素 7 的数组，而 Array(7) 创建一个长度为7的空数组（注意：这是指一个有7个空位(empty)的数组，而不是由7个undefined组成的数组）。</p><h4 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h4><blockquote><p>Array.of(element0[, element1[, …[, elementN]]])</p></blockquote><p>参数</p><p>elementN:任意个参数，将按顺序成为返回数组中的元素。</p><p>返回值</p><p>新的 Array 实例。</p><h4 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用Array构造函数并传入一个数值类型值</span></span><br><span class="line"><span class="keyword">let</span> arr=<span class="keyword">new</span> <span class="built_in">Array</span>(<span class="number">2</span>);</span><br><span class="line"><span class="built_in">console</span>.log(arr); <span class="comment">// [undefined,undefined]</span></span><br><span class="line"><span class="built_in">console</span>.log(arr.length); <span class="comment">// 2</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用Array.of()方法并传入一个数值类型值</span></span><br><span class="line"><span class="keyword">let</span> array=<span class="built_in">Array</span>.of(<span class="number">2</span>);</span><br><span class="line"><span class="built_in">console</span>.log(array); <span class="comment">// [2]</span></span><br><span class="line"><span class="built_in">console</span>.log(array.length); <span class="comment">// 1</span></span><br></pre></td></tr></table></figure><h3 id="Array-from-方法将非数组对象转化为数组对象"><a href="#Array-from-方法将非数组对象转化为数组对象" class="headerlink" title="Array.from()方法将非数组对象转化为数组对象"></a>Array.from()方法将非数组对象转化为数组对象</h3><h4 id="概述-1"><a href="#概述-1" class="headerlink" title="概述"></a>概述</h4><p>Array.from() 方法从一个类似数组或可迭代对象中创建一个新的，浅拷贝的数组实例。</p><h4 id="语法-1"><a href="#语法-1" class="headerlink" title="语法"></a>语法</h4><blockquote><p>Array.from(arrayLike[, mapFn[, thisArg]])</p></blockquote><p><strong>参数</strong></p><p>arrayLike<br>    想要转换成数组的伪数组对象或可迭代对象。</p><p>mapFn (可选参数)<br>    如果指定了该参数，新数组中的每个元素会执行该回调函数。</p><p>thisArg (可选参数)<br>    可选参数，执行回调函数 mapFn 时 this 对象。</p><p><strong>返回值</strong></p><p>一个新的数组实例</p><h4 id="例子-1"><a href="#例子-1" class="headerlink" title="例子"></a>例子</h4><p>使用Array.from()方法将类数组对象转化为数组对象</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a=&#123;</span><br><span class="line">    <span class="number">0</span>:<span class="number">1</span>,</span><br><span class="line">    <span class="number">1</span>:<span class="number">2</span>,</span><br><span class="line">    length:<span class="number">2</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用Array.from()方法将类数组对象转化为数组对象</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> arr=<span class="built_in">Array</span>.from(a);</span><br><span class="line"><span class="built_in">console</span>.log(arr); <span class="comment">// [1,2]</span></span><br></pre></td></tr></table></figure><p>使用Array.from()方法将可迭代对象转化为数组对象</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 将字符串转化为数组</span></span><br><span class="line"><span class="keyword">let</span> str=<span class="string">'hello'</span>;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Array</span>.from(str)); <span class="comment">// ['h','e','l','l','o']</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 将Set集合转化为数组</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Array</span>.from(<span class="keyword">new</span> <span class="built_in">Set</span>([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]))); <span class="comment">// [1,2,3]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 将Map集合转化为数组</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Array</span>.from(<span class="keyword">new</span> <span class="built_in">Map</span>([[<span class="string">'a'</span>,<span class="number">1</span>],[<span class="string">'b'</span>,<span class="number">2</span>],[<span class="string">'c'</span>,<span class="number">3</span>]]))); <span class="comment">// [['a',1],['b',2],['c',3]]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 将普通自定义对象利用生成器转化为可迭代对象之后再转化为数组</span></span><br><span class="line"><span class="keyword">let</span> test=&#123;</span><br><span class="line">    a:<span class="string">'a'</span>,</span><br><span class="line">    c:<span class="string">'c'</span>,</span><br><span class="line">    *[<span class="built_in">Symbol</span>.iterator]() &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">let</span> i <span class="keyword">in</span> test) &#123;</span><br><span class="line">            <span class="keyword">yield</span> test[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Array</span>.from(test)); <span class="comment">// ['a','c']</span></span><br></pre></td></tr></table></figure><p>映射转化：使用Array.from()的第二个参数将被转化对象的每一个值转化为其他形式</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> test=&#123;</span><br><span class="line">    a:<span class="string">'a'</span>,</span><br><span class="line">    c:<span class="string">'c'</span>,</span><br><span class="line">    *[<span class="built_in">Symbol</span>.iterator]() &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">let</span> i <span class="keyword">in</span> test) &#123;</span><br><span class="line">            <span class="keyword">yield</span> test[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Array</span>.from(test,(v)=&gt;<span class="string">'hello '</span>+v)); <span class="comment">// ['hello a','hello c']</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;ES6之前数组创建的一些问题&quot;&gt;&lt;a href=&quot;#ES6之前数组创建的一些问题&quot; class=&quot;headerlink&quot; title=&quot;ES6之前数组创建的一些问题&quot;&gt;&lt;/a&gt;ES6之前数组创建的一些问题&lt;/h2&gt;&lt;p&gt;在ES6之前，数组的创建具有以下的一些问题&lt;
      
    
    </summary>
    
      <category term="ES6" scheme="http://yoursite.com/categories/ES6/"/>
    
    
  </entry>
  
  <entry>
    <title>leetcode-263 丑数</title>
    <link href="http://yoursite.com/2019/09/09/leetcode-263/"/>
    <id>http://yoursite.com/2019/09/09/leetcode-263/</id>
    <published>2019-09-09T07:51:06.000Z</published>
    <updated>2019-09-09T07:58:23.372Z</updated>
    
    <content type="html"><![CDATA[<h1 id="丑数"><a href="#丑数" class="headerlink" title="丑数"></a>丑数</h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>编写一个程序判断给定的数是否为丑数。</p><p>丑数就是只包含质因数 2, 3, 5 的正整数。</p><p>示例 1:</p><blockquote><p>输入: 6<br>输出: true<br>解释: 6 = 2 × 3</p></blockquote><p>示例 2:</p><blockquote><p>输入: 8<br>输出: true<br>解释: 8 = 2 × 2 × 2</p></blockquote><p>示例 3:</p><blockquote><p>输入: 14<br>输出: false <br>解释: 14 不是丑数，因为它包含了另外一个质因数 7。</p></blockquote><p>说明：</p><ol><li>1是丑数。</li><li>输入不会超过 32 位有符号整数的范围: [−231,  231 − 1]。<a id="more"></a>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/ugly-number" target="_blank" rel="noopener">https://leetcode-cn.com/problems/ugly-number</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。<h2 id="核心思路"><a href="#核心思路" class="headerlink" title="核心思路"></a>核心思路</h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3>题目说明只包含质因数2,3,5的整数位丑数（且1为丑数）。那么，我们先排除掉小于等于0的数。那么对于正整数来说，如果该数只包含质因数2,3,5；那么我们只要将该数不断地除以2（如果可以整除），不断地除以3（如果可以整除），不断地除以5（如果可以整除）；如果最后的结果为1的话，那么该数就是丑数</li></ol><h3 id="解题步骤"><a href="#解题步骤" class="headerlink" title="解题步骤"></a>解题步骤</h3><ol><li>如果给定数小于等于0，返回false</li><li>如果该数可以整除2，那么不断将该数除以2</li><li>如果该数可以整除3，那么不断将该数除以3</li><li>如果该数可以整除5，那么不断将该数除以5</li><li>执行完2,3,4步骤后如果结果为1，那么该数为丑数，返回true；否则返回false</li></ol><h2 id="Coding实现"><a href="#Coding实现" class="headerlink" title="Coding实现"></a>Coding实现</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @param &#123;number&#125; num</span></span><br><span class="line"><span class="comment"> * @return &#123;boolean&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> isUgly = <span class="function"><span class="keyword">function</span>(<span class="params">num</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(num&lt;=<span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">while</span>(num%<span class="number">2</span>===<span class="number">0</span>) &#123;</span><br><span class="line">        num=num/<span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(num%<span class="number">3</span>===<span class="number">0</span>) &#123;</span><br><span class="line">        num=num/<span class="number">3</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(num%<span class="number">5</span>===<span class="number">0</span>) &#123;</span><br><span class="line">        num=num/<span class="number">5</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(num===<span class="number">1</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;丑数&quot;&gt;&lt;a href=&quot;#丑数&quot; class=&quot;headerlink&quot; title=&quot;丑数&quot;&gt;&lt;/a&gt;丑数&lt;/h1&gt;&lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h2&gt;&lt;p&gt;编写一个程序判断给定的数是否为丑数。&lt;/p&gt;
&lt;p&gt;丑数就是只包含质因数 2, 3, 5 的正整数。&lt;/p&gt;
&lt;p&gt;示例 1:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;输入: 6&lt;br&gt;输出: true&lt;br&gt;解释: 6 = 2 × 3&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;示例 2:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;输入: 8&lt;br&gt;输出: true&lt;br&gt;解释: 8 = 2 × 2 × 2&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;示例 3:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;输入: 14&lt;br&gt;输出: false &lt;br&gt;解释: 14 不是丑数，因为它包含了另外一个质因数 7。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;说明：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;1是丑数。&lt;/li&gt;
&lt;li&gt;输入不会超过 32 位有符号整数的范围: [−231,  231 − 1]。
    
    </summary>
    
      <category term="leetcode题解与算法" scheme="http://yoursite.com/categories/leetcode%E9%A2%98%E8%A7%A3%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
  </entry>
  
  <entry>
    <title>类语法不得不知的几点</title>
    <link href="http://yoursite.com/2019/09/08/%E7%B1%BB%E8%AF%AD%E6%B3%95%E4%B8%8D%E5%BE%97%E4%B8%8D%E7%9F%A5%E7%9A%84%E5%87%A0%E7%82%B9/"/>
    <id>http://yoursite.com/2019/09/08/类语法不得不知的几点/</id>
    <published>2019-09-08T08:25:41.000Z</published>
    <updated>2019-09-08T13:03:35.824Z</updated>
    
    <content type="html"><![CDATA[<h2 id="ES5实现模拟类"><a href="#ES5实现模拟类" class="headerlink" title="ES5实现模拟类"></a>ES5实现模拟类</h2><p>ES5是通过构造函数和原型来是模拟实现类的</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Test</span>(<span class="params">item</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.item=item;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Test.prototype.getItem=<span class="function"><span class="keyword">function</span> (<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.item;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> test=<span class="keyword">new</span> Test(<span class="number">123</span>);</span><br><span class="line"><span class="built_in">console</span>.log(test); <span class="comment">// &#123;item:123&#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(test.getItem()); <span class="comment">// 123</span></span><br></pre></td></tr></table></figure><h2 id="ES6类的声明"><a href="#ES6类的声明" class="headerlink" title="ES6类的声明"></a>ES6类的声明</h2><h3 id="基本类声明语法"><a href="#基本类声明语法" class="headerlink" title="基本类声明语法"></a>基本类声明语法</h3><p>要声明一个类，可以按照如下的方法</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span></span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(item) &#123;</span><br><span class="line">        <span class="keyword">this</span>.item=item;</span><br><span class="line">    &#125;</span><br><span class="line">    getItem() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.item;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> test=<span class="keyword">new</span> Test(<span class="number">123</span>);</span><br><span class="line"><span class="built_in">console</span>.log(test); <span class="comment">// &#123;item:123&#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(test.getItem()); <span class="comment">// 123</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 查看test实例原型上的属性</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.getOwnPropertyNames(<span class="built_in">Object</span>.getPrototypeOf(test))); <span class="comment">// [ 'constructor', 'getItem' ]</span></span><br></pre></td></tr></table></figure><p>其中，constructor方法用来定义构造函数，除此之外的所有方法就是定义在原型上的方法</p><p>另外，类声明其实是基于已有自定义类型声明的语法糖。如果使用typeof Test最终返回的结果会是’function’，因此，类其实就是创建了一个具有构造函数方法行为的函数</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span></span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(item) &#123;</span><br><span class="line">        <span class="keyword">this</span>.item=item;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> Test); <span class="comment">// function</span></span><br></pre></td></tr></table></figure><h3 id="类表达式语法"><a href="#类表达式语法" class="headerlink" title="类表达式语法"></a>类表达式语法</h3><p>类和函数一样(类实质上就是一个函数)，它在声明的时候也具有表达式语法</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用匿名类赋值给Test</span></span><br><span class="line"><span class="keyword">let</span> Test=<span class="class"><span class="keyword">class</span></span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(item) &#123;</span><br><span class="line">        <span class="keyword">this</span>.item=item;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用命名类赋值给Test</span></span><br><span class="line"><span class="keyword">let</span> Test=<span class="class"><span class="keyword">class</span> <span class="title">A</span></span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(item) &#123;</span><br><span class="line">        <span class="keyword">this</span>.item=item;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="类的一些特性"><a href="#类的一些特性" class="headerlink" title="类的一些特性"></a>类的一些特性</h2><p>类声明具有的一些特性</p><ol><li><p>虽然类实质上是函数，函数声明可以被提升，但是类声明却是与let声明类似不能被提升</p></li><li><p>因为类实质上是函数，因此类可以作为参数传递给函数，也可以作为值赋给变量</p> <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span></span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(item) &#123;</span><br><span class="line">        <span class="keyword">this</span>.item=item;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> M=Test;</span><br><span class="line"><span class="keyword">let</span> m=<span class="keyword">new</span> M(<span class="number">1</span>);</span><br><span class="line"><span class="built_in">console</span>.log(m); <span class="comment">// &#123;item:1&#125;</span></span><br></pre></td></tr></table></figure></li><li><p>类方法与函数一样同样支持使用可计算属性名</p> <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a=<span class="string">'get Item'</span>;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span></span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(item) &#123;</span><br><span class="line">        <span class="keyword">this</span>.item=item;</span><br><span class="line">    &#125;</span><br><span class="line">    [a]() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.item;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> M=Test;</span><br><span class="line"><span class="keyword">let</span> m=<span class="keyword">new</span> M(<span class="number">1</span>);</span><br><span class="line"><span class="built_in">console</span>.log(m[a]()); <span class="comment">// 1</span></span><br></pre></td></tr></table></figure></li><li><p>类是个函数，那么它也就是个对象，因此，我们可以在类中定义生成器方法</p> <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span></span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(...item) &#123;</span><br><span class="line">        <span class="keyword">this</span>.a=item[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">this</span>.b=item[<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">this</span>.c=item[<span class="number">2</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 建立生成器方法</span></span><br><span class="line">    *[<span class="built_in">Symbol</span>.iterator]() &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">let</span> i <span class="keyword">in</span> <span class="keyword">this</span>) &#123;</span><br><span class="line">            <span class="keyword">yield</span> <span class="keyword">this</span>[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> test=<span class="keyword">new</span> Test(<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 可以用for...of进行迭代</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> v <span class="keyword">of</span> test) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(v); <span class="comment">// 3,4,5</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h2 id="静态成员"><a href="#静态成员" class="headerlink" title="静态成员"></a>静态成员</h2><p>静态成员通过static关键字来声明，它会作为类的一个方法属性。无法被类的实例调用，只能通过类本身被调用</p><p>例如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> Test=<span class="class"><span class="keyword">class</span></span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(item) &#123;</span><br><span class="line">        <span class="keyword">this</span>.item=item;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> getValue() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> test=<span class="keyword">new</span> Test(<span class="number">1</span>);</span><br><span class="line"><span class="built_in">console</span>.log(test);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 通过类本身来调用静态成员</span></span><br><span class="line"><span class="built_in">console</span>.log(Test.getValue()); <span class="comment">// 1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 无法通过类的实例来调用，因为静态成员不会出现在构造函数的原型对象上，所以实例无法访问到该方法</span></span><br><span class="line"><span class="built_in">console</span>.log(test.getValue()); <span class="comment">// 报错：test.getValue is not a function</span></span><br></pre></td></tr></table></figure><p>那么，静态成员一般用来做什么呢？他们通常是一些实用程序方法，例如创建或克隆对象</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> Test=<span class="class"><span class="keyword">class</span></span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(item) &#123;</span><br><span class="line">        <span class="keyword">this</span>.item=item;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 实用静态成员来创建对象</span></span><br><span class="line">    <span class="keyword">static</span> create(item) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Test(item);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 实用静态成员来创建对象</span></span><br><span class="line"><span class="keyword">let</span> test=Test.create(<span class="number">1</span>);</span><br><span class="line"><span class="built_in">console</span>.log(test); <span class="comment">// &#123;item:1&#125;</span></span><br></pre></td></tr></table></figure><h3 id="静态成员的继承"><a href="#静态成员的继承" class="headerlink" title="静态成员的继承"></a>静态成员的继承</h3><p>如果基类有静态成员，那么这些静态成员在派生类中也可以被使用</p><p>例如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> Person=<span class="class"><span class="keyword">class</span></span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(item) &#123;</span><br><span class="line">        <span class="keyword">this</span>.item=item;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 实用静态成员来创建对象</span></span><br><span class="line">    <span class="keyword">static</span> create(item) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Person(item);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Man</span> <span class="keyword">extends</span> <span class="title">Person</span></span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(item) &#123;</span><br><span class="line">        <span class="keyword">super</span>(item);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> man=Man.create(<span class="string">'man'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(man); <span class="comment">// &#123;item:'man'&#125;</span></span><br></pre></td></tr></table></figure><h2 id="继承与派生类"><a href="#继承与派生类" class="headerlink" title="继承与派生类"></a>继承与派生类</h2><h3 id="ES5模拟实现继承"><a href="#ES5模拟实现继承" class="headerlink" title="ES5模拟实现继承"></a>ES5模拟实现继承</h3><p>ES5模拟实现继承主要是通过利用原型链</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">item</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.item=item;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Person.prototype.sayPerson=<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'person'</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 利用call来继承父类的构造函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Man</span>(<span class="params">item</span>) </span>&#123;</span><br><span class="line">    Person.call(<span class="keyword">this</span>,item);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 原型对象的继承</span></span><br><span class="line">Man.prototype=<span class="keyword">new</span> Person();</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> man=<span class="keyword">new</span> Man(<span class="string">'man'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(man); <span class="comment">// &#123;item:'man'&#125;</span></span><br><span class="line">man.sayPerson(); <span class="comment">// 'person'</span></span><br></pre></td></tr></table></figure><h3 id="ES6的继承"><a href="#ES6的继承" class="headerlink" title="ES6的继承"></a>ES6的继承</h3><p>ES6使用extends关键字来指定类继承的函数，并且通过super()方法即可访问基类的构造函数</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span></span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(item) &#123;</span><br><span class="line">        <span class="keyword">this</span>.item=item;</span><br><span class="line">    &#125;</span><br><span class="line">    getItem() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.item;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Man</span> <span class="keyword">extends</span> <span class="title">Person</span></span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(item) &#123;</span><br><span class="line">        <span class="keyword">super</span>(item);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> man=<span class="keyword">new</span> Man(<span class="string">'man'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(man); <span class="comment">// &#123;item:'man'&#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(man.getItem()); <span class="comment">// 'man'</span></span><br></pre></td></tr></table></figure><p>继承自其它类的类被称为派生类，因此，对于上述代码，Person类被称为基类（父类），Man类被称为派生类（子类）</p><p><strong>注意</strong>：</p><blockquote><p>如果在派生类中指定了构造函数，那么在构造函数中就必须要调用super()方法，如果不这样做程序就会报错；<br>当然，你也可以不指定构造函数，那么派生类就会默认执行构造函数并调用super()方法并传入所有参数</p></blockquote><p>例如:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Man</span> <span class="keyword">extends</span> <span class="title">Person</span></span>&#123;</span><br><span class="line">    <span class="comment">// 没有构造函数</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 等价于</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Man</span> <span class="keyword">extends</span> <span class="title">Person</span></span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(...items)&#123;</span><br><span class="line">        <span class="keyword">super</span>(...items);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>为了避免一些参数传入引起的问题，我们最好是手动建立构造函数</p><h3 id="super-的一些注意点"><a href="#super-的一些注意点" class="headerlink" title="super()的一些注意点"></a>super()的一些注意点</h3><p>super()方法有一些注意点</p><ol><li>我们只能在派生类的构造函数中使用super()方法，如果尝试在非派生类（不适用extends声明的类）或函数中使用就会导致程序抛出错误</li><li>在构造函数中访问this前一定要调用super()，它负责初始化this</li></ol><h3 id="类方法的遮蔽"><a href="#类方法的遮蔽" class="headerlink" title="类方法的遮蔽"></a>类方法的遮蔽</h3><p>派生类的同名方法会覆盖基类中的同名方法，因为继承的本质就是原型链来实现的；而原型链的查找是从底端向上查找的，如果找到了一个符合要求的便不会再向上查找</p><p>例如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span></span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(item) &#123;</span><br><span class="line">        <span class="keyword">this</span>.item=item;</span><br><span class="line">    &#125;</span><br><span class="line">    sayHello() &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'Person say hello'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Man</span> <span class="keyword">extends</span> <span class="title">Person</span></span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(item) &#123;</span><br><span class="line">        <span class="keyword">super</span>(item);</span><br><span class="line">    &#125;</span><br><span class="line">    sayHello() &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'Man say hello'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> man=<span class="keyword">new</span> Man(<span class="string">'man'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(man); <span class="comment">// &#123;item:'man'&#125;</span></span><br><span class="line">man.sayHello(); <span class="comment">// 'Man say hello'</span></span><br></pre></td></tr></table></figure><h3 id="继承自表达式的类"><a href="#继承自表达式的类" class="headerlink" title="继承自表达式的类"></a>继承自表达式的类</h3><p>只要表达式可以被解析为一个函数并且具有[[construct]]属性（箭头函数不具有该属性）和原型，那么就可以用extends进行派生</p><p>例如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 该函数为构造函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">item</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.item=item;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Person.prototype.sayHello=<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'hello'</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 继承自构造函数而非基本类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Man</span> <span class="keyword">extends</span> <span class="title">Person</span></span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(item) &#123;</span><br><span class="line">        <span class="keyword">super</span>(item);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> man=<span class="keyword">new</span> Man(<span class="string">'man'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(man); <span class="comment">// &#123;item:'man'&#125;</span></span><br><span class="line">man.sayHello(); <span class="comment">// 'hello'</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;ES5实现模拟类&quot;&gt;&lt;a href=&quot;#ES5实现模拟类&quot; class=&quot;headerlink&quot; title=&quot;ES5实现模拟类&quot;&gt;&lt;/a&gt;ES5实现模拟类&lt;/h2&gt;&lt;p&gt;ES5是通过构造函数和原型来是模拟实现类的&lt;/p&gt;
&lt;figure class=&quot;highl
      
    
    </summary>
    
      <category term="ES6" scheme="http://yoursite.com/categories/ES6/"/>
    
    
      <category term="基础语法" scheme="http://yoursite.com/tags/%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>leetcode-258 各位相加</title>
    <link href="http://yoursite.com/2019/09/08/leetcode-258/"/>
    <id>http://yoursite.com/2019/09/08/leetcode-258/</id>
    <published>2019-09-08T06:21:30.000Z</published>
    <updated>2019-09-08T07:24:05.907Z</updated>
    
    <content type="html"><![CDATA[<h1 id="各位相加"><a href="#各位相加" class="headerlink" title="各位相加"></a>各位相加</h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>给定一个非负整数 num，反复将各个位上的数字相加，直到结果为一位数。</p><p>示例:</p><blockquote><p>输入: 38<br>输出: 2 <br>解释: 各位相加的过程为：3 + 8 = 11, 1 + 1 = 2。 由于 2 是一位数，所以返回 2。</p></blockquote><p>进阶:<br>你可以不使用循环或者递归，且在 O(1) 时间复杂度内解决这个问题吗？</p><a id="more"></a><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/add-digits" target="_blank" rel="noopener">https://leetcode-cn.com/problems/add-digits</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p><h2 id="核心思路"><a href="#核心思路" class="headerlink" title="核心思路"></a>核心思路</h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><ol><li>如果不考虑进阶的要求的话，那么第一直觉就会是使用循环或者递归，将数的各位和一直相加，直到和为个位数</li><li>如果需要满足进阶的要求的话，那么我们需要一些数学的技巧。对于一个数abc,它等于a*100+b*10+c。将它求和的话，就会变为a+b+c,也就是求和之后减少了99*a+9*b=9*(11*a+b);因此，每次求和这个数就会减少9的倍数的值；也就是相当于，原数-9*未知值=和；这个式子可以转化为：原数%9=和；因此，若结果为 0 则考虑num本身是否为 0，若本身不为不为 0，则返回 9；此外，返回结果</li></ol><h3 id="解题步骤"><a href="#解题步骤" class="headerlink" title="解题步骤"></a>解题步骤</h3><h2 id="Coding实现"><a href="#Coding实现" class="headerlink" title="Coding实现"></a>Coding实现</h2><p>循环版</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @param &#123;number&#125; num</span></span><br><span class="line"><span class="comment"> * @return &#123;number&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> addDigits = <span class="function"><span class="keyword">function</span>(<span class="params">num</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(num&gt;=<span class="number">10</span>) &#123;</span><br><span class="line">        num=num.toString().split(<span class="string">''</span>).reduce(<span class="function">(<span class="params">pre,value</span>)=&gt;</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> pre+<span class="built_in">parseInt</span>(value);</span><br><span class="line">        &#125;,<span class="number">0</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> num;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>数学推断版</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @param &#123;number&#125; num</span></span><br><span class="line"><span class="comment"> * @return &#123;number&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> addDigits = <span class="function"><span class="keyword">function</span>(<span class="params">num</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(num&gt;<span class="number">9</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span>(num%<span class="number">9</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> num%<span class="number">9</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> <span class="number">9</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> num;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;各位相加&quot;&gt;&lt;a href=&quot;#各位相加&quot; class=&quot;headerlink&quot; title=&quot;各位相加&quot;&gt;&lt;/a&gt;各位相加&lt;/h1&gt;&lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h2&gt;&lt;p&gt;给定一个非负整数 num，反复将各个位上的数字相加，直到结果为一位数。&lt;/p&gt;
&lt;p&gt;示例:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;输入: 38&lt;br&gt;输出: 2 &lt;br&gt;解释: 各位相加的过程为：3 + 8 = 11, 1 + 1 = 2。 由于 2 是一位数，所以返回 2。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;进阶:&lt;br&gt;你可以不使用循环或者递归，且在 O(1) 时间复杂度内解决这个问题吗？&lt;/p&gt;
    
    </summary>
    
      <category term="leetcode题解与算法" scheme="http://yoursite.com/categories/leetcode%E9%A2%98%E8%A7%A3%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
  </entry>
  
  <entry>
    <title>迭代器与生成器</title>
    <link href="http://yoursite.com/2019/09/07/%E8%BF%AD%E4%BB%A3%E5%99%A8%E4%B8%8E%E7%94%9F%E6%88%90%E5%99%A8/"/>
    <id>http://yoursite.com/2019/09/07/迭代器与生成器/</id>
    <published>2019-09-07T06:34:17.000Z</published>
    <updated>2019-09-07T08:41:37.115Z</updated>
    
    <content type="html"><![CDATA[<h2 id="什么是迭代器"><a href="#什么是迭代器" class="headerlink" title="什么是迭代器"></a>什么是迭代器</h2><p>首先，迭代器是一个对象，一个专门为迭代过程设计的对象。所有的迭代器对象都会具有一个next()方法，用来返回一个结果对象（该结果对象包括两个属性，一个是下一个要返回的值，一个是done属性。在返回最后一个值及之前时，done值为false，否则为true）。</p><h3 id="使用ES5模拟一个迭代器"><a href="#使用ES5模拟一个迭代器" class="headerlink" title="使用ES5模拟一个迭代器"></a>使用ES5模拟一个迭代器</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 利用闭包的特性，使得next()方法一直保存着index的变量值</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createIterator</span>(<span class="params">items</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> index=<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        next : <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">            index++;</span><br><span class="line">            <span class="keyword">return</span> &#123;</span><br><span class="line">                value:items[index],</span><br><span class="line">                done:index&lt;=items.length<span class="number">-1</span>?<span class="literal">false</span>:<span class="literal">true</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> iterator=createIterator([<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>]);</span><br><span class="line"><span class="built_in">console</span>.log(iterator.next());</span><br><span class="line"><span class="built_in">console</span>.log(iterator.next());</span><br><span class="line"><span class="built_in">console</span>.log(iterator.next());</span><br><span class="line"><span class="built_in">console</span>.log(iterator.next());</span><br><span class="line"><span class="built_in">console</span>.log(iterator.next());</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 输出结果</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">&#123; value: 3, done: false &#125;</span></span><br><span class="line"><span class="comment">&#123; value: 4, done: false &#125;</span></span><br><span class="line"><span class="comment">&#123; value: 5, done: false &#125;</span></span><br><span class="line"><span class="comment">&#123; value: undefined, done: true &#125;</span></span><br><span class="line"><span class="comment">&#123; value: undefined, done: true &#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h2 id="什么是生成器"><a href="#什么是生成器" class="headerlink" title="什么是生成器"></a>什么是生成器</h2><p>生成器是一个可以返回迭代器对象的函数，通过*关键字来表示该函数为生成器函数。</p><p>在生成器函数中，我们一般需要使用yield关键字来指定调用迭代器的next()方法的返回值和返回顺序。</p><p>yield关键字可以返回任何值或者表达式</p><p>例如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用生成器函数来返回一个迭代器，其中的yield关键字来指定调用此迭代器中的next()方法的返回值与返回顺序</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> *<span class="title">createIterator</span>(<span class="params">items</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">0</span>;i&lt;items.length;i++) &#123;</span><br><span class="line">        <span class="keyword">yield</span> items[i];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> iterator=createIterator([<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>]);</span><br><span class="line"><span class="built_in">console</span>.log(iterator.next());</span><br><span class="line"><span class="built_in">console</span>.log(iterator.next());</span><br><span class="line"><span class="built_in">console</span>.log(iterator.next());</span><br><span class="line"><span class="built_in">console</span>.log(iterator.next());</span><br><span class="line"><span class="built_in">console</span>.log(iterator.next());</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 输出结果</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">&#123; value: 3, done: false &#125;</span></span><br><span class="line"><span class="comment">&#123; value: 4, done: false &#125;</span></span><br><span class="line"><span class="comment">&#123; value: 5, done: false &#125;</span></span><br><span class="line"><span class="comment">&#123; value: undefined, done: true &#125;</span></span><br><span class="line"><span class="comment">&#123; value: undefined, done: true &#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>对于生成器函数中的yield，每当执行完一个yield语句后，该函数就会自动停止执行，直到再次调用返回的迭代器的next()方法</p><h3 id="生成器函数表达式"><a href="#生成器函数表达式" class="headerlink" title="生成器函数表达式"></a>生成器函数表达式</h3><p>上面的例子是使用函数声明的方式来创建生成器，同样我们也可以使用函数表达式的方式来创建生成器。此时，我们只需要在function关键字和小括号中间添加*号即可</p><p>例如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 匿名函数</span></span><br><span class="line"><span class="keyword">let</span> createIterator=<span class="function"><span class="keyword">function</span> *(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">yield</span> <span class="number">3</span>;</span><br><span class="line">    <span class="keyword">yield</span> <span class="number">4</span>;</span><br><span class="line">    <span class="keyword">yield</span> <span class="number">5</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 非匿名函数</span></span><br><span class="line"><span class="keyword">let</span> createIterator=<span class="function"><span class="keyword">function</span> *<span class="title">test</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">yield</span> <span class="number">3</span>;</span><br><span class="line">    <span class="keyword">yield</span> <span class="number">4</span>;</span><br><span class="line">    <span class="keyword">yield</span> <span class="number">5</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="生成器函数作为一个对象的方法"><a href="#生成器函数作为一个对象的方法" class="headerlink" title="生成器函数作为一个对象的方法"></a>生成器函数作为一个对象的方法</h3><p>由于生成器本身就是一个函数，因此我们可以将生成器作为一个对象的方法。</p><p>这样，我们可以使用ES6对象的简写方法来创建生成器，只需要在方法名前加上*即可</p><p>例如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> test=&#123;</span><br><span class="line">    *createIterator() &#123;</span><br><span class="line">        <span class="keyword">yield</span> <span class="number">3</span>;</span><br><span class="line">        <span class="keyword">yield</span> <span class="number">4</span>;</span><br><span class="line">        <span class="keyword">yield</span> <span class="number">5</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="可迭代对象与for…of循环"><a href="#可迭代对象与for…of循环" class="headerlink" title="可迭代对象与for…of循环"></a>可迭代对象与for…of循环</h2><h3 id="什么是可迭代对象"><a href="#什么是可迭代对象" class="headerlink" title="什么是可迭代对象"></a>什么是可迭代对象</h3><p>可迭代对象都会有Symbol.iterator属性。该属性可以通过指定的函数来返回一个迭代器。</p><p>在ES6中，所有的集合对象（数组，Set集合，Map集合）和字符串都是可迭代对象。这些对象都有默认的迭代器。</p><p>而我们自己创建的对象一般都不是可迭代对象，当然我们可以将他们转变为可迭代对象</p><blockquote><p>注意：由于生成器默认会为Symbol.iterator属性赋值，因此所有通过生成器创建的迭代器都会是可迭代对象。因此，我们可以这一特性将不可迭代对象转化为可迭代对象</p></blockquote><h4 id="判断一个对象是否为可迭代对象"><a href="#判断一个对象是否为可迭代对象" class="headerlink" title="判断一个对象是否为可迭代对象"></a>判断一个对象是否为可迭代对象</h4><p>因为可迭代对象都会有Symbol.iterator方法属性，所以我们可以判断某对象中是否具有该方法来判断是否为可迭代对象</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">isIterable</span>(<span class="params">object</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">typeof</span> object[<span class="built_in">Symbol</span>.iterator] === <span class="string">'function'</span></span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(isIterable([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>])); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(isIterable(<span class="keyword">new</span> <span class="built_in">Set</span>([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]))); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(isIterable(<span class="keyword">new</span> <span class="built_in">Map</span>([[<span class="number">1</span>,<span class="number">1</span>],[<span class="number">2</span>,<span class="number">2</span>]]))); <span class="comment">//true</span></span><br><span class="line"><span class="built_in">console</span>.log(isIterable(<span class="string">'hello'</span>)); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(isIterable(&#123;<span class="attr">a</span>:<span class="number">1</span>,<span class="attr">b</span>:<span class="number">2</span>&#125;)); <span class="comment">// false</span></span><br></pre></td></tr></table></figure><h3 id="for…of循环"><a href="#for…of循环" class="headerlink" title="for…of循环"></a>for…of循环</h3><p>for…of循环只能循环可迭代对象。</p><p>其实质上是会调用可迭代对象的Symbol.iterator的属性方法来获取到一个迭代器，然后不断调用迭代器的next()方法直到done属性值为true时退出</p><p>例如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> test=[<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> v <span class="keyword">of</span> test) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(v);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 输出结果</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">3</span></span><br><span class="line"><span class="comment">4</span></span><br><span class="line"><span class="comment">5</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h3 id="访问默认迭代器"><a href="#访问默认迭代器" class="headerlink" title="访问默认迭代器"></a>访问默认迭代器</h3><p>每个可迭代对象都会有一个Symbol.iterator的方法属性，该方法被调用后可以返回一个迭代器。</p><p>因此，我们可以通过该属性去访问一个可迭代对象的默认迭代器</p><p>例如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> test=[<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>];</span><br><span class="line"><span class="comment">// 获得数组对象的默认迭代器</span></span><br><span class="line"><span class="keyword">let</span> iterator=test[<span class="built_in">Symbol</span>.iterator]();</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(iterator.next());</span><br><span class="line"><span class="built_in">console</span>.log(iterator.next());</span><br><span class="line"><span class="built_in">console</span>.log(iterator.next());</span><br><span class="line"><span class="built_in">console</span>.log(iterator.next());</span><br><span class="line"><span class="built_in">console</span>.log(iterator.next());</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 输出结果</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">&#123; value: 3, done: false &#125;</span></span><br><span class="line"><span class="comment">&#123; value: 4, done: false &#125;</span></span><br><span class="line"><span class="comment">&#123; value: 5, done: false &#125;</span></span><br><span class="line"><span class="comment">&#123; value: undefined, done: true &#125;</span></span><br><span class="line"><span class="comment">&#123; value: undefined, done: true &#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h3 id="将不可迭代对象转化为可迭代对象"><a href="#将不可迭代对象转化为可迭代对象" class="headerlink" title="将不可迭代对象转化为可迭代对象"></a>将不可迭代对象转化为可迭代对象</h3><h4 id="通过添加Symbol-iterator属性"><a href="#通过添加Symbol-iterator属性" class="headerlink" title="通过添加Symbol.iterator属性"></a>通过添加Symbol.iterator属性</h4><p>因为一个对象是否可迭代是根据是否有Symbol.iterator属性的，因此，我们可以手动添加该生成器</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> test=&#123;</span><br><span class="line">    a:<span class="number">1</span>,</span><br><span class="line">    b:<span class="number">2</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 自建对象一般都是不可迭代的</span></span><br><span class="line"><span class="built_in">console</span>.log(test[<span class="built_in">Symbol</span>.iterator]); <span class="comment">// undefined</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 为不可迭代对象创建Symbol.iterator并赋予一个生成器,使其成为一个可迭代对象</span></span><br><span class="line">test[<span class="built_in">Symbol</span>.iterator]=<span class="function"><span class="keyword">function</span> *(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// this指向test对象</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i <span class="keyword">in</span> <span class="keyword">this</span>) &#123;</span><br><span class="line">        <span class="keyword">yield</span> <span class="keyword">this</span>[i];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 验证是否成为了一个可迭代对象</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> v <span class="keyword">of</span> test) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(v); <span class="comment">// 1 2</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="通过生成器函数"><a href="#通过生成器函数" class="headerlink" title="通过生成器函数"></a>通过生成器函数</h4><p>在前文提到过，由于生成器默认会为传入的对象Symbol.iterator属性赋值，因此，我们只需向生成器函数传入不可迭代对象即可</p><p>例如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> *<span class="title">createIterator</span>(<span class="params">object</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i <span class="keyword">in</span> object) &#123;</span><br><span class="line">        <span class="keyword">yield</span> object[i];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> test=&#123;</span><br><span class="line">    a:<span class="number">1</span>,</span><br><span class="line">    b:<span class="number">2</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> iterator=createIterator(test);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> v <span class="keyword">of</span> iterator) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(v); <span class="comment">// 1,2</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;什么是迭代器&quot;&gt;&lt;a href=&quot;#什么是迭代器&quot; class=&quot;headerlink&quot; title=&quot;什么是迭代器&quot;&gt;&lt;/a&gt;什么是迭代器&lt;/h2&gt;&lt;p&gt;首先，迭代器是一个对象，一个专门为迭代过程设计的对象。所有的迭代器对象都会具有一个next()方法，用来返回
      
    
    </summary>
    
      <category term="ES6" scheme="http://yoursite.com/categories/ES6/"/>
    
    
      <category term="基础语法" scheme="http://yoursite.com/tags/%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>leetcode-257 二叉树的所有路径</title>
    <link href="http://yoursite.com/2019/09/07/leetcode-257/"/>
    <id>http://yoursite.com/2019/09/07/leetcode-257/</id>
    <published>2019-09-07T04:49:58.000Z</published>
    <updated>2019-09-07T04:57:43.739Z</updated>
    
    <content type="html"><![CDATA[<h1 id="二叉树的所有路径"><a href="#二叉树的所有路径" class="headerlink" title="二叉树的所有路径"></a>二叉树的所有路径</h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>给定一个二叉树，返回所有从根节点到叶子节点的路径。</p><p>说明: 叶子节点是指没有子节点的节点。</p><p>示例:</p><p><img src="https://s2.ax1x.com/2019/09/07/nlmn4s.png" alt></p><a id="more"></a><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/binary-tree-paths" target="_blank" rel="noopener">https://leetcode-cn.com/problems/binary-tree-paths</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p><h2 id="核心思路"><a href="#核心思路" class="headerlink" title="核心思路"></a>核心思路</h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>二叉树的路径是根节点到叶子节点上的路径。因此，我们可以传入一个数组，在递归的时候存储每个节点当前的路径，如果遇到叶子节点，就将叶子节点上的路径加入到ans数组</p><h3 id="解题步骤"><a href="#解题步骤" class="headerlink" title="解题步骤"></a>解题步骤</h3><ol><li>设立一个ans数组，用来存放二叉树的路径</li><li>先序遍历二叉树，同时传入一个数组，用来保存当前节点的路径</li><li>如果遇到叶子节点，则将数组存入ans数组中，并return</li><li>访问其左子树和右子树</li><li>递归2,3,4步骤，直到二叉树遍历完毕</li><li>利用map()方法和join()方法将输出满足题目要求</li></ol><h2 id="Coding实现"><a href="#Coding实现" class="headerlink" title="Coding实现"></a>Coding实现</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * function TreeNode(val) &#123;</span></span><br><span class="line"><span class="comment"> *     this.val = val;</span></span><br><span class="line"><span class="comment"> *     this.left = this.right = null;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @param &#123;TreeNode&#125; root</span></span><br><span class="line"><span class="comment"> * @return &#123;string[]&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> binaryTreePaths = <span class="function"><span class="keyword">function</span>(<span class="params">root</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> ans=[];</span><br><span class="line">    (<span class="function"><span class="keyword">function</span> <span class="title">getPath</span>(<span class="params">root,arr</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root===<span class="literal">null</span>) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            arr.push(root.val);</span><br><span class="line">            <span class="keyword">let</span> arrLeft=arr.concat();</span><br><span class="line">            <span class="keyword">let</span> arrRight=arr.concat();</span><br><span class="line">            <span class="keyword">if</span>(!root.left&amp;&amp;!root.right) &#123;</span><br><span class="line">                ans.push(arr);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            getPath(root.left,arrLeft);</span><br><span class="line">            getPath(root.right,arrRight);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)(root,[])</span><br><span class="line">    ans=ans.map(<span class="function"><span class="params">v</span>=&gt;</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> v.join(<span class="string">'-&gt;'</span>);</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;二叉树的所有路径&quot;&gt;&lt;a href=&quot;#二叉树的所有路径&quot; class=&quot;headerlink&quot; title=&quot;二叉树的所有路径&quot;&gt;&lt;/a&gt;二叉树的所有路径&lt;/h1&gt;&lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h2&gt;&lt;p&gt;给定一个二叉树，返回所有从根节点到叶子节点的路径。&lt;/p&gt;
&lt;p&gt;说明: 叶子节点是指没有子节点的节点。&lt;/p&gt;
&lt;p&gt;示例:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://s2.ax1x.com/2019/09/07/nlmn4s.png&quot; alt&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="leetcode题解与算法" scheme="http://yoursite.com/categories/leetcode%E9%A2%98%E8%A7%A3%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="树" scheme="http://yoursite.com/tags/%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>leetcode-242 有效的字母异位词</title>
    <link href="http://yoursite.com/2019/09/05/leetcode-242/"/>
    <id>http://yoursite.com/2019/09/05/leetcode-242/</id>
    <published>2019-09-05T11:58:38.000Z</published>
    <updated>2019-09-05T12:03:39.170Z</updated>
    
    <content type="html"><![CDATA[<h1 id="有效的字母异位词"><a href="#有效的字母异位词" class="headerlink" title="有效的字母异位词"></a>有效的字母异位词</h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>给定两个字符串 s 和 t ，编写一个函数来判断 t 是否是 s 的字母异位词。</p><p>示例 1:</p><blockquote><p>输入: s = “anagram”, t = “nagaram”<br>输出: true</p></blockquote><p>示例 2:</p><blockquote><p>输入: s = “rat”, t = “car”<br>输出: false</p></blockquote><p>说明:<br>你可以假设字符串只包含小写字母。</p><p>进阶:<br>如果输入字符串包含 unicode 字符怎么办？你能否调整你的解法来应对这种情况？</p><a id="more"></a><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/valid-anagram" target="_blank" rel="noopener">https://leetcode-cn.com/problems/valid-anagram</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p><h2 id="核心思路"><a href="#核心思路" class="headerlink" title="核心思路"></a>核心思路</h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>判断两个字符串互相是不是字母异位词，这也就意味着，两个字符串内的每个字符数量都是相同的。因此，我们只需要设定一个map集合来存储每个字符的数量即可</p><h3 id="解题步骤"><a href="#解题步骤" class="headerlink" title="解题步骤"></a>解题步骤</h3><ol><li>如果两字符的长度不一样则返回false</li><li>如果两字符相等，返回true</li><li>设定map集合，遍历其中一个字符串，以字符和字符个数为键值对存入哈希表中</li><li>遍历另一个字符串，如果出现哈希表中没有的字符，则返回false；如果是哈希表中已有的字符，那么将该键值减一</li><li>遍历哈希表，如果所有的键值都为0，那么返回true；否则返回false</li></ol><h2 id="Coding实现"><a href="#Coding实现" class="headerlink" title="Coding实现"></a>Coding实现</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @param &#123;string&#125; s</span></span><br><span class="line"><span class="comment"> * @param &#123;string&#125; t</span></span><br><span class="line"><span class="comment"> * @return &#123;boolean&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> isAnagram = <span class="function"><span class="keyword">function</span>(<span class="params">s, t</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(s.length!==t.length) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">if</span>(s===t) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">let</span> map=<span class="keyword">new</span> <span class="built_in">Map</span>();</span><br><span class="line">    <span class="keyword">let</span> flag=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> v <span class="keyword">of</span> s) &#123;</span><br><span class="line">        <span class="keyword">if</span>(map.has(v)) &#123;</span><br><span class="line">            map.set(v,map.get(v)+<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            map.set(v,<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> v <span class="keyword">of</span> t) &#123;</span><br><span class="line">        <span class="keyword">if</span>(map.has(v)) &#123;</span><br><span class="line">            map.set(v,map.get(v)<span class="number">-1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    map.forEach(<span class="function"><span class="params">v</span>=&gt;</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(v!==<span class="number">0</span>) flag=<span class="number">0</span>; </span><br><span class="line">    &#125;)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Boolean</span>(flag);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;有效的字母异位词&quot;&gt;&lt;a href=&quot;#有效的字母异位词&quot; class=&quot;headerlink&quot; title=&quot;有效的字母异位词&quot;&gt;&lt;/a&gt;有效的字母异位词&lt;/h1&gt;&lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h2&gt;&lt;p&gt;给定两个字符串 s 和 t ，编写一个函数来判断 t 是否是 s 的字母异位词。&lt;/p&gt;
&lt;p&gt;示例 1:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;输入: s = “anagram”, t = “nagaram”&lt;br&gt;输出: true&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;示例 2:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;输入: s = “rat”, t = “car”&lt;br&gt;输出: false&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;说明:&lt;br&gt;你可以假设字符串只包含小写字母。&lt;/p&gt;
&lt;p&gt;进阶:&lt;br&gt;如果输入字符串包含 unicode 字符怎么办？你能否调整你的解法来应对这种情况？&lt;/p&gt;
    
    </summary>
    
      <category term="leetcode题解与算法" scheme="http://yoursite.com/categories/leetcode%E9%A2%98%E8%A7%A3%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="哈希表" scheme="http://yoursite.com/tags/%E5%93%88%E5%B8%8C%E8%A1%A8/"/>
    
  </entry>
  
</feed>
