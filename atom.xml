<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Hexo</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://angellike_fairy.gitee.io/angellikefairy/"/>
  <updated>2019-12-18T08:34:04.585Z</updated>
  <id>http://angellike_fairy.gitee.io/angellikefairy/</id>
  
  <author>
    <name>Angel</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>TypeScript元数据的理解与使用</title>
    <link href="http://angellike_fairy.gitee.io/angellikefairy/2019/12/16/TypeScript%E5%85%83%E6%95%B0%E6%8D%AE%E7%9A%84%E7%90%86%E8%A7%A3%E4%B8%8E%E4%BD%BF%E7%94%A8/"/>
    <id>http://angellike_fairy.gitee.io/angellikefairy/2019/12/16/TypeScript元数据的理解与使用/</id>
    <published>2019-12-16T07:29:14.000Z</published>
    <updated>2019-12-18T08:34:04.585Z</updated>
    
    <content type="html"><![CDATA[<h2 id="元数据"><a href="#元数据" class="headerlink" title="元数据"></a>元数据</h2><p>我们知道,TS仅在代码设计时使用类型，但一些特性，注入依赖注入，运行时类型断言、反射和测试，需要运行时的类型信息才可以实现。</p><p>因此，TS使用了反射元信息API来获取元数据。</p><h3 id="什么是元数据"><a href="#什么是元数据" class="headerlink" title="什么是元数据"></a>什么是元数据</h3><p>元数据是用来定义数据的数据。例如，对于一个数据A，它会具有值，数据类型等等描述这个数据的数据。这样的数据，我们称之为元数据。</p><p>通过元数据反射API，我们可以为数据添加和获取元数据</p><blockquote><p>Reflect Metadata 的 API 可以用于类或者类的属性上</p></blockquote><p>当我们为类或类的属性添加了元数据之后，构造函数或者构造函数的原型将会具有一个新的[[Metadata]]内部属性,该属性将包含一个Map，其键是属性键（或undefined），其值是元数据键值</p><p>元数据的定义具有以下特征：</p><ol><li>当在类C声明上或者类C的静态成员上定义元数据时，元数据会存储在C.[[Metadata]]中</li><li>当在类C的实例成员上定义元数据时，元数据会存储在C.prototype.[[Metadata]]中</li></ol><p>TS定义了三种保留元数据键</p><ol><li>类型元数据使用元数据键”design:type”（用来获取属性类型）</li><li>参数类型元数据使用元数据键”design:paramtypes”（用来获取参数类型）</li><li>返回值类型元数据使用元数据键”design:returntype”（用来获取返回值类型）</li></ol><h3 id="元数据的定义和添加"><a href="#元数据的定义和添加" class="headerlink" title="元数据的定义和添加"></a>元数据的定义和添加</h3><p>我们有以下三种方式进行元数据的定义：</p><ol><li>通过为类或类中的成员定义一个装饰器</li><li>通过Reflect.metadata声明式定义</li><li>通过Reflect.defineMetadata命令式定义</li></ol><p>注意：</p><blockquote><p>如果没有进行这三种方式的定义，我们无法通过反射元数据API来获得元数据</p></blockquote><h4 id="通过为类或类中的成员定义一个装饰器"><a href="#通过为类或类中的成员定义一个装饰器" class="headerlink" title="通过为类或类中的成员定义一个装饰器"></a>通过为类或类中的成员定义一个装饰器</h4><p>事实上，这是我在元编程实战的时候发现的。当我将TS代码翻译成ES5代码的时候，我发现了这个特性。</p><p>当我们为类或类中的成员使用装饰器时，ES会默认为其添加上元数据的信息。但是，这会有以下几种不同的情况</p><ol><li>当我们为类使用装饰器是，只会为类添加上”design:paramtypes”的元数据信息，含义为其构造函数的传入参数的类型数组</li><li>当我们为类中的属性使用装饰器时，只会为该属性添加上”design:type”的元数据，含义为该属性的类型</li><li>当我们为类中的方法使用装饰器时，会为该属性添加上所有三种保留元数据键，含义分别为方法的类型，传入该方法的形参类型数组，该方法的返回值的类型</li></ol><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">"Reflect-metadata"</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> <span class="keyword">constructor</span>&lt;T = any&gt; = new(<span class="params">...args: <span class="built_in">Array</span>&lt;<span class="built_in">any</span>&gt;</span>) =&gt; T;</span><br><span class="line"></span><br><span class="line">@log</span><br><span class="line">class A &#123;</span><br><span class="line">    <span class="meta">@log</span></span><br><span class="line">    <span class="keyword">static</span> n: <span class="built_in">string</span> = <span class="string">'hello'</span>;</span><br><span class="line">    <span class="keyword">constructor</span>(<span class="params"><span class="keyword">private</span> m: <span class="built_in">string</span></span>) &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@log</span></span><br><span class="line">    getMes(mes:<span class="built_in">number</span>): <span class="built_in">number</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> mes;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">log</span>&lt;<span class="title">T</span>&gt;(<span class="params">constructor: constructor&lt;T&gt;|&#123;&#125;,propertyName?: <span class="built_in">string</span>,descriptor?: PropertyDescriptor</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">type</span>: <span class="built_in">Function</span>,paramtypes: <span class="built_in">Array</span>&lt;<span class="built_in">Function</span>&gt;,returntype: <span class="built_in">Function</span>;</span><br><span class="line">    <span class="keyword">type</span> = Reflect.getMetadata(<span class="string">"design:type"</span>,<span class="keyword">constructor</span>,propertyName);</span><br><span class="line">    if(<span class="params">descriptor</span>) &#123;</span><br><span class="line">        paramtypes = Reflect.getMetadata(<span class="string">"design:paramtypes"</span>,<span class="keyword">constructor</span>,propertyName);</span><br><span class="line">        returntype = Reflect.getMetadata(<span class="params">"design:returntype",constructor,propertyName</span>);</span><br><span class="line">        console.log(<span class="params">propertyName,<span class="keyword">type</span>,paramtypes,returntype</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    else &#123;</span><br><span class="line">        <span class="keyword">if</span>(propertyName) &#123;</span><br><span class="line">            <span class="built_in">console</span>.log(propertyName,<span class="keyword">type</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            paramtypes = Reflect.getMetadata(<span class="string">"design:paramtypes"</span>,<span class="keyword">constructor</span>);</span><br><span class="line">            console.log(<span class="params">constructor,paramtypes</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">export &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 输出结果</span></span><br><span class="line"><span class="comment">getMes [Function: Function] [ [Function: Number] ] [Function: Number]</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">n [Function: String]</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">[Function: A] &#123; n: 'hello' &#125; [ [Function: String] ]</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>当我们查看其编译成ES5的代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">"use strict"</span>;</span><br><span class="line"><span class="keyword">var</span> __decorate = (<span class="keyword">this</span> &amp;&amp; <span class="keyword">this</span>.__decorate) || <span class="function"><span class="keyword">function</span> (<span class="params">decorators, target, key, desc</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> c = <span class="built_in">arguments</span>.length, r = c &lt; <span class="number">3</span> ? target : desc === <span class="literal">null</span> ? desc = <span class="built_in">Object</span>.getOwnPropertyDescriptor(target, key) : desc, d;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="built_in">Reflect</span> === <span class="string">"object"</span> &amp;&amp; <span class="keyword">typeof</span> <span class="built_in">Reflect</span>.decorate === <span class="string">"function"</span>) r = <span class="built_in">Reflect</span>.decorate(decorators, target, key, desc);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">for</span> (<span class="keyword">var</span> i = decorators.length - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) <span class="keyword">if</span> (d = decorators[i]) r = (c &lt; <span class="number">3</span> ? d(r) : c &gt; <span class="number">3</span> ? d(target, key, r) : d(target, key)) || r;</span><br><span class="line">    <span class="keyword">return</span> c &gt; <span class="number">3</span> &amp;&amp; r &amp;&amp; <span class="built_in">Object</span>.defineProperty(target, key, r), r;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> __metadata = (<span class="keyword">this</span> &amp;&amp; <span class="keyword">this</span>.__metadata) || <span class="function"><span class="keyword">function</span> (<span class="params">k, v</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="built_in">Reflect</span> === <span class="string">"object"</span> &amp;&amp; <span class="keyword">typeof</span> <span class="built_in">Reflect</span>.metadata === <span class="string">"function"</span>) <span class="keyword">return</span> <span class="built_in">Reflect</span>.metadata(k, v);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">Object</span>.defineProperty(exports, <span class="string">"__esModule"</span>, &#123; <span class="attr">value</span>: <span class="literal">true</span> &#125;);</span><br><span class="line"><span class="built_in">require</span>(<span class="string">"Reflect-metadata"</span>);</span><br><span class="line"><span class="keyword">var</span> A = <span class="comment">/** @class */</span> (<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">A</span>(<span class="params">m</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.m = m;</span><br><span class="line">    &#125;</span><br><span class="line">    A.prototype.getMes = <span class="function"><span class="keyword">function</span> (<span class="params">mes</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> mes;</span><br><span class="line">    &#125;;</span><br><span class="line">    A.n = <span class="string">'hello'</span>;</span><br><span class="line">    __decorate([</span><br><span class="line">        log,</span><br><span class="line">        __metadata(<span class="string">"design:type"</span>, <span class="built_in">Function</span>),</span><br><span class="line">        __metadata(<span class="string">"design:paramtypes"</span>, [<span class="built_in">Number</span>]),</span><br><span class="line">        __metadata(<span class="string">"design:returntype"</span>, <span class="built_in">Number</span>)</span><br><span class="line">    ], A.prototype, <span class="string">"getMes"</span>, <span class="literal">null</span>);</span><br><span class="line">    __decorate([</span><br><span class="line">        log,</span><br><span class="line">        __metadata(<span class="string">"design:type"</span>, <span class="built_in">String</span>)</span><br><span class="line">    ], A, <span class="string">"n"</span>, <span class="keyword">void</span> <span class="number">0</span>);</span><br><span class="line">    A = __decorate([</span><br><span class="line">        log,</span><br><span class="line">        __metadata(<span class="string">"design:paramtypes"</span>, [<span class="built_in">String</span>])</span><br><span class="line">    ], A);</span><br><span class="line">    <span class="keyword">return</span> A;</span><br><span class="line">&#125;());</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">log</span>(<span class="params">constructor, propertyName, descriptor</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> type, paramtypes, returntype;</span><br><span class="line">    type = <span class="built_in">Reflect</span>.getMetadata(<span class="string">"design:type"</span>, <span class="keyword">constructor</span>, propertyName);</span><br><span class="line">    if (descriptor) &#123;</span><br><span class="line">        paramtypes = <span class="built_in">Reflect</span>.getMetadata(<span class="string">"design:paramtypes"</span>, <span class="keyword">constructor</span>, propertyName);</span><br><span class="line">        returntype = Reflect.getMetadata("design:returntype", <span class="keyword">constructor</span>, propertyName);</span><br><span class="line">        console.log(propertyName, type, paramtypes, returntype);</span><br><span class="line">    &#125;</span><br><span class="line">    else &#123;</span><br><span class="line">        <span class="keyword">if</span> (propertyName) &#123;</span><br><span class="line">            <span class="built_in">console</span>.log(propertyName, type);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            paramtypes = <span class="built_in">Reflect</span>.getMetadata(<span class="string">"design:paramtypes"</span>, <span class="keyword">constructor</span>);</span><br><span class="line">            console.log(<span class="keyword">constructor</span>, paramtypes);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">//# sourceMappingURL=hello.js.map</span><br></pre></td></tr></table></figure><p>我们就很容易明白，为类及类中的成员使用装饰器会为它们定义元数据。</p><h4 id="将Reflect-metadata当做装饰器使用进行声明式定义"><a href="#将Reflect-metadata当做装饰器使用进行声明式定义" class="headerlink" title="将Reflect.metadata当做装饰器使用进行声明式定义"></a>将Reflect.metadata当做装饰器使用进行声明式定义</h4><p>我们可以将Reflect.metadata当做装饰器来使用，直接装饰类或类的属性。</p><blockquote><p>@Reflect.metadata(metadataKey, metadataValue)</p></blockquote><p>使用这样的装饰器语法，就相当于在类或类的属性上添加了元数据的键名和键值。</p><p>例如：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">"reflect-metadata"</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@Reflect</span>.metadata(<span class="string">"name"</span>,<span class="string">"classA"</span>)</span><br><span class="line"><span class="keyword">class</span> A &#123;</span><br><span class="line">    <span class="meta">@Reflect</span>.metadata(<span class="string">"name"</span>,<span class="string">"propertyN"</span>)</span><br><span class="line">    n: <span class="built_in">string</span> = <span class="string">'nice'</span>;</span><br><span class="line">    <span class="meta">@Reflect</span>.metadata(<span class="string">"name"</span>,<span class="string">"propertyK"</span>)</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> k: <span class="built_in">string</span> = <span class="string">"hello"</span>;</span><br><span class="line">    <span class="keyword">constructor</span>(<span class="params"><span class="keyword">public</span> m: <span class="built_in">string</span></span>) &#123;&#125;</span><br><span class="line">    <span class="meta">@Reflect</span>.metadata(<span class="string">"name"</span>,<span class="string">"funcGet"</span>)</span><br><span class="line">    <span class="keyword">get</span>() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.m;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(Reflect.getMetadata(<span class="string">"name"</span>,A));</span><br><span class="line"><span class="built_in">console</span>.log(Reflect.getMetadata(<span class="string">"name"</span>,A,<span class="string">"k"</span>));</span><br><span class="line"><span class="built_in">console</span>.log(Reflect.getMetadata(<span class="string">"name"</span>,A.prototype,<span class="string">"get"</span>));</span><br><span class="line"><span class="built_in">console</span>.log(Reflect.getMetadata(<span class="string">"name"</span>,A.prototype,<span class="string">"n"</span>));</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 输出结果</span></span><br><span class="line"><span class="comment">classA</span></span><br><span class="line"><span class="comment">propertyK</span></span><br><span class="line"><span class="comment">funcGet</span></span><br><span class="line"><span class="comment">propertyN</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h4 id="使用Reflect-defineMetadata进行命令式定义"><a href="#使用Reflect-defineMetadata进行命令式定义" class="headerlink" title="使用Reflect.defineMetadata进行命令式定义"></a>使用Reflect.defineMetadata进行命令式定义</h4><p>“Reflect-metadata”提供了Reflect.defineMetadata来对元数据进行命令式的定义。与之前定义元数据的目标一致，我们可以用命令式定义API来定义类或类的成员（属性和方法），其有以下两种语法：</p><ol><li><p>为类定义元数据</p><blockquote><p>Reflect.defineMetadata(metadataKey, metadataValue, target)</p></blockquote></li><li><p>为类的成员（属性和方法）定义元数据</p><blockquote><p>Reflect.defineMetadata(metadataKey, metadataValue, target, propertyKey)</p></blockquote></li></ol><p>例如：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">"Reflect-metadata"</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> A &#123;</span><br><span class="line">    <span class="keyword">static</span> m: <span class="built_in">string</span> = <span class="string">"hello"</span>;</span><br><span class="line">    <span class="keyword">constructor</span>(<span class="params"><span class="keyword">public</span> n: <span class="built_in">string</span></span>) &#123;&#125;</span><br><span class="line">    getMes(): <span class="built_in">string</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.n;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Reflect.defineMetadata(<span class="string">"name"</span>,<span class="string">"classA"</span>,A);</span><br><span class="line">Reflect.defineMetadata(<span class="string">"name"</span>,<span class="string">"propertyM"</span>,A,<span class="string">"m"</span>);</span><br><span class="line">Reflect.defineMetadata(<span class="string">"name"</span>,<span class="string">"propertyGetMes"</span>,A.prototype,<span class="string">"getMes"</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(Reflect.getMetadata(<span class="string">"name"</span>,A));</span><br><span class="line"><span class="built_in">console</span>.log(Reflect.getMetadata(<span class="string">"name"</span>,A,<span class="string">"m"</span>));</span><br><span class="line"><span class="built_in">console</span>.log(Reflect.getMetadata(<span class="string">"name"</span>,A.prototype,<span class="string">"getMes"</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 输出结果</span></span><br><span class="line"><span class="comment">classA</span></span><br><span class="line"><span class="comment">propertyM</span></span><br><span class="line"><span class="comment">propertyGetMes</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h3 id="Reflect-getMetadata获取元数据信息"><a href="#Reflect-getMetadata获取元数据信息" class="headerlink" title="Reflect.getMetadata获取元数据信息"></a>Reflect.getMetadata获取元数据信息</h3><p>我们可以通过以下的反射元数据API来获取元数据的信息</p><ol><li>获取类（构造函数）上的元数据<blockquote><p>Reflect.getMetadata(metadataKey, target);</p></blockquote></li><li>获取静态成员或实例成员的元数据<blockquote><p>Reflect.hasOwnMetadata(metadataKey, target, propertyKey);</p></blockquote></li></ol><p>其中,metadataKey表示元数据键,target表示构造函数或者是构造函数的原型，peropertyKey表示属性或者是方法</p><p>除了自定义的元数据键(metadataKey)，还有三种常用的保留元数据键</p><ol><li>类型元数据使用元数据键”design:type”（用来获取属性类型）</li><li>参数类型元数据使用元数据键”design:paramtypes”（用来获取参数类型）</li><li>返回值类型元数据使用元数据键”design:returntype”（用来获取返回值类型）</li></ol><p>例如：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">"Reflect-metadata"</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用类型别名，将构造函数类型别名为使用泛型的Construct&lt;T = any&gt;</span></span><br><span class="line"><span class="keyword">type</span> Construct&lt;T = <span class="built_in">any</span>&gt; = <span class="keyword">new</span> (...args: <span class="built_in">Array</span>&lt;<span class="built_in">any</span>&gt;) =&gt; T</span><br><span class="line"></span><br><span class="line"><span class="comment">// 为类添加装饰器使得类具有保留元数据（只具有"design:paramtyps"元数据键，表示该构造函数的所有形参类型数组）</span></span><br><span class="line"><span class="meta">@Injectable</span></span><br><span class="line"><span class="keyword">class</span> A &#123;</span><br><span class="line">    <span class="comment">// 对类中的属性使用Reflect.metadata装饰器进行声明式定义，同样，该属性也会具有保留元数据（只具有"design:type"元数据键，表示该属性的类型）。另外，该属性还具有声明式定义的元数据键值对“name:propertyM”</span></span><br><span class="line">    <span class="meta">@Reflect</span>.metadata(<span class="string">"name"</span>,<span class="string">"propertyM"</span>)</span><br><span class="line">    <span class="keyword">static</span> m: <span class="built_in">string</span> = <span class="string">"hello"</span>;</span><br><span class="line">    <span class="keyword">constructor</span>(<span class="params"><span class="keyword">public</span> n: <span class="built_in">string</span></span>) &#123;&#125;</span><br><span class="line">    getMes(): <span class="built_in">string</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.n;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Injectable</span>&lt;<span class="title">T</span>&gt;(<span class="params">constructor: Construct&lt;T&gt;</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> paramtypes = Reflect.getMetadata(<span class="string">"design:paramtypes"</span>,<span class="keyword">constructor</span>);</span><br><span class="line">    console.log(<span class="params">"传递给类A的构造函数的参数类型数组",paramtypes</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">console.log(<span class="params">Reflect.getMetadata(<span class="string">"design:type"</span>,A,<span class="string">"m"</span>)</span>);</span><br><span class="line"></span><br><span class="line">// 使用Reflect.defineMetadata进行命令式定义时，则不会为其添加保留元数据键，而只是添加命令式定义的元数据键值对“name:propertyGetMes”</span><br><span class="line">Reflect.defineMetadata(<span class="params">"name","propertyGetMes",A.prototype,"getMes"</span>);</span><br><span class="line">console.log(<span class="params">Reflect.getMetadata(<span class="string">"name"</span>,A.prototype,<span class="string">"getMes"</span>)</span>);</span><br><span class="line">console.log(<span class="params">Reflect.getMetadata(<span class="string">"design:returntype"</span>,A.prototype,<span class="string">"getMes"</span>)</span>);</span><br><span class="line"></span><br><span class="line">/* 输出结果</span><br><span class="line">传递给类A的构造函数的参数类型数组 [ [Function: String] ]</span><br><span class="line">[Function: String]</span><br><span class="line">propertyGetMes</span><br><span class="line">undefined</span><br><span class="line">*/</span><br></pre></td></tr></table></figure><h3 id="元数据相关总结"><a href="#元数据相关总结" class="headerlink" title="元数据相关总结"></a>元数据相关总结</h3><p>通过以上的所有例子，可以得到以下的元数据相关总结：</p><ul><li>我们只能为类或者是类中的成员（属性和方法）来进行元数据定义</li><li>我们可以通过三种方式来进行元数据的定义：<ol><li>为类或类的成员使用自定义装饰器</li><li>为类或类的成员使用@Reflect.metadata装饰器进行声明式定义</li><li>使用Reflect.defineMetadata进行命令式定义</li></ol></li><li>只有使用以上三种方式进行元数据定义后，目标对象才会拥有[[Metadata]]属性（默认为不可枚举属性），也就是说才能获取和定义元数据</li><li>为类或类的静态成员定义元数据时，元数据会存储在C.[[Metadata]]中</li><li>为类的实例成员定义元数据时，元数据会存储在C.prototype[[Metadata]]中</li><li>TS为我们定义了三种保留元数据键<ol><li>“design:type” 类型元数据使用元数据键，用来获取元素的属性（只有类中的成员会具有，类本身不具有）</li><li>“design:paramtypes” 参数类型元数据使用元数据键，用来获取参数的类型数组（只有类（构造函数的形参数组），类中的方法（该方法的形参数组）会具有，类的属性不具有）</li><li>“desing:returntype” 返回值元数据使用元数据键，用来获取方法返回值的类型（只有类中的方法会具有，类声明和类中的属性都不具有）</li></ol></li><li>使用Reflect.defineMetadata为类和类中的成员进行命令式定义时，并不会为指定的类或类的成员默认添加保留元数据键，而其他两种定义方法会默认添加</li></ul><h2 id="使用反射元数据和装饰器进行应用"><a href="#使用反射元数据和装饰器进行应用" class="headerlink" title="使用反射元数据和装饰器进行应用"></a>使用反射元数据和装饰器进行应用</h2><h3 id="控制翻转和依赖注入的简单实现"><a href="#控制翻转和依赖注入的简单实现" class="headerlink" title="控制翻转和依赖注入的简单实现"></a>控制翻转和依赖注入的简单实现</h3><p>依赖注入可以通过类构造函数进行注入，也可以通过书信进行注入。在这里，我们只进行类构造函数注入的简单实现。</p><p>我们来模拟Nest.js的依赖注入的简单实现：</p><p>首先，我们需要定义一些基础的装饰器以及IOC容器</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在common.ts中</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"Reflect-metadata"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Construct&lt;T = <span class="built_in">any</span>&gt; = <span class="keyword">new</span> (...args: <span class="built_in">Array</span>&lt;<span class="built_in">any</span>&gt;) =&gt; T;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 声明Injectable装饰器，当为类声明装饰该装饰器时则表示该类是可注入的类</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Injectable</span>&lt;<span class="title">T</span>&gt;(<span class="params">constructor: Construct&lt;T&gt;</span>) </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 声明Controller装饰齐齐，当为类声明装饰器装饰器时则表示该类是控制器模块</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Controller</span>&lt;<span class="title">T</span>&gt;(<span class="params">constructor: Construct&lt;T&gt;</span>) </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 声明简单的IOC容器，用来将对象创建的控制器反转</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Factory</span>&lt;<span class="title">T</span>&gt;(<span class="params">constructor: Construct&lt;T&gt;</span>): <span class="title">T</span> </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> paramtypes = Reflect.getMetadata(<span class="string">"design:paramtypes"</span>,<span class="keyword">constructor</span>);</span><br><span class="line">    let providers = paramtypes.map(<span class="params">(provider: Construct&lt;T&gt;) =&gt; <span class="keyword">new</span> provider()</span>);</span><br><span class="line">    return new <span class="keyword">constructor</span>(<span class="params">...providers</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">export &#123;Injectable,Controller,Factory&#125;</span><br></pre></td></tr></table></figure><p>可以看到，我们只是声明了一些装饰器函数，但我们并没有为装饰器函数添加任何函数体。那么这是为什么呢？我们之前提到过，为类或类的成员使用装饰器会默认为它们添加它们所允许拥有的保留元数据键。这些元数据键我们在之后的Factory函数中需要使用到。</p><p>接下来，我们来定义Service模块和Controller模块</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在cats.service.ts中，该模块为cats的service模块，用来编写业务代码</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> &#123;Injectable&#125; <span class="keyword">from</span> <span class="string">"./common"</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@Injectable</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">class</span> CatsService &#123;</span><br><span class="line">    catName: <span class="built_in">string</span> = <span class="string">"jack"</span>;</span><br><span class="line">    getCatName(): <span class="built_in">string</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.catName;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在cats.controller.ts中，该模块为控制器模块</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> &#123;Controller&#125; <span class="keyword">from</span> <span class="string">"./common"</span></span><br><span class="line"><span class="keyword">import</span> &#123;CatsService&#125; <span class="keyword">from</span> <span class="string">"./cats.service"</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">class</span> CatsController &#123;</span><br><span class="line">    <span class="keyword">constructor</span>(<span class="params"><span class="keyword">public</span> readonly catsService: CatsService</span>) &#123;&#125;</span><br><span class="line">    getCatsServiceMes(): <span class="built_in">string</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.catsService.getCatName();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，在catsController类的构造函数中没有任何函数体，而构造函数的参数前添加了访问限定符public和readonly。这是一种叫做参数属性的特性：</p><blockquote><p>参数属性通过给构造函数参数前面添加一个访问限定符来声明。 使用 private限定一个参数属性会声明并初始化一个私有成员；对于 public，protected和readonly来说也是一样。</p></blockquote><p>使用参数属性，允许我们将声明和赋值合并至一处。</p><p>最后是模拟依赖注入的过程：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在main.ts中</span></span><br><span class="line"><span class="keyword">import</span> &#123;Factory&#125; <span class="keyword">from</span> <span class="string">"./common"</span></span><br><span class="line"><span class="keyword">import</span> &#123;CatsController&#125; <span class="keyword">from</span> <span class="string">"./cats.controller"</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(Factory(CatsController));</span><br><span class="line"><span class="built_in">console</span>.log(Factory(CatsController).getCatsServiceMes());</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 输出结果</span></span><br><span class="line"><span class="comment">catsController &#123; catsService: CatsService &#123; catName: 'jack' &#125; &#125;</span></span><br><span class="line"><span class="comment">jack</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>到这里，我们完成了依赖注入的最简单的实现。总之，实现依赖注入就得需要依靠装饰器和反射元数据API的使用，因为，我们需要在运行中获得参数的类型信息。</p><h3 id="Controller和-Get的简单实现"><a href="#Controller和-Get的简单实现" class="headerlink" title="@Controller和@Get的简单实现"></a>@Controller和@Get的简单实现</h3><p>在Nest.js中，我们经常会使用到这些装饰器。@Controller负责路由控制，@Get表示请求的方法须为get请求</p><p>首先，我们建立Controller和请求方法的装饰器函数</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在common.ts中</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"Reflect-metadata"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Construct&lt;T = <span class="built_in">any</span>&gt; = <span class="keyword">new</span> (...args: <span class="built_in">Array</span>&lt;<span class="built_in">any</span>&gt;) =&gt; T</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> Route &#123;</span><br><span class="line">    route: <span class="built_in">string</span>;</span><br><span class="line">    method: <span class="built_in">string</span>;</span><br><span class="line">    fn: <span class="built_in">Function</span>;</span><br><span class="line">    methodName: <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 建立@Controller装饰器函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Controller</span>(<span class="params">path: <span class="built_in">string</span></span>): <span class="title">Function</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>&lt;<span class="title">T</span>&gt;(<span class="params">constructor: Construct&lt;T&gt;</span>) </span>&#123;</span><br><span class="line">        Reflect.defineMetadata(<span class="string">'path'</span>,<span class="string">'/'</span>+path,<span class="keyword">constructor</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line">// 一个工厂函数，根据传入的请求方法类型来返回一个该类型的装饰器工厂函数</span><br><span class="line">function createMethodsDecorator(<span class="params">method: <span class="built_in">string</span></span>): Function &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">routeName: <span class="built_in">string</span></span>): <span class="title">Function</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">target: <span class="built_in">any</span>,propertyName: <span class="built_in">string</span>,descriptor: PropertyDescriptor</span>) </span>&#123;</span><br><span class="line">            <span class="comment">// @Get之类的装饰器会装饰实例方法。因此，为该实例方法设定元数据route路由路径和method请求方法</span></span><br><span class="line">            Reflect.defineMetadata(<span class="string">"route"</span>,<span class="string">'/'</span>+routeName,target,propertyName);</span><br><span class="line">            Reflect.defineMetadata(<span class="string">"method"</span>,method,target,propertyName);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 路径信息解析函数，传入的参数为控制器类，返回该控制器的所有路由信息</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">mapRoute</span>&lt;<span class="title">T</span>&gt;(<span class="params">constructor: Construct&lt;T&gt;</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 得到控制器路径，即@Controller()中的参数值</span></span><br><span class="line">    <span class="keyword">let</span> pathName = Reflect.getMetadata(<span class="string">"path"</span>,<span class="keyword">constructor</span>);</span><br><span class="line">    let routes: Array&lt;Object&gt; = [];</span><br><span class="line">    let proto = <span class="keyword">constructor</span>.prototype;</span><br><span class="line">    // 过滤掉类的原型中不是函数的属性</span><br><span class="line">    let funcs = Object.keys(<span class="params">proto</span>).filter(<span class="params">item =&gt; (<span class="keyword">typeof</span> proto[item] === <span class="string">'function'</span>)</span>);</span><br><span class="line">    funcs.forEach(<span class="params">funcName=&gt;&#123;</span></span><br><span class="line"><span class="params">        <span class="comment">// 得到@Get()中的参数值</span></span></span><br><span class="line"><span class="params">        <span class="keyword">let</span> route = Reflect.getMetadata(<span class="string">"route"</span>,proto,funcName);</span></span><br><span class="line"><span class="params">        route = pathName + route;</span></span><br><span class="line"><span class="params">        <span class="comment">// 得到为该方法设定的允许请求方法</span></span></span><br><span class="line"><span class="params">        <span class="keyword">let</span> method = Reflect.getMetadata(<span class="string">"method"</span>,proto,funcName);</span></span><br><span class="line"><span class="params">        <span class="keyword">let</span> fn = proto[funcName];</span></span><br><span class="line"><span class="params">        <span class="keyword">let</span> routeMes: Route = &#123;</span></span><br><span class="line"><span class="params">            route,</span></span><br><span class="line"><span class="params">            method,</span></span><br><span class="line"><span class="params">            fn,</span></span><br><span class="line"><span class="params">            methodName: funcName</span></span><br><span class="line"><span class="params">        &#125;;</span></span><br><span class="line"><span class="params">        routes.push(routeMes)</span></span><br><span class="line"><span class="params">    &#125;</span>)</span><br><span class="line">    return &#123;</span><br><span class="line">        pathName,</span><br><span class="line">        routes</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 通过上述工厂函数得到装饰器工厂函数</span><br><span class="line">const Get = createMethodsDecorator(<span class="params">'GET'</span>);</span><br><span class="line">const Post = createMethodsDecorator(<span class="params">'POST'</span>);</span><br><span class="line"></span><br><span class="line">export &#123;Controller,Get,Post,mapRoute&#125;</span><br></pre></td></tr></table></figure><p>接着，我们编写控制器模块</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在cats.controller.ts中</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> &#123;Controller,Get,Post&#125; <span class="keyword">from</span> <span class="string">"./common"</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@Controller</span>(<span class="string">"cats"</span>)</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">class</span> CatsController &#123;</span><br><span class="line">    <span class="meta">@Get</span>(<span class="string">'findAll'</span>)</span><br><span class="line">    findAll(): <span class="built_in">string</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Find all"</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Get</span>(<span class="string">'findOne'</span>)</span><br><span class="line">    findOne(): <span class="built_in">string</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Find one"</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Post</span>(<span class="string">'create'</span>)</span><br><span class="line">    create(): <span class="built_in">string</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Create succeed"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接着，我们需要解析这个控制器得到相应的路径信息，并且创建http服务器进行请求监听</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在main.ts中</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> http <span class="keyword">from</span> <span class="string">"http"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> &#123;mapRoute&#125; <span class="keyword">from</span> <span class="string">"./common"</span></span><br><span class="line"><span class="keyword">import</span> &#123;CatsController&#125; <span class="keyword">from</span> <span class="string">"./cats.controller"</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> controller = mapRoute(CatsController);</span><br><span class="line"></span><br><span class="line">http.createServer(<span class="function">(<span class="params">req,res</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> route of controller.routes) &#123;</span><br><span class="line">        <span class="keyword">let</span> routeName = (route <span class="keyword">as</span> <span class="built_in">any</span>).route;</span><br><span class="line">        <span class="keyword">if</span>(req.url === routeName) &#123;</span><br><span class="line">            res.setHeader(<span class="string">"Content-Type"</span>,<span class="string">"text/palin"</span>);</span><br><span class="line">            res.end((route <span class="keyword">as</span> <span class="built_in">any</span>).fn());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;).listen(<span class="number">3000</span>,<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"Port 3000 is listening"</span>);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>这样我们就完成了从控制器模块到服务器监听程序建立的全部过程了。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;元数据&quot;&gt;&lt;a href=&quot;#元数据&quot; class=&quot;headerlink&quot; title=&quot;元数据&quot;&gt;&lt;/a&gt;元数据&lt;/h2&gt;&lt;p&gt;我们知道,TS仅在代码设计时使用类型，但一些特性，注入依赖注入，运行时类型断言、反射和测试，需要运行时的类型信息才可以实现。&lt;/p&gt;
      
    
    </summary>
    
      <category term="TypeScript" scheme="http://angellike_fairy.gitee.io/angellikefairy/categories/TypeScript/"/>
    
    
  </entry>
  
  <entry>
    <title>在TS中使用混合</title>
    <link href="http://angellike_fairy.gitee.io/angellikefairy/2019/12/14/%E5%9C%A8TS%E4%B8%AD%E4%BD%BF%E7%94%A8%E6%B7%B7%E5%90%88/"/>
    <id>http://angellike_fairy.gitee.io/angellikefairy/2019/12/14/在TS中使用混合/</id>
    <published>2019-12-14T05:33:17.000Z</published>
    <updated>2019-12-14T08:01:32.495Z</updated>
    
    <content type="html"><![CDATA[<h2 id="为什么需要混合"><a href="#为什么需要混合" class="headerlink" title="为什么需要混合"></a>为什么需要混合</h2><p>在TS中，类语法遵循严格的单继承，我们无法通过extends语法来实现多继承</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> Bat <span class="keyword">extends</span> Mammal , WingedAnimal &#123; <span class="comment">// Error: 类只能扩展一个类</span></span><br><span class="line">   <span class="comment">// ...  </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是有时候我们又会遇到一种需求：从可重用组件中创建一个新类。也就是说，我们希望新创建的类可以同时拥有可重用组件中的方法。然而，多继承已经在语法上就予以否决了。因此，我们需要混合的方式来解决这个问题</p><h2 id="什么是混合"><a href="#什么是混合" class="headerlink" title="什么是混合"></a>什么是混合</h2><p>首先，我们需要明确的是：我们无法使用extends语法，因此，我们使用了implements语法来做替代。在这里，我们把基类当做了接口而不是类，因此，在继承的时候，我们只使用了它们的类型定义而非实现。那么，我们需要考虑的就是如何在想要被扩展的类中实现那些接口。</p><p>混合可以帮助我们解决这个问题。</p><p>混合是一个函数。它需要两个参数：</p><ol><li>构造函数（需要扩展的类）</li><li>可重用组件（想要被继承的类）</li></ol><p>之后，混合函数会遍历基类（类实质上是一个构造函数）的原型对象中的所有属性，并复制到我们所需要扩展的类上</p><h2 id="混合的实例"><a href="#混合的实例" class="headerlink" title="混合的实例"></a>混合的实例</h2><p>我们现在来使用混合的方式来实现多继承的替代（事实上这并不是多继承）</p><h3 id="实例1（初级版本：类直接继承多个接口）"><a href="#实例1（初级版本：类直接继承多个接口）" class="headerlink" title="实例1（初级版本：类直接继承多个接口）"></a>实例1（初级版本：类直接继承多个接口）</h3><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 声明并定义基类A,B</span></span><br><span class="line"><span class="keyword">class</span> A &#123;</span><br><span class="line">    basicA() &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'基类A'</span>);</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> B &#123;</span><br><span class="line">    basicB() &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'基类B'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 声明想要被扩展的类C implements A,B</span></span><br><span class="line"><span class="keyword">class</span> C <span class="keyword">implements</span> A,B &#123;</span><br><span class="line">    <span class="comment">// 我们需要预先为继承过来的属性做好类型定义，否则如果后续有调用这些属性的话编译阶段则无法通过</span></span><br><span class="line">    basicA: <span class="function"><span class="params">()</span> =&gt;</span> <span class="built_in">void</span>;</span><br><span class="line">    basicB: <span class="function"><span class="params">()</span> =&gt;</span> <span class="built_in">void</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 实现混合函数applyMixins</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">applyMixins</span>(<span class="params">derivedCtor: <span class="built_in">any</span>, baseCtors: <span class="built_in">Array</span>&lt;<span class="built_in">any</span>&gt;</span>): <span class="title">void</span> </span>&#123;</span><br><span class="line">    baseCtors.forEach(<span class="function"><span class="params">baseCtor</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">Object</span>.getOwnPropertyNames(baseCtor.prototype).forEach(<span class="function"><span class="params">name</span> =&gt;</span> &#123;</span><br><span class="line">            derivedCtor.prototype[name] = baseCtor.prototype[name];</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 应用混合函数</span></span><br><span class="line">applyMixins(C,[A,B]);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> c = <span class="keyword">new</span> C();</span><br><span class="line">c.basicA();</span><br><span class="line">c.basicB();</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 输出结果</span></span><br><span class="line"><span class="comment">基类A</span></span><br><span class="line"><span class="comment">基类B</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>需要注意的是：</p><blockquote><p>我们需要为将要mixin进来的属性方法创建出占位属性。这告诉编译器这些成员在运行时是可用的。否则如果后续有调用这些属性的话编译阶段则无法通过</p></blockquote><h3 id="实例2（改进版本：接口继承多个接口，然后类继承该接口）"><a href="#实例2（改进版本：接口继承多个接口，然后类继承该接口）" class="headerlink" title="实例2（改进版本：接口继承多个接口，然后类继承该接口）"></a>实例2（改进版本：接口继承多个接口，然后类继承该接口）</h3><p>在实例1中，我们需要在想要被扩展的类中预先创立一些站位属性。那么，我们可以避免这个行为吗？</p><p>当然可以。我们可以让这个类继承某个接口，而这个接口会继承那些基类。我们知道，当接口继承某个类的时候，它会继承类的成员但不包括其实现。这就好像接口声明了所有类中存在的成员，但并没有提供具体实现一样。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> A &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> B &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> C implements A,B &#123;&#125;</span><br></pre></td></tr></table></figure><p>最后，这个接口就会具有所有基类的成员但不包括它们的实现。接着，我们只需要定义与接口相同名的类，利用声明合并的特性，那么我们就不需要预先创建占位属性。</p><p>完整实现如下：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> A &#123;</span><br><span class="line">    staticA() &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'基类A'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> B &#123;</span><br><span class="line">    staticB() &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'基类B'</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 接口C多继承类A，B（只继承成员而不继承实现）</span></span><br><span class="line"><span class="keyword">interface</span> C <span class="keyword">extends</span> A,B &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 类C与接口C同名，由于声明合并的特性，因此，该类C会与接口C合并，从而我们不需要显式继承该接口</span></span><br><span class="line"><span class="keyword">class</span> C &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">applyMixins</span>(<span class="params">derivedCtor: <span class="built_in">any</span>, baseCtors: <span class="built_in">Array</span>&lt;<span class="built_in">any</span>&gt;</span>): <span class="title">void</span> </span>&#123;</span><br><span class="line">    baseCtors.forEach(<span class="function"><span class="params">baseCtor</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">Object</span>.getOwnPropertyNames(baseCtor.prototype).forEach(<span class="function"><span class="params">name</span> =&gt;</span> &#123;</span><br><span class="line">            derivedCtor.prototype[name] = baseCtor.prototype[name];</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">applyMixins(C,[A,B]);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> c = <span class="keyword">new</span> C();</span><br><span class="line">c.staticA();</span><br><span class="line">c.staticB();</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 输出结果</span></span><br><span class="line"><span class="comment">基类A</span></span><br><span class="line"><span class="comment">基类B</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h2 id="应用装饰器进行混合"><a href="#应用装饰器进行混合" class="headerlink" title="应用装饰器进行混合"></a>应用装饰器进行混合</h2><p>因为混合函数就是用来修改类的成员，因此，我们很容易可以想到是否可以将以上混合函数applyMixins的调用改为类装饰器</p><p>事实上当然是可行的：</p><p>定义一个装饰器工厂函数用来返回一个装饰器</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">mixins</span>(<span class="params">baseCtors: <span class="built_in">Array</span>&lt;<span class="built_in">any</span>&gt;</span>): <span class="title">Function</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> <span class="title">applyMixins</span>(<span class="params">constructor: <span class="built_in">Function</span></span>): <span class="title">void</span> </span>&#123;</span><br><span class="line">        baseCtors.forEach(<span class="function"><span class="params">baseCtor</span> =&gt;</span> &#123;</span><br><span class="line">            <span class="built_in">Object</span>.getOwnPropertyNames(baseCtor.prototype).forEach(<span class="function"><span class="params">name</span> =&gt;</span> &#123;</span><br><span class="line">                <span class="keyword">constructor</span>.prototype[name] = baseCtor.prototype[name];</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>应用装饰器</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> C <span class="keyword">extends</span> A,B &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@mixins</span>([A,B])</span><br><span class="line"><span class="keyword">class</span> C &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> c = <span class="keyword">new</span> C();</span><br><span class="line">c.staticA();</span><br><span class="line">c.staticB();</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 输出结果</span></span><br><span class="line"><span class="comment">基类A</span></span><br><span class="line"><span class="comment">基类B</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h2 id="混合的限制"><a href="#混合的限制" class="headerlink" title="混合的限制"></a>混合的限制</h2><p>我们之前说混合是一种可以替代多继承的一种可行的方式。但我们知道多继承只能是一个类继承多个接口，因此，我们在继承多个类的时候使用的是implements关键字，从而将类视作是接口，然后，我们使用混合函数的方式来将这些接口实现。</p><p>但如果我们去看混合函数就会发现，我们通过遍历基类上的成员来进行复制。那么如果两个类中有成员是重名的，那么被扩展的类只能继承在给定数组中较后位置的成员值</p><p>例如：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> A &#123;</span><br><span class="line">    staticA() &#123;&#125;</span><br><span class="line">    <span class="keyword">get</span>() &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'基类A中的get方法'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> B &#123;</span><br><span class="line">    <span class="keyword">static</span> B() &#123;&#125;</span><br><span class="line">    <span class="keyword">get</span>() &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'基类B中的get方法'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 需要利用声明合并的特性，因此，我们需要定义两个与类型相同的接口</span></span><br><span class="line"><span class="keyword">interface</span> C <span class="keyword">extends</span> A,B &#123;&#125;</span><br><span class="line"><span class="keyword">interface</span> D <span class="keyword">extends</span> A,B &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@mixins</span>([A,B])</span><br><span class="line"><span class="keyword">class</span> C &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@mixins</span>([B,A])</span><br><span class="line"><span class="keyword">class</span> D &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> c = <span class="keyword">new</span> C();</span><br><span class="line"><span class="keyword">let</span> d = <span class="keyword">new</span> D();</span><br><span class="line"></span><br><span class="line">c.get();</span><br><span class="line">d.get();</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 输出结果</span></span><br><span class="line"><span class="comment">基类B中的get方法</span></span><br><span class="line"><span class="comment">基类A中的get方法</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>注意：</p><blockquote><p>如果不使用声明合并的特性，那么一个类继承某个接口则必须要实现这个接口</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;为什么需要混合&quot;&gt;&lt;a href=&quot;#为什么需要混合&quot; class=&quot;headerlink&quot; title=&quot;为什么需要混合&quot;&gt;&lt;/a&gt;为什么需要混合&lt;/h2&gt;&lt;p&gt;在TS中，类语法遵循严格的单继承，我们无法通过extends语法来实现多继承&lt;/p&gt;
&lt;figure
      
    
    </summary>
    
      <category term="TypeScript" scheme="http://angellike_fairy.gitee.io/angellikefairy/categories/TypeScript/"/>
    
    
  </entry>
  
  <entry>
    <title>代理proxy和反射Reflection的基本使用</title>
    <link href="http://angellike_fairy.gitee.io/angellikefairy/2019/12/09/%E4%BB%A3%E7%90%86proxy%E5%92%8C%E5%8F%8D%E5%B0%84Reflection%E7%9A%84%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/"/>
    <id>http://angellike_fairy.gitee.io/angellikefairy/2019/12/09/代理proxy和反射Reflection的基本使用/</id>
    <published>2019-12-09T05:53:12.000Z</published>
    <updated>2019-12-17T08:28:33.626Z</updated>
    
    <content type="html"><![CDATA[<h2 id="ES5的Object-defineProperty"><a href="#ES5的Object-defineProperty" class="headerlink" title="ES5的Object.defineProperty()"></a>ES5的Object.defineProperty()</h2><p>在ES5的时候，我们可以使用Object.defineProperty来对属性的特性做出定义或者修改。例如，我们经常使用到的访问器属性：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">    _item: <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.defineProperty(obj,<span class="string">'item'</span>,&#123;</span><br><span class="line">    <span class="keyword">get</span>() &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'这是访问器方法get'</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>._item;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="keyword">set</span>(item) &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'这是访问器方法set'</span>);</span><br><span class="line">        <span class="keyword">this</span>._item = item;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(obj); <span class="comment">// &#123;_item: 1&#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(obj.item); <span class="comment">// 这是访问器方法get 1</span></span><br><span class="line">obj.item = <span class="number">2</span>; <span class="comment">// 这是访问器方法set</span></span><br><span class="line"><span class="built_in">console</span>.log(obj.item); <span class="comment">// 这是访问器方法get 2</span></span><br></pre></td></tr></table></figure><p>因此，我们可以使用Object.defineProperty来为属性的赋值与访问操作进行拦截从而加入一些自定义的操作。</p><p>到了ES6，语言为我们添加了一些内建对象来允许我们更多地访问JavaScript引擎的能力。</p><p>其中，代理（Proxy）是一种可以拦截并改变底层JavaScript引擎操作的包装器。</p><h2 id="代理和反射"><a href="#代理和反射" class="headerlink" title="代理和反射"></a>代理和反射</h2><h3 id="什么是代理"><a href="#什么是代理" class="headerlink" title="什么是代理"></a>什么是代理</h3><p>那么什么是代理呢？MDN是这样定义的</p><blockquote><p>Proxy 对象用于定义基本操作的自定义行为（如属性查找，赋值，枚举，函数调用等）。</p></blockquote><p>这么看起来，好像Proxy这个内建对象允许我们可以自定义一些JavaScript引擎已有的一些基本操作。但是，代理这个词体现在哪里呢？</p><p>事实上，我们需要调用new Proxy(target,handler)来创建一个target对象的代理。我们将一些自定义的行为会放在handler对象内作为其属性</p><p>之后，我们在代理上做的所有操作都会通过handler中定义的陷阱来执行</p><p>现在，我们来创建一个代理并且进行简单的应用：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">    _item: <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> handler = &#123;</span><br><span class="line">    <span class="keyword">get</span>(trapTarget,key,receiver) &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'这是get代理陷阱'</span>);</span><br><span class="line">        <span class="keyword">return</span> trapTarget[key];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> objProxy = <span class="keyword">new</span> <span class="built_in">Proxy</span>(obj,handler);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(objProxy._item); </span><br><span class="line"><span class="comment">/* 输出结果</span></span><br><span class="line"><span class="comment">这是get代理陷阱</span></span><br><span class="line"><span class="comment">1</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>乍一看，是不是特别像之前提到过的ES5中的Object.defineProperty()为对象属性设置了访问器特性从而进行了拦截。</p><p>的确，我们确实为属性读取操作进行了一层拦截，但是使用的方法却有大的不同。</p><h3 id="什么是反射"><a href="#什么是反射" class="headerlink" title="什么是反射"></a>什么是反射</h3><p>代理用来拦截内建特性的基本操作，而反射则是在代理中提供这些基本操作。</p><p>也就是说，如果我们在代理中仍旧需要内建特性，那么我们就必须得使用反射API</p><h3 id="常用的代理陷阱与相应的反射API"><a href="#常用的代理陷阱与相应的反射API" class="headerlink" title="常用的代理陷阱与相应的反射API"></a>常用的代理陷阱与相应的反射API</h3><p>我们将代理要执行的一些操作称为代理陷阱。同时，每个代理陷阱都会对应一个命名和参数都相同的反射(Reflect)方法</p><p>以下，是一些常用的代理陷阱及其相应的反射API</p><table><thead><tr><th>代理陷阱</th><th>覆写的特性</th><th>默认特性（反射API）</th></tr></thead><tbody><tr><td>get</td><td>读取一个属性值</td><td>Reflect.get()</td></tr><tr><td>set</td><td>写入一个属性</td><td>Reflect.set()</td></tr><tr><td>has</td><td>判断对象中是否有某属性，相当于in操作符</td><td>Reflect.has()</td></tr><tr><td>deleteProperty</td><td>删除某属性，相当于delete操作符</td><td>Reflect.deleteProperty()</td></tr><tr><td>getPrototypeOf</td><td>返回给定对象的原型，Object.getPrototypeOf()</td><td>Reflect.getPrototypeOf()</td></tr><tr><td>setPrototypeOf</td><td>设置某对象为目标对象的原型</td><td>Reflect.setPrototypeOf()</td></tr><tr><td>getOwnPropertyDescriptor</td><td>获取属性描述符，Object.getOwnPropertyDescriptor()</td><td>Reflect.getOwnPropertyDescriptor()</td></tr><tr><td>defineProperty</td><td>定义或修改属性的特性，Object.defineProperty()</td><td>Reflect.defineProperty()</td></tr><tr><td>apply</td><td>调用一个函数</td><td>Reflect.apply()</td></tr><tr><td>construct</td><td>用new调用一个函数</td><td>Reflect.construct()</td></tr></tbody></table><h2 id="一些常用陷阱及其反射的使用"><a href="#一些常用陷阱及其反射的使用" class="headerlink" title="一些常用陷阱及其反射的使用"></a>一些常用陷阱及其反射的使用</h2><h3 id="get陷阱"><a href="#get陷阱" class="headerlink" title="get陷阱"></a>get陷阱</h3><p>我们使用get陷阱来定义对象属性读取的自定义操作。</p><p>get陷阱接受三个参数：</p><ol><li>trapTarget 代理的目标（被代理的对象），也就是源对象</li><li>key 要读取的属性值</li><li>receiver 代理对象</li></ol><p>需要记住的是，所有与陷阱相对应的反射API都接受对应陷阱接受的参数。在这里也就是说，get陷阱对应的反射API Reflect.get()也同样接受trapTarget,key,receiver这三个参数</p><p>现在，我们来使用get陷阱来写个例子。我们知道，get陷阱覆写的特性是属性的读取，那么我们可以利用get陷阱来对读取操作进行重新的定义</p><p>一般来说，如果某个对象中没有指定要读取的属性则会返回undefined</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">    _item: <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(obj.item); <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure><p>现在，我希望当我读取某个不存在的属性时可以通知我这个属性不存在而不是返回undefined。因为，有些存在的属性但是赋予了undefined值访问后也是返回undefined。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">    _item: <span class="literal">undefined</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(obj._item); <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure><p>因此，我们无法通过undefined来确定某个属性是否存在。但我们可以使用in操作符</p><p>因此，我们可以这样来使用get陷阱来达到我们想要的目的：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">    _item: <span class="number">1</span>,</span><br><span class="line">    item: <span class="literal">undefined</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> handler = &#123;</span><br><span class="line">    <span class="keyword">get</span>(trapTarget,key,receiver) &#123;</span><br><span class="line">        <span class="comment">// 使用in操作符来判断属性是否存在</span></span><br><span class="line">        <span class="keyword">if</span>(!(key <span class="keyword">in</span> trapTarget)) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'该属性不存在'</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果属性存在则使用默认行为</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> <span class="built_in">Reflect</span>.get(trapTarget,key,receiver);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> proxy = <span class="keyword">new</span> <span class="built_in">Proxy</span>(obj,handler);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(proxy._item); <span class="comment">// 1</span></span><br><span class="line"><span class="built_in">console</span>.log(proxy.item); <span class="comment">// undefined</span></span><br><span class="line"><span class="built_in">console</span>.log(proxy.itemA); <span class="comment">// Error: '该属性不存在'</span></span><br></pre></td></tr></table></figure><h3 id="set陷阱"><a href="#set陷阱" class="headerlink" title="set陷阱"></a>set陷阱</h3><p>set陷阱接受以下四个参数：</p><ol><li>trapTarget 被代理的对象 </li><li>key 要设置的属性名</li><li>value 属性名对应的属性值</li><li>receiver 代理</li></ol><p>通常，我们会在设置对象的属性时使用到set陷阱。那么，我们可以在写入的时候为写入的属性值做出限制，比如写入的属性值必须为number类型；当然，对于那些已经存在的属性，当我们要对那些属性值做出修改的时候，属性值也必须为number类型</p><p>那么，我们可以这样写：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">    item: <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> handler = &#123;</span><br><span class="line">    <span class="keyword">set</span>(trapTarget,key,value,receiver) &#123;</span><br><span class="line">        <span class="comment">// 判断要修改或要写入的值是否为非数值</span></span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">isNaN</span>(value)) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'写入的属性值必须为number类型'</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> <span class="built_in">Reflect</span>.set(trapTarget,key,value,receiver);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> objProxy = <span class="keyword">new</span> <span class="built_in">Proxy</span>(obj,handler);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 写入一个新属性</span></span><br><span class="line">objProxy._item = <span class="number">2</span>;</span><br><span class="line"><span class="built_in">console</span>.log(obj);  <span class="comment">// &#123; item: 1, _item: 2 &#125;</span></span><br><span class="line"><span class="comment">// 修改已有属性</span></span><br><span class="line">objProxy.item = <span class="string">'nice'</span>; <span class="comment">// Error: 写入的属性值必须为number类型</span></span><br></pre></td></tr></table></figure><h2 id="为什么Proxy远比Object-defineProperty强大"><a href="#为什么Proxy远比Object-defineProperty强大" class="headerlink" title="为什么Proxy远比Object.defineProperty强大"></a>为什么Proxy远比Object.defineProperty强大</h2><h3 id="Proxy可以监听对象属性的增加和删除"><a href="#Proxy可以监听对象属性的增加和删除" class="headerlink" title="Proxy可以监听对象属性的增加和删除"></a>Proxy可以监听对象属性的增加和删除</h3><p>我们知道在Vue2.x的版本中，数据绑定的实现中是无法监听到属性的增加和删除的。因为，在2.x版本中，通过深层次（递归）遍历每个属性（包括属性值为对象中的属性）然后使用Object.defineProperty来进行数据劫持的，因此，它只能监听属性值的变化。</p><p>但是Proxy通过set陷阱就可以很方便地做到这一点</p><h3 id="Proxy可以监听数组变化（使用push-pop-shift-slice等操作）"><a href="#Proxy可以监听数组变化（使用push-pop-shift-slice等操作）" class="headerlink" title="Proxy可以监听数组变化（使用push,pop,shift,slice等操作）"></a>Proxy可以监听数组变化（使用push,pop,shift,slice等操作）</h3><p>同样的，这些事情也是Object,defineProperty无法做到的，而是用proxy则可以很方便地实现。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;ES5的Object-defineProperty&quot;&gt;&lt;a href=&quot;#ES5的Object-defineProperty&quot; class=&quot;headerlink&quot; title=&quot;ES5的Object.defineProperty()&quot;&gt;&lt;/a&gt;ES5的Objec
      
    
    </summary>
    
      <category term="ES6" scheme="http://angellike_fairy.gitee.io/angellikefairy/categories/ES6/"/>
    
    
  </entry>
  
  <entry>
    <title>防抖与节流</title>
    <link href="http://angellike_fairy.gitee.io/angellikefairy/2019/11/28/%E9%98%B2%E6%8A%96%E4%B8%8E%E8%8A%82%E6%B5%81/"/>
    <id>http://angellike_fairy.gitee.io/angellikefairy/2019/11/28/防抖与节流/</id>
    <published>2019-11-28T05:57:52.000Z</published>
    <updated>2019-11-30T08:51:31.128Z</updated>
    
    <content type="html"><![CDATA[<h2 id="为什么需要防抖与节流"><a href="#为什么需要防抖与节流" class="headerlink" title="为什么需要防抖与节流"></a>为什么需要防抖与节流</h2><p>试着去想象一个场景，当我们在输入框输入内容的时候。如果有一个函数是根据输入框当前输入的内容来进行接口调用。那么，当你在不断输入的时候这个函数就会一直被调用，那么就很容易加重浏览器的负担导致性能降低。</p><p>除此之外，包括当我们点击一个按钮时，如果我们没有立即得到反馈，我们可能就会一直去频繁点击它，导致时间绑定程序不断地被调用；另外，还有scroll事件,resize事件等等</p><p>因此，采用防抖与节流的方式可以让我们降低调用函数的频率，又可以保证功能的正常执行</p><h2 id="防抖"><a href="#防抖" class="headerlink" title="防抖"></a>防抖</h2><h3 id="什么是函数防抖"><a href="#什么是函数防抖" class="headerlink" title="什么是函数防抖"></a>什么是函数防抖</h3><p>一般来说，我们会为需要进行防抖操作的函数设置一个超时时间，这个函数在这段时间内仅仅只会被触发一次。</p><p>更加通俗的来说，防抖对于要被执行的方法</p><p>当然，我们可以选择让这个仅仅只会被触发一次的函数是立即执行还是延迟执行。其中：</p><ol><li>立即执行指第一次触发后函数会立刻执行，之后只有再经过超时时间间隔后才可以被执行</li><li>延迟执行指的是在时间间隔内连续触发的函数只有最后一次会被延时执行</li></ol><h3 id="延迟执行的函数防抖"><a href="#延迟执行的函数防抖" class="headerlink" title="延迟执行的函数防抖"></a>延迟执行的函数防抖</h3><p>延迟执行的函数防抖主要适用于那些需要最后才响应频繁操作的函数。例如，在往输入框不断输入内容的时候希望当内容全部输入完毕后才进行接口的调用</p><h4 id="基本思路"><a href="#基本思路" class="headerlink" title="基本思路"></a>基本思路</h4><p>延迟执行的基本思路是：</p><ol><li>创建一个定时器timer用来保存每一次定时操作返回的定时器ID</li><li>如果我们在超时时间内又一次触发了该函数，那么清空之前设定的定时器，并且将timer绑定新的定时器ID</li><li>这样，只要你在超时时间间隔内无论多少次频繁的触发函数，之前触发的函数都不会响应</li></ol><h4 id="coding实现"><a href="#coding实现" class="headerlink" title="coding实现"></a>coding实现</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">debounce</span>(<span class="params">fn,wait</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 利用闭包的特性，返回函数中访问到的timer都会访问到这个timer</span></span><br><span class="line">    <span class="keyword">let</span> timer = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">...args</span>) </span>&#123;</span><br><span class="line">        <span class="comment">// 若没有到超时时间，函数被触发的话，如果已经有timer，则说明之前已经触发过，那么取消之前的定时器</span></span><br><span class="line">        <span class="keyword">if</span>(timer) clearTimeout(timer);</span><br><span class="line">        <span class="comment">// 这个fn函数永远会在最后一次触发后延时wait秒被执行</span></span><br><span class="line">        timer = setTimeout(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">            fn.apply(<span class="keyword">this</span>,args);</span><br><span class="line">        &#125;,wait);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> button = <span class="built_in">document</span>.getElementById(<span class="string">'button'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> wait = <span class="number">1000</span>;</span><br><span class="line">button.addEventListener(<span class="string">'click'</span>,debounce(alert,wait));</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">alert</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'alert'</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="立即执行的函数防抖"><a href="#立即执行的函数防抖" class="headerlink" title="立即执行的函数防抖"></a>立即执行的函数防抖</h3><p>立即执行的函数防抖要求当函数第一次被触发后就会被执行，但是下一次函数执行与前一次函数执行的时间间隔必须大于超时时间。</p><p>也就是说，当你第一次触发该函数后，该函数会立即被执行。之后，如果你每次触发该函数的时间间隔小于超时时间，那么函数都不会被触发。只有，在你最后一次触发该函数（无论是有效触发（调用成功）还是无效触发（不允许调用））经过超时时间后才可以被再次成功调用</p><p>例如用户给interviewMap点star的时候，我们希望用户点第一下的时候就去调用接口，并且成功之后改变star按钮的样子，用户就可以立马得到反馈是否star成功了，这个情况适用立即执行的防抖函数，它总是在第一次调用，并且下一次调用必须与前一次调用的时间间隔大于wait才会触发。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">debounce</span>(<span class="params">fn,wait</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 还是利用闭包的特性来创建定时器</span></span><br><span class="line">    <span class="keyword">let</span> timer = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">...args</span>) </span>&#123;</span><br><span class="line">        <span class="comment">// 如果定时器为空，那么说明该函数是第一次被触发，那么立即执行它</span></span><br><span class="line">        <span class="keyword">if</span>(!timer) &#123;</span><br><span class="line">            fn.apply(<span class="keyword">this</span>,args);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 否则清空前一个定时器</span></span><br><span class="line">        <span class="keyword">else</span> clearTimeout(timer);</span><br><span class="line">        <span class="comment">// 设定定时器，当时间间隔超过wait后才将timer重新赋予null</span></span><br><span class="line">        timer = setTimeout(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">            timer = <span class="literal">null</span>;</span><br><span class="line">        &#125;,wait);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="两种方式结合的版本"><a href="#两种方式结合的版本" class="headerlink" title="两种方式结合的版本"></a>两种方式结合的版本</h3><p>我们总希望封装的可以更加彻底一点，因此，我们可以利用传入的immediate参数来决定是立即执行防抖还是延迟防抖</p><p>以下是实现：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">debounce</span>(<span class="params">func,wait,immediate</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> timer = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">...args</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(immediate) &#123;</span><br><span class="line">            <span class="keyword">if</span>(timer) clearTimeout(timer);</span><br><span class="line">            <span class="keyword">else</span> func.apply(<span class="keyword">this</span>,args);</span><br><span class="line">            timer = setTimeout(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">                timer = <span class="literal">null</span>;</span><br><span class="line">            &#125;,wait); </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span>(timer) clearTimeout(timer);</span><br><span class="line">            timer = setTimeout(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">                func.apply(<span class="keyword">this</span>,args);</span><br><span class="line">            &#125;,wait) </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="节流"><a href="#节流" class="headerlink" title="节流"></a>节流</h2><h3 id="什么是函数节流"><a href="#什么是函数节流" class="headerlink" title="什么是函数节流"></a>什么是函数节流</h3><p>与防抖不同，防抖是用来将一个多次在超时时间内执行的函数只让其执行一次，无论是立即执行还是延迟执行。</p><p>而节流是将多次执行变成每隔一段时间进行执行。比如，你在10s中按了n次按钮（每次按钮的时间间隔小于给定的超时时间），那么对于节流来说，这n次按钮绑定的事件处理程序不是都执行也不是像防抖一样只执行一次，而是每隔一段给定时间就执行其中一次事件</p><p>简而言之：</p><blockquote><p>当持续触发事件时，保证一定时间段内只调用一次事件处理函数</p></blockquote><p>实现函数节流的方式也有两种：</p><ol><li>时间戳实现函数节流</li><li>定时器实现函数节流</li></ol><h3 id="时间戳实现函数节流"><a href="#时间戳实现函数节流" class="headerlink" title="时间戳实现函数节流"></a>时间戳实现函数节流</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">throttle</span>(<span class="params">func,wait</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> start = <span class="built_in">Date</span>.now();</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">...args</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">let</span> now = <span class="built_in">Date</span>.now();</span><br><span class="line">        <span class="keyword">if</span>(now-start&gt;=wait) &#123;</span><br><span class="line">            func.apply(<span class="keyword">this</span>,args);</span><br><span class="line">            start = now;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="定时器实现函数节流"><a href="#定时器实现函数节流" class="headerlink" title="定时器实现函数节流"></a>定时器实现函数节流</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">throttle</span>(<span class="params">func,wait</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> timer = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">...args</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!timer) &#123;</span><br><span class="line">            timer = setTimeout(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">                func.apply(<span class="keyword">this</span>,args);</span><br><span class="line">                timer = <span class="literal">null</span>;</span><br><span class="line">            &#125;,wait)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;为什么需要防抖与节流&quot;&gt;&lt;a href=&quot;#为什么需要防抖与节流&quot; class=&quot;headerlink&quot; title=&quot;为什么需要防抖与节流&quot;&gt;&lt;/a&gt;为什么需要防抖与节流&lt;/h2&gt;&lt;p&gt;试着去想象一个场景，当我们在输入框输入内容的时候。如果有一个函数是根据输入框
      
    
    </summary>
    
      <category term="javaScript基础" scheme="http://angellike_fairy.gitee.io/angellikefairy/categories/javaScript%E5%9F%BA%E7%A1%80/"/>
    
    
  </entry>
  
  <entry>
    <title>二叉树的递归与非递归遍历</title>
    <link href="http://angellike_fairy.gitee.io/angellikefairy/2019/11/25/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%80%92%E5%BD%92%E4%B8%8E%E9%9D%9E%E9%80%92%E5%BD%92%E9%81%8D%E5%8E%86/"/>
    <id>http://angellike_fairy.gitee.io/angellikefairy/2019/11/25/二叉树的递归与非递归遍历/</id>
    <published>2019-11-25T11:13:54.000Z</published>
    <updated>2019-11-25T13:05:03.464Z</updated>
    
    <content type="html"><![CDATA[<h2 id="二叉树的遍历"><a href="#二叉树的遍历" class="headerlink" title="二叉树的遍历"></a>二叉树的遍历</h2><p>首先，我们做好树建立的准备工作</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> Node&lt;T&gt; &#123;</span><br><span class="line">    val: T;</span><br><span class="line">    left: Node&lt;T&gt;;</span><br><span class="line">    right: Node&lt;T&gt;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> TreeNode&lt;T&gt; <span class="keyword">implements</span> Node&lt;T&gt; &#123;</span><br><span class="line">    val: T;</span><br><span class="line">    left = <span class="literal">null</span>;</span><br><span class="line">    right = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">constructor</span>(<span class="params">val: T</span>) &#123;</span><br><span class="line">        <span class="keyword">this</span>.val = val;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> a = <span class="keyword">new</span> TreeNode(<span class="string">'a'</span>);</span><br><span class="line"><span class="keyword">let</span> b = <span class="keyword">new</span> TreeNode(<span class="string">'b'</span>);</span><br><span class="line"><span class="keyword">let</span> c = <span class="keyword">new</span> TreeNode(<span class="string">'c'</span>);</span><br><span class="line"><span class="keyword">let</span> d = <span class="keyword">new</span> TreeNode(<span class="string">'d'</span>);</span><br><span class="line"><span class="keyword">let</span> e = <span class="keyword">new</span> TreeNode(<span class="string">'e'</span>);</span><br><span class="line"><span class="keyword">let</span> f = <span class="keyword">new</span> TreeNode(<span class="string">'f'</span>);</span><br><span class="line"><span class="keyword">let</span> g = <span class="keyword">new</span> TreeNode(<span class="string">'g'</span>);</span><br><span class="line"><span class="keyword">let</span> h = <span class="keyword">new</span> TreeNode(<span class="string">'h'</span>);</span><br><span class="line"></span><br><span class="line">a.left = b;</span><br><span class="line">a.right = c;</span><br><span class="line">b.left = d;</span><br><span class="line">b.right = e;</span><br><span class="line">d.right = f;</span><br><span class="line">e.left = g;</span><br><span class="line">f.right = h;</span><br></pre></td></tr></table></figure><h3 id="先序遍历"><a href="#先序遍历" class="headerlink" title="先序遍历"></a>先序遍历</h3><h4 id="递归实现"><a href="#递归实现" class="headerlink" title="递归实现"></a>递归实现</h4><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">preOrder</span>&lt;<span class="title">T</span>&gt;(<span class="params">root: TreeNode&lt;T&gt;</span>): <span class="title">Array</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root === <span class="literal">null</span>) <span class="keyword">return</span> [];</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Array</span>.of(root.val).concat(preOrder&lt;T&gt;(root.left)).concat(preOrder&lt;T&gt;(root.right));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="非递归实现"><a href="#非递归实现" class="headerlink" title="非递归实现"></a>非递归实现</h4><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">preOrder</span>&lt;<span class="title">T</span>&gt;(<span class="params">root: TreeNode&lt;T&gt;</span>): <span class="title">Array</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> result: <span class="built_in">Array</span>&lt;T&gt; = [];</span><br><span class="line">    <span class="keyword">let</span> stack: <span class="built_in">Array</span>&lt;TreeNode&lt;T&gt;&gt; = [];</span><br><span class="line">    <span class="keyword">while</span>(root||stack.length&gt;<span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span>(root) &#123;</span><br><span class="line">            stack.push(root);</span><br><span class="line">            result.push(root.val);</span><br><span class="line">            root = root.left;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">let</span> node = stack.pop();</span><br><span class="line">            root = node.right;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="中序遍历"><a href="#中序遍历" class="headerlink" title="中序遍历"></a>中序遍历</h3><h4 id="递归实现-1"><a href="#递归实现-1" class="headerlink" title="递归实现"></a>递归实现</h4><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">inOrder</span>&lt;<span class="title">T</span>&gt;(<span class="params">root: TreeNode&lt;T&gt;</span>): <span class="title">Array</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root === <span class="literal">null</span>) <span class="keyword">return</span> [];</span><br><span class="line">    <span class="keyword">return</span> inOrder&lt;T&gt;(root.left).concat(<span class="built_in">Array</span>.of(root.val)).concat(inOrder&lt;T&gt;(root.right));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="非递归实现-1"><a href="#非递归实现-1" class="headerlink" title="非递归实现"></a>非递归实现</h4><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">inOrder</span>&lt;<span class="title">T</span>&gt;(<span class="params">root: TreeNode&lt;T&gt;</span>): <span class="title">Array</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> result: <span class="built_in">Array</span>&lt;T&gt; = [];</span><br><span class="line">    <span class="keyword">let</span> stack: <span class="built_in">Array</span>&lt;TreeNode&lt;T&gt;&gt; = [];</span><br><span class="line">    <span class="keyword">while</span>(root||stack.length&gt;<span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span>(root) &#123;</span><br><span class="line">            stack.push(root);</span><br><span class="line">            root = root.left;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">let</span> node = stack.pop();</span><br><span class="line">            result.push(node.val);</span><br><span class="line">            root = node.right;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="后序遍历"><a href="#后序遍历" class="headerlink" title="后序遍历"></a>后序遍历</h3><h4 id="递归实现-2"><a href="#递归实现-2" class="headerlink" title="递归实现"></a>递归实现</h4><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">postOrder</span>&lt;<span class="title">T</span>&gt;(<span class="params">root: TreeNode&lt;T&gt;</span>): <span class="title">Array</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root === <span class="literal">null</span>) <span class="keyword">return</span> [];</span><br><span class="line">    <span class="keyword">return</span> postOrder&lt;T&gt;(root.left).concat(postOrder&lt;T&gt;(root.right)).concat(<span class="built_in">Array</span>.of(root.val));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="非递归遍历"><a href="#非递归遍历" class="headerlink" title="非递归遍历"></a>非递归遍历</h4><p>使用两个栈的方式来进行后序遍历。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">postOrder</span>&lt;<span class="title">T</span>&gt;(<span class="params">root: TreeNode&lt;T&gt;</span>): <span class="title">Array</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root === <span class="literal">null</span>) <span class="keyword">return</span> [];</span><br><span class="line">    <span class="keyword">let</span> stack1: <span class="built_in">Array</span>&lt;TreeNode&lt;T&gt;&gt; = [root];</span><br><span class="line">    <span class="keyword">let</span> stack2: <span class="built_in">Array</span>&lt;T&gt; = [];</span><br><span class="line">    <span class="keyword">while</span>(stack1.length&gt;<span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">let</span> node = stack1.pop();</span><br><span class="line">        stack2.push(node.val);</span><br><span class="line">        <span class="keyword">if</span>(node.left) &#123;</span><br><span class="line">            stack1.push(node.left);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(node.right) &#123;</span><br><span class="line">            stack1.push(node.right);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> stack2.reverse();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="层次遍历"><a href="#层次遍历" class="headerlink" title="层次遍历"></a>层次遍历</h3><h4 id="非递归实现-2"><a href="#非递归实现-2" class="headerlink" title="非递归实现"></a>非递归实现</h4><p>使用队列</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">levelOrder</span>&lt;<span class="title">T</span>&gt;(<span class="params">root: TreeNode&lt;T&gt;</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root === <span class="literal">null</span>) <span class="keyword">return</span> [];</span><br><span class="line">    <span class="keyword">let</span> queue: <span class="built_in">Array</span>&lt;TreeNode&lt;T&gt;&gt; = [root];</span><br><span class="line">    <span class="keyword">let</span> node: TreeNode&lt;T&gt;;</span><br><span class="line">    <span class="keyword">let</span> result: <span class="built_in">Array</span>&lt;T&gt; = [];</span><br><span class="line">    <span class="keyword">while</span>(node = queue.shift()) &#123;</span><br><span class="line">        result.push(node.val);</span><br><span class="line">        <span class="keyword">if</span>(node.left) &#123;</span><br><span class="line">            queue.push(node.left);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(node.right) &#123;</span><br><span class="line">            queue.push(node.right);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;二叉树的遍历&quot;&gt;&lt;a href=&quot;#二叉树的遍历&quot; class=&quot;headerlink&quot; title=&quot;二叉树的遍历&quot;&gt;&lt;/a&gt;二叉树的遍历&lt;/h2&gt;&lt;p&gt;首先，我们做好树建立的准备工作&lt;/p&gt;
&lt;figure class=&quot;highlight typescrip
      
    
    </summary>
    
      <category term="算法笔记" scheme="http://angellike_fairy.gitee.io/angellikefairy/categories/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/"/>
    
    
  </entry>
  
  <entry>
    <title>TypeScript装饰器理解</title>
    <link href="http://angellike_fairy.gitee.io/angellikefairy/2019/11/23/TypeScript%E8%A3%85%E9%A5%B0%E5%99%A8%E7%90%86%E8%A7%A3/"/>
    <id>http://angellike_fairy.gitee.io/angellikefairy/2019/11/23/TypeScript装饰器理解/</id>
    <published>2019-11-23T11:50:21.000Z</published>
    <updated>2019-12-16T09:45:26.648Z</updated>
    
    <content type="html"><![CDATA[<h2 id="什么是装饰器"><a href="#什么是装饰器" class="headerlink" title="什么是装饰器"></a>什么是装饰器</h2><blockquote><p>装饰器（Decorators）为我们在类的声明及成员上通过元编程语法添加标注提供了一种方式。</p></blockquote><p>事实上，它是一种特殊类型的声明，它能够被附加到类声明，方法，访问符，属性或参数上。</p><p>装饰器使用@expression的形式，expression求值后必须为一个函数(也就是说expression本身就是一个装饰器函数或者是装饰器工厂函数)，其中可以包括装饰声明信息（该信息会被作为参数传入）</p><h2 id="为什么需要装饰器"><a href="#为什么需要装饰器" class="headerlink" title="为什么需要装饰器"></a>为什么需要装饰器</h2><p>那么，为什么需要装饰器呢？我们可以思考一个场景，现在我们有一个类，该类中有一个用setTimout来模拟向后端请求数据的方法，例如：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> Model &#123;</span><br><span class="line">    <span class="keyword">async</span> getData() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">await</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve,reject</span>)=&gt;</span>&#123;</span><br><span class="line">            setTimeout(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">                resolve(&#123;data: <span class="number">123</span>&#125;)</span><br><span class="line">            &#125;,<span class="number">2000</span>)</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那么，如果我们想要统计这次请求花了多少时间呢？我们的确可以在该getData方法中添加统计时间的逻辑，但事实上，我们需要明白的是：如果有更多的方法需要添加统计时间的功能，那么我们需要为每一个方法都添加上相应的逻辑。</p><p>很容易明白这样是有很大缺陷的。而装饰器这个概念就是用来解决这一问题的。如果哪个方法需要统计时间，那么我们只要为其加上时间统计的装饰器，就可以做到时间的统计又不需要修改原来方法内部的逻辑。</p><p>在使用语法糖@expression之前，我们先使用函数来解决这个问题</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这个函数要做的就是获取到类中的方法，然后修改方法中的逻辑添加统计时间的逻辑</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">timeCount</span>(<span class="params">Model: <span class="built_in">Function</span>,key: <span class="built_in">string</span></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> target = Model.prototype;</span><br><span class="line">    <span class="keyword">let</span> func = target[key];</span><br><span class="line">    <span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">newFunc</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">let</span> start = <span class="built_in">Date</span>.now();</span><br><span class="line">        <span class="built_in">console</span>.log(start);</span><br><span class="line">        <span class="keyword">let</span> v = <span class="keyword">await</span> func.call(<span class="keyword">this</span>);</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'得到的值为'</span>,v);</span><br><span class="line">        <span class="keyword">let</span> duration = <span class="built_in">Date</span>.now()-start;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">`请求花费了<span class="subst">$&#123;duration&#125;</span>秒`</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">Object</span>.defineProperty(target,key,&#123;</span><br><span class="line">        value: newFunc</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将类Model和方法名getData传递给这个统计时间函数</span></span><br><span class="line">timeCount(Model,<span class="string">'getData'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> m = <span class="keyword">new</span> Model();</span><br><span class="line">m.getData();</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 输出结果</span></span><br><span class="line"><span class="comment">1574512136828</span></span><br><span class="line"><span class="comment">得到的值为 &#123; data: 123 &#125;</span></span><br><span class="line"><span class="comment">请求花费了2006秒</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>那么，以后只要哪个方法需要添加统计时间功能，那么我们只要将该方法名传递给该统计时间函数。这种思想也就是装饰器思想。</p><p>装饰器的思想在于：</p><ol><li>我们不用修改原来方法中的逻辑以及破坏原方法中的代码结构便可以添加上一些自定义的功能</li><li>可以复用</li></ol><h2 id="装饰器的用法"><a href="#装饰器的用法" class="headerlink" title="装饰器的用法"></a>装饰器的用法</h2><h3 id="装饰器工厂函数"><a href="#装饰器工厂函数" class="headerlink" title="装饰器工厂函数"></a>装饰器工厂函数</h3><p>装饰器@expression中的expression在求值后必须是一个函数，也就是说，如果expression本身就是装饰器函数，那么我们不需要在方法名后面加上()来执行；如果，expression需要求值后才能得到装饰器函数，那么我们就需要在函数后添加()来执行该函数</p><p>需要进行求值后才能得到函数，一般都是利用了工厂函数的思想。</p><p>例如：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">time</span>(<span class="params">...args: <span class="built_in">any</span>[]</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">target,key,descriptor</span>) </span>&#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="类装饰器"><a href="#类装饰器" class="headerlink" title="类装饰器"></a>类装饰器</h3><p>类装饰器需要在类声明之前被声明。类装饰器应用于类构造函数，可以用来监视，修改或替换类定义。</p><blockquote><p>类装饰器表达式会在运行时当作函数被调用，类的构造函数会作为其唯一的参数。</p></blockquote><blockquote><p>注意：如果类装饰器返回一个值，它会使用提供的构造函数来替换类的声明</p></blockquote><p>例如，我们可以通过修改原有构造函数的方式来为类添加一些新的实例属性</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@property</span>(<span class="string">'I am a person'</span>)</span><br><span class="line"><span class="keyword">class</span> Person &#123;</span><br><span class="line">    name: <span class="built_in">string</span>;</span><br><span class="line">    sex: <span class="built_in">string</span>;</span><br><span class="line">    <span class="keyword">constructor</span>(<span class="params">name: <span class="built_in">string</span>,sex: <span class="built_in">string</span></span>) &#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.sex = sex;</span><br><span class="line">    &#125;</span><br><span class="line">    getMes() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.name+<span class="string">' '</span>+<span class="keyword">this</span>.sex;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 为类Person添加property属性和getProperty方法</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">property</span>(<span class="params">propertyDescription: <span class="built_in">string</span></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 确保传入的泛型是一个构造函数使得TS编译阶段可以通过，因此需要&lt;T extends &#123;new(...args:Array&lt;any&gt;): &#123;&#125;&#125;&gt;</span></span><br><span class="line">    <span class="keyword">return</span> &lt;T <span class="keyword">extends</span> &#123;<span class="keyword">new</span>(...args: <span class="built_in">Array</span>&lt;<span class="built_in">any</span>&gt;):&#123;&#125;&#125;&gt;<span class="function">(<span class="params">Constructor: T</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="comment">// 返回一个继承自给定构造函数的继承匿名类</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">class</span> <span class="keyword">extends</span> Constructor &#123;</span><br><span class="line">            property: <span class="built_in">string</span>;</span><br><span class="line">            <span class="keyword">constructor</span>(<span class="params">...args</span>) &#123;</span><br><span class="line">                <span class="comment">// 调用super方法来实现原有类的构造方法</span></span><br><span class="line">                <span class="keyword">super</span>(...args);</span><br><span class="line">                <span class="keyword">this</span>.property = propertyDescription;</span><br><span class="line">            &#125;</span><br><span class="line">            getProperty(): <span class="built_in">string</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">this</span>.property;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> ming = <span class="keyword">new</span> Person(<span class="string">'ming'</span>,<span class="string">'男'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(ming); <span class="comment">// Person &#123; name: 'ming', sex: '男', property: 'I am a person' &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 因为装饰器实在运行阶段运行的，因此，一开始在编译阶段无法判断ming实例具有property属性和getProperty方法，因此，我们需要通过断言的方式来进行正确的输出</span></span><br><span class="line"><span class="built_in">console</span>.log((ming <span class="keyword">as</span> <span class="built_in">any</span>).property); <span class="comment">// I am a person</span></span><br><span class="line"><span class="built_in">console</span>.log((ming <span class="keyword">as</span> <span class="built_in">any</span>).getProperty()); <span class="comment">// I am a person</span></span><br><span class="line"><span class="built_in">console</span>.log(ming.property); <span class="comment">// Error: 类型“Person”上不存在属性“property”</span></span><br><span class="line"><span class="built_in">console</span>.log(ming.getProperty); <span class="comment">// Error: 类型“Person”上不存在属性“getProperty”</span></span><br></pre></td></tr></table></figure><p>当然，如果我们只是想为类添加一些新的方法，那我们大可不必去返回一个新的构造函数，而是通过修改构造函数的原型的方式来进行</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@get</span>(<span class="string">'name'</span>)</span><br><span class="line"><span class="keyword">class</span> Person &#123;</span><br><span class="line">    <span class="keyword">private</span> name: <span class="built_in">string</span>;</span><br><span class="line">    <span class="keyword">private</span> sex: <span class="built_in">string</span>;</span><br><span class="line">    <span class="keyword">constructor</span>(<span class="params">name: <span class="built_in">string</span>,sex: <span class="built_in">string</span></span>) &#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.sex = sex;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">get</span>(<span class="params">key: <span class="built_in">string</span></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">target: <span class="built_in">Function</span></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">let</span> func = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>[key];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">Object</span>.defineProperty(target.prototype,<span class="string">'get_'</span>+key,&#123;</span><br><span class="line">            value: func</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> ming = <span class="keyword">new</span> Person(<span class="string">'ming'</span>,<span class="string">'男'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(ming); <span class="comment">// Person &#123; name: 'ming', sex: '男' &#125;</span></span><br><span class="line"><span class="built_in">console</span>.log((ming <span class="keyword">as</span> <span class="built_in">any</span>).get_name()); <span class="comment">// 'ming'</span></span><br><span class="line"><span class="built_in">console</span>.log(ming.name); <span class="comment">// Error: 属性“name”为私有属性，只能在类“Person”中访问</span></span><br></pre></td></tr></table></figure><p>如果我们不想使用ES5的Object.defineProperty()。我们还可以使用更为强大的ES6的Proxy和Reflection</p><p>以下只改写上述例子中的get装饰器函数</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">get</span>(<span class="params">key: <span class="built_in">string</span></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">target: <span class="built_in">Function</span></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">let</span> handler = &#123;</span><br><span class="line">            defineProperty(trapTarget: <span class="built_in">Object</span>,key: <span class="built_in">string</span>,receiver: <span class="built_in">Object</span>) &#123;</span><br><span class="line">                <span class="comment">// 如果属性名已存在，则抛出错误</span></span><br><span class="line">                <span class="keyword">if</span>(key <span class="keyword">in</span> trapTarget) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'属性已存在'</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> Reflect.defineProperty(trapTarget,key,receiver);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">let</span> proxy = <span class="keyword">new</span> Proxy(target.prototype,handler);</span><br><span class="line">        <span class="keyword">let</span> func = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>[key];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">Object</span>.defineProperty(proxy,<span class="string">'get_'</span>+key,&#123;</span><br><span class="line">            value: func</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用Proxy的好处就是，我们在可以拦截底层的一些操作，从而定义一些自定义操作。以上Proxy就定义了如果Object.defineProperty要定义的属性名已存在则抛出错误，否则就使用Reflect.defineProperty执行常规操作</p><h3 id="方法装饰器"><a href="#方法装饰器" class="headerlink" title="方法装饰器"></a>方法装饰器</h3><p>方法装饰器声明在一个方法的声明之前（紧靠着方法声明）。 它会被应用到方法的 属性描述符上，可以用来监视，修改或者替换方法定义。 </p><p>方法装饰器表达式会在运行时当作函数被调用，传入下列3个参数：</p><ol><li>对于静态成员来说是类的构造函数，对于实例成员是类的原型对象。</li><li>成员的名字。</li><li>成员的属性描述符（通过Object.getOwnPropertyDescriptor()来得到）。</li></ol><p>例如：我们为类中的某一个方法增加一行输出’这是方法装饰器’</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> Person &#123;</span><br><span class="line">    name: <span class="built_in">string</span>;</span><br><span class="line">    <span class="keyword">constructor</span>(<span class="params">name: <span class="built_in">string</span></span>) &#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@sayHelloMore</span></span><br><span class="line">    sayHello() &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'hello'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sayHelloMore</span>(<span class="params">target: <span class="built_in">any</span>,key: <span class="built_in">string</span>,descriptor: PropertyDescriptor</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> func = target[key];</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">newFunc</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        func.call(<span class="keyword">this</span>);</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'这是方法装饰器'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    descriptor.value = newFunc;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> ming = <span class="keyword">new</span> Person(<span class="string">'ming'</span>);</span><br><span class="line">ming.sayHello();</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 输出结果</span></span><br><span class="line"><span class="comment">hello</span></span><br><span class="line"><span class="comment">这是方法装饰器</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h3 id="访问器装饰器"><a href="#访问器装饰器" class="headerlink" title="访问器装饰器"></a>访问器装饰器</h3><p>访问器装饰器声明在一个访问器的声明之前（紧靠着访问器声明）。 访问器装饰器应用于访问器的 属性描述符并且可以用来监视，修改或替换一个访问器的定义。</p><p>访问器装饰器的使用与方法装饰器的使用一致，因为访问器属性就是getter和setter函数</p><p>例如：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> Person &#123;</span><br><span class="line">    _name: <span class="built_in">string</span>;</span><br><span class="line">    <span class="keyword">constructor</span>(<span class="params">_name: <span class="built_in">string</span></span>) &#123;</span><br><span class="line">        <span class="keyword">this</span>._name = _name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@nameMore</span></span><br><span class="line">    <span class="keyword">get</span> name() &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'在getter函数中'</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>._name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">set</span> name(_name: <span class="built_in">string</span>) &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'在setter函数中'</span>);</span><br><span class="line">        <span class="keyword">this</span>._name = _name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">nameMore</span>(<span class="params">target: <span class="built_in">any</span>,key: <span class="built_in">string</span>,descriptor: PropertyDescriptor</span>) </span>&#123;</span><br><span class="line">    descriptor.get = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'访问器装饰器--读取name值'</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>._name;</span><br><span class="line">    &#125;</span><br><span class="line">    descriptor.set = <span class="function"><span class="keyword">function</span>(<span class="params">_name</span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'访问器属性--修改name值'</span>);</span><br><span class="line">        <span class="keyword">this</span>._name = _name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> ming = <span class="keyword">new</span> Person(<span class="string">'ming'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(ming.name);</span><br><span class="line">ming.name = <span class="string">'zheng'</span>;</span><br><span class="line"><span class="built_in">console</span>.log(ming.name);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 输出结果</span></span><br><span class="line"><span class="comment">访问器装饰器--读取name值</span></span><br><span class="line"><span class="comment">ming</span></span><br><span class="line"><span class="comment">访问器属性--修改name值</span></span><br><span class="line"><span class="comment">访问器装饰器--读取name值</span></span><br><span class="line"><span class="comment">zheng</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h3 id="属性装饰器"><a href="#属性装饰器" class="headerlink" title="属性装饰器"></a>属性装饰器</h3><p>与其他装饰器不同，属性装饰器只会传入两个参数，而不会传入第三个参数descriptor。因为，实例属性是要在实例化之后才可以被描述。</p><blockquote><p> 因为目前没有办法在定义一个原型对象的成员时描述一个实例属性，并且没办法监视或修改一个属性的初始化方法。返回值也会被忽略。因此，属性描述符只能用来监视类中是否声明了某个名字的属性。</p></blockquote><p>但是，我们可以去修改静态属性的值</p><p>例如：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> Person &#123;</span><br><span class="line">    <span class="meta">@mesChange</span>(<span class="string">'hello'</span>)</span><br><span class="line">    <span class="keyword">static</span> mes: <span class="built_in">string</span> = <span class="string">'person mes'</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">mesChange</span>(<span class="params">value: <span class="built_in">string</span></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">target,key</span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(target.prototype);</span><br><span class="line">        target[key] = value;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(Person.mes); <span class="comment">// 'hello'</span></span><br></pre></td></tr></table></figure><h3 id="函数参数装饰器"><a href="#函数参数装饰器" class="headerlink" title="函数参数装饰器"></a>函数参数装饰器</h3><p>参数装饰器声明在一个参数声明之前（紧靠着参数声明）。 参数装饰器应用于类构造函数或方法声明。</p><p>参数装饰器表达式会在运行时当作函数被调用，传入下列3个参数：</p><ol><li>对于静态成员来说是类的构造函数，对于实例成员是类的原型对象。</li><li>成员的名字（参数所在函数名）。</li><li>参数在函数参数列表中的索引。</li></ol><p>这个装饰器也是像实例属性一样的，没有办法单独使用，毕竟函数是在运行时调用的，而无论是何种装饰器，都是在声明类时（可以认为是伪编译期）调用的。</p><blockquote><p>注意  参数装饰器只能用来监视一个方法的参数是否被传入。</p></blockquote><p>例如： </p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> Person &#123;</span><br><span class="line">    name: <span class="built_in">string</span>;</span><br><span class="line">    <span class="keyword">constructor</span>(<span class="params">name: <span class="built_in">string</span></span>) &#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    sayHello(<span class="meta">@param</span>(<span class="string">'123'</span>) data: <span class="built_in">string</span>) &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'hello '</span>+data);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">param</span>(<span class="params">value: <span class="built_in">string</span></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">target: <span class="built_in">any</span>,name: <span class="built_in">string</span>,index: <span class="built_in">number</span></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(value);</span><br><span class="line">        <span class="built_in">console</span>.log(target);</span><br><span class="line">        <span class="built_in">console</span>.log(name);</span><br><span class="line">        <span class="built_in">console</span>.log(index);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> ming = <span class="keyword">new</span> Person(<span class="string">'ming'</span>);</span><br><span class="line">ming.sayHello(<span class="string">'world'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 输出结果</span></span><br><span class="line"><span class="comment">123</span></span><br><span class="line"><span class="comment">Person &#123; sayHello: [Function] &#125;</span></span><br><span class="line"><span class="comment">sayHello</span></span><br><span class="line"><span class="comment">0</span></span><br><span class="line"><span class="comment">hello world</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;什么是装饰器&quot;&gt;&lt;a href=&quot;#什么是装饰器&quot; class=&quot;headerlink&quot; title=&quot;什么是装饰器&quot;&gt;&lt;/a&gt;什么是装饰器&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;装饰器（Decorators）为我们在类的声明及成员上通过元编程语法添加标注提供了
      
    
    </summary>
    
      <category term="TypeScript" scheme="http://angellike_fairy.gitee.io/angellikefairy/categories/TypeScript/"/>
    
    
  </entry>
  
  <entry>
    <title>TypeScript中的泛型理解</title>
    <link href="http://angellike_fairy.gitee.io/angellikefairy/2019/11/19/TypeScript%E4%B8%AD%E7%9A%84%E6%B3%9B%E5%9E%8B%E7%90%86%E8%A7%A3/"/>
    <id>http://angellike_fairy.gitee.io/angellikefairy/2019/11/19/TypeScript中的泛型理解/</id>
    <published>2019-11-19T06:25:42.000Z</published>
    <updated>2019-12-15T07:02:42.592Z</updated>
    
    <content type="html"><![CDATA[<h2 id="什么是泛型"><a href="#什么是泛型" class="headerlink" title="什么是泛型"></a>什么是泛型</h2><p>我们在写JS的时候可以不用去管输入输出的类型，但是当我们在使用TS的时候就要注意类型的约束</p><p>例如：</p><p>我们有一个方法要返回传入的number类型的值：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getValue</span>(<span class="params">arg: <span class="built_in">number</span></span>): <span class="title">number</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> arg;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>而另一个方法要返回传入的string类型的值：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getValue</span>(<span class="params">arg: <span class="built_in">string</span></span>): <span class="title">string</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> arg;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>为了类型的约束与安全，我们经常会这么写。但是，仔细一看除了类型约束的差别外，这两个方法并没有本质的区别</p><p>因此，我们肯定想要减少重复代码的书写。这时候，肯定有人会想到用any数据类型来解决通用性问题，事实上这的确可以：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getValue</span>(<span class="params">arg: <span class="built_in">any</span></span>): <span class="title">any</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> arg;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样一来，我们输入各种类型参数就都没有任何问题了：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">getValue(<span class="number">123</span>);</span><br><span class="line">getValue(<span class="string">'123'</span>);</span><br></pre></td></tr></table></figure><p>但是，沉下心来仔细思考，这样子做会有什么问题呢？</p><p>我们的确可以传入任何类型，但是有一点是需要注意的，当参数类型和函数输出值类型为any时，TS无法判断输入的是什么类型，输出的是什么类型。那么，这样子就会破坏了类型安全（这样子就与js无异了，没有输入输出的类型检测）</p><p>因此，ts引入了泛型的概念，用来保证类型的安全同时又能使代码具有可复用性</p><blockquote><p>泛型（Generics）是指在定义函数、接口或类的时候，不预先指定具体的类型，而在使用的时候再指定类型的一种特性。</p></blockquote><h2 id="了解泛型的初步概念"><a href="#了解泛型的初步概念" class="headerlink" title="了解泛型的初步概念"></a>了解泛型的初步概念</h2><p>那么，我们现在尝试使用泛型来解决上述的问题。</p><blockquote><p>在泛型中，我们使用Type参数来表示传递给类，接口和函数的参数的数据类型。Type参数通常被定义为T</p></blockquote><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getValue</span>&lt;<span class="title">T</span>&gt;(<span class="params">arg: T</span>): <span class="title">T</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> arg;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中，函数名getValue后跟的<t>中的T就用来指代输入的类型。当该T类型被确认后，在后面的参数arg和函数返回值都会被当做该指定类型</t></p><p>例如，当你将T指代为string类型后，上述函数的效果就相当于我们之前写过的传入为字符串类型的函数：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getValue</span>(<span class="params">arg: <span class="built_in">string</span></span>): <span class="title">string</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> arg;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那么，我们该如何为T来指定输入的类型呢？</p><ol><li><p>第一种方法：显式传入类型参数（也就是显式为T赋值），例如：</p> <figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">getValue&lt;<span class="built_in">string</span>&gt;(<span class="string">'123'</span>);</span><br></pre></td></tr></table></figure><p> 这样，我们就明确为T指定为string类型，那么，传递给函数的参数和输出值的类型现在就只能为string类型</p></li><li><p>第二种方法： （这种方法更为普遍）利用ts的类型推论 – 即编译器会根据传入的参数自动地帮助我们确定T的类型，那么，我们只要像正常一样调用即可</p> <figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">getValue(<span class="string">'123'</span>);</span><br></pre></td></tr></table></figure></li></ol><h3 id="多个类型参数"><a href="#多个类型参数" class="headerlink" title="多个类型参数"></a>多个类型参数</h3><p>如果我们要传入多个参数呢？没关系，在定义泛型的时候，我们也可以定义多个类型参数</p><p>事实上我们可以用任何可用标识符来表示这个类型参数，例如a,A,mmm,$等等等</p><p>但一般情况下，我们常用T,U,V来表示类型参数</p><p>例如：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getValue</span>&lt;<span class="title">T</span>,<span class="title">U</span>,<span class="title">V</span>&gt;(<span class="params">arg1: T,arg2: U,arg3: V</span>): [<span class="title">T</span>,<span class="title">U</span>,<span class="title">V</span>] </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> [arg1,arg2,arg3]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">getValue&lt;<span class="built_in">string</span>,<span class="built_in">number</span>,<span class="built_in">boolean</span>&gt;(<span class="string">'hello'</span>,<span class="number">123</span>,<span class="literal">true</span>); <span class="comment">// [ 'hello', 123, true ]</span></span><br><span class="line"></span><br><span class="line">getValue(<span class="literal">undefined</span>,<span class="literal">null</span>,&#123;a:<span class="number">1</span>&#125;); <span class="comment">// [ undefined, null, &#123; a: 1 &#125; ]</span></span><br></pre></td></tr></table></figure><h3 id="泛型的约束"><a href="#泛型的约束" class="headerlink" title="泛型的约束"></a>泛型的约束</h3><blockquote><p>我们需要一直记住一点，ts不同于js，它是具有静态类型系统的。</p></blockquote><h4 id="js是运行时检查类型"><a href="#js是运行时检查类型" class="headerlink" title="js是运行时检查类型"></a>js是运行时检查类型</h4><p>js的类型检查会是在运行期间进行的（也就是说运行到某个地方需要检查类型才会去检查）。例如，定义一个函数输出传入参数的length属性值：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getLength</span>(<span class="params">arg</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> arg.length;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当我们传入一个数组或者是具有length属性的对象，这完全没有任何问题。但是，当我们传入undefined的时候，当代码运行到arg.length的时候，就会去检查arg的类型，然后发现其是undefined类型，它不会有length属性，因此报出错误</p><p>这便是在运行时检查类型</p><h4 id="ts是编译时检查类型"><a href="#ts是编译时检查类型" class="headerlink" title="ts是编译时检查类型"></a>ts是编译时检查类型</h4><p>相比于js，ts使用了静态类型系统，这也意味着ts是在编译时（运行前）就检查类型的</p><p>那么，在函数内部使用泛型变量的时候，由于我们事先并不知道它是那种类型，因此，我们不能再函数内随意操作它的属性或方法</p><p>例如：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getValue</span>&lt;<span class="title">T</span>&gt;(<span class="params">arg: T</span>): <span class="title">T</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> arg.length;</span><br><span class="line">    <span class="comment">// 报错：类型“T”上不存在属性“length”</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样子就会产生报错。</p><p>那么，在函数内使用类型断言可以吗？我们之前学到过可以将较为不具体的类型推断为更加具体的类型，比如将any断言为string。</p><p>事实上，这是不允许的。因为类型变量T在函数声明的时候是不确定，因此，我们不能为它进行断言为更具体的类型（除了any类型）。</p><p>那么，为什么any类型可以呢？因为，我们知道any类型可以访问任何属性和方法（即使不存在），这在编译的时候是不会有任何错误的，只是可能在运行阶段报错</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getValue</span>&lt;<span class="title">T</span>&gt;(<span class="params">arg: T</span>): <span class="title">T</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (arg <span class="keyword">as</span> <span class="built_in">any</span>).length;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(getValue(&#123;length:<span class="number">2</span>&#125;)); <span class="comment">// 2</span></span><br></pre></td></tr></table></figure><h4 id="通用性约束"><a href="#通用性约束" class="headerlink" title="通用性约束"></a>通用性约束</h4><p>既然我们想要在泛型中操作某个属性与方法，那么为了类型安全，我们可以对泛型进行更加通用性的约束，只允许这个函数传入具有某个属性与方法的变量</p><p>我们之前使用接口来描述一个对象或函数的形状，那么在泛型约束中我们就可以使用接口和extends来实现约束</p><p>例如：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> Value &#123;</span><br><span class="line">    length: <span class="built_in">any</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getValue</span>&lt;<span class="title">T</span> <span class="title">extends</span> <span class="title">Value</span>&gt;(<span class="params">arg: T</span>): <span class="title">T</span> </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(arg.length); <span class="comment">// 1</span></span><br><span class="line">    <span class="keyword">return</span> arg;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(getValue(&#123;length: <span class="number">1</span>,m: <span class="number">2</span>&#125;)); <span class="comment">// &#123; length: 1, m: 2 &#125;</span></span><br></pre></td></tr></table></figure><p>我们定义了一个接口，这个接口内有一个length属性，然后类型变量T继承了该接口，使得传入函数的参数必须包含该length属性</p><p>我们知道，我们可以使用接口来对对象或者函数来做形状上的约束。</p><p>事实上，上述代码在调用函数的时候传递给泛型的类型参数是通过类型推断进行传递，那么如果我们显示传递类型给类型变量T呢？</p><p>以上代码相当于：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> Value &#123;</span><br><span class="line">    length: <span class="built_in">any</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getValue</span>&lt;<span class="title">T</span>&gt;(<span class="params">arg: T</span>): <span class="title">T</span> </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(arg.length); <span class="comment">// 1</span></span><br><span class="line">    <span class="keyword">return</span> arg;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义一个需要显示传递给泛型的类型参数T的接口M</span></span><br><span class="line"><span class="keyword">interface</span> M &#123;</span><br><span class="line">    length: <span class="built_in">any</span>;</span><br><span class="line">    m: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(getValue&lt;M&gt;(&#123;length: <span class="number">1</span>,m: <span class="number">2</span>&#125;)); <span class="comment">// &#123;length: 1,m:2&#125;</span></span><br></pre></td></tr></table></figure><h3 id="泛型接口"><a href="#泛型接口" class="headerlink" title="泛型接口"></a>泛型接口</h3><p>在上述中，我们将泛型运用在了函数中，事实上，我们还可以将泛型运用在接口中</p><p>例如：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 我们将泛型的类型变量T当做整个接口的参数</span></span><br><span class="line"><span class="keyword">interface</span> Person&lt;T&gt; &#123;</span><br><span class="line">    name: T;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 显示传递string类型给接口中的参数类型变量T</span></span><br><span class="line"><span class="keyword">let</span> ming: Person&lt;<span class="built_in">string</span>&gt; = &#123;</span><br><span class="line">    name: <span class="string">'ming'</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接口除了可以约束对象之外，还可以去约束函数的形状：</p><p>例如：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> Func &#123;</span><br><span class="line">    (m: <span class="built_in">string</span>,n: <span class="built_in">number</span>): <span class="built_in">void</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> test: Func = <span class="function"><span class="keyword">function</span>(<span class="params">m: <span class="built_in">string</span>,n: <span class="built_in">number</span></span>): <span class="title">void</span> </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(m,n);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但如果我们想约束一个使用了泛型的函数呢？</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> Func &#123;</span><br><span class="line">    &lt;T&gt;(m: T,n: <span class="built_in">number</span>): <span class="built_in">void</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> test: Func = <span class="function"><span class="keyword">function</span>&lt;<span class="title">T</span>&gt;(<span class="params">m: T,n: <span class="built_in">number</span></span>): <span class="title">void</span> </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(m,n); <span class="comment">// 'hello' 123</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">test&lt;<span class="built_in">string</span>&gt;(<span class="string">'hello'</span>,<span class="number">123</span>);</span><br></pre></td></tr></table></figure><p>另外，我们也可以将类型变量T作为接口的参数：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> Func&lt;T&gt; &#123;</span><br><span class="line">    (m: T,n: <span class="built_in">number</span>): <span class="built_in">void</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 需要注意的是，此时我们需要定义好泛型的类型，因为此时我们必须将某个类型传递给类型参数T，而不能T传递给T</span></span><br><span class="line"><span class="keyword">let</span> test: Func&lt;<span class="built_in">string</span>&gt; = <span class="function"><span class="keyword">function</span>&lt;<span class="title">T</span>&gt;(<span class="params">m: T,n: <span class="built_in">number</span></span>): <span class="title">void</span> </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(m,n);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">test(<span class="string">'hello'</span>,<span class="number">123</span>);</span><br></pre></td></tr></table></figure><h3 id="泛型类"><a href="#泛型类" class="headerlink" title="泛型类"></a>泛型类</h3><p>泛型也能作用于类上。</p><p>例如：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> Item&lt;T&gt; &#123;</span><br><span class="line">    property: T;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> a = <span class="keyword">new</span> Item&lt;<span class="built_in">string</span>&gt;();</span><br><span class="line"><span class="keyword">let</span> b = <span class="keyword">new</span> Item&lt;<span class="built_in">number</span>&gt;();</span><br><span class="line"></span><br><span class="line">a.property = <span class="string">'hello'</span>;</span><br><span class="line">b.property = <span class="number">123</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(a,b);</span><br><span class="line"><span class="comment">// Item &#123; property: 'hello' &#125; Item &#123; property: 123 &#125;</span></span><br></pre></td></tr></table></figure><h3 id="类型参数作为类型的一部分"><a href="#类型参数作为类型的一部分" class="headerlink" title="类型参数作为类型的一部分"></a>类型参数作为类型的一部分</h3><p>在之前，我们一直将泛型的类型参数T作为整个类型来使用。但事实上，泛型的类型参数T还可以作为整个类型的一部分来使用</p><p>例如，我们考虑传入的参数是一个数组，然后利用泛型来限定该数组元素的类型</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getLength</span>&lt;<span class="title">T</span>&gt;(<span class="params">arg: T[]</span>): <span class="title">number</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> arg.length;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(getLength&lt;<span class="built_in">number</span>&gt;([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">4</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>])); <span class="comment">// 9</span></span><br></pre></td></tr></table></figure><h3 id="TS定义好的常用泛型"><a href="#TS定义好的常用泛型" class="headerlink" title="TS定义好的常用泛型"></a>TS定义好的常用泛型</h3><p>TS为我们定义好了一些极其常用的泛型，包括：</p><ol><li>Array&lt;T&gt;</li><li>Promise&lt;T&gt;</li><li>Set&lt;T&gt;</li><li>Map&lt;K,V&gt;</li></ol><p>我们分别为以上四个泛型举一些例子：</p><h4 id="Array-lt-T-gt"><a href="#Array-lt-T-gt" class="headerlink" title="Array&lt;T&gt;"></a>Array&lt;T&gt;</h4><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getArr</span>&lt;<span class="title">T</span>&gt;(<span class="params">arg: <span class="built_in">Array</span>&lt;T&gt;</span>): <span class="title">Array</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> arg;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(getArr&lt;<span class="built_in">string</span>&gt;([<span class="string">'hello'</span>,<span class="string">'world'</span>])); <span class="comment">// [ 'hello', 'world' ]</span></span><br></pre></td></tr></table></figure><h4 id="Promise-lt-T-gt"><a href="#Promise-lt-T-gt" class="headerlink" title="Promise&lt;T&gt;"></a>Promise&lt;T&gt;</h4><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getPromise</span>&lt;<span class="title">T</span>&gt;(<span class="params">arg: T</span>): <span class="title">Promise</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>&lt;T&gt;<span class="function">(<span class="params">(<span class="params">resolve,reject</span>)=&gt;&#123;</span></span></span><br><span class="line"><span class="function"><span class="params">        setTimeout(<span class="params">(<span class="params"></span>)=&gt;&#123;</span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="params">            resolve(<span class="params">arg</span>);</span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="params">        &#125;,1000</span>)</span></span></span><br><span class="line"><span class="function"><span class="params">    &#125;</span>)</span></span><br><span class="line"><span class="function">&#125;</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="params">getPromise</span>&lt;<span class="params">string</span>&gt;(<span class="params">'hello'</span>).<span class="params">then</span>(<span class="params">v=&gt;&#123;</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="built_in">console</span>.log(<span class="params">v</span>); <span class="comment">// 'hello'</span></span></span></span><br><span class="line"><span class="function"><span class="params">&#125;</span>)</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="params">getPromise</span>&lt;<span class="params">number</span>&gt;(<span class="params">123</span>).<span class="params">then</span>(<span class="params">v=&gt;&#123;</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="built_in">console</span>.log(<span class="params">v</span>); <span class="comment">// 123</span></span></span></span><br><span class="line"><span class="function"><span class="params">&#125;</span>)</span></span><br></pre></td></tr></table></figure><p>Promise&lt;T&gt;表示传递给Promise对象的参数的类型必须为T</p><h4 id="Set-lt-T-gt"><a href="#Set-lt-T-gt" class="headerlink" title="Set&lt;T&gt;"></a>Set&lt;T&gt;</h4><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getSet</span>&lt;<span class="title">T</span>&gt;(<span class="params">args: <span class="built_in">Array</span>&lt;T&gt;</span>): <span class="title">Set</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Set(args);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(getSet&lt;<span class="built_in">number</span>&gt;([<span class="number">1</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">3</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">5</span>])); <span class="comment">// Set &#123; 1, 2, 3, 5 &#125;</span></span><br></pre></td></tr></table></figure><h4 id="Map-lt-K-V-gt"><a href="#Map-lt-K-V-gt" class="headerlink" title="Map&lt;K,V&gt;"></a>Map&lt;K,V&gt;</h4><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getMap</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;(<span class="params">args: <span class="built_in">Array</span>&lt;[K,V]&gt;</span>): <span class="title">Map</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Map(args);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(getMap&lt;<span class="built_in">string</span>,<span class="built_in">string</span>&gt;([[<span class="string">'key1'</span>,<span class="string">'value1'</span>],[<span class="string">'key2'</span>,<span class="string">'value2'</span>],[<span class="string">'key3'</span>,<span class="string">'value3'</span>]])); <span class="comment">// Map &#123; 'key1' =&gt; 'value1', 'key2' =&gt; 'value2', 'key3' =&gt; 'value3' &#125;</span></span><br></pre></td></tr></table></figure><h3 id="泛型接口实现TS自带的一些泛型"><a href="#泛型接口实现TS自带的一些泛型" class="headerlink" title="泛型接口实现TS自带的一些泛型"></a>泛型接口实现TS自带的一些泛型</h3><p>下面，我们将使用泛型接口来自定义实现TS自带的一些泛型</p><p>首先，我们需要知道，我们可以使用接口来表示可索引的类型比如数组、类数组等：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> numArray &#123;</span><br><span class="line">    [index: <span class="built_in">number</span>]: <span class="built_in">any</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> numArray = [<span class="number">1</span>,<span class="string">'hello'</span>,<span class="literal">true</span>];</span><br></pre></td></tr></table></figure><p>现在我们开始来自定义一下数组泛型，我们需要为该接口设置可索引，具有length属性，并且由一些常用的数组方法：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> numArray&lt;T&gt; &#123;</span><br><span class="line">    length: <span class="built_in">number</span>;</span><br><span class="line">    [index: <span class="built_in">number</span>]: <span class="built_in">any</span>;</span><br><span class="line"></span><br><span class="line">    reverse(): <span class="built_in">Array</span>&lt;T&gt;;</span><br><span class="line">    shift(): T;</span><br><span class="line">    push(...items: <span class="built_in">Array</span>&lt;T&gt;): <span class="built_in">number</span>;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>之后我们创建数组类来实现这些接口中定义的方法和属性即可。</p><h3 id="在泛型中使用new操作（类类型）"><a href="#在泛型中使用new操作（类类型）" class="headerlink" title="在泛型中使用new操作（类类型）"></a>在泛型中使用new操作（类类型）</h3><p>如果我们想要构造一个工厂函数，该工厂函数可以返回传入该函数的类的实例。因为，我们不知道这个类的具体类型，因此，我们使用泛型来进行。</p><p>值得注意的是，如果我们直接这样写，编译是会出错的：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createObjec</span>&lt;<span class="title">T</span>&gt;(<span class="params">ctor: T</span>): <span class="title">T</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ctor(); <span class="comment">// Error: 该类型不具有构造函数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们知道只有一个函数具有[[constructor]]时，该构造函数才可以被实例化（进行new操作）。</p><p>因此，我们做出如下修改：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 声明传入的参数ctor具有构造函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createObject</span>&lt;<span class="title">T</span>&gt;(<span class="params">ctor: &#123;<span class="keyword">new</span>(): T;&#125;</span>): <span class="title">T</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ctor();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> Test &#123;</span><br><span class="line">    data: <span class="built_in">string</span> = <span class="string">'hello world'</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> test: Test = createObject&lt;Test&gt;(Test);</span><br><span class="line"><span class="built_in">console</span>.log(test);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 输出结果</span></span><br><span class="line"><span class="comment">Test &#123; data: 'hello world' &#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;什么是泛型&quot;&gt;&lt;a href=&quot;#什么是泛型&quot; class=&quot;headerlink&quot; title=&quot;什么是泛型&quot;&gt;&lt;/a&gt;什么是泛型&lt;/h2&gt;&lt;p&gt;我们在写JS的时候可以不用去管输入输出的类型，但是当我们在使用TS的时候就要注意类型的约束&lt;/p&gt;
&lt;p&gt;例如：&lt;/
      
    
    </summary>
    
      <category term="TypeScript" scheme="http://angellike_fairy.gitee.io/angellikefairy/categories/TypeScript/"/>
    
    
  </entry>
  
  <entry>
    <title>TypeScript的类与接口</title>
    <link href="http://angellike_fairy.gitee.io/angellikefairy/2019/11/17/TypeScript%E7%9A%84%E7%B1%BB%E4%B8%8E%E6%8E%A5%E5%8F%A3/"/>
    <id>http://angellike_fairy.gitee.io/angellikefairy/2019/11/17/TypeScript的类与接口/</id>
    <published>2019-11-17T10:40:57.000Z</published>
    <updated>2019-11-18T09:31:53.371Z</updated>
    
    <content type="html"><![CDATA[<h1 id="TypeScript中对类的加强"><a href="#TypeScript中对类的加强" class="headerlink" title="TypeScript中对类的加强"></a>TypeScript中对类的加强</h1><p>我们知道TypeScript能够提前用上最新ES版本的一些特性。例如，类的一些用法在ES7和Ts中就得到了更新</p><h2 id="实例属性"><a href="#实例属性" class="headerlink" title="实例属性"></a>实例属性</h2><p>在ES6中，我们只能在constructor中来定义实例属性</p><p>例如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(name,age) &#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然而，ts中允许我们直接在类中定义实例属性</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> Person &#123;</span><br><span class="line">    name: <span class="built_in">string</span> = <span class="string">'lee'</span>;</span><br><span class="line">    age: <span class="built_in">number</span> = <span class="number">18</span>;</span><br><span class="line">    <span class="keyword">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> lee = <span class="keyword">new</span> Person();</span><br><span class="line"><span class="built_in">console</span>.log(lee);</span><br><span class="line"><span class="comment">// Person &#123; name: 'lee', age: 18 &#125;</span></span><br></pre></td></tr></table></figure><h3 id="静态成员"><a href="#静态成员" class="headerlink" title="静态成员"></a>静态成员</h3><p>我们也可以在类上定义静态成员，这些静态成员只存在于类本身而不会被实例所得到的</p><blockquote><p>我们使用static关键字来定义静态成员</p></blockquote><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> Person &#123;</span><br><span class="line">    name: <span class="built_in">string</span>;</span><br><span class="line">    age: <span class="built_in">number</span>;</span><br><span class="line">    <span class="keyword">static</span> id: <span class="built_in">string</span> = <span class="string">'12345'</span>;</span><br><span class="line">    <span class="keyword">constructor</span>(<span class="params">name: <span class="built_in">string</span>,age: <span class="built_in">number</span></span>) &#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="keyword">static</span> getId() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.id;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> ming = <span class="keyword">new</span> Person(<span class="string">'ming'</span>,<span class="number">18</span>);</span><br><span class="line"><span class="built_in">console</span>.log(ming);</span><br><span class="line"><span class="comment">// Person &#123; name: 'ming', age: 18 &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 我们可以看到在实例上并不能访问到静态成员</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(Person.id); </span><br><span class="line"><span class="comment">// '12345'</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(Person.getId());</span><br><span class="line"><span class="comment">// '12345'</span></span><br></pre></td></tr></table></figure><h2 id="类的继承"><a href="#类的继承" class="headerlink" title="类的继承"></a>类的继承</h2><p>类的继承在面向对象的特性中是一个重要的特点</p><p>看个例子：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> Person &#123;</span><br><span class="line">    name: <span class="built_in">string</span>;</span><br><span class="line">    age: <span class="built_in">number</span>;</span><br><span class="line">    <span class="keyword">static</span> mes: <span class="built_in">string</span> = <span class="string">'short mes'</span>;</span><br><span class="line">    <span class="keyword">constructor</span>(<span class="params">name: <span class="built_in">string</span>,age: <span class="built_in">number</span></span>) &#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> getMes(): <span class="built_in">any</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.mes;</span><br><span class="line">    &#125;</span><br><span class="line">    sayHello(): <span class="built_in">void</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'Person say hello'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> Man <span class="keyword">extends</span> Person &#123;</span><br><span class="line">    sex: <span class="built_in">string</span> = <span class="string">'man'</span>;</span><br><span class="line">    friends: <span class="built_in">Array</span>&lt;<span class="built_in">string</span>&gt;;</span><br><span class="line">    <span class="keyword">constructor</span>(<span class="params">name: <span class="built_in">string</span>,age: <span class="built_in">number</span>,friends: <span class="built_in">Array</span>&lt;<span class="built_in">string</span>&gt;</span>) &#123;</span><br><span class="line">        <span class="keyword">super</span>(name,age);</span><br><span class="line">        <span class="keyword">this</span>.friends = friends;</span><br><span class="line">    &#125;</span><br><span class="line">    sayHello(): <span class="built_in">void</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'Man say hello'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> Woman <span class="keyword">extends</span> Person &#123;</span><br><span class="line">    sex: <span class="built_in">string</span> = <span class="string">'woman'</span>;</span><br><span class="line">    friends: <span class="built_in">Array</span>&lt;<span class="built_in">string</span>&gt;;</span><br><span class="line">    <span class="keyword">constructor</span>(<span class="params">name: <span class="built_in">string</span>,age: <span class="built_in">number</span>,friends: <span class="built_in">Array</span>&lt;<span class="built_in">string</span>&gt;</span>) &#123;</span><br><span class="line">        <span class="keyword">super</span>(name,age);</span><br><span class="line">        <span class="keyword">this</span>.friends = friends;</span><br><span class="line">    &#125;</span><br><span class="line">    sayHello(): <span class="built_in">void</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'woman say hello'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> ming = <span class="keyword">new</span> Man(<span class="string">'ming'</span>,<span class="number">18</span>,[<span class="string">'lee'</span>,<span class="string">'alice'</span>]);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> alice = <span class="keyword">new</span> Woman(<span class="string">'alice'</span>,<span class="number">17</span>,[<span class="string">'lee,ming'</span>]);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(ming,alice);</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">Man &#123; name: 'ming', age: 18, sex: 'man', friends: [ 'lee', 'alice' ] &#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">Woman &#123; name: 'alice', age: 17, sex: 'woman', friends: [ 'lee,ming' ] &#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line">ming.sayHello();</span><br><span class="line"><span class="comment">// 'Man say hello'</span></span><br><span class="line"></span><br><span class="line">alice.sayHello();</span><br><span class="line"><span class="comment">// 'woman say hello'</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(Man.getMes());</span><br><span class="line"><span class="comment">// 'short mes'</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(Woman.getMes());</span><br><span class="line"><span class="comment">// 'short mes'</span></span><br></pre></td></tr></table></figure><p>通过以上的例子，我们基本可以总结出关于类的继承方面的几点：</p><ol><li>使用extends关键字进行类的继承</li><li>在子类的构造函数中调用super来调用父类的构造函数</li><li>在子类的构造函数中this的使用必须在super调用后</li><li>子类可以重写父类的方法</li><li>静态成员可以被继承，同样也可以被重写</li></ol><h2 id="访问修饰符"><a href="#访问修饰符" class="headerlink" title="访问修饰符"></a>访问修饰符</h2><p>TypeScript可以提供三种访问修饰符，分别是public,private,protected</p><p>其中：</p><ul><li>public修饰的属性或方法是公有的，可以在任何地方被访问到，所有类中的成员默认为public</li><li>private修饰的属性或方法是私有的，不能在声明它的类外部进行访问</li><li>protected修饰的属性或方法是受保护的，它允许在基类和基类的子类中进行访问</li></ul><h3 id="public"><a href="#public" class="headerlink" title="public"></a>public</h3><p>类中默认所有的属性和方法都是public修饰符，因此，所有属性和方法都可以在任何地方被访问到（静态成员和实例属性均可）</p><p>例如：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> Person &#123;</span><br><span class="line">    <span class="keyword">public</span> name: <span class="built_in">string</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> mes: <span class="built_in">string</span> = <span class="string">'short mes'</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">constructor</span>(<span class="params">name: <span class="built_in">string</span></span>) &#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个看起来与我们之前的例子相比只是在每个属性和方法之前添加了public修饰符而已，实际上它们的效果也是一样的。因为，类中所有属性和方法都是默认使用public修饰符的，之前只是简写罢了。</p><h3 id="private"><a href="#private" class="headerlink" title="private"></a>private</h3><p>当成员被标记为private后，它就不能在声明它的类的外部使用了</p><p>我们将上述代码的public改为private来看下会有什么影响：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> Person &#123;</span><br><span class="line">    <span class="keyword">private</span> name: <span class="built_in">string</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> mes: <span class="built_in">string</span> = <span class="string">'short mes'</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">constructor</span>(<span class="params">name: <span class="built_in">string</span></span>) &#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> ming = <span class="keyword">new</span> Person(<span class="string">'ming'</span>);</span><br><span class="line"><span class="comment">// 类“Person”的构造函数是私有的，仅可在类声明中访问</span></span><br><span class="line"><span class="built_in">console</span>.log(Person.mes);</span><br><span class="line"><span class="comment">// 属性“mes”为私有属性，只能在类“Person”中访问。</span></span><br></pre></td></tr></table></figure><p>我们就可以看到会报出如上的错误。因此，如果类中的某个成员前添加了private修饰符，那么该成员就变为了这个类的私有成员，在类的外部是无法访问该成员的</p><h3 id="protected"><a href="#protected" class="headerlink" title="protected"></a>protected</h3><p>使用protected修饰符的类中成员可以在该类以及该类的派生类中进行使用</p><p>例如：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> Person &#123;</span><br><span class="line">    name: <span class="built_in">string</span>;</span><br><span class="line">    age: <span class="built_in">number</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> mes: <span class="built_in">string</span> = <span class="string">'这是Person的私有成员mes'</span>;</span><br><span class="line">    <span class="keyword">constructor</span>(<span class="params">name: <span class="built_in">string</span>,age: <span class="built_in">number</span></span>) &#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">static</span> getMes() &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>,<span class="keyword">this</span>.mes);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> Man <span class="keyword">extends</span> Person &#123;</span><br><span class="line">    <span class="keyword">constructor</span>(<span class="params">name,age</span>) &#123;</span><br><span class="line">        <span class="keyword">super</span>(name,age);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> getPersonMes() &#123;</span><br><span class="line">        <span class="comment">// 调用Person的子类Man继承得到的protected方法getMes</span></span><br><span class="line">        Man.getMes();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建Man实例</span></span><br><span class="line"><span class="keyword">let</span> ming = <span class="keyword">new</span> Man(<span class="string">'ming'</span>,<span class="number">18</span>);</span><br><span class="line"><span class="built_in">console</span>.log(ming);</span><br><span class="line"><span class="comment">// Man &#123; name: 'ming', age: 18 &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 访问Person类私有静态成员mes，则会报错</span></span><br><span class="line"><span class="comment">// console.log(Person.mes);</span></span><br><span class="line"></span><br><span class="line">Man.getPersonMes();</span><br><span class="line"><span class="comment">// [Function: Man] 这是Person的私有成员mes</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">在看到这段输出的时候，我产生了疑问，为什么this指向的是子类Man，而this.mes却可以得到基类中的私有属性，后来当我将这段代码编译成es6的时候就想明白了</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>为了说明上述的问题，我将代码做了精简</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> Person &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> mes = <span class="string">'这是Person基类的私有属性mes'</span>;</span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">static</span> getMes() &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>,<span class="keyword">this</span>.mes);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">constructor</span>(<span class="params"></span>) &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> Man <span class="keyword">extends</span> Person &#123;</span><br><span class="line">    <span class="keyword">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">super</span>();</span><br><span class="line">        Man.getMes();</span><br><span class="line">        <span class="comment">// [Function: Man] 这是Person基类的私有属性mes</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> man = <span class="keyword">new</span> Man();</span><br></pre></td></tr></table></figure><p>当我们将该段代码编译为es6时，得到以下的文件：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> __extends = (<span class="keyword">this</span> &amp;&amp; <span class="keyword">this</span>.__extends) || (<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> extendStatics = <span class="function"><span class="keyword">function</span> (<span class="params">d, b</span>) </span>&#123;</span><br><span class="line">        extendStatics = <span class="built_in">Object</span>.setPrototypeOf ||</span><br><span class="line">            (&#123; <span class="attr">__proto__</span>: [] &#125; <span class="keyword">instanceof</span> <span class="built_in">Array</span> &amp;&amp; <span class="function"><span class="keyword">function</span> (<span class="params">d, b</span>) </span>&#123; d.__proto__ = b; &#125;) ||</span><br><span class="line">            <span class="function"><span class="keyword">function</span> (<span class="params">d, b</span>) </span>&#123; <span class="keyword">for</span> (<span class="keyword">var</span> p <span class="keyword">in</span> b) <span class="keyword">if</span> (b.hasOwnProperty(p)) d[p] = b[p]; &#125;;</span><br><span class="line">        <span class="keyword">return</span> extendStatics(d, b);</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params">d, b</span>) </span>&#123;</span><br><span class="line">        extendStatics(d, b);</span><br><span class="line">        <span class="function"><span class="keyword">function</span> <span class="title">__</span>(<span class="params"></span>) </span>&#123; <span class="keyword">this</span>.constructor = d; &#125;</span><br><span class="line">        d.prototype = b === <span class="literal">null</span> ? <span class="built_in">Object</span>.create(b) : (__.prototype = b.prototype, <span class="keyword">new</span> __());</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;)();</span><br><span class="line"><span class="keyword">var</span> Person = <span class="comment">/** @class */</span> (<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    Person.getMes = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>, <span class="keyword">this</span>.mes);</span><br><span class="line">    &#125;;</span><br><span class="line">    Person.mes = <span class="string">'这是Person基类的私有属性mes'</span>;</span><br><span class="line">    <span class="keyword">return</span> Person;</span><br><span class="line">&#125;());</span><br><span class="line"><span class="keyword">var</span> Man = <span class="comment">/** @class */</span> (<span class="function"><span class="keyword">function</span> (<span class="params">_super</span>) </span>&#123;</span><br><span class="line">    __extends(Man, _super);</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">Man</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> _this = _super.call(<span class="keyword">this</span>) || <span class="keyword">this</span>;</span><br><span class="line">        Man.getMes();</span><br><span class="line">        <span class="keyword">return</span> _this;</span><br><span class="line">        <span class="comment">// [Function: Man] 这是Person基类的私有属性mes</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> Man;</span><br><span class="line">&#125;(Person));</span><br><span class="line"><span class="keyword">var</span> man = <span class="keyword">new</span> Man();</span><br><span class="line"><span class="comment">//# sourceMappingURL=a.js.map</span></span><br></pre></td></tr></table></figure><p>当看到这段代码的时候，我就突然明白了。因为，Js的继承是通过原型链来实现的。</p><p>因此，父类Person是子类Man的原型对象。所以，当在Man中找不到属性mes的时候，它就会顺着原型链向上查找，因此在原型对象Person中找到了属性mes</p><h2 id="readonly关键字"><a href="#readonly关键字" class="headerlink" title="readonly关键字"></a>readonly关键字</h2><p>我们之前在接口部分接触到了readonly关键字的概念。该关键字用来表示属性是只读的，不允许被修改</p><p>例如：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> Person &#123;</span><br><span class="line">    <span class="keyword">static</span> readonly mes: <span class="built_in">string</span> = <span class="string">'short mes'</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Person.mes = <span class="string">'long mes'</span>;</span><br><span class="line"><span class="comment">// 报错： Cannot assign to 'mes' because it is a read-only property.</span></span><br></pre></td></tr></table></figure><p>我们可以看到，当我们试图要修改一个readonly成员时是不被允许的</p><p>另外，值得注意的是：</p><blockquote><p>如果 readonly 和其他修饰符（例如：public private protected static）同时存在的话，需要写在其后面。</p></blockquote><h2 id="存储器（getter和setter）"><a href="#存储器（getter和setter）" class="headerlink" title="存储器（getter和setter）"></a>存储器（getter和setter）</h2><p>TypeScript支持通过getters/setters来截取对对象成员的访问。 它能帮助你有效的控制对对象成员的访问。</p><p>例如：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> Person &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> _mes: <span class="built_in">string</span> = <span class="string">'short mes'</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">constructor</span>(<span class="params"></span>) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">get</span> mes() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>._mes;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">set</span> mes(_mes: <span class="built_in">string</span>) &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'现在开始修改Person类的私有属性_mes'</span>)</span><br><span class="line">        <span class="keyword">this</span>._mes = _mes;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(Person.mes);</span><br><span class="line"><span class="comment">// 'short mes'</span></span><br><span class="line">Person.mes = <span class="string">'long mes'</span>;</span><br><span class="line"><span class="comment">// '现在开始修改Person类的私有属性_mes'</span></span><br><span class="line"><span class="built_in">console</span>.log(Person.mes);</span><br><span class="line"><span class="comment">// 'long mes'</span></span><br></pre></td></tr></table></figure><p>因此，使用getter和setter方法我们就可以在值访问和值操作之前进行拦截，从而进行一些自定义操作</p><h2 id="抽象类"><a href="#抽象类" class="headerlink" title="抽象类"></a>抽象类</h2><p>有些时候，我们经常会在子类重写父类的某个方法，而且我们不会去实例化这个父类。那么，抽象类就变得很有用处了。</p><p>抽象类不允许被实例化，并且抽象类需要定义抽象方法。该抽象方法不用完整地定义方法体。</p><blockquote><p>记住，抽象类不能被实例化</p></blockquote><p>另外，我们需要在派生类中实现该抽象方法</p><blockquote><p>我们使用abstract关键字是定义抽象类和在抽象类内部定义抽象方法。</p></blockquote><p>例如：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> Person &#123;</span><br><span class="line">    <span class="keyword">abstract</span> sayHello(): <span class="built_in">void</span>;</span><br><span class="line">    sayBye() &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'bye'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> Man <span class="keyword">extends</span> Person &#123;</span><br><span class="line">    sayHello():<span class="built_in">void</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'Man say hello'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">super</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> Woman <span class="keyword">extends</span> Person &#123;</span><br><span class="line">    sayHello() &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'Woman say hello'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">super</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> man = <span class="keyword">new</span> Man();</span><br><span class="line"><span class="keyword">let</span> woman = <span class="keyword">new</span> Woman();</span><br><span class="line"></span><br><span class="line">man.sayHello(); <span class="comment">// 'Man say hello'</span></span><br><span class="line">woman.sayHello(); <span class="comment">// 'Woman say hello'</span></span><br><span class="line">man.sayBye(); <span class="comment">// 'bye'</span></span><br><span class="line">woman.sayBye(); <span class="comment">// 'bye'</span></span><br></pre></td></tr></table></figure><h2 id="给类的实例化对象加上类型"><a href="#给类的实例化对象加上类型" class="headerlink" title="给类的实例化对象加上类型"></a>给类的实例化对象加上类型</h2><p>类似于给对象加上接口类型，我们也可以给类的实例化对象加上类的类型，表明该对象是由此类实例化得到的</p><p>例如：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> Person &#123;</span><br><span class="line">    <span class="keyword">constructor</span>(<span class="params"></span>) &#123;&#125;</span><br><span class="line">    sayHello() &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'hello'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> ming: Person = <span class="keyword">new</span> Person();</span><br><span class="line">ming.sayHello(); <span class="comment">// 'hello'</span></span><br></pre></td></tr></table></figure><h1 id="类与接口"><a href="#类与接口" class="headerlink" title="类与接口"></a>类与接口</h1><p>我们知道接口可以用于描述一个对象的形状以及对象内部的结构，除此之外，接口还可以对类的一部分行为进行抽象</p><p>在Java之类的面向对象的语言中，接口常用于实现多继承，在ts中也可以让一个类去强制去实现某种契约</p><h2 id="类实现接口"><a href="#类实现接口" class="headerlink" title="类实现接口"></a>类实现接口</h2><p>比如说，有Man类和Woman类，他们都可以有一个方法sayHello()。我们可以让这个方法从基类Person中继承得到，例如：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> Person &#123;</span><br><span class="line">    sayHello() &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> Man <span class="keyword">extends</span> Person&#123;</span><br><span class="line">    sayHello() &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'Man say hello'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> Woman <span class="keyword">extends</span> Person&#123;</span><br><span class="line">    sayHello() &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'Woman say hello'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>除此之外，我们也可以使用抽象类：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> Person &#123;</span><br><span class="line">    <span class="keyword">abstract</span> sayHello(): <span class="built_in">void</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> Man <span class="keyword">extends</span> Person&#123;</span><br><span class="line">    sayHello() &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'Man say hello'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> Woman <span class="keyword">extends</span> Person&#123;</span><br><span class="line">    sayHello() &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'Woman say hello'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是我们知道，类是不允许被多继承的，那么抽象类也是如此。因此，我们就可以使用接口来定义：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> Say &#123;</span><br><span class="line">    sayHello(): <span class="built_in">void</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> Man <span class="keyword">implements</span> Say &#123;</span><br><span class="line">    sayHello(): <span class="built_in">void</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'Man say hello'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> Woman <span class="keyword">implements</span> Say &#123;</span><br><span class="line">    sayHello(): <span class="built_in">void</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'Man say hello'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="类实现多个接口"><a href="#类实现多个接口" class="headerlink" title="类实现多个接口"></a>类实现多个接口</h3><p>接口的很重要的一个功能就是用来实现多继承的。</p><p>因此，我们可以用一个类来继承多个接口：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> Say &#123;</span><br><span class="line">    sayHello(): <span class="built_in">void</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> Travel&#123;</span><br><span class="line">    travelByBus(): <span class="built_in">void</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> Man <span class="keyword">implements</span> Say,Travel &#123;</span><br><span class="line">    sayHello(): <span class="built_in">void</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'Man say hello'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    travelByBus(): <span class="built_in">void</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'Man travel by bus'</span>);</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> man = <span class="keyword">new</span> Man();</span><br><span class="line">man.sayHello(); <span class="comment">// 'Man say hello'</span></span><br><span class="line">man.travelByBus(); <span class="comment">// 'Man travel by bus'</span></span><br></pre></td></tr></table></figure><h2 id="接口继承"><a href="#接口继承" class="headerlink" title="接口继承"></a>接口继承</h2><h3 id="接口继承接口"><a href="#接口继承接口" class="headerlink" title="接口继承接口"></a>接口继承接口</h3><p>事实上，和类一样，接口也可以实现继承。我们可以将一个接口继承另一个接口，来实现更为灵活的可重用</p><p>例如：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> Person &#123;</span><br><span class="line">    sayHello(): <span class="built_in">void</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> Man <span class="keyword">extends</span> Person&#123;</span><br><span class="line">    gender: <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> MaleStudents <span class="keyword">implements</span> Man &#123;</span><br><span class="line">    gender: <span class="built_in">string</span> = <span class="string">'male'</span>;</span><br><span class="line">    sayHello(): <span class="built_in">void</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'Students say hello'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    constuctor() &#123;&#125;</span><br><span class="line">    sayNice() &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'nice'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> maleStudent = <span class="keyword">new</span> MaleStudents();</span><br><span class="line"><span class="built_in">console</span>.log(maleStudent.gender); <span class="comment">// 'male'</span></span><br><span class="line">maleStudent.sayHello(); <span class="comment">// 'Students say hello'</span></span><br><span class="line">maleStudent.sayNice(); <span class="comment">// 'nice'</span></span><br></pre></td></tr></table></figure><p>当然，既然类可以多继承多个接口，那么接口也可以多继承多个接口</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> Say &#123;</span><br><span class="line">    say(): <span class="built_in">void</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> Walk &#123;</span><br><span class="line">    walk(): <span class="built_in">void</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> Person <span class="keyword">extends</span> Say,Walk&#123;</span><br><span class="line">    property: <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> Man <span class="keyword">implements</span> Person &#123;</span><br><span class="line">    property = <span class="string">'person'</span>;</span><br><span class="line">    say() &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'say'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    walk() &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'walk'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="接口继承类"><a href="#接口继承类" class="headerlink" title="接口继承类"></a>接口继承类</h3><p>接口也可以继承类。</p><blockquote><p>当接口继承了一个类类型时，它会继承类的成员但不包括其实现。 就好像接口声明了所有类中存在的成员，但并没有提供具体实现一样。 接口同样会继承到类的private和protected成员。 这意味着当你创建了一个接口继承了一个拥有私有或受保护的成员的类时，这个接口类型只能被这个类或其子类所实现（implement）。</p></blockquote><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> Person &#123;</span><br><span class="line">    property: <span class="built_in">string</span> = <span class="string">'person'</span>;</span><br><span class="line">    sayHello(): <span class="built_in">void</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'Person say hello'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> InterfacePerson <span class="keyword">extends</span> Person &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> Man <span class="keyword">implements</span> InterfacePerson &#123;</span><br><span class="line">    property = <span class="string">'man'</span>;</span><br><span class="line">    sayHello(): <span class="built_in">void</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'Man say hello'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> man = <span class="keyword">new</span> Man();</span><br><span class="line"><span class="built_in">console</span>.log(man.property); <span class="comment">// 'man'</span></span><br><span class="line">man.sayHello(); <span class="comment">// 'Man say hello'</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;TypeScript中对类的加强&quot;&gt;&lt;a href=&quot;#TypeScript中对类的加强&quot; class=&quot;headerlink&quot; title=&quot;TypeScript中对类的加强&quot;&gt;&lt;/a&gt;TypeScript中对类的加强&lt;/h1&gt;&lt;p&gt;我们知道TypeScript
      
    
    </summary>
    
      <category term="TypeScript" scheme="http://angellike_fairy.gitee.io/angellikefairy/categories/TypeScript/"/>
    
    
  </entry>
  
  <entry>
    <title>flex布局一把梭</title>
    <link href="http://angellike_fairy.gitee.io/angellikefairy/2019/11/16/flex%E5%B8%83%E5%B1%80%E4%B8%80%E6%8A%8A%E6%A2%AD/"/>
    <id>http://angellike_fairy.gitee.io/angellikefairy/2019/11/16/flex布局一把梭/</id>
    <published>2019-11-16T12:09:06.000Z</published>
    <updated>2019-11-16T14:44:32.702Z</updated>
    
    <content type="html"><![CDATA[<h2 id="flex布局的基本语法知识"><a href="#flex布局的基本语法知识" class="headerlink" title="flex布局的基本语法知识"></a>flex布局的基本语法知识</h2><h3 id="如何设置flex布局"><a href="#如何设置flex布局" class="headerlink" title="如何设置flex布局"></a>如何设置flex布局</h3><p>我们可以通过</p><ol><li>将块级元素设置为display: flex</li><li>将内联元素设置为display: inline-flex</li></ol><p>来为元素创建flex布局</p><h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><p>引用阮老师的一张图：</p><p><img src="https://s2.ax1x.com/2019/11/16/MBFu9K.png" alt></p><p>我们将设置为flex布局的那个元素称之为flex容器，而在该容器内部的其他元素称之为flex子项</p><p>我们可以看到，如果不设置flex-direction的属性，那么容器的主轴默认为横向，与主轴垂直的轴称之为交叉轴</p><p>当然，如果我们将flex-direction属性值设置为</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-id">#app</span> &#123;</span><br><span class="line"><span class="attribute">display</span>: flex;</span><br><span class="line"><span class="attribute">flex-direction</span>: column;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那么，项目的主轴就会变成竖向，而项目的交叉轴就会变为横向</p><h3 id="flex容器可以设置的属性"><a href="#flex容器可以设置的属性" class="headerlink" title="flex容器可以设置的属性"></a>flex容器可以设置的属性</h3><p>flex容器内包含了多个子项，因此，flex容器的属性就是为了控制多个子项的分布</p><p>其主要具有以下几个属性（只提及常用属性和对应属性值）：</p><table><thead><tr><th>属性名</th><th>属性值</th><th>作用</th></tr></thead><tbody><tr><td>flex-direction</td><td>row,column</td><td>设置flex容器主轴为横向或者为竖向</td></tr><tr><td>flex-wrap</td><td>wrap,nowrap</td><td>是否换行</td></tr><tr><td>justify-content</td><td>flex-start,flex-end,center,space-between,space-around,space-evenly</td><td>稍后详解</td></tr><tr><td>align-items</td><td>stretch, flex-start,flex-end, center,baseline</td><td>稍后详解</td></tr><tr><td>align-content</td><td>stretch, flex-start,flex-end, center,space-between,space-around,space-evenly</td><td>稍后详解</td></tr></tbody></table><h4 id="justify-content"><a href="#justify-content" class="headerlink" title="justify-content"></a>justify-content</h4><p>justify-content属性用来设置子项在主轴上的排列方式</p><p>语法如下：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">justify-content: flex-start | flex-end | center | space-between | space-around | space-evenly;</span><br></pre></td></tr></table></figure><p>其中：</p><ul><li><p>flex-start<br>  默认值，主轴的起点对齐</p></li><li><p>flex-end<br>  主轴的终点对齐</p></li><li><p>center<br>  主轴方向上居中</p></li><li><p>space-between<br>  两端对齐，中间各项目之间的间隔相同</p><p>  <img src="https://s2.ax1x.com/2019/11/16/MBZuOU.png" alt></p></li><li><p>space-around<br>  每个flex子项两侧都环绕互不干扰的等宽的空白间距，最终视觉上边缘两侧的空白只有中间空白宽度一半。</p><p>  <img src="https://s2.ax1x.com/2019/11/16/MBZMmF.png" alt></p></li><li><p>space-evenly<br>  每个子项之间的间隔与子项与容器边界的间隔完全相同（视觉上看起来所有子项平分了空白区域）</p><p>  <img src="https://s2.ax1x.com/2019/11/16/MBZnyT.png" alt></p></li></ul><h4 id="align-items"><a href="#align-items" class="headerlink" title="align-items"></a>align-items</h4><p>align-items用来设置容器交叉轴上的子项排列方式</p><p>其语法如下：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">align-items: align-items: stretch | flex-start | flex-end | center | baseline;</span><br></pre></td></tr></table></figure><p>其中：</p><ul><li><p>stretch<br>  （默认值）如果子项没有设置高度或者设置为auto，那么子项高度就为容器高度</p></li><li><p>flex-start<br>  交叉轴的起点对齐</p></li><li><p>flex-end<br>  交叉轴的终点对齐</p></li><li><p>center<br>  交叉轴方向上居中</p></li><li><p>baseline<br>  所有flex子项都相对于flex容器的基线对齐</p><p>  <img src="https://s2.ax1x.com/2019/11/16/MBmQi9.png" alt></p></li></ul><h4 id="align-content"><a href="#align-content" class="headerlink" title="align-content"></a>align-content</h4><p>align-content则是指明垂直方向每一行flex元素的对齐和分布方式。如果所有flex子项只有一行，则align-content属性是没有任何效果的。</p><p>也就是说，使用align-content属性是将flex容器中的所有主轴上的所有项目合起来看做是一个flex子项，然后各个主轴上的整体子项可以使用justify-content上的属性值进行排列</p><p>其语法如下：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">align-content: stretch | flex-start | flex-end | center | space-between | space-around | space-evenly;</span><br></pre></td></tr></table></figure><p>具体含义不再赘述，与justify-content属性值并无二异。只是前者作用于交叉轴上，而后者作用在主轴上</p><p>举个align-content:space-between属性值的例子即可</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"item"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">p</span>&gt;</span>A<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"item"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">p</span>&gt;</span>B<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"item"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">p</span>&gt;</span>C<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"item"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">p</span>&gt;</span>D<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"item"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">p</span>&gt;</span>E<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"item"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">p</span>&gt;</span>F<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-id">#app</span> &#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">500px</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">200px</span>;</span><br><span class="line"><span class="attribute">border</span>: <span class="number">1px</span> solid black;</span><br><span class="line">    <span class="attribute">display</span>: flex;</span><br><span class="line">    <span class="attribute">flex-direction</span>: row;</span><br><span class="line">    <span class="attribute">flex-wrap</span>: wrap;</span><br><span class="line">    <span class="attribute">justify-content</span>: space-evenly;</span><br><span class="line">    <span class="attribute">align-content</span>: space-between;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.item</span> &#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">200px</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">30px</span>;</span><br><span class="line">    <span class="attribute">background-color</span>: pink;</span><br><span class="line">    <span class="attribute">display</span>: flex;</span><br><span class="line">    <span class="attribute">justify-content</span>: center;</span><br><span class="line">    <span class="attribute">align-items</span>: center;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">p</span> &#123;</span><br><span class="line">    <span class="attribute">font-size</span>: <span class="number">20px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后得到的效果如下：</p><p><img src="https://s2.ax1x.com/2019/11/16/MBKsQ1.png" alt></p><h3 id="flex子项可以设置的属性"><a href="#flex子项可以设置的属性" class="headerlink" title="flex子项可以设置的属性"></a>flex子项可以设置的属性</h3><p>在flex子项上设置的属性用于作用在子项自身身上，并不会对整个容器的所有子项产生影响。</p><p>其主要有以下几个属性：</p><ul><li>order</li><li>flex-grow</li><li>flex-shrink</li><li>flex-basis</li><li>flex</li><li>align-self</li></ul><h4 id="order"><a href="#order" class="headerlink" title="order"></a>order</h4><p>order属性可以设置子项的排列顺序，数值越小，排列越靠前。所有子项的默认order属性值为0</p><p>例如：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-id">#A</span> &#123;</span><br><span class="line">    <span class="attribute">order</span>: -<span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-id">#B</span> &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-id">#C</span> &#123;</span><br><span class="line">    <span class="attribute">order</span>: -<span class="number">4</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们可以看到各个子项的order由小到大排序应该是C，A，B（默认order为0）</p><p>渲染结果为：</p><p><img src="https://s2.ax1x.com/2019/11/16/MBQO2j.png" alt></p><h4 id="flex-grow"><a href="#flex-grow" class="headerlink" title="flex-grow"></a>flex-grow</h4><p>flex-grow中的grow就是扩展的意思。这个属性的目的就是在自身子项已有的宽度上来根据属性值来决定利用剩余的空白部分来扩展自身的宽度</p><p>语法为：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">flex-grow</span>: &lt;<span class="selector-tag">number</span>&gt; <span class="comment">/* 数值，可以是小数，但不支持负数，默认值是 0 */</span></span><br></pre></td></tr></table></figure><p>首先，我们需要明确的是，所有剩余空白空间在数值上表示为1</p><p>那么具体的分配规则如下：</p><ol><li>如果只有一个子项设置了flex-grow属性，那么就只对该子项进行空间扩展。其中可以分为两种情况：<ul><li>如果flex-grow的属性值小于1，那么扩展的空间就相当于总剩余空间和这个比例的乘积值。</li><li>如果属性值大于等于1，那么扩展的空间就是剩余所有空间</li></ul></li><li>如果有多个子项设置了flex-grow属性，那么具体可以分为以下情况：<ul><li>如果所有已设置flex-grow属性的属性值的和小于1，那么每个已设置该属性的子项的扩展空间相当于总剩余空间和各个子项设置的属性值的乘积值</li><li>如果flex-grow值总和大于或等于1，则所有剩余空间被利用，分配比例就是flex-grow属性值的比例。例如所有的flex子项都设置flex-grow:1，则表示剩余空白间隙大家等分，如果设置的flex-grow比例是1:2:1，则中间的flex子项占据一半的空白间隙，剩下的前后两个元素等分。</li></ul></li></ol><p>来看下具体例子：</p><h5 id="只有一个子项设置flex-grow属性"><a href="#只有一个子项设置flex-grow属性" class="headerlink" title="只有一个子项设置flex-grow属性"></a>只有一个子项设置flex-grow属性</h5><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-id">#app</span> &#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">500px</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">200px</span>;</span><br><span class="line"><span class="attribute">border</span>: <span class="number">1px</span> solid black;</span><br><span class="line">    <span class="attribute">display</span>: flex;</span><br><span class="line">    <span class="attribute">flex-direction</span>: row;</span><br><span class="line">    <span class="attribute">flex-wrap</span>: wrap;</span><br><span class="line">    <span class="attribute">justify-content</span>: space-evenly;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-id">#A</span> &#123;</span><br><span class="line">    <span class="attribute">flex-grow</span>: <span class="number">0.5</span>;</span><br><span class="line">    <span class="attribute">background-color</span>: blue;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">100px</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-id">#B</span> &#123;</span><br><span class="line">    <span class="attribute">background-color</span>: pink;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">100px</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-id">#C</span> &#123;</span><br><span class="line">    <span class="attribute">background-color</span>: pink;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">100px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>渲染结果为：</p><p><img src="https://s2.ax1x.com/2019/11/16/MB8geI.png" alt></p><p>我们可以看到容器的总宽度为500px。每个子项最初本来只占100px，也就是说本来会剩余200px宽度的空白空间。</p><p>然后，我们在A子项设置了flex-grow:0.5。因此，A子项所获得的扩展空间也就为200px*0.5=100px宽度的空白空间</p><h5 id="多个子项设置flex-grow属性"><a href="#多个子项设置flex-grow属性" class="headerlink" title="多个子项设置flex-grow属性"></a>多个子项设置flex-grow属性</h5><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-id">#app</span> &#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">500px</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">200px</span>;</span><br><span class="line"><span class="attribute">border</span>: <span class="number">1px</span> solid black;</span><br><span class="line">    <span class="attribute">display</span>: flex;</span><br><span class="line">    <span class="attribute">flex-direction</span>: row;</span><br><span class="line">    <span class="attribute">flex-wrap</span>: wrap;</span><br><span class="line">    <span class="attribute">justify-content</span>: space-evenly;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-id">#A</span> &#123;</span><br><span class="line">    <span class="attribute">flex-grow</span>: <span class="number">0.5</span>;</span><br><span class="line">    <span class="attribute">background-color</span>: blue;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">100px</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-id">#B</span> &#123;</span><br><span class="line">    <span class="attribute">flex-grow</span>: <span class="number">0.5</span>;</span><br><span class="line">    <span class="attribute">background-color</span>: pink;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">100px</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-id">#C</span> &#123;</span><br><span class="line">    <span class="attribute">flex-grow</span>: <span class="number">1</span>;</span><br><span class="line">    <span class="attribute">background-color</span>: pink;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">100px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>渲染结果为：</p><p><img src="https://s2.ax1x.com/2019/11/16/MBJ5rj.png" alt></p><p>我们可以看到，因为A子项设置flex-grow为0.5，B子项为0.5，C子项为1.因此，这三者的和超过了1。那么，这三个子项的扩展空间将占领全部的剩余空白空间，并且每个子项在扩展空间的分配比例相当于它们属性值的比例。因此：</p><ul><li>A子项获得200px*(0.5/(0.5+0.5+1))=50px的宽度的扩展空间</li><li>B子项获得200px*(0.5/(0.5+0.5+1))=50px的宽度的扩展空间</li><li>C子项获得200px*(0.5/(0.5+0.5+1))=100px的宽度的扩展空间</li></ul><h4 id="flex-shrink"><a href="#flex-shrink" class="headerlink" title="flex-shrink"></a>flex-shrink</h4><p>shrink是收缩的意思。因此，该属性用来处理当剩余空间不足的情况下，各个子项该如何收缩。</p><p>什么叫剩余空间不够呢？假如说，当flex容器的宽度为500px，每个子项的宽度为200px，并且我们设置不允许换行（flex-wrap:nowrap）。那么，如果每个子项不收缩的话，那么就会有一个子项溢出，如下所示：</p><p><img src="https://s2.ax1x.com/2019/11/16/MBUAzT.png" alt></p><p>因此，该flex-shrink属性就是用来当剩余空间不足的情况下来处理各个子项的收缩情况</p><p>语法如下：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">flex-shrink</span>: &lt;<span class="selector-tag">number</span>&gt;; <span class="comment">/* 数值，不支持负值，所有子项默认值是 1，也就是都进行同等比例的收缩，以保证元素不会溢出 */</span></span><br></pre></td></tr></table></figure><p>默认渲染情况如下：</p><p><img src="https://s2.ax1x.com/2019/11/16/MBUT6U.png" alt></p><p>具体收缩规则如下：</p><ol><li><p>如果只有一个子项设置了flex-shrink，那么只有该子项会进行收缩</p><ul><li>如果flex-shrink属性值小于1，那么收缩尺寸不完全，仍然会有一部分内容会溢出</li><li>如果flex-shrink属性值大于或等于1，那么收缩尺寸完全，不会有任何溢出</li></ul></li><li><p>如果有多个子项设置了flex-shrink，那么设置该属性的子项会进行收缩</p><ul><li>如果所有设置该属性的属性值的和小于1，那么收缩会不完全，每个元素收缩尺寸为“完全收缩的尺寸”与每个子项上的该属性值的乘积</li><li>flex-shrink值的总和大于1，则收缩完全，每个元素收缩尺寸的比例和flex-shrink值的比例一样</li></ul></li></ol><h4 id="align-self"><a href="#align-self" class="headerlink" title="align-self"></a>align-self</h4><p>align-self用于单独设置该子项在交叉轴上的对齐方式。</p><p>其语法如下：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">align-self: auto | flex-start | flex-end | center | baseline | stretch;</span><br></pre></td></tr></table></figure><p>属性值都已介绍过，这里不再赘述</p><p>我们以align-self:center为示例：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-id">#app</span> &#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">500px</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">200px</span>;</span><br><span class="line"><span class="attribute">border</span>: <span class="number">1px</span> solid black;</span><br><span class="line">    <span class="attribute">display</span>: flex;</span><br><span class="line">    <span class="attribute">flex-direction</span>: row;</span><br><span class="line"><span class="attribute">justify-content</span>: space-evenly;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-id">#A</span> &#123;</span><br><span class="line">    <span class="attribute">background-color</span>: blue;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">50px</span>;</span><br><span class="line"><span class="attribute">height</span>: <span class="number">100px</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-id">#B</span> &#123;</span><br><span class="line">    <span class="attribute">background-color</span>: pink;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">100px</span>;</span><br><span class="line"><span class="attribute">height</span>: <span class="number">100px</span>;</span><br><span class="line"><span class="attribute">align-self</span>: center;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-id">#C</span> &#123;</span><br><span class="line"><span class="attribute">background-color</span>: gainsboro;</span><br><span class="line"><span class="attribute">height</span>: <span class="number">100px</span>;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">150px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>渲染结果为：</p><p><img src="https://s2.ax1x.com/2019/11/16/MBdvQK.png" alt></p><h2 id="flex布局的应用场景"><a href="#flex布局的应用场景" class="headerlink" title="flex布局的应用场景"></a>flex布局的应用场景</h2><h3 id="三栏布局"><a href="#三栏布局" class="headerlink" title="三栏布局"></a>三栏布局</h3><p>三栏布局就是整体高度已知，左栏和右栏宽度确定然后中间栏宽度自适应</p><p>我们假设整体高度为200px。左右两栏的宽度为20px，高度为100%</p><p>那么，我们可以利用flex布局来实现，同时使用flex-grow来是实现中间栏自适应宽度</p><p>首先设置三个flex子项</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"A"</span> <span class="attr">class</span>=<span class="string">"flex"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">p</span>&gt;</span>A<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"B"</span> <span class="attr">class</span>=<span class="string">"flex"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">p</span>&gt;</span>B<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"C"</span> <span class="attr">class</span>=<span class="string">"flex"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">p</span>&gt;</span>C<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p>然后设置css属性</p><p>这里假设整体宽度为500px</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-id">#app</span> &#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">500px</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">200px</span>;</span><br><span class="line"><span class="attribute">border</span>: <span class="number">1px</span> solid black;</span><br><span class="line">    <span class="attribute">display</span>: flex;</span><br><span class="line">    <span class="attribute">flex-direction</span>: row;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-id">#A</span> &#123;</span><br><span class="line">    <span class="attribute">background-color</span>: blue;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">20px</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-id">#B</span> &#123;</span><br><span class="line">    <span class="attribute">background-color</span>: pink;</span><br><span class="line"><span class="attribute">flex-grow</span>: <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-id">#C</span> &#123;</span><br><span class="line"><span class="attribute">background-color</span>: gainsboro;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">20px</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">p</span> &#123;</span><br><span class="line">    <span class="attribute">font-size</span>: <span class="number">20px</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.flex</span> &#123;</span><br><span class="line"><span class="attribute">display</span>: flex;</span><br><span class="line"><span class="attribute">justify-content</span>: center;</span><br><span class="line"><span class="attribute">align-items</span>: center;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那么，渲染结果为：</p><p><img src="https://s2.ax1x.com/2019/11/16/MBDz9A.png" alt></p><p>当我们将整体宽度设置为200px，</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-id">#app</span> &#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">200px</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">200px</span>;</span><br><span class="line"><span class="attribute">border</span>: <span class="number">1px</span> solid black;</span><br><span class="line">    <span class="attribute">display</span>: flex;</span><br><span class="line">    <span class="attribute">flex-direction</span>: row;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那么渲染结果为：<br><img src="https://s2.ax1x.com/2019/11/16/MBDvhd.png" alt></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;flex布局的基本语法知识&quot;&gt;&lt;a href=&quot;#flex布局的基本语法知识&quot; class=&quot;headerlink&quot; title=&quot;flex布局的基本语法知识&quot;&gt;&lt;/a&gt;flex布局的基本语法知识&lt;/h2&gt;&lt;h3 id=&quot;如何设置flex布局&quot;&gt;&lt;a href=&quot;
      
    
    </summary>
    
      <category term="css" scheme="http://angellike_fairy.gitee.io/angellikefairy/categories/css/"/>
    
    
  </entry>
  
  <entry>
    <title>相等==与全等===的区别</title>
    <link href="http://angellike_fairy.gitee.io/angellikefairy/2019/11/15/%E7%9B%B8%E7%AD%89-%E4%B8%8E%E5%85%A8%E7%AD%89-%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
    <id>http://angellike_fairy.gitee.io/angellikefairy/2019/11/15/相等-与全等-的区别/</id>
    <published>2019-11-15T06:44:33.000Z</published>
    <updated>2019-11-15T08:47:40.647Z</updated>
    
    <content type="html"><![CDATA[<h2 id="概要"><a href="#概要" class="headerlink" title="概要"></a>概要</h2><p>JavaScript 有两种比较方式：严格比较运算符和转换类型比较运算符。对于严格比较运算符（===）来说，仅当两个操作数的类型相同且值相等为 true，而对于被广泛使用的比较运算符（==）来说，会在进行比较之前，将两个操作数转换成相同的类型。</p><h2 id="全等运算符（-）"><a href="#全等运算符（-）" class="headerlink" title="全等运算符（===）"></a>全等运算符（===）</h2><p>全等运算符（===）的规则相对简单，我们先来看全等运算符的运算规则</p><ol><li>如果两个操作数有不同的类型，它们不是严格相等的</li><li>如果两个操作数都为 null，则它们是严格相等的</li><li>如果两个操作数都为 undefined，它们是严格相等的</li><li>如果一个或两个操作数都是 NaN，它们就不是严格相等的</li><li>如果两个操作数都为 true 或都为 false，它们是严格相等的</li><li>如果两个操作数都是 number 类型并且具有相同的值，则它们是严格相等的</li><li>如果两个操作数都是 string 类型并且具有相同的值，则它们是严格相等的</li><li>如果两个操作数都引用相同的对象或函数，则它们是严格相等的</li><li>以上所有其他情况下操作数都不是严格相等的。</li></ol><p>简单概括来说，对于全等运算符来说，操作数双方必须是同一类型并且具有相同的值（引用的指向必须指向同一个引用）（除了NaN）以外。因为，NaN与任何值都不相等包括其本身。</p><p>例如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="literal">undefined</span>===<span class="literal">undefined</span>); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">1</span>===<span class="string">'1'</span>); <span class="comment">// false</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="literal">null</span>===<span class="literal">null</span>); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(&#123;<span class="attr">a</span>:<span class="number">1</span>&#125;===&#123;<span class="attr">a</span>:<span class="number">1</span>&#125;); <span class="comment">// false</span></span><br></pre></td></tr></table></figure><h2 id="数值转换"><a href="#数值转换" class="headerlink" title="数值转换"></a>数值转换</h2><p>我们使用Number()转型函数来将其他类型转化为数值型</p><p>具体规则如下：</p><ol><li>如果是布尔值，那么true转化为1，false转化为0<br>2，如果是null值，那么转化为0</li><li>如果是undefined，返回NaN</li><li>如果是字符串，又会分以下几种情况<ul><li>如果字符串只包含数字（包括带正负号，整数或者是浮点数），那么就会返回该数值</li><li>如果字符串是空的，那么返回数字0</li></ul><ol start="3"><li>其余情况返回NaN</li></ol></li><li>如果是对象，那么调用对象的valueOf()方法，然后再依照前面的规则转换返回的值</li></ol><h2 id="对象转化为基本类型值"><a href="#对象转化为基本类型值" class="headerlink" title="对象转化为基本类型值"></a>对象转化为基本类型值</h2><p>在将相等运算符的规则之前，我们需要弄清楚对象转化为基本类型值会变成怎么样？因为，这会出现在相等运算符的比较规则中</p><blockquote><p>对象在转换基本类型时，首先会调用 valueOf 然后调用 toString</p></blockquote><h3 id="valueOf-NaN"><a href="#valueOf-NaN" class="headerlink" title="valueOf"></a>valueOf</h3><blockquote><p>valueOf() 方法返回指定对象的原始值。</p></blockquote><p>具体规则如下：<br>对象|返回值<br>–|–<br>Array|返回数组本身对象<br>Boolean|布尔值<br>Date|存储的时间是从 1970 年 1 月 1 日午夜开始计的毫秒数 UTC<br>Function|函数本身<br>Number|数字值<br>Object|对象本身<br>String|字符串值</p><p>例如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>].valueOf()); <span class="comment">// [1,2,3]</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">new</span> <span class="built_in">Boolean</span>(<span class="literal">false</span>).valueOf()); <span class="comment">//false</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">new</span> <span class="built_in">Date</span>().valueOf()); <span class="comment">// 1573803246103</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="function"><span class="keyword">function</span> <span class="title">a</span>(<span class="params"></span>)</span>&#123;&#125;.valueOf()); <span class="comment">// function a()&#123;&#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">new</span> <span class="built_in">Number</span>(<span class="number">1</span>).valueOf()); <span class="comment">// 1</span></span><br><span class="line"><span class="built_in">console</span>.log(&#123;<span class="attr">a</span>:<span class="number">1</span>&#125;.valueOf()); <span class="comment">// &#123;a:1&#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">new</span> <span class="built_in">String</span>(<span class="string">'nice'</span>).valueOf()); <span class="comment">// 'nice'</span></span><br></pre></td></tr></table></figure><h3 id="toString-NaN"><a href="#toString-NaN" class="headerlink" title="toString"></a>toString</h3><blockquote><p>toString() 方法返回一个表示该对象的字符串。</p></blockquote><p>例如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>].toString()); <span class="comment">// '1,2,3'</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">new</span> <span class="built_in">Boolean</span>(<span class="literal">false</span>).toString()); <span class="comment">//'false'</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">new</span> <span class="built_in">Date</span>().toString()); <span class="comment">// 'Fri Nov 15 2019 15:41:22 GMT+0800 (GMT+08:00)'</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="function"><span class="keyword">function</span> <span class="title">a</span>(<span class="params"></span>)</span>&#123;&#125;.toString()); <span class="comment">// 'function a()&#123;&#125;'</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">new</span> <span class="built_in">Number</span>(<span class="number">1</span>).toString()); <span class="comment">// '1'</span></span><br><span class="line"><span class="built_in">console</span>.log(&#123;<span class="attr">a</span>:<span class="number">1</span>&#125;.toString()); <span class="comment">// [object Object]</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">new</span> <span class="built_in">String</span>(<span class="string">'nice'</span>).toString()); <span class="comment">// 'nice'</span></span><br></pre></td></tr></table></figure><h2 id="相等运算符（-）"><a href="#相等运算符（-）" class="headerlink" title="相等运算符（==）"></a>相等运算符（==）</h2><p>使用相等运算符时，都会先转换操作数（通常称为强制转型）为相同的类型，然后再比较他们的相等性</p><p>相等运算符遵循以下规则：</p><ol><li>如果操作数具有相同的类型，请使用上面的 IEA 测试它们是否严格相等。 如果它们不严格相等，则它们不相等，否则相等。</li><li>如果操作数有不同的类型：<ul><li>如果一个操作数为 null 而另一个 undefined，则它们相等</li><li>如果一个值是数字，另一个是字符串，先将字符串转换为数字，然后使用转换后的值比较</li><li>如果一个操作数是布尔值，则将 true 转换为 1，将 false 转换为 0，然后使用转换后的值比较</li><li>如果一个操作数是一个对象，而另一个操作数是一个数字或字符串，则调用valueOf()将该对象转换为基本类型值，再使用转换后的值进行比较</li></ul></li><li>在以上的其他情况下，操作数都不相等</li></ol><p>注意：</p><blockquote><p>在进行相等比较操作中,undefined和null是不能进行类型转化的。因此,undefined和null只能互相相等或者它们自身相等</p></blockquote><p>例如：</p><h3 id="其中一个操作数为布尔值"><a href="#其中一个操作数为布尔值" class="headerlink" title="其中一个操作数为布尔值"></a>其中一个操作数为布尔值</h3><blockquote><p>如果一个操作数为布尔值，那么将true转化为1，将false转化为0。然后，再利用其余规则进行比较</p></blockquote><h4 id="布尔值与数值比较"><a href="#布尔值与数值比较" class="headerlink" title="布尔值与数值比较"></a>布尔值与数值比较</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="number">1</span>==<span class="literal">true</span>); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">3</span>==<span class="literal">false</span>); <span class="comment">// false</span></span><br></pre></td></tr></table></figure><h4 id="布尔值与字符串比较"><a href="#布尔值与字符串比较" class="headerlink" title="布尔值与字符串比较"></a>布尔值与字符串比较</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="string">'1'</span>==<span class="literal">true</span>); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'123'</span>==<span class="literal">false</span>); <span class="comment">// false</span></span><br></pre></td></tr></table></figure><h4 id="布尔值与其余基本类型值比较"><a href="#布尔值与其余基本类型值比较" class="headerlink" title="布尔值与其余基本类型值比较"></a>布尔值与其余基本类型值比较</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="literal">undefined</span>==<span class="literal">true</span>); <span class="comment">// false</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="literal">null</span>==<span class="literal">false</span>); <span class="comment">// false</span></span><br></pre></td></tr></table></figure><p>因为，在进行相等比较操作中，undefined和null是不能进行转化的，而布尔值需要转化为数值型，因此，两者不可能相等</p><h4 id="布尔值与数组比较"><a href="#布尔值与数组比较" class="headerlink" title="布尔值与数组比较"></a>布尔值与数组比较</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log([]==<span class="literal">false</span>); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]==<span class="literal">false</span>); <span class="comment">// false</span></span><br><span class="line"><span class="built_in">console</span>.log([<span class="number">1</span>]==<span class="literal">true</span>); <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>是不是感觉很奇怪？</p><p>我们在前面提过，如果其中一个操作数为对象，那么就要该对象先通过valueOf()再通过toString()转化为基本类型值（确切来说是字符串型）然后再利用其余规则进行比较</p><p>又因为另一个操作数为布尔值，那么，布尔值就会被转化为数值型，true转化为1，false转化为0</p><p>因此，已经转化为字符串的对象还需要将字符串转化为数值型</p><p>具体过程如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line">比较[]与false</span><br><span class="line">1. [].valueOf() --&gt; &apos;&apos;</span><br><span class="line">2. &apos;&apos;.toString() --&gt; &apos;&apos;</span><br><span class="line">3. Number(&apos;&apos;) --&gt; 0</span><br><span class="line"></span><br><span class="line">4. Number(false) --&gt; 0</span><br><span class="line"></span><br><span class="line">5. 0===0 --&gt;true</span><br><span class="line"></span><br><span class="line">*/</span><br></pre></td></tr></table></figure><p>其余几个过程类似，因此不再赘述</p><h4 id="布尔值与其余对象"><a href="#布尔值与其余对象" class="headerlink" title="布尔值与其余对象"></a>布尔值与其余对象</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(&#123;<span class="attr">a</span>:<span class="number">1</span>&#125; == <span class="literal">false</span>); <span class="comment">// false</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">new</span> <span class="built_in">Date</span>()=== <span class="literal">true</span>); <span class="comment">// false</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="function"><span class="keyword">function</span> (<span class="params"></span>)</span>&#123;&#125; == <span class="literal">false</span>); <span class="comment">// false</span></span><br></pre></td></tr></table></figure><h3 id="其中一个操作数为字符串"><a href="#其中一个操作数为字符串" class="headerlink" title="其中一个操作数为字符串"></a>其中一个操作数为字符串</h3><p>在进行操作数比较前，我们需要明确，只有另一个操作数为数值型的情况下（可能发生了转换变为了数值型），我们才需要将该字符串转化为数值；否则，该字符串不会进行转化</p><p>例如：</p><h4 id="另一个操作数为数值"><a href="#另一个操作数为数值" class="headerlink" title="另一个操作数为数值"></a>另一个操作数为数值</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="string">'123'</span>==<span class="number">123</span>); <span class="comment">// true</span></span><br></pre></td></tr></table></figure><h4 id="另一个操作数为布尔值"><a href="#另一个操作数为布尔值" class="headerlink" title="另一个操作数为布尔值"></a>另一个操作数为布尔值</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="string">'1'</span>==<span class="literal">true</span>); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'0'</span>==<span class="literal">false</span>); <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>因为布尔值在进行相等比较的前一定会转换为数值型，因此，字符串也会被通过Number转型函数变为数值型。</p><h4 id="另一个操作数为其他基本类型值"><a href="#另一个操作数为其他基本类型值" class="headerlink" title="另一个操作数为其他基本类型值"></a>另一个操作数为其他基本类型值</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="string">'0'</span>==<span class="literal">null</span>); <span class="comment">// false</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'0'</span>==<span class="literal">undefined</span>); <span class="comment">// false</span></span><br></pre></td></tr></table></figure><p>在相等比较前，null和undefined不能被转换为其他类型值</p><h4 id="另一个操作数为数组"><a href="#另一个操作数为数组" class="headerlink" title="另一个操作数为数组"></a>另一个操作数为数组</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="string">'0'</span>==[]); <span class="comment">// false</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'1'</span>==[<span class="number">1</span>]); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'123'</span>==[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]); <span class="comment">// false</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'1,2,3'</span>==[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]); <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>首先，必须明确地是，如果其中一个操作数为字符串类型，那么我们先去看另一个操作数为什么类型。</p><p>在这里，另一个操作数为引用类型值，那么引用类型值会通过valueOf和toString转换为字符串型。那么，另一个字符型操作数就不需要进行转换，两个字符串类型进行比较即可。（因为，相等操作符在比较比较之前的目的就是将两个操作数的类型转换为一致，然后再进行比较）</p><h4 id="另一个操作数为对象"><a href="#另一个操作数为对象" class="headerlink" title="另一个操作数为对象"></a>另一个操作数为对象</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(&#123;<span class="attr">a</span>:<span class="number">1</span>&#125;==<span class="string">'a:1'</span>); <span class="comment">// false</span></span><br><span class="line"><span class="built_in">console</span>.log(&#123;&#125;==<span class="string">''</span>); <span class="comment">// false</span></span><br></pre></td></tr></table></figure><p>在这里，我们千万不要忘记自定义对象通过toString()方法转换得到的都是：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(&#123;<span class="attr">a</span>:<span class="number">1</span>&#125;.valueOf().toString()); <span class="comment">// '[object Object]'</span></span><br></pre></td></tr></table></figure><h3 id="其中一个操作数为数组"><a href="#其中一个操作数为数组" class="headerlink" title="其中一个操作数为数组"></a>其中一个操作数为数组</h3><p>大致的比较方法差不多在前面都提及了，这里看一个奇葩的题目：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log([]=![]); <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>是不是很奇怪，但是，如果仔细进行分析就不会觉得奇怪了。</p><p>具体过程：</p><ol><li>第一个操作数为[]，那么将其通过valueOf和toString转换为字符串得到空字符串’’</li><li>第二个操作数![]，因为有逻辑非布尔操作符，因此第二个操作数实际上是布尔值false</li><li>布尔值需要转换为数值型,false转换为0</li><li>因为第二个操作数转换为数值型了，因此，第一个操作数也要将得到的字符串转换为数值型，空字符串’’通过Number转型函数得到的是0</li><li>0===0 返回true</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;概要&quot;&gt;&lt;a href=&quot;#概要&quot; class=&quot;headerlink&quot; title=&quot;概要&quot;&gt;&lt;/a&gt;概要&lt;/h2&gt;&lt;p&gt;JavaScript 有两种比较方式：严格比较运算符和转换类型比较运算符。对于严格比较运算符（===）来说，仅当两个操作数的类型相同且值相等
      
    
    </summary>
    
      <category term="javaScript基础" scheme="http://angellike_fairy.gitee.io/angellikefairy/categories/javaScript%E5%9F%BA%E7%A1%80/"/>
    
    
  </entry>
  
  <entry>
    <title>TypeScript零散知识点总结</title>
    <link href="http://angellike_fairy.gitee.io/angellikefairy/2019/11/15/TypeScript%E9%9B%B6%E6%95%A3%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/"/>
    <id>http://angellike_fairy.gitee.io/angellikefairy/2019/11/15/TypeScript零散知识点总结/</id>
    <published>2019-11-15T05:26:14.000Z</published>
    <updated>2019-11-15T06:10:05.964Z</updated>
    
    <content type="html"><![CDATA[<h2 id="如何注解二维数组"><a href="#如何注解二维数组" class="headerlink" title="如何注解二维数组"></a>如何注解二维数组</h2><p>我们一般会使用一下两种方式来注解一维数组：</p><ol><li><p>类型+方括号</p> <figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr: <span class="built_in">number</span>[];</span><br></pre></td></tr></table></figure></li><li><p>数组泛型</p> <figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr: <span class="built_in">Array</span>&lt;<span class="built_in">number</span>&gt;;</span><br></pre></td></tr></table></figure></li></ol><p>那么，以此类推，我们也可以用以上两种方式来注解二维数组：</p><ol><li><p>类型+两个方括号</p> <figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr: <span class="built_in">number</span>[][];</span><br></pre></td></tr></table></figure></li><li><p>泛型中类型为泛型数组</p> <figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr: <span class="built_in">Array</span>&lt;<span class="built_in">Array</span>&lt;<span class="built_in">number</span>&gt;&gt;</span><br></pre></td></tr></table></figure></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;如何注解二维数组&quot;&gt;&lt;a href=&quot;#如何注解二维数组&quot; class=&quot;headerlink&quot; title=&quot;如何注解二维数组&quot;&gt;&lt;/a&gt;如何注解二维数组&lt;/h2&gt;&lt;p&gt;我们一般会使用一下两种方式来注解一维数组：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;类型+方括号&lt;/
      
    
    </summary>
    
      <category term="TypeScript" scheme="http://angellike_fairy.gitee.io/angellikefairy/categories/TypeScript/"/>
    
    
  </entry>
  
  <entry>
    <title>Vue的一些零散知识点总结</title>
    <link href="http://angellike_fairy.gitee.io/angellikefairy/2019/11/11/Vue%E7%9A%84%E4%B8%80%E4%BA%9B%E9%9B%B6%E6%95%A3%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/"/>
    <id>http://angellike_fairy.gitee.io/angellikefairy/2019/11/11/Vue的一些零散知识点总结/</id>
    <published>2019-11-11T05:47:44.000Z</published>
    <updated>2019-11-13T11:17:19.725Z</updated>
    
    <content type="html"><![CDATA[<h2 id="v-if与v-show的区别"><a href="#v-if与v-show的区别" class="headerlink" title="v-if与v-show的区别"></a>v-if与v-show的区别</h2><p>官方文档对于这两个指令的定义：</p><ul><li><p>v-show：根据表达式之真假值，切换元素的 display CSS属性。</p></li><li><p>v-if: 根据表达式的值的真假条件渲染元素。在切换时元素及它的数据绑定 / 组件被销毁并重建。如果元素是 &lt;template&gt; ，将提出它的内容作为条件块。</p></li></ul><p>我们通过实际的例子来区分这两个指令的区别：</p><h3 id="v-show的渲染情况"><a href="#v-show的渲染情况" class="headerlink" title="v-show的渲染情况"></a>v-show的渲染情况</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span> <span class="attr">v-show</span>=<span class="string">"bool"</span>&gt;</span>&#123;&#123;value&#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p>当bool值为真时，渲染情况如下：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>123<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure><p>当bool值为假时，渲染情况发生了如下变化：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">styel</span>=<span class="string">"display:none;"</span>&gt;</span>123<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure><p>我们可以看到，当使用v-show时，该节点会被添加到DOM树中，始终会被渲染。切换v-show的值只是简单的切换元素的display元素而已</p><h4 id="display与opacity与visibility的区别"><a href="#display与opacity与visibility的区别" class="headerlink" title="display与opacity与visibility的区别"></a>display与opacity与visibility的区别</h4><p>当v-show为false时，vue会将该元素的style属性的display属性设置为none。</p><p>那么，对于其他两种也可以将元素隐藏的css方式，这三种有什么区别呢？</p><table><thead><tr><th>属性</th><th>属性值</th><th>是否可见</th><th>是否占用布局</th><th>是否可以被点击</th></tr></thead><tbody><tr><td>display</td><td>none</td><td>不可见</td><td>不占用</td><td>不能</td></tr><tr><td>opacity</td><td>0</td><td>不可见</td><td>占用</td><td>能</td></tr><tr><td>visibility</td><td>hidden</td><td>不可见</td><td>占用</td><td>不能</td></tr></tbody></table><h3 id="v-if的渲染情况"><a href="#v-if的渲染情况" class="headerlink" title="v-if的渲染情况"></a>v-if的渲染情况</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span> <span class="attr">v-if</span>=<span class="string">"bool"</span>&gt;</span>&#123;&#123;value&#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p>当bool值为真时，渲染情况如下：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>123<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure><p>当bool值为假时，渲染情况发生了如下变化：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app"</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!----&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p>我们可以看到，当使用v-if时，如果v-if的值为false，那么该节点就不会被添加到DOM树中，当然也不会被渲染。只有，当v-if的值为true时，该节点才会被正常渲染</p><p>另外，我们也可以使用v-else与v-if进行配合</p><p>例如：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">v-if</span>=<span class="string">"bool"</span>&gt;</span>&#123;&#123;value&#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">v-else</span>&gt;</span>&#123;&#123;anotherValue&#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="多元素条件渲染（v-if支持-v-show不支持）"><a href="#多元素条件渲染（v-if支持-v-show不支持）" class="headerlink" title="多元素条件渲染（v-if支持,v-show不支持）"></a>多元素条件渲染（v-if支持,v-show不支持）</h3><p>以上我们使用v-if和v-show都是对单个元素进行条件渲染，那么如果想对多个元素一起进行条件渲染呢？</p><p>vue允许我们在&lt;template&gt;元素上使用v-if来对多个元素进行一起条件渲染。</p><p>此时vue会把 &lt;template&gt; 元素当做不可见的包裹元素，并在上面使用 v-if。最终的渲染结果将不包含 &lt;template&gt; 元素。</p><p>例如：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">template</span> <span class="attr">v-if</span>=<span class="string">"bool"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">p</span>&gt;</span>&#123;&#123;value1&#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">p</span>&gt;</span>&#123;&#123;value2&#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">p</span>&gt;</span>&#123;&#123;value3&#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">template</span> <span class="attr">v-else</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">p</span>&gt;</span>&#123;&#123;anotherValue&#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">"changeIf"</span>&gt;</span>change<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p>那么v-show呢？它支持多元素条件渲染吗？遗憾的是，它并不支持。</p><blockquote><p>注意，v-show 不支持 &lt;template&gt; 元素，也不支持 v-else</p></blockquote><h3 id="v-if与v-show区别总结"><a href="#v-if与v-show区别总结" class="headerlink" title="v-if与v-show区别总结"></a>v-if与v-show区别总结</h3><p>由以上的示例我们可以看到：</p><ol><li>v-if是真正的条件渲染，它会根据条件的真值来决定是否将该DOM元素加入或移除DOM树</li><li>v-show会一直渲染该DOM元素，也就是该DOM元素一直在DOM树上。只是，简单地切换该元素的style属性中的display而已</li></ol><p>因此，v-if有更高的切换开销，而v-show有更高的初始渲染开销。如果，元素需要频繁的切换的话，那么使用v-show更好，反之，使用v-if较好</p><h2 id="除了数组，我们还可以给v-for传递什么参数"><a href="#除了数组，我们还可以给v-for传递什么参数" class="headerlink" title="除了数组，我们还可以给v-for传递什么参数"></a>除了数组，我们还可以给v-for传递什么参数</h2><p>通常来说，我们一般会传递v-for一个数组来让vue进行列表渲染</p><p>但事实上，除了数组，我们还可以传递给v-for更多类型的参数。官方文档并没有太多的提及传递的参数类型限制。但是，我们可以从源码中找到答案：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; isObject, isDef, hasSymbol &#125; <span class="keyword">from</span> <span class="string">'core/util/index'</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Runtime helper for rendering v-for lists.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">renderList</span> (<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  val: <span class="built_in">any</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">  render: (</span></span></span><br><span class="line"><span class="function"><span class="params">    val: <span class="built_in">any</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">    keyOrIndex: <span class="built_in">string</span> | <span class="built_in">number</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">    index?: <span class="built_in">number</span></span></span></span><br><span class="line"><span class="function"><span class="params">  ) =&gt; VNode</span></span></span><br><span class="line"><span class="function"><span class="params"></span>): ?<span class="title">Array</span>&lt;<span class="title">VNode</span>&gt; </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> ret: ?<span class="built_in">Array</span>&lt;VNode&gt;, i, l, keys, key</span><br><span class="line">  <span class="comment">// 如果传递的参数是数组或者是字符串，那么生成的新数组的元素为数组元素或是字符串中的每个字符</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">Array</span>.isArray(val) || <span class="keyword">typeof</span> val === <span class="string">'string'</span>) &#123;</span><br><span class="line">    ret = <span class="keyword">new</span> <span class="built_in">Array</span>(val.length)</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>, l = val.length; i &lt; l; i++) &#123;</span><br><span class="line">      ret[i] = render(val[i], i)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">typeof</span> val === <span class="string">'number'</span>) &#123;</span><br><span class="line">    <span class="comment">// 如果传递的参数是number，那么生成一个数组，数组元素为1到该number的值</span></span><br><span class="line">    ret = <span class="keyword">new</span> <span class="built_in">Array</span>(val)</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; val; i++) &#123;</span><br><span class="line">      ret[i] = render(i + <span class="number">1</span>, i)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (isObject(val)) &#123; <span class="comment">// 传递的参数为对象类型，需要进行进一步的判断</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果传递的对象可迭代，即具有Symbol.iterator生成器方法</span></span><br><span class="line">    <span class="keyword">if</span> (hasSymbol &amp;&amp; val[Symbol.iterator]) &#123;</span><br><span class="line">      ret = []</span><br><span class="line">      <span class="keyword">const</span> iterator: Iterator&lt;<span class="built_in">any</span>&gt; = val[Symbol.iterator]()</span><br><span class="line">      <span class="keyword">let</span> result = iterator.next()</span><br><span class="line">      <span class="keyword">while</span> (!result.done) &#123;</span><br><span class="line">        ret.push(render(result.value, ret.length))</span><br><span class="line">        result = iterator.next()</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// 该对象为不可迭代对象，一般为用户自定义对象，那么使用object.keys遍历它（因此，如果对象中有不可枚举属性，则该属性值无法得到）</span></span><br><span class="line">      keys = <span class="built_in">Object</span>.keys(val)</span><br><span class="line">      ret = <span class="keyword">new</span> <span class="built_in">Array</span>(keys.length)</span><br><span class="line">      <span class="keyword">for</span> (i = <span class="number">0</span>, l = keys.length; i &lt; l; i++) &#123;</span><br><span class="line">        key = keys[i]</span><br><span class="line">        ret[i] = render(val[key], key, i)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (!isDef(ret)) &#123;</span><br><span class="line">    ret = []</span><br><span class="line">  &#125;</span><br><span class="line">  (ret: <span class="built_in">any</span>)._isVList = <span class="literal">true</span></span><br><span class="line">  <span class="keyword">return</span> ret</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>读完上面这段源码后，可以做个总结：<br>无论我们传递什么类型的数据给v-if，vue层面会将该数据进行转化得到一个数组再进行列表渲染。</p><p>分类来说：</p><ol><li>如果为string，那么会得到一个字符数组</li><li>如果为number，那么数组将会是[1,2,3…,number];</li><li>如果为数组，那么以该数组建立新数组</li><li>如果为对象，又要分两类<ol><li>如果为可迭代对象（集合对象：数组，Map，Set，字符等其他有Symbol.iterator生成器方法的对象）那么将迭代的值存入新数组</li><li>如果为不可迭代对象，那么使用Object.keys()方法将得到的属性值存入新数组；因此，不会包括不可枚举属性的属性值</li></ol></li></ol><h2 id="数组和对象更新时需要注意的地方"><a href="#数组和对象更新时需要注意的地方" class="headerlink" title="数组和对象更新时需要注意的地方"></a>数组和对象更新时需要注意的地方</h2><p>我们知道，在进行数据双向绑定的时候。vue会将data中的每个属性和子属性使用Object.defineProperty变为访问器属性。当我们修改这些属性的属性值时，就会触发setter函数，从而引起视图变化。</p><p>但是，这个Object.defineProperty方法只能对具有属性的对象使用，那么vue是怎么做到对数组的监听呢？</p><p>这里只给出总体代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Observe a list of Array items.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">observeArray (items: <span class="built_in">Array</span>&lt;any&gt;) &#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>, l = items.length; i &lt; l; i++) &#123;</span><br><span class="line">    observe(items[i])  <span class="comment">// observe 功能为监测数据的变化</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>具体的，之后再深入的过程中会做出更加详细的解释s</p><p>然而，我们要注意，这个数据双向绑定的过程是发生在vue生命周期的挂载节点之后的。也就是说，当vue实例完全初始化完毕进入运行状态后，我们进行以下的操作将不会使数据进行响应：</p><p>对于数组：</p><ol><li>当你利用索引直接设置一个数组项时，例如：vm.items[indexOfItem] = newValue</li><li>当你修改数组的长度时，例如：vm.items.length = newLength</li></ol><p>对于对象：</p><ol><li>添加对象属性</li><li>删除对象属性</li></ol><p>对于以上的情况，我们都可以使用vm.$set来解决</p><h2 id="Vue为DOM元素设置和获取自定义属性"><a href="#Vue为DOM元素设置和获取自定义属性" class="headerlink" title="Vue为DOM元素设置和获取自定义属性"></a>Vue为DOM元素设置和获取自定义属性</h2><p>在html5中，我们使用 data-* 属性来嵌入自定义数据：</p><blockquote><p>data-* 属性赋予我们在所有 HTML 元素上嵌入自定义 data 属性的能力。</p></blockquote><p>需要注意的是：</p><blockquote><p>属性名不应该包含任何大写字母，并且在前缀 “data-“ 之后必须有至少一个字符</p></blockquote><p>例如：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">data-v</span>=<span class="string">'1'</span>&gt;</span>hello<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure><p>因此，为了遵循这一规范，我们在Vue中为一个DOM元素添加自定义属性时，也应当这样写：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">:data-v</span>=<span class="string">"value"</span>&gt;</span>&#123;&#123;value&#125;&#125;<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure><p>然后，我们可以通过element.getAttribute()来获取元素</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a = <span class="built_in">document</span>.getElementsByTagName(<span class="string">'a'</span>)[<span class="number">0</span>];</span><br><span class="line"><span class="built_in">console</span>.log(a.getAttribute(<span class="string">'data-v'</span>));</span><br></pre></td></tr></table></figure><p>但是，Vue并不推荐我们直接来操纵DOM，因此，我们可以使用Vue的ref属性来进行DOM元素的引用，引用的信息将会被注册在$refs对象上</p><p>因此，我们可以做出如下的修改：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">:data-v</span>=<span class="string">"value"</span> <span class="attr">ref</span>=<span class="string">"aLink"</span>&gt;</span>&#123;&#123;value&#125;&#125;<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure><p>此时，该a标签DOM元素将会作为aLink的键值在$refs对象中被注册</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 数据对象</span></span><br><span class="line">data: &#123;</span><br><span class="line">    value: <span class="number">123</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在Vue组件的某个方法中</span></span><br><span class="line">getDataV() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.$refs); <span class="comment">// &#123;aLink: a&#125;</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.$refs.aLink.getAttribute(<span class="string">'data-v'</span>)); <span class="comment">// 123</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="为指令设置动态参数"><a href="#为指令设置动态参数" class="headerlink" title="为指令设置动态参数"></a>为指令设置动态参数</h2><p>我们知道，Vue允许在指令后添加参数。例如，在v-bind指令后添加参数就可以将该参数作为DOM元素的属性</p><p>例如：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">:value</span>=<span class="string">"value"</span> <span class="attr">ref</span>=<span class="string">"aLink"</span>&gt;</span><span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure><p>我们通过控制台查看该DOM元素就可以得到如下结果：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">value</span>=<span class="string">"123346"</span>&gt;</span>value<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure><p>初次之外，Vue可以支持使用类似方括号的语法（但是方括号中只能填写Vue实例中data声明的变量）来为指令设置动态参数</p><p>例如：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">a</span> <span class="attr">:</span>[<span class="attr">attributeName</span>]=<span class="string">"url"</span>&gt;</span>&#123;&#123;value&#125;&#125;<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p>然后，我们在Vue实例中这样设置：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> Vue(&#123;</span><br><span class="line">    el: <span class="string">'#app'</span>,</span><br><span class="line">    data: &#123;</span><br><span class="line">        attributeName: <span class="string">'href'</span>,</span><br><span class="line">        url: <span class="string">'https://www.baidu.com'</span>,</span><br><span class="line">        value: <span class="string">'baidu'</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>然后，我们在控制台进行查看，就可以得到如下的结果：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span>&gt;</span>baidu<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure><p>令人意外的是，得到的结果并不是预料中的如下的结果：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"https://www.baidu.com"</span>&gt;</span>baidu<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure><p>然后我查看官方文档才发现了原因所在：</p><p>其实，Vue对于动态参数表达式是有限制的：</p><ol><li>空格和引号在表达式中是无效的</li><li>避免使用大写字符来命名键名，因为浏览器会把 attribute（属性） 名全部强制转为小写</li></ol><p>因此，我们需要将之前的模板和Vue实例进行修改：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">a</span> <span class="attr">:</span>[<span class="attr">attribute</span>]=<span class="string">"url"</span>&gt;</span>&#123;&#123;value&#125;&#125;<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> Vue(&#123;</span><br><span class="line">    el: <span class="string">'#app'</span>,</span><br><span class="line">    data: &#123;</span><br><span class="line">        attribute: <span class="string">'href'</span>,</span><br><span class="line">        url: <span class="string">'https://www.baidu.com'</span>,</span><br><span class="line">        value: <span class="string">'baidu'</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>此时，我们就可以查看到正确的DOM元素了</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"https://www.baidu.com"</span>&gt;</span>baidu<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="Vue的常用修饰符"><a href="#Vue的常用修饰符" class="headerlink" title="Vue的常用修饰符"></a>Vue的常用修饰符</h2><p>修饰符 (modifier) 是以半角句号 . 指明的特殊后缀，用于指出一个指令应该以特殊方式绑定。</p><p>在进行详细的事件处理修饰符的说明前，我们先来了解target.addEventListener方法的详细说明，因为，下面的修饰符大多数针对该方法进行简写而已</p><h3 id="addEventListener的详细说明"><a href="#addEventListener的详细说明" class="headerlink" title="addEventListener的详细说明"></a>addEventListener的详细说明</h3><p>完整的addEventListener的方法定义如下：</p><blockquote><p>target .addEventListener（type，listener [，options ]）;</p></blockquote><p>参数说明：</p><ul><li><p>type: 区分大小写的字符串，表示要侦听的事件类型。</p></li><li><p>listener: Event当指定类型的事件发生时，接收通知的对象（实现接口的对象）。这必须是实现EventListener接口的对象或JavaScript 函数</p></li><li><p>options: 可选，一个选项对象，可以包括以下几个选项：</p><ul><li>capture true表示在捕获阶段执行事件处理程序，false表示在冒泡阶段</li><li>once Boolean，listener应在添加后最多调用一次。如果为true，则listener在调用时会自动将其删除。</li><li>passive: Boolean 如果true表示表示所指定的函数listener将永远不会调用preventDefault()。如果被动侦听器确实进行了调用preventDefault()，则用户代理将不执行任何操作，只生成控制台警告。</li></ul></li></ul><h3 id="v-on事件处理的修饰符"><a href="#v-on事件处理的修饰符" class="headerlink" title="v-on事件处理的修饰符"></a>v-on事件处理的修饰符</h3><p>Vue的官方文档是这样叙述为什么要使用数件处理修饰符的：</p><blockquote><p>在事件处理程序中调用 event.preventDefault() 或 event.stopPropagation() 是非常常见的需求。尽管我们可以在方法中轻松实现这点，但更好的方式是：方法只有纯粹的数据逻辑，而不是去处理 DOM 事件细节。</p></blockquote><p>因此，Vue为v-on提供了事件处理修饰符</p><h4 id="stop修饰符-相当于调用event-stopPropagation"><a href="#stop修饰符-相当于调用event-stopPropagation" class="headerlink" title=".stop修饰符 相当于调用event.stopPropagation()"></a>.stop修饰符 相当于调用event.stopPropagation()</h4><p>该.stop修饰符可以阻止事件流进一步的传递（捕获或者冒泡）</p><p>以下以阻止事件进一步冒泡为例进行说明：</p><h5 id="没有使用-stop修饰符"><a href="#没有使用-stop修饰符" class="headerlink" title="没有使用.stop修饰符"></a>没有使用.stop修饰符</h5><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app"</span> <span class="attr">style</span>=<span class="string">"border: 1px solid black;width: 100px;height: 100px;"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span> <span class="attr">:</span>[<span class="attr">attribute</span>]=<span class="string">"url"</span> @<span class="attr">click</span>=<span class="string">"clickP"</span>&gt;</span>&#123;&#123;value&#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p>我们分别为div元素和p元素设置一个方法用来监听click事件:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> vm = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">    el: <span class="string">'#app'</span>,</span><br><span class="line">    data: &#123;</span><br><span class="line">        attribute: <span class="string">'href'</span>,</span><br><span class="line">        url: <span class="string">'https://www.baidu.com'</span>,</span><br><span class="line">        value: <span class="string">'baidu'</span></span><br><span class="line">    &#125;,</span><br><span class="line">    methods: &#123;</span><br><span class="line">        <span class="comment">// p元素的事件监听程序</span></span><br><span class="line">        clickP() &#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">'p is clicked'</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">// 在挂载节点完毕后的生命周期阶段添加div元素的事件监听程序</span></span><br><span class="line">    mounted() &#123;</span><br><span class="line">        <span class="keyword">this</span>.$el.addEventListener(<span class="string">'click'</span>,()=&gt;&#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">'app is clicked'</span>);</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>当我们单击p元素的时候可以得到以下的输出结果：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 输出结果</span></span><br><span class="line"><span class="comment">p is clicked</span></span><br><span class="line"><span class="comment">app is clicked</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>我们知道DOM事件流会经过以下三个阶段：</p><ol><li>捕获阶段</li><li>处于事件目标阶段</li><li>冒泡阶段</li></ol><p>在这里提一句，如果在v-on后没有添加.capture修饰符，那么该事件会在冒泡阶段发生（相当于addEventListener方法的第二个参数为false）</p><p>因此，当我们单击p元素时，会经过以下步骤：</p><ol><li>在捕获阶段，没有绑定若任何处理程序，因此没有任何响应</li><li>处于目标阶段，因为我们单击的是p元素，因此，响应p元素绑定的事件监听程序，输出’p is clicked’</li><li>处于冒泡阶段，此时div元素绑定的click事件监听程序被响应，因此，输出’app is clicked’</li></ol><p>那么，如果使用.stop修饰符呢？</p><h5 id="使用-stop修饰符"><a href="#使用-stop修饰符" class="headerlink" title="使用.stop修饰符"></a>使用.stop修饰符</h5><p>我们将html代码修改，js代码保持不变：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app"</span> <span class="attr">style</span>=<span class="string">"border: 1px solid black;width: 100px;height: 100px;"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span> <span class="attr">:</span>[<span class="attr">attribute</span>]=<span class="string">"url"</span> @<span class="attr">click.stop</span>=<span class="string">"clickP"</span>&gt;</span>&#123;&#123;value&#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p>此时，当我们单击p元素的时候，就会得到以下的输出结果：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 输出结果</span></span><br><span class="line"><span class="comment">p is clicked</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>我们看到’app is clicked’并没有输出，这是因为修饰符.stop起到了stopPropagation的作用，阻止了事件流的进一步传递</p><h4 id="prevent修饰符-相当于调用-event-preventDefault"><a href="#prevent修饰符-相当于调用-event-preventDefault" class="headerlink" title=".prevent修饰符 相当于调用 event.preventDefault()"></a>.prevent修饰符 相当于调用 event.preventDefault()</h4><p>我们知道preventDefault方法可以取消事件的默认行为。因此，.prevent修饰符也是起到同样的作用</p><p>例如：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span> =<span class="string">"https://www.baidu.com"</span> @<span class="attr">click.prevent</span>=<span class="string">"clickA"</span>&gt;</span>clickA<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure><p>本来，当我们点击a标签的时候，默认将会跳转到href给定的地址。但是，当我们使用.prevent修饰符后就可以取消跳转这一默认行为</p><h4 id="capture修饰符-添加事件监听器时使用捕获模式"><a href="#capture修饰符-添加事件监听器时使用捕获模式" class="headerlink" title=".capture修饰符 添加事件监听器时使用捕获模式"></a>.capture修饰符 添加事件监听器时使用捕获模式</h4><p>之前就提到过这一修饰符的作用，.capture修饰符可以让事件在捕获阶段被调用，而不是默认在冒泡阶段被调用</p><p>例如：</p><p>注意，此时我将带修饰符的事件处理程序绑定在了div元素，而p元素的事件处理程序没有带修饰符</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app"</span> @<span class="attr">click.capture</span>=<span class="string">"clickDiv"</span> <span class="attr">style</span>=<span class="string">"border: 1px solid black;width: 100px;height: 100px;"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span> @<span class="attr">click</span>=<span class="string">"clickP"</span>&gt;</span>&#123;&#123;value&#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> vm = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">    el: <span class="string">'#app'</span>,</span><br><span class="line">    data: &#123;</span><br><span class="line">        value: <span class="string">'click it'</span></span><br><span class="line">    &#125;,</span><br><span class="line">    methods: &#123;</span><br><span class="line">        clickP() &#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">'p is clicked'</span>);</span><br><span class="line">        &#125;,</span><br><span class="line">        clickDiv() &#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">'div is clicked'</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>现在，当我们点击p元素时可以得到如下输出结果：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 输出结果</span></span><br><span class="line"><span class="comment">div is clicked</span></span><br><span class="line"><span class="comment">p is clicked</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>的确，div元素绑定的事件处理程序在事件流的捕获阶段被触发了。</p><p>那么，如果我们不添加.capture修饰符，那么点击p元素得到的输出结果就会是：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 输出结果</span></span><br><span class="line"><span class="comment">p is clicked</span></span><br><span class="line"><span class="comment">div is clicked</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>这样，div事件处理程序就会默认在事件流的冒泡阶段被执行</p><h4 id="self修饰符-相当于事件自身触发的而不是从内部元素触发的"><a href="#self修饰符-相当于事件自身触发的而不是从内部元素触发的" class="headerlink" title=".self修饰符 相当于事件自身触发的而不是从内部元素触发的"></a>.self修饰符 相当于事件自身触发的而不是从内部元素触发的</h4><p>.self修饰符的作用是：只有当事件是自身元素触发的而不是该元素内部元素触发的才会被执行相应的事件处理程序</p><p>示例：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app"</span> @<span class="attr">click.self</span>=<span class="string">"clickDiv"</span> <span class="attr">style</span>=<span class="string">"border: 1px solid black;width: 100px;height: 100px;"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span> @<span class="attr">click</span>=<span class="string">"clickP"</span>&gt;</span>&#123;&#123;value&#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> vm = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">    el: <span class="string">'#app'</span>,</span><br><span class="line">    data: &#123;</span><br><span class="line">        value: <span class="string">'click it'</span></span><br><span class="line">    &#125;,</span><br><span class="line">    methods: &#123;</span><br><span class="line">        clickP() &#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">'p is clicked'</span>);</span><br><span class="line">        &#125;,</span><br><span class="line">        clickDiv() &#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">'div is clicked'</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>现在，当我们点击p元素时的输出结果会得到以下的输出结果：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 输出结果</span></span><br><span class="line"><span class="comment">p is cliked</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>我们看到div元素的事件处理程序没有被触发。因为,.self修饰符让该元素的事件处理程序只有在该元素自身触发事件才可以被执行</p><p>但是，如果我们将div元素的.self修饰符去掉</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app"</span> @<span class="attr">click</span>=<span class="string">"clickDiv"</span> <span class="attr">style</span>=<span class="string">"border: 1px solid black;width: 100px;height: 100px;"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span> @<span class="attr">click</span>=<span class="string">"clickP"</span>&gt;</span>&#123;&#123;value&#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p>那么，当我们点击p元素的输出结果就会是这样的:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 输出结果</span></span><br><span class="line"><span class="comment">p is clicked</span></span><br><span class="line"><span class="comment">div is clicked</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>此时，div的事件处理程序就会在事件流的冒泡阶段而被触发</p><h4 id="once修饰符-点击事件将只会被触发一次"><a href="#once修饰符-点击事件将只会被触发一次" class="headerlink" title=".once修饰符 点击事件将只会被触发一次"></a>.once修饰符 点击事件将只会被触发一次</h4><p>.once修饰符只允许事件监听程序只会被执行一次，无论你多少次触发该事件</p><p>例如：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app"</span> @<span class="attr">click</span>=<span class="string">"clickDiv"</span> <span class="attr">style</span>=<span class="string">"border: 1px solid black;width: 100px;height: 100px;"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span> @<span class="attr">click.once</span>=<span class="string">"clickP"</span>&gt;</span>&#123;&#123;value&#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p>事件处理程序的定义还是如下，不做任何改变</p><p>那么，当我们第一次点击p元素的时候会得到如下的输出结果：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 输出结果</span></span><br><span class="line"><span class="comment">p is clicked</span></span><br><span class="line"><span class="comment">div is clicked</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>那么，当我们第二次再点击该p元素，此时输出结果就变成这样了：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 输出结果</span></span><br><span class="line"><span class="comment">div is clicked</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>我们可以看到，p元素的事件处理程序没有再执行。这可以用来实现防抖的效果。</p><h4 id="passive修饰符"><a href="#passive修饰符" class="headerlink" title=".passive修饰符"></a>.passive修饰符</h4><p>该.passive修饰符对应addEventListener中的passive选项，当我们使用该.passive修饰符时，也就是默认将addEventListener的passive选项设置为true。</p><p>那么，这也意味着：</p><blockquote><p>所指定的函数listener将永远不会调用preventDefault()。</p></blockquote><p>简而言之，该.passive修饰符的作用是不要阻止事件的默认行为。那么，如果我们将.passive 和 .prevent 一起使用，那么.prevent 将会被忽略。</p><h5 id="passcive修饰符对于移动端性能的提升"><a href="#passcive修饰符对于移动端性能的提升" class="headerlink" title=".passcive修饰符对于移动端性能的提升"></a>.passcive修饰符对于移动端性能的提升</h5><p>在移动端，我们经常要使用触摸滚动的事件，那么使用passive修饰符将会大幅提升移动端的性能</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">v-on:scroll.passive</span>=<span class="string">"onScroll"</span>&gt;</span>...<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p>那么，这是为什么呢？</p><p>MDN文档是这样做出解释的：</p><blockquote><p>根据规范，passive 选项的默认值始终为false。但是，这引入了处理某些触摸事件（以及其他）的事件监听器在尝试处理滚动时阻止浏览器的主线程的可能性，从而导致滚动处理期间性能可能大大降低。</p></blockquote><h3 id="v-model表单输入绑定的修饰符"><a href="#v-model表单输入绑定的修饰符" class="headerlink" title="v-model表单输入绑定的修饰符"></a>v-model表单输入绑定的修饰符</h3><h4 id="lazy修饰符"><a href="#lazy修饰符" class="headerlink" title=".lazy修饰符"></a>.lazy修饰符</h4><p>我们知道在默认情况下，v-model使用监听oninput事件来使得数据保持同步。此时，只要我们在输入数据时该事件就会被触发</p><p>但是，当我们使用.lazy修饰符，v-model就会转而去监听onchange事件，而不是oninput事件。这意味着，只有当表单的value值发生了改变，并且该表单失去焦点时才会触发</p><p>例如：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">v-model.lazy</span>=<span class="string">"value"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>&#123;&#123;value&#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure><p>此时，当我们输入数据时，p元素中的value值不会立即更新。只有当input输入框失去焦点后，value值才会更新</p><h4 id="trim修饰符"><a href="#trim修饰符" class="headerlink" title=".trim修饰符"></a>.trim修饰符</h4><p>如果要自动过滤用户输入的首尾空白字符，可以给 v-model 添加 trim 修饰符</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">v-model.trim</span>=<span class="string">"msg"</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="计算属性和侦听器"><a href="#计算属性和侦听器" class="headerlink" title="计算属性和侦听器"></a>计算属性和侦听器</h2><h3 id="计算属性"><a href="#计算属性" class="headerlink" title="计算属性"></a>计算属性</h3><h4 id="什么是计算属性"><a href="#什么是计算属性" class="headerlink" title="什么是计算属性"></a>什么是计算属性</h4><p>我们知道，可以在模板语法中写入表达式：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span>&gt;</span>&#123;&#123;value.split('').reverse().join('')&#125;&#125;<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure><p>但是，为了模板的可读性，Vue提供了可计算属性来代替这种在模板中插入复杂的表达式计算</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">computed: &#123;</span><br><span class="line">    reverseValue: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.value.split(<span class="string">''</span>).reverse().join(<span class="string">''</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果，我们试着在某个阶段输出一下Vue实例，我们可以看到computed对象中的计算属性的值是直接被添加到vue实例的属性中的</p><p><img src="https://s2.ax1x.com/2019/11/12/M1cfld.png" alt></p><p>因此，它可以直接被作为模板语法直接进行插入</p><h4 id="计算属性的getter和setter"><a href="#计算属性的getter和setter" class="headerlink" title="计算属性的getter和setter"></a>计算属性的getter和setter</h4><p>其实，计算属性就是一个访问器属性。虽然，在computed对象中，我们声明的计算属性目前只是一个函数（此时计算属性默认只有getter），但其实，我们也可以为计算属性添加setter函数</p><p>例如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">computed: &#123;</span><br><span class="line">    reverseValue: &#123;</span><br><span class="line">        <span class="keyword">get</span>: function () &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>.value.split(<span class="string">''</span>).reverse().join(<span class="string">''</span>);</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="keyword">set</span>: function (value) &#123;</span><br><span class="line">            <span class="keyword">this</span>.value = value;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当我学习到这部分的时候，我就产生了疑问。明明这个计算属性应该是访问器属性才对，但是为什么计算属性使用了包含get和set属性的对象写法？还有，之前的默认是getter函数的为什么只需要采用函数写法？</p><p>这一切疑问我们可以从源码中找到答案</p><p>这是初始化计算属性的函数</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">initComputed</span> (<span class="params">vm: Component, computed: Object</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// $flow-disable-line</span></span><br><span class="line">  <span class="keyword">const</span> watchers = vm._computedWatchers = <span class="built_in">Object</span>.create(<span class="literal">null</span>)</span><br><span class="line">  <span class="comment">// computed properties are just getters during SSR</span></span><br><span class="line">  <span class="keyword">const</span> isSSR = isServerRendering()</span><br><span class="line"></span><br><span class="line"> <span class="comment">// 遍历所有computed对象中声明的计算属性</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">const</span> key <span class="keyword">in</span> computed) &#123;</span><br><span class="line">    <span class="keyword">const</span> userDef = computed[key]</span><br><span class="line">    <span class="comment">// 如果属性值为函数，那么将该函数赋值给getter；如果属性值为对象，那么将对象的get属性值赋值给getter</span></span><br><span class="line">    <span class="keyword">const</span> getter = <span class="keyword">typeof</span> userDef === <span class="string">'function'</span> ? userDef : userDef.get</span><br><span class="line">    <span class="keyword">if</span> (process.env.NODE_ENV !== <span class="string">'production'</span> &amp;&amp; getter == <span class="literal">null</span>) &#123;</span><br><span class="line">      warn(</span><br><span class="line">        <span class="string">`Getter is missing for computed property "<span class="subst">$&#123;key&#125;</span>".`</span>,</span><br><span class="line">        vm</span><br><span class="line">      )</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!isSSR) &#123;</span><br><span class="line">      <span class="comment">// create internal watcher for the computed property.</span></span><br><span class="line">      watchers[key] = <span class="keyword">new</span> Watcher(</span><br><span class="line">        vm,</span><br><span class="line">        getter || noop,</span><br><span class="line">        noop,</span><br><span class="line">        computedWatcherOptions</span><br><span class="line">      )</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// component-defined computed properties are already defined on the</span></span><br><span class="line">    <span class="comment">// component prototype. We only need to define computed properties defined</span></span><br><span class="line">    <span class="comment">// at instantiation here.</span></span><br><span class="line">    <span class="keyword">if</span> (!(key <span class="keyword">in</span> vm)) &#123;</span><br><span class="line">        <span class="comment">// 将该计算属性添加到vm实例上</span></span><br><span class="line">      defineComputed(vm, key, userDef)</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (process.env.NODE_ENV !== <span class="string">'production'</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (key <span class="keyword">in</span> vm.$data) &#123;</span><br><span class="line">        warn(<span class="string">`The computed property "<span class="subst">$&#123;key&#125;</span>" is already defined in data.`</span>, vm)</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (vm.$options.props &amp;&amp; key <span class="keyword">in</span> vm.$options.props) &#123;</span><br><span class="line">        warn(<span class="string">`The computed property "<span class="subst">$&#123;key&#125;</span>" is already defined as a prop.`</span>, vm)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们找到对应的defineComputed方法</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">defineComputed</span> (<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  target: any,</span></span></span><br><span class="line"><span class="function"><span class="params">  key: string,</span></span></span><br><span class="line"><span class="function"><span class="params">  userDef: Object | Function</span></span></span><br><span class="line"><span class="function"><span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> shouldCache = !isServerRendering()</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> userDef === <span class="string">'function'</span>) &#123;</span><br><span class="line">    sharedPropertyDefinition.get = shouldCache</span><br><span class="line">      ? createComputedGetter(key)</span><br><span class="line">      : createGetterInvoker(userDef)</span><br><span class="line">    sharedPropertyDefinition.set = noop</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    sharedPropertyDefinition.get = userDef.get</span><br><span class="line">      ? shouldCache &amp;&amp; userDef.cache !== <span class="literal">false</span></span><br><span class="line">        ? createComputedGetter(key)</span><br><span class="line">        : createGetterInvoker(userDef.get)</span><br><span class="line">      : noop</span><br><span class="line">    sharedPropertyDefinition.set = userDef.set || noop</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (process.env.NODE_ENV !== <span class="string">'production'</span> &amp;&amp;</span><br><span class="line">      sharedPropertyDefinition.set === noop) &#123;</span><br><span class="line">    sharedPropertyDefinition.set = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      warn(</span><br><span class="line">        <span class="string">`Computed property "<span class="subst">$&#123;key&#125;</span>" was assigned to but it has no setter.`</span>,</span><br><span class="line">        <span class="keyword">this</span></span><br><span class="line">      )</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 在这里将计算属性添加到vm实例上，并且该属性正式成为了访问器属性</span></span><br><span class="line">  <span class="built_in">Object</span>.defineProperty(target, key, sharedPropertyDefinition)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>看完了这两段源码，之前的困惑就应该消除了。</p><p>如果，我们将计算属性写成函数的形式，那么就将该函数作为该属性的getter方法；</p><p>如果，我们将计算属性写成对象的形式，那么就将对象中的get属性值和set属性值作为计算属性的getter方法和setter方法</p><h4 id="计算属性缓存和方法"><a href="#计算属性缓存和方法" class="headerlink" title="计算属性缓存和方法"></a>计算属性缓存和方法</h4><p>以下是源码中的初始化方法的函数</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">initMethods</span> (<span class="params">vm: Component, methods: Object</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> props = vm.$options.props</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">const</span> key <span class="keyword">in</span> methods) &#123;</span><br><span class="line">    <span class="keyword">if</span> (process.env.NODE_ENV !== <span class="string">'production'</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">typeof</span> methods[key] !== <span class="string">'function'</span>) &#123;</span><br><span class="line">        warn(</span><br><span class="line">          <span class="string">`Method "<span class="subst">$&#123;key&#125;</span>" has type "<span class="subst">$&#123;<span class="keyword">typeof</span> methods[key]&#125;</span>" in the component definition. `</span> +</span><br><span class="line">          <span class="string">`Did you reference the function correctly?`</span>,</span><br><span class="line">          vm</span><br><span class="line">        )</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (props &amp;&amp; hasOwn(props, key)) &#123;</span><br><span class="line">        warn(</span><br><span class="line">          <span class="string">`Method "<span class="subst">$&#123;key&#125;</span>" has already been defined as a prop.`</span>,</span><br><span class="line">          vm</span><br><span class="line">        )</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> ((key <span class="keyword">in</span> vm) &amp;&amp; isReserved(key)) &#123;</span><br><span class="line">        warn(</span><br><span class="line">          <span class="string">`Method "<span class="subst">$&#123;key&#125;</span>" conflicts with an existing Vue instance method. `</span> +</span><br><span class="line">          <span class="string">`Avoid defining component methods that start with _ or $.`</span></span><br><span class="line">        )</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    vm[key] = <span class="keyword">typeof</span> methods[key] !== <span class="string">'function'</span> ? noop : bind(methods[key], vm)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>粗略看一眼我们就可以看到，vm实例中的methods对象中的属性都是直接添加到vm实例的属性上的。</p><p>这也就意味着，我们在模板语法中也可以直接使用methods中的方法</p><p>例如：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">"change"</span>&gt;</span>&#123;&#123;getValue()&#125;&#125;<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br></pre></td></tr></table></figure><p>那么，对于之前的计算属性的写法，我们又可以直接将逻辑写在methods的方法中了</p><p>原来的复杂逻辑直接作为表达式插入模板中</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span>&gt;</span>&#123;&#123;value.split('').reverse().join('')&#125;&#125;<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure><p>使用计算属性</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span>&gt;</span>&#123;&#123;reverseValue&#125;&#125;<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure><p>现在，我们使用方法：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span>&gt;</span>&#123;&#123;reverseValue()&#125;&#125;<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">methods: &#123;</span><br><span class="line">    reverseValue() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.value.split(<span class="string">''</span>).reverse().join(<span class="string">''</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对了，计算属性的属性名不能与方法中的方法名同名，不然，计算属性就会无效。原因在于，计算属性和方法都会作为属性被添加到vm实例中去，那么总不能同名吧。具体，看上面的两个初始化函数。</p><p>来看个总体的例子：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>&#123;&#123;value&#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>&#123;&#123;reverseValue&#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>&#123;&#123;reverse()&#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> Vue(&#123;</span><br><span class="line">    el: <span class="string">'#app'</span>,</span><br><span class="line">    data: &#123;</span><br><span class="line">        value: <span class="string">'abc'</span></span><br><span class="line">    &#125;,</span><br><span class="line">    methods: &#123;</span><br><span class="line">        reverse() &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>.value.split(<span class="string">''</span>).reverse().join(<span class="string">''</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    computed: &#123;</span><br><span class="line">        reverseValue() &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>.value.split(<span class="string">''</span>).reverse().join(<span class="string">''</span>);     </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>渲染结果：</p><p><img src="https://s2.ax1x.com/2019/11/12/M1T2QK.png" alt></p><h5 id="计算属性与方法的区别"><a href="#计算属性与方法的区别" class="headerlink" title="计算属性与方法的区别"></a>计算属性与方法的区别</h5><p>那么，这两种写法有什么区别呢？</p><p>官方文档是这样解释的：</p><blockquote><p>计算属性是基于它们的响应式依赖进行缓存的。只在相关响应式依赖发生改变时它们才会重新求值</p></blockquote><p>也就是说，如果计算属性的getter函数中所依赖的值是响应式数据（上文中的value），那么只有当value值更新时，该计算属性才会更新。</p><p>但是，对于方法呢？只要DOM树重新渲染，这个方法就会被重新执行。我们知道，在vue的生命周期中，只要响应式数据发生了update，那么虚拟DOM就会被重建，挂载的那一部分就会被重新渲染</p><p>我们可以用一个例子来说明以上的结论</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>&#123;&#123;value&#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>&#123;&#123;dateNow&#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>&#123;&#123;getDateNow()&#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">"changeValue"</span>&gt;</span>change value<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> Vue(&#123;</span><br><span class="line">    el: <span class="string">'#app'</span>,</span><br><span class="line">    data: &#123;</span><br><span class="line">        value: <span class="number">123</span></span><br><span class="line">    &#125;,</span><br><span class="line">    methods: &#123;</span><br><span class="line">        getDateNow() &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">Date</span>.now();</span><br><span class="line">        &#125;,</span><br><span class="line">        changeValue() &#123;</span><br><span class="line">            <span class="keyword">this</span>.value = <span class="number">321</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    computed: &#123;</span><br><span class="line">        dateNow() &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">Date</span>.now();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>此时，渲染结果会如下gif<br><img src="https://i.imgur.com/r8wsMQ1.gif" alt></p><p>我们可以看到，当我们改变value值的时候，计算属性的值并没有改变，而方法所得到的的值发生了改变。</p><p>因为，计算属性的值依赖于响应式数据的变化，但是，上述代码中的计算属性的getter函数中并没有响应式数据，因此，就算该组件因为数据变化而重新渲染，计算属性的值也没有发生变化</p><p>但是，模板中的方法只要组件被重新渲染，就会被重新执行，因此，得到的值也就发生了变化</p><h3 id="侦听器"><a href="#侦听器" class="headerlink" title="侦听器"></a>侦听器</h3><p>Vue提供了侦听器用来响应数据的变化。</p><p>在vm实例中，我们可以用watch选项来侦听数据的变化，并作出响应</p><p>例如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> Vue(&#123;</span><br><span class="line">    el: <span class="string">'#app'</span>,</span><br><span class="line">    data: &#123;</span><br><span class="line">        value: <span class="number">123</span></span><br><span class="line">    &#125;,</span><br><span class="line">    watch: &#123;</span><br><span class="line">        value: <span class="function"><span class="keyword">function</span>(<span class="params">newVal,oldVal</span>) </span>&#123;</span><br><span class="line">            <span class="built_in">console</span>.log(newVal,oldVal);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h2 id="class与style绑定"><a href="#class与style绑定" class="headerlink" title="class与style绑定"></a>class与style绑定</h2><h3 id="class绑定"><a href="#class绑定" class="headerlink" title="class绑定"></a>class绑定</h3><p>因为，class属性属于元素上的一个特性，那么，我们可以使用v-bind语法进行绑定</p><h4 id="表达式结果为字符串的绑定"><a href="#表达式结果为字符串的绑定" class="headerlink" title="表达式结果为字符串的绑定"></a>表达式结果为字符串的绑定</h4><p>因为，v-bind中需要的是一个表达式，因此，我们只需要计算出表达式的字符串结果即可</p><h5 id="单变量绑定"><a href="#单变量绑定" class="headerlink" title="单变量绑定"></a>单变量绑定</h5><p>假如v-bind表达式中只有一个变量，那么，我们可以这样写：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line">.red &#123;</span><br><span class="line">    color: red</span><br><span class="line">&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span> <span class="attr">:class</span>=<span class="string">"className"</span>&gt;</span>&#123;&#123;value&#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> Vue(&#123;</span><br><span class="line">    el: <span class="string">"#app"</span>,</span><br><span class="line">    data: &#123;</span><br><span class="line">        value: &#123;</span><br><span class="line">            value: <span class="number">123</span>,</span><br><span class="line">            className: <span class="string">'red'</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h5 id="变量与字符串进行拼接"><a href="#变量与字符串进行拼接" class="headerlink" title="变量与字符串进行拼接"></a>变量与字符串进行拼接</h5><p>因为表达式的值必须为字符串，那么当拼接的时候就要求必须至少有一方为字符串类型</p><p>例如：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line">.red-item &#123;</span><br><span class="line">    color: red</span><br><span class="line">&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span> <span class="attr">:class</span>=<span class="string">"className+'-item'"</span>&gt;</span>&#123;&#123;value&#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> Vue(&#123;</span><br><span class="line">    el: <span class="string">"#app"</span>,</span><br><span class="line">    data: &#123;</span><br><span class="line">        value: &#123;</span><br><span class="line">            value: <span class="number">123</span>,</span><br><span class="line">            className: <span class="string">'red'</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h4 id="表达式结果为对象的绑定"><a href="#表达式结果为对象的绑定" class="headerlink" title="表达式结果为对象的绑定"></a>表达式结果为对象的绑定</h4><p>我们可以为v-bind传入一个对象来作为表达式的结果以动态切换class的值</p><p>例如：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">:class</span>=<span class="string">"&#123;['red-item']:true&#125;"</span>&gt;</span>&#123;&#123;value&#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure><p>另外，为了更加清晰的模板效果，我们可以将对象放在实例的data中</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">:class</span>=<span class="string">"classObj"</span>&gt;</span>&#123;&#123;value&#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> Vue(&#123;</span><br><span class="line">    el: <span class="string">'#app'</span>,</span><br><span class="line">    data: &#123;</span><br><span class="line">        value: <span class="number">123</span>,</span><br><span class="line">        classObj: &#123;</span><br><span class="line">            [<span class="string">'red-item'</span>]: <span class="literal">true</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>当然，作为计算属性也可：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> Vue(&#123;</span><br><span class="line">    el: <span class="string">'#app'</span>,</span><br><span class="line">    data: &#123;</span><br><span class="line">        value: <span class="number">123</span></span><br><span class="line">    &#125;,</span><br><span class="line">    computed: &#123;</span><br><span class="line">        classObj() &#123;</span><br><span class="line">            <span class="keyword">return</span> &#123;</span><br><span class="line">                [<span class="string">'red-item'</span>]: <span class="literal">true</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h4 id="表达式结果为数组的绑定"><a href="#表达式结果为数组的绑定" class="headerlink" title="表达式结果为数组的绑定"></a>表达式结果为数组的绑定</h4><p>Vue还允许我们使用数组来对class进行绑定，数组的结果就是class列表</p><p>例如：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">:class</span>=<span class="string">"['red-item']"</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure><p>当然，我们可以在数组项中加入对象</p><p>例如：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">:class</span>=<span class="string">"[classObj]"</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure><p>此时classObj对象作为vm实例的data属性和计算属性都可以</p><h3 id="style绑定"><a href="#style绑定" class="headerlink" title="style绑定"></a>style绑定</h3><p>当然，对于style我们也可以进行如上以数组和对象的表达式结果的绑定</p><h4 id="对象绑定"><a href="#对象绑定" class="headerlink" title="对象绑定"></a>对象绑定</h4><p>对于对象绑定，我们可以这样写</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">p</span> <span class="attr">:style</span>=<span class="string">"&#123;color: 'red',['font-size']: 15+'px'&#125;"</span>&gt;</span>&#123;&#123;value&#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br></pre></td></tr></table></figure><p>因为，在Js中变量不能包含’-‘连字符，因此，我们需要使用方括号语法进行转换[‘font-size’]</p><h4 id="数组绑定"><a href="#数组绑定" class="headerlink" title="数组绑定"></a>数组绑定</h4><p>v-bind:style 的数组语法可以将多个<strong>样式对象</strong>应用到同一个元素上</p><blockquote><p>如果对:style进行数组语法的绑定，那么数组元素必须为对象</p></blockquote><p>例如：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">:style="[&#123;color: 'red'&#125;,&#123;['font-size']: 20+'px',['font-weight']: 'bolder'&#125;]"</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;v-if与v-show的区别&quot;&gt;&lt;a href=&quot;#v-if与v-show的区别&quot; class=&quot;headerlink&quot; title=&quot;v-if与v-show的区别&quot;&gt;&lt;/a&gt;v-if与v-show的区别&lt;/h2&gt;&lt;p&gt;官方文档对于这两个指令的定义：&lt;/p&gt;
&lt;u
      
    
    </summary>
    
      <category term="Vue" scheme="http://angellike_fairy.gitee.io/angellikefairy/categories/Vue/"/>
    
    
  </entry>
  
  <entry>
    <title>Vue的生命周期理解</title>
    <link href="http://angellike_fairy.gitee.io/angellikefairy/2019/11/10/Vue%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E7%90%86%E8%A7%A3/"/>
    <id>http://angellike_fairy.gitee.io/angellikefairy/2019/11/10/Vue的生命周期理解/</id>
    <published>2019-11-10T04:50:15.000Z</published>
    <updated>2019-11-10T06:28:23.197Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Vue的生命周期"><a href="#Vue的生命周期" class="headerlink" title="Vue的生命周期"></a>Vue的生命周期</h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>每个Vue实例的生命周期大致如下：创建实例，初始化数据，模板编译，挂载DOM，，更新数据然后视图重新渲染，实例销毁等一系列过程</p><h3 id="各个生命周期的具体作用"><a href="#各个生命周期的具体作用" class="headerlink" title="各个生命周期的具体作用"></a>各个生命周期的具体作用</h3><p>在Vue实例的生命周期中，Vue提供了一系列相关的生命周期钩子的函数用来帮助开发者在Vue的不同生命周期阶段来添加适当的代码</p><p>以下是一张Vue官方文档中的生命周期示意图</p><p><img src="https://s2.ax1x.com/2019/11/10/MuEtdx.png" alt></p><p>我们来详细理解以下这张生命周期示意图</p><ol><li><p>new Vue()阶段 创建Vue实例，这一步也就是调用Vue构造函数</p> <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> vm = <span class="keyword">new</span> Vue(&#123;&#125;);</span><br></pre></td></tr></table></figure></li><li><p>初始化了一个空的Vue实例，此时该Vue实例对象上只有默认的一些生命周期函数和默认事件。</p></li><li><p>在这里有一个beforeCreate()生命周期钩子，但是在该钩子函数里我们还无法访问到data以及methods里的方法，当然更无法访问el</p> <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">beforeCreate() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.$data,<span class="keyword">this</span>.$el); <span class="comment">// undefined undefined</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>数据初始化完毕，此时data和methods可以被访问了</p></li><li><p>在该阶段有一个created()的钩子可以供我们调用，此时在该钩子函数中我们可以访问到data和methods内的属性了，但是此时仍然无法访问到el。因此，我们也可以看到该钩子函数是我们在所有钩子函数中最早能够访问到data和methods的阶段</p></li><li><p>Vue开始进行模板编译</p></li><li><p>当模板编译完毕后，Vue在这里提供了一个beforeMount()的生命周期钩子函数，此时render函数将开始被调用，在这个钩子里，我们已经可以访问到el属性了</p> <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">beforeMount() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.$el);</span><br><span class="line">&#125; <span class="comment">// &lt;div id="app"&gt;...&lt;/div&gt;</span></span><br></pre></td></tr></table></figure><p> 但是，在此阶段模板仅仅只是被编译好，而没有真正地替换到页面中去，我们点击上面的this.$el的输出结果可以发现：</p> <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id=<span class="string">"app"</span>&gt;</span><br><span class="line">    &lt;input v-model=<span class="string">"value"</span> /&gt;</span><br><span class="line">    &lt;p&gt;&#123;&#123;value&#125;&#125;&lt;<span class="regexp">/p&gt;</span></span><br><span class="line"><span class="regexp">&lt;/</span>div&gt;</span><br></pre></td></tr></table></figure><p> 我们可以看到此时的输出的要挂载的节点内容并没有被真实地替换掉，模板语法仍旧存在</p></li><li><p>将编译好的模板真实地替换到页面中去，此时我们在mounted()钩子中就可以看到真实被渲染完毕的el</p> <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">mounted() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.$el);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 输出结果</span></span><br><span class="line"><span class="comment">&lt;div&gt;</span></span><br><span class="line"><span class="comment">    &lt;input /&gt;</span></span><br><span class="line"><span class="comment">    &lt;p&gt;123&lt;/p&gt;</span></span><br><span class="line"><span class="comment">&lt;/div&gt;</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p> 此时，Vue实例已经被初始化完毕了，之后就是实例的运行阶段。</p></li><li><p>此时，在Vue组件运行阶段我们可能会要更新数据，当更新数据的时候，beforeUpdate钩子就会被调用，此时，data中的数据是最新的，但是还没有更新到视图中</p></li><li><p>虚拟DOM树重新渲染，然后更新到视图中</p></li><li><p>更行完毕后,updated钩子会被调用，此时数据与视图已经是同步的了</p></li><li><p>当vm.$destroy()实例销毁函数显式被调用时，便会触发触发 beforeDestroy 和 destroyed 的钩子。</p></li><li><p>在实例销毁之前我们可以调用beforeDestroy钩子，此时实例并没有被销毁，该组件所有的功能都还是可用的</p></li><li><p>destroyed()调用时，此时实例已经被销毁完毕了，该组件的所有功能都不再可用</p></li></ol><h2 id="各个生命周期适合开发者适合做的操作"><a href="#各个生命周期适合开发者适合做的操作" class="headerlink" title="各个生命周期适合开发者适合做的操作"></a>各个生命周期适合开发者适合做的操作</h2><h3 id="异步操作应该在哪个生命周期阶段进行"><a href="#异步操作应该在哪个生命周期阶段进行" class="headerlink" title="异步操作应该在哪个生命周期阶段进行"></a>异步操作应该在哪个生命周期阶段进行</h3><p>首先我们需要确认异步操作会不会阻塞Vue的整个生命周期的进行</p><p>我们可以使用宏任务setTimeout并且不设置过时时间来模拟异步操作的进行并修改data中的数据，具体实现如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 确定脚本开始运行的时间</span></span><br><span class="line"><span class="keyword">let</span> start = <span class="built_in">Date</span>.now();</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> vm = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">    el: <span class="string">'#app'</span>,</span><br><span class="line">    data: &#123;</span><br><span class="line">        value: <span class="number">123</span></span><br><span class="line">    &#125;,</span><br><span class="line">    created() &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">`created time <span class="subst">$&#123;<span class="built_in">Date</span>.now()-start&#125;</span>s`</span>);</span><br><span class="line">        <span class="comment">// 没有设置宏任务setTimeout的过时时间</span></span><br><span class="line">        setTimeout(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">`<span class="subst">$&#123;<span class="built_in">Date</span>.now()-start&#125;</span>s change the value to 321`</span>);</span><br><span class="line">            <span class="keyword">this</span>.value = <span class="number">321</span>;</span><br><span class="line">        &#125;)        </span><br><span class="line">    &#125;,</span><br><span class="line">    mounted() &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">`mounted time <span class="subst">$&#123;<span class="built_in">Date</span>.now()-start&#125;</span>s`</span>);        </span><br><span class="line">    &#125;,</span><br><span class="line">    updated() &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">`<span class="subst">$&#123;<span class="built_in">Date</span>.now()-start&#125;</span>s updated the value to <span class="subst">$&#123;<span class="keyword">this</span>.value&#125;</span>`</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 输出结果</span></span><br><span class="line"><span class="comment">created time 2s</span></span><br><span class="line"><span class="comment">mounted time 29s</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">140s change the value to 321</span></span><br><span class="line"><span class="comment">141s start updating the value to 321</span></span><br><span class="line"><span class="comment">143s updated the value to 321</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>我们可以看到宏任务setTimeout在Vue实例完全初始化后，也就是mounted阶段后才会开始运行。因此，对于异步请求数据操作也只会在Vue实例初始化完毕后（mounted阶段后）才会进行，之后的数据修改或赋值就会直接触发beforeUpdate以及后续进行的updated钩子</p><p>通过以上的输出结果，我们可以得出一个结论：</p><blockquote><p>异步操作并不会阻塞Vue初始化生命周期的进行。</p></blockquote><p>因此，我们将异步操作放在created，beforeMount，mounted这三个钩子里都是OK的。因为这三个阶段data数据都已经被初始化好了，我们可以在异步操作的回调中对data中的数据进行修改或赋值了</p><p>但是，为了减少用户的等待时间，我们最好在created阶段进行异步操作。因为异步任务都会被放入event table中进行，越早声明也就代表着被运行的时间越早，因此也就越有可能会在异步回调中的任务队列优先被执行回调</p><h3 id="DOM访问操作应该在哪个生命周期阶段进行"><a href="#DOM访问操作应该在哪个生命周期阶段进行" class="headerlink" title="DOM访问操作应该在哪个生命周期阶段进行"></a>DOM访问操作应该在哪个生命周期阶段进行</h3><p>只有在Vue实例挂在到DOM节点时，我们才可以去访问和操作DOM，因此，DOM访问操作应该在mounted阶段进行</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Vue的生命周期&quot;&gt;&lt;a href=&quot;#Vue的生命周期&quot; class=&quot;headerlink&quot; title=&quot;Vue的生命周期&quot;&gt;&lt;/a&gt;Vue的生命周期&lt;/h2&gt;&lt;h3 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; titl
      
    
    </summary>
    
      <category term="Vue" scheme="http://angellike_fairy.gitee.io/angellikefairy/categories/Vue/"/>
    
    
  </entry>
  
  <entry>
    <title>MVVM模式的理解以及双向数据绑定</title>
    <link href="http://angellike_fairy.gitee.io/angellikefairy/2019/11/09/MVVM%E6%A8%A1%E5%BC%8F%E7%9A%84%E7%90%86%E8%A7%A3%E4%BB%A5%E5%8F%8A%E5%8F%8C%E5%90%91%E6%95%B0%E6%8D%AE%E7%BB%91%E5%AE%9A/"/>
    <id>http://angellike_fairy.gitee.io/angellikefairy/2019/11/09/MVVM模式的理解以及双向数据绑定/</id>
    <published>2019-11-09T06:38:05.000Z</published>
    <updated>2019-11-09T11:19:20.682Z</updated>
    
    <content type="html"><![CDATA[<h2 id="MVVM"><a href="#MVVM" class="headerlink" title="MVVM"></a>MVVM</h2><h3 id="什么是MVVM"><a href="#什么是MVVM" class="headerlink" title="什么是MVVM"></a>什么是MVVM</h3><p>MVVM是一种软件架构设计模式，其由以下三个方面组成：</p><ul><li>Model: 对应MVVM中的第一个M，表示数据模型层，包括自定义数据以及后端给定的api接口数据</li><li>View: 对应MVVM中的第一个V，表示视图层，也就是我们常说的用户界面，这一层使用html+css来进行构建</li><li>ViewModel: 对应MVVM中的VM，表示视图数据层。这一层也是MVVM设计模式的核心。该层作为桥梁用来沟通View视图层和Model数据模型层。我们在该层对Model层给的数据进行数据上和业务上的处理，然后通过双向数据绑定，使得View视图层实时更新视图</li></ul><p><img src="https://s2.ax1x.com/2019/11/09/MmEkRJ.png" alt></p><h2 id="双向数据绑定"><a href="#双向数据绑定" class="headerlink" title="双向数据绑定"></a>双向数据绑定</h2><h3 id="什么数据双向绑定"><a href="#什么数据双向绑定" class="headerlink" title="什么数据双向绑定"></a>什么数据双向绑定</h3><p>对于MVVM设计模式来说，数据绑定是指当数据变化时试图会进行更新，当视图变化时数据会进行相应更新</p><p><img src="https://s2.ax1x.com/2019/11/09/MmmSl4.png" alt></p><h3 id="双向数据绑定的原理"><a href="#双向数据绑定的原理" class="headerlink" title="双向数据绑定的原理"></a>双向数据绑定的原理</h3><p>对于View视图层变化更新数据，一般可以通过事件监听的方式</p><p>例如：<br>vue中的指令v-model就可以监听表单的输入事件来更新相应的数据</p><p>先看下vue中实现的例子：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">v-model</span>=<span class="string">"value"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>&#123;&#123;value&#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var app = new Vue(&#123;</span><br><span class="line">    el: &apos;#app&apos;,</span><br><span class="line">    data: &#123;</span><br><span class="line">        value: &apos;&apos;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>当我们在input表单中输入数据的时候，value值也会进行相应的更新</p><p>实现效果如下：</p><p><img src="https://s2.ax1x.com/2019/11/09/Mmnd2D.png" alt></p><h4 id="利用事件监听机制来实现视图变动来更新数据"><a href="#利用事件监听机制来实现视图变动来更新数据" class="headerlink" title="利用事件监听机制来实现视图变动来更新数据"></a>利用事件监听机制来实现视图变动来更新数据</h4><p>对于v-model指令在表单中输入数据可以进行相应数据的更新，我们可以利用事件监听机制来进行实现</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app"</span>&gt;</span></span><br><span class="line">    /*绑定一个changeData事件，用于当进行表单输入操作时进行数据的更新*/</span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">value</span>=<span class="string">""</span> <span class="attr">id</span>=<span class="string">"input"</span> @<span class="attr">click</span>=<span class="string">"changeData"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>&#123;&#123;value&#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p>input输入框有一个oninput方法可以用来监听输入框中的value值是否有变化</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> app = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">    el: <span class="string">'#app'</span>,</span><br><span class="line">    data: &#123;</span><br><span class="line">        value: <span class="string">''</span></span><br><span class="line">    &#125;,</span><br><span class="line">    methods: &#123;</span><br><span class="line">        changeData() &#123;</span><br><span class="line">            <span class="keyword">let</span> input = <span class="built_in">document</span>.getElementById(<span class="string">'input'</span>);</span><br><span class="line">            <span class="comment">// 如果value值发生了变化，那么就将该value赋值给vue实例data中的value属性</span></span><br><span class="line">            input.addEventListener(<span class="string">'input'</span>,(e)=&gt;&#123;</span><br><span class="line">                <span class="comment">// e.target指向事件绑定的元素，也就是input元素，然后再获取到该元素的value值</span></span><br><span class="line">                <span class="keyword">this</span>.value = e.target.value;</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h4 id="发布订阅模式来解决数据的更新引起视图的更新"><a href="#发布订阅模式来解决数据的更新引起视图的更新" class="headerlink" title="发布订阅模式来解决数据的更新引起视图的更新"></a>发布订阅模式来解决数据的更新引起视图的更新</h4><p>以下是一张来自vue官方的数据双向绑定的原理图</p><p><img src="https://s2.ax1x.com/2019/11/09/MmM8bj.png" alt></p><p>对于Vue中的数据双向绑定的实现，主要通过以下四个步骤来实现</p><ul><li><p>实现一个监听器 Observer：对数据对象进行遍历，包括子属性对象的属性，利用 Object.defineProperty() 对属性都加上访问器属性 setter 和 getter。这样的话，监听器就可以对数据进行劫持，当我们给这个对象的某个值赋值，就会触发 setter，从而监听到数据的变化。</p></li><li><p>实现一个解析器 Compile：解析 Vue 模板指令，将模板中的变量都替换成数据，然后初始化渲染页面视图，并将每个指令对应的节点绑定更新函数，添加监听数据的订阅者，一旦数据有变动，收到通知，调用更新函数进行数据更新。</p></li><li><p>实现一个订阅者 Watcher：Watcher 订阅者是 Observer 和 Compile 之间通信的桥梁 ，主要的任务是订阅 Observer 中的属性值变化的消息，当收到属性值变化的消息时，触发解析器 Compile 中对应的更新函数。</p></li><li><p>实现一个订阅器 Dep：订阅器采用 发布-订阅 设计模式，用来收集订阅者 Watcher，对监听器 Observer 和 订阅者 Watcher 进行统一管理。</p></li></ul><p>大致流程图如下：</p><p><img src="https://s2.ax1x.com/2019/11/09/Mmlp6O.png" alt></p><p>接下来我们会一一实现这些步骤</p><h5 id="Observer监听器进行事件劫持"><a href="#Observer监听器进行事件劫持" class="headerlink" title="Observer监听器进行事件劫持"></a>Observer监听器进行事件劫持</h5><p>此过程主要是通过Object.defineProperty将data对象中的所有属性（包括属性是对象类型所有的子属性）具有访问器属性getter和setter</p><p>具体实现如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 要劫持的数据</span></span><br><span class="line"><span class="keyword">let</span> data = &#123;</span><br><span class="line">    item: <span class="number">1</span>,</span><br><span class="line">    k: &#123;</span><br><span class="line">        m: &#123;</span><br><span class="line">            g: <span class="number">2</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">observe(data)</span><br><span class="line"><span class="built_in">console</span>.log(data.item,data.k,data.k.m);</span><br><span class="line">data.item = &#123;<span class="attr">i</span>:<span class="number">1</span>&#125;;</span><br><span class="line">data.k = <span class="number">2</span>;</span><br><span class="line"><span class="built_in">console</span>.log(data.item,data.k,data.k.m);</span><br><span class="line"></span><br><span class="line"><span class="comment">// observer监听器函数，遍历data对象中的所有属性包括子属性然后调用自定义数据劫持函数setProperty进行数据劫持</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">observe</span>(<span class="params">obj</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> keys = <span class="built_in">Object</span>.keys(obj);</span><br><span class="line">    keys.forEach(<span class="function"><span class="params">v</span>=&gt;</span>&#123;</span><br><span class="line">        <span class="comment">// 如果该属性值是对象，那么进行递归</span></span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">typeof</span> obj[v] === <span class="string">'object'</span> &amp;&amp; v!==<span class="literal">null</span>) &#123;</span><br><span class="line">            observe(obj[v]);</span><br><span class="line">        &#125;</span><br><span class="line">        setProperty(data,v,obj[v]);</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 数据劫持函数，使用Object.defineProperty进行劫持</span></span><br><span class="line"><span class="comment">// 传入对象，键名，以及键值，并将它们作为对象的私有变量，之后对属性值修改与访问都是在操作该私有变量val</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">setProperty</span>(<span class="params">obj, key, val</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">Object</span>.defineProperty(obj, key, &#123;</span><br><span class="line">    enumerable: <span class="literal">true</span>,</span><br><span class="line">    configurable: <span class="literal">true</span>,</span><br><span class="line">    <span class="comment">// 访问器属性get，访问属性时将会调用该函数</span></span><br><span class="line">    <span class="keyword">get</span>: function() &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">'get value'</span>)</span><br><span class="line">      <span class="keyword">return</span> val</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">// 访问器属性set，设置属性值时将会调用该函数</span></span><br><span class="line">    <span class="keyword">set</span>: function(newVal) &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">'change value'</span>)</span><br><span class="line">      val = newVal</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在我们已经实现了，当数据变化后我们可以获得通知。接下来我们要去实现订阅器，来更加方便地管理这些变动</p><h5 id="Dep订阅器的实现"><a href="#Dep订阅器的实现" class="headerlink" title="Dep订阅器的实现"></a>Dep订阅器的实现</h5><p>订阅器的主要功能就是收集订阅者的订阅，然后当发布者发布事件后将订阅者的回调进行执行</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dep</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>() &#123;</span><br><span class="line">    <span class="keyword">this</span>.subs = []</span><br><span class="line">  &#125;</span><br><span class="line">  addSub(sub) &#123;</span><br><span class="line">    <span class="comment">// sub 是 Watcher 实例</span></span><br><span class="line">    <span class="keyword">this</span>.subs.push(sub)</span><br><span class="line">  &#125;</span><br><span class="line">  notify() &#123;</span><br><span class="line">    <span class="keyword">this</span>.subs.forEach(<span class="function"><span class="params">sub</span> =&gt;</span> &#123;</span><br><span class="line">      sub.update()</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 全局属性，通过该属性配置 Watcher</span></span><br><span class="line">Dep.target = <span class="literal">null</span></span><br></pre></td></tr></table></figure><h5 id="Watcher订阅者的实现"><a href="#Watcher订阅者的实现" class="headerlink" title="Watcher订阅者的实现"></a>Watcher订阅者的实现</h5><p>Watcher订阅者的功能就是等待发布者发布之后，订阅器就会统一执行所有订阅者的回调</p><p>事实上，data对象中并不是所有的数据都与视图层有关系，因此，当在模板解析的时候，解析到该值时模板语法，那么就会将该属性作为订阅者添加到订阅器中</p><p>具体实现如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Watcher</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(obj, key, cb) &#123;</span><br><span class="line">    <span class="comment">// 将 Dep.target 指向自己</span></span><br><span class="line">    <span class="comment">// 然后触发属性的 getter 添加监听</span></span><br><span class="line">    <span class="comment">// 最后将 Dep.target 置空</span></span><br><span class="line">    Dep.target = <span class="keyword">this</span></span><br><span class="line">    <span class="keyword">this</span>.cb = cb</span><br><span class="line">    <span class="keyword">this</span>.obj = obj</span><br><span class="line">    <span class="keyword">this</span>.key = key</span><br><span class="line">    <span class="keyword">this</span>.value = obj[key]</span><br><span class="line">    Dep.target = <span class="literal">null</span></span><br><span class="line">  &#125;</span><br><span class="line">  update() &#123;</span><br><span class="line">    <span class="comment">// 获得新值</span></span><br><span class="line">    <span class="keyword">this</span>.value = <span class="keyword">this</span>.obj[<span class="keyword">this</span>.key]</span><br><span class="line">    <span class="comment">// 调用 update 方法更新 Dom</span></span><br><span class="line">    <span class="keyword">this</span>.cb(<span class="keyword">this</span>.value)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">update</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">document</span>.querySelector(<span class="string">'div'</span>).innerText = value</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后，我们还需要修改之前的setProperty函数，在属性访问的时候将其作为订阅者添加到订阅器中，将属性值被修改时，将该事件发布，并执行订阅者相应的回调函数</p><p>具体实现如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">setProperty</span>(<span class="params">obj, key, val</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> dp = <span class="keyword">new</span> Dep()</span><br><span class="line">  <span class="built_in">Object</span>.defineProperty(obj, key, &#123;</span><br><span class="line">    enumerable: <span class="literal">true</span>,</span><br><span class="line">    configurable: <span class="literal">true</span>,</span><br><span class="line">    <span class="keyword">get</span>: function reactiveGetter() &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">'get value'</span>)</span><br><span class="line">      <span class="comment">// 将 Watcher 添加到订阅</span></span><br><span class="line">      <span class="keyword">if</span> (Dep.target) &#123;</span><br><span class="line">        dp.addSub(Dep.target)</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> val</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="keyword">set</span>: function reactiveSetter(newVal) &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">'change value'</span>)</span><br><span class="line">      val = newVal</span><br><span class="line">      <span class="comment">// 执行 watcher 的 update 方法</span></span><br><span class="line">      dp.notify()</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;MVVM&quot;&gt;&lt;a href=&quot;#MVVM&quot; class=&quot;headerlink&quot; title=&quot;MVVM&quot;&gt;&lt;/a&gt;MVVM&lt;/h2&gt;&lt;h3 id=&quot;什么是MVVM&quot;&gt;&lt;a href=&quot;#什么是MVVM&quot; class=&quot;headerlink&quot; title=&quot;什么是
      
    
    </summary>
    
      <category term="Vue" scheme="http://angellike_fairy.gitee.io/angellikefairy/categories/Vue/"/>
    
    
  </entry>
  
  <entry>
    <title>Buffer的理解以及文件上传的应用</title>
    <link href="http://angellike_fairy.gitee.io/angellikefairy/2019/11/05/Buffer%E7%9A%84%E7%90%86%E8%A7%A3%E4%BB%A5%E5%8F%8A%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E7%9A%84%E5%BA%94%E7%94%A8/"/>
    <id>http://angellike_fairy.gitee.io/angellikefairy/2019/11/05/Buffer的理解以及文件上传的应用/</id>
    <published>2019-11-05T07:16:53.000Z</published>
    <updated>2019-11-06T12:59:53.569Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Buffer（缓冲区）"><a href="#Buffer（缓冲区）" class="headerlink" title="Buffer（缓冲区）"></a>Buffer（缓冲区）</h2><p>在Node中，应用需要处理网络协议、操作数据库、处理图片、接收上传的文件等，在网络流和文件的操作中，还要处理大量的二进制数据，而Js自有的字符串远远无法满足这些需求，于是Buffer对象应运而生</p><p>Buffer类在全局作用域中，因此，我们无需使用require(‘buffer’).Buffer来进行使用</p><h3 id="什么是Buffer（缓冲区）"><a href="#什么是Buffer（缓冲区）" class="headerlink" title="什么是Buffer（缓冲区）"></a>什么是Buffer（缓冲区）</h3><p>我们知道数据的移动是以流的方式进行的。当我们从文件或网络读取数据的时候，就需要一个输入流来进行数据的读取；而当我们要写入一些数据的时候，就需要开启一个输出流来进行数据的移动。</p><p>但是，Node并无法控制数据流的速度以及数据到达目的地的时间。因此，如果数据到达的速度比进程消耗的速度快，那么少数早到达的数据会处于等待区等候被处理。反之，如果数据到达的速度比进程消耗的数据慢，那么早先到达的数据需要在等待区中等待一定量的数据到达之后才能被处理。</p><p>这个等待区也就是我们要提的Buffer（缓冲区）</p><h3 id="Buffer对象"><a href="#Buffer对象" class="headerlink" title="Buffer对象"></a>Buffer对象</h3><p>Buffer对象类似与一个数组，它的元素为16进制的两位数，即0到255的数值。</p><p>我们可以这样来创建Buffer对象</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> buf =  Buffer.from(<span class="string">'理解Buffer'</span>)</span><br><span class="line"><span class="built_in">console</span>.log(buf); <span class="comment">// &lt;Buffer e7 90 86 e8 a7 a3 42 75 66 66 65 72&gt;</span></span><br></pre></td></tr></table></figure><p>我们输出一下这个buf对象长度</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(buf.length); <span class="comment">// 12</span></span><br></pre></td></tr></table></figure><p>我们可以看到buf对象的长度与给定的字符串长度不一样。因此，我们可以得出不同编码的字符串占用的元素个数各不相同。上面的代码中的中文字在UTF-8的编码下占用3个元素，而字母和半角标点符号占用1个元素。</p><p>另外，以下是创建Buffer对象时常用的API：</p><ol><li><p>Buffer.from(array) 返回一个新的 Buffer，其中包含提供的八位字节数组的副本。</p></li><li><p>Buffer.from(arrayBuffer[, byteOffset [, length]]) 返回一个新的 Buffer，它与给定的 ArrayBuffer 共享相同的已分配内存。</p></li><li><p>Buffer.from(buffer) 返回一个新的 Buffer，其中包含给定 Buffer 的内容的副本。</p></li><li><p>Buffer.from(string[, encoding]) 返回一个新的 Buffer，其中包含提供的字符串的副本,encoding为给定的string的编码格式。</p></li><li><p>Buffer.alloc(size[, fill[, encoding]]) 返回一个指定大小的新建的的已初始化的 Buffer。 此方法比 Buffer.allocUnsafe(size) 慢，但能确保新创建的 Buffer 实例永远不会包含可能敏感的旧数据。 如果 size 不是数字，则将会抛出 TypeError。</p></li><li><p>Buffer.allocUnsafe(size) 和 Buffer.allocUnsafeSlow(size) 分别返回一个指定大小的新建的未初始化的 Buffer。 由于 Buffer 是未初始化的，因此分配的内存片段可能包含敏感的旧数据。</p></li></ol><p>如果 size 小于或等于 Buffer.poolSize 的一半，则 Buffer.allocUnsafe() 返回的 Buffer 实例可能是从共享的内部内存池中分配。 Buffer.allocUnsafeSlow() 返回的实例则从不使用共享的内部内存池。</p><p>示例：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建一个给定Array的Buffer，其中Array的元素为10进制整数，它会被转化为16进制的二进制数</span></span><br><span class="line"><span class="keyword">let</span> buffer = Buffer.from([<span class="number">53</span>,<span class="number">198</span>,<span class="number">255</span>]);</span><br><span class="line"><span class="built_in">console</span>.log(buffer); <span class="comment">// &lt;Buffer 35 c6 ff&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 分配一个指定大小的新建的的已初始化的 Buffer，该Buffer永远不会包含旧数据</span></span><br><span class="line">buffer = Buffer.alloc(<span class="number">10</span>);</span><br><span class="line"><span class="built_in">console</span>.log(buffer); <span class="comment">// &lt;Buffer 00 00 00 00 00 00 00 00 00 00&gt;</span></span><br></pre></td></tr></table></figure><h3 id="Buffer的内存分配"><a href="#Buffer的内存分配" class="headerlink" title="Buffer的内存分配"></a>Buffer的内存分配</h3><p>我们在V8的垃圾回收机制中了解到，一般的基本类型变量会存储在栈中，而复杂引用类型会存储在v8的堆内存中。</p><p>然而，Buffer对象的内存分配不是在v8的堆内存中进行的，而是在Node的C++层面进行内存分配的。</p><p>因为处理大量的字节数据不能采用需要一点内存就向系统申请内存的方式（v8的内存管理就采用这种方式，如果堆内存不够就继续申请堆内存直到超过系统限制），这样的话会造成操作系统层面的压力</p><p>Node采用slab分配机制来进行Buffer对象的内存分配。</p><p>slab是一块申请号的固定大小的内存区域，它的大小为8kb。Node通常也以8Kb为分界来区分小Buffe对象和大Buffer对象</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Buffer.poolSize = <span class="number">8</span>*<span class="number">1024</span>;</span><br></pre></td></tr></table></figure><p>之前提过，我们可以使用Buffer.alloc(size)来分配指定大小的Buffer对象</p><p>当size&lt;8*1024时，该Buffer对象为小对象，否则，则是大对象</p><p>当在进行slab内存分配的时候，其符合以下的规则：</p><ol><li>如果要分配的Buffer内存大小小于slab内存大小，那么在slab中分配内存给Buffer</li><li>如果slab剩余空闲内存小于需要分配的Buffer内存大小，那么重新会新建一个slab来分配该Buffer对象的内存</li><li>如果Buffer对象为大对象，即需要分配的内存大于8kb，那么，系统将会直接分配一个SlowBuffer对象作为slab单元，这个slab单元将会被该Buffer对象独占</li></ol><h3 id="Buffer与字符串的相互转换"><a href="#Buffer与字符串的相互转换" class="headerlink" title="Buffer与字符串的相互转换"></a>Buffer与字符串的相互转换</h3><p>当字符串存储入一个Buffer实例或者从Buffer实例中提取时，我们可以指定一个字符编码</p><p>例如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 以utf-8编码将字符串存储入Buffer中</span></span><br><span class="line"><span class="keyword">let</span> buf = Buffer.from(<span class="string">'理解Buffer'</span>,<span class="string">'utf-8'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(buf); <span class="comment">// &lt;Buffer e7 90 86 e8 a7 a3 42 75 66 66 65 72&gt;</span></span><br><span class="line"><span class="comment">// 以base64编码取出该字符串</span></span><br><span class="line"><span class="built_in">console</span>.log(buf.toString(<span class="string">'base64'</span>)); <span class="comment">// 55CG6KejQnVmZmVy</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 以ascii编码将字符串存入Buffer中</span></span><br><span class="line">buf = Buffer.from(<span class="string">'理解Buffer'</span>,<span class="string">'ascii'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(buf);</span><br></pre></td></tr></table></figure><h3 id="Buffer的拼接"><a href="#Buffer的拼接" class="headerlink" title="Buffer的拼接"></a>Buffer的拼接</h3><h4 id="直接拼接Buffer时遇到的问题"><a href="#直接拼接Buffer时遇到的问题" class="headerlink" title="直接拼接Buffer时遇到的问题"></a>直接拼接Buffer时遇到的问题</h4><p>我们知道数据的移动是以流的方式进行的。那么，使用了Buffer作为缓冲区后，我们得到一个流数据就是一段一段的进行获取</p><p>现在我们来试着使用读取流来读取一个文件内容：</p><p>例如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 该fs.createReadStream()方法会返回一个新的fs.ReadStream对象，该对象也就是读取流</span></span><br><span class="line"><span class="keyword">let</span> rs = fs.createReadStream(<span class="string">'./a.ja'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> data = <span class="string">''</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 当流将数据块传送给消费者后触发data事件</span></span><br><span class="line">rs.on(<span class="string">'data'</span>,(chunk)=&gt;&#123;</span><br><span class="line">    data+=chunk;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 'end' 事件只有在数据被完全消费掉后才会触发</span></span><br><span class="line">rs.on(<span class="string">'end'</span>,()=&gt;&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(data);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>此时a.js文件内容如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="string">'hello'</span>);</span><br></pre></td></tr></table></figure><p>那么，输出结果如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">console.log(&apos;hello&apos;);</span><br></pre></td></tr></table></figure><p>我们发现读取似乎没有什么问题。但其实，这是有问题的。上述程序中有一行语句是</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">data+=chunk;</span><br></pre></td></tr></table></figure><p>我们知道流的读取时，传递的应该是Buffer对象，我们试着输出一下这个chunk</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">rs.on(<span class="string">'data'</span>,(chunk)=&gt;&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(chunk); <span class="comment">// &lt;Buffer 63 6f 6e 73 6f 6c 65 2e 6c 6f 67 28 27 68 65 6c 6c 6f 27 29 3b&gt;</span></span><br><span class="line">    data+=chunk;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>的确，这个chunk确实是Buffer对象，那么为什么最后输出的是正确的字符串呢？</p><p>我们知道在字符串拼接的时候，如果有一方不是字符串，那么就会将其转化为字符串之后再进行拼接。因此，那行代码又可以等价为</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">data+=chunk.toString();</span><br></pre></td></tr></table></figure><p>这样似乎都可以说的通了，但是如果我们读取的内容不全是英文，而是包括有宽字节的中文呢?</p><p>我们将a.js文件内容改为如下</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="string">'你好呀，我很好'</span>);</span><br></pre></td></tr></table></figure><p>同时，我们利用highWaterMark属性将缓冲区的大小限制为5。</p><p>此时，完整的程序如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将每次读取的Buffer长度限制为5</span></span><br><span class="line"><span class="keyword">let</span> rs = fs.createReadStream(<span class="string">'./a.js'</span>,&#123;<span class="attr">highWaterMark</span>:<span class="number">5</span>&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> data = <span class="string">''</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">rs.on(<span class="string">'data'</span>,(chunk)=&gt;&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(chunk);</span><br><span class="line">    data+=chunk;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">rs.on(<span class="string">'end'</span>,()=&gt;&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(data);</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 输出结果</span></span><br><span class="line"><span class="comment">&lt;Buffer 63 6f 6e 73 6f&gt;</span></span><br><span class="line"><span class="comment">&lt;Buffer 6c 65 2e 6c 6f&gt;</span></span><br><span class="line"><span class="comment">&lt;Buffer 67 28 27 e4 bd&gt;</span></span><br><span class="line"><span class="comment">&lt;Buffer a0 e5 a5 bd e5&gt;</span></span><br><span class="line"><span class="comment">&lt;Buffer 91 80 ef bc 8c&gt;</span></span><br><span class="line"><span class="comment">&lt;Buffer e6 88 91 e5 be&gt;</span></span><br><span class="line"><span class="comment">&lt;Buffer 88 e5 a5 bd 27&gt;</span></span><br><span class="line"><span class="comment">&lt;Buffer 29 3b&gt;</span></span><br><span class="line"><span class="comment">console.log('��好���，我��好');</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>我们可以看到，每次的读取Buffer长度的确为5。此时，我们惊奇的发现，文件内容出现了乱码。</p><p>这是为什么呢？我们知道，中文字符为宽字节字符，在utf-8模式下，其占3个字节。因此，我们用每次5个字节进行读取时，就会遇到，有些中文字符会被拆分到两次读取中，因此，就会显示出乱码</p><h4 id="利用setEncoding来解决"><a href="#利用setEncoding来解决" class="headerlink" title="利用setEncoding来解决"></a>利用setEncoding来解决</h4><p>readable.setEncoding() 方法为从可读流读取的数据设置字符编码。</p><p>默认情况下没有设置字符编码，流数据返回的是 Buffer 对象。 如果设置了字符编码，则流数据返回指定编码的字符串。 例如，调用 readable.setEncoding(‘utf-8’) 会将数据解析为 UTF-8 数据，并返回字符串，调用 readable.setEncoding(‘hex’) 则会将数据编码成十六进制字符串。</p><p>因此，我们可以这样修改上述的程序：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> rs = fs.createReadStream(<span class="string">'./a.js'</span>,&#123;<span class="attr">highWaterMark</span>:<span class="number">5</span>&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置字符编码，将流Buffer对象转化为字符串</span></span><br><span class="line">rs.setEncoding(<span class="string">'utf-8'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> data = <span class="string">''</span>;</span><br><span class="line">rs.on(<span class="string">'data'</span>,(chunk)=&gt;&#123;</span><br><span class="line">    <span class="comment">// 此时chunk为字符串形式</span></span><br><span class="line">    <span class="built_in">console</span>.log(chunk);</span><br><span class="line">    data+=chunk;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">rs.on(<span class="string">'end'</span>,()=&gt;&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(data);</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 输出结果</span></span><br><span class="line"><span class="comment">conso</span></span><br><span class="line"><span class="comment">le.lo</span></span><br><span class="line"><span class="comment">g('</span></span><br><span class="line"><span class="comment">你好</span></span><br><span class="line"><span class="comment">呀，</span></span><br><span class="line"><span class="comment">我</span></span><br><span class="line"><span class="comment">很好'</span></span><br><span class="line"><span class="comment">);</span></span><br><span class="line"><span class="comment">console.log('你好呀，我很好');</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>虽然使用setEncoding可以解决目前的问题，但是它目前只能处理utf-8、Base64等部分编码，因此，它并不是完美的。</p><h4 id="使用Buffer-concat-来解决"><a href="#使用Buffer-concat-来解决" class="headerlink" title="使用Buffer.concat()来解决"></a>使用Buffer.concat()来解决</h4><p>相较setEncoding方法在接收时并将buffer对象进行编码转换的不同，Buffer.concat()方法的思想是先接收到所有的小Buffer对象，然后将所有的小Buffer对象进行合并成一个大对象然后再进行字符串输出</p><p>Buffer.concat(list[,totalLength])方法接受一个要合并的Buffer数组和合并后list中的Buffer实例的总长度，然后返回一个合并了list中所有Buffer实例的新Buffer</p><p>如果没有提供 totalLength，则计算 list 中的 Buffer 实例的总长度。 但是这会导致执行额外的循环用于计算 totalLength，因此如果已知长度，则明确提供长度会更快</p><p>因此，最完美的解决方案应该如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> rs = fs.createReadStream(<span class="string">'./a.js'</span>,&#123;<span class="attr">highWaterMark</span>:<span class="number">5</span>&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> list = [];</span><br><span class="line"><span class="keyword">let</span> length = <span class="number">0</span>;</span><br><span class="line">rs.on(<span class="string">'data'</span>,(chunk)=&gt;&#123;</span><br><span class="line">    list.push(chunk);</span><br><span class="line">    length+=chunk.length;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">rs.on(<span class="string">'end'</span>,()=&gt;&#123;</span><br><span class="line">    <span class="keyword">let</span> newBuf = Buffer.concat(list,length);</span><br><span class="line">    <span class="built_in">console</span>.log(newBuf);</span><br><span class="line">    <span class="built_in">console</span>.log(newBuf.toString(<span class="string">'utf-8'</span>));</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 输出结果</span></span><br><span class="line"><span class="comment">&lt;Buffer 63 6f 6e 73 6f 6c 65 2e 6c 6f 67 28 27 e4 bd a0 e5 a5 bd e5 91 80 ef bc 8c e6 88 91 e5 be 88 e5 a5 bd 27 29 3b&gt;</span></span><br><span class="line"><span class="comment">console.log('你好呀，我很好');</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>我们可以看到，结果是可以正确输出的。</p><h3 id="BUffer与网络传输"><a href="#BUffer与网络传输" class="headerlink" title="BUffer与网络传输"></a>BUffer与网络传输</h3><p>网络传输一般使用字节流来进行传输，因此，无论我们在传输之前什么类型的值，在传输的过程中都会转化为Buffer对象来进行网络传输</p><p>例如：当客户端想要通过post方式传递一些数据的时候，这些数据就会被转化为Buffer对象，一点一点地传递到服务器端</p><p>注意：</p><blockquote><p>网络传输中，请求与响应都是流对象，req为可读流，res为可写流</p></blockquote><p>因此，我们可以利用以下的方式来获取post请求的携带的数据</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> http = <span class="built_in">require</span>(<span class="string">'http'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> list = [];</span><br><span class="line"><span class="keyword">let</span> length = <span class="number">0</span>;</span><br><span class="line">http.createServer(<span class="function">(<span class="params">req,res</span>)=&gt;</span>&#123;</span><br><span class="line">    req.on(<span class="string">'data'</span>,(chunk)=&gt;&#123;</span><br><span class="line">        <span class="comment">// console.log(chunk);</span></span><br><span class="line">        list.push(chunk);</span><br><span class="line">        length+=chunk.length;</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    req.on(<span class="string">'end'</span>,()=&gt;&#123;</span><br><span class="line">        <span class="keyword">let</span> buf = Buffer.concat(list,length);</span><br><span class="line">        <span class="comment">// console.log(buf);</span></span><br><span class="line">        <span class="built_in">console</span>.log(buf.toString(<span class="string">'utf-8'</span>));</span><br><span class="line"></span><br><span class="line">        res.setHeader(<span class="string">'Content-Type'</span>,<span class="string">'application/JSON'</span>);</span><br><span class="line">        res.end(buf.toString(<span class="string">'utf-8'</span>))</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>因此，如果我们直接返回Buffer类型，cpu就不需要进行类型转换工作，可以有效地减少cpu的重复使用，节省服务器资源</p><h2 id="文件上传"><a href="#文件上传" class="headerlink" title="文件上传"></a>文件上传</h2><p>首先我们要在前端选取文件，并得到文件的base64编码</p><p>前端部分代码，通过FileReader对象来将获取的文件进行base64编码，通过axios来进行文件上传</p><p>前端部分</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> axios = <span class="built_in">require</span>(<span class="string">'axios'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> fileSelect = <span class="built_in">document</span>.getElementsByTagName(<span class="string">'input'</span>)[<span class="number">0</span>];</span><br><span class="line"><span class="keyword">let</span> submit = <span class="built_in">document</span>.getElementsByTagName(<span class="string">'input'</span>)[<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">submit.addEventListener(<span class="string">'click'</span>,()=&gt;&#123;</span><br><span class="line">    <span class="keyword">let</span> file = fileSelect.files[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">let</span> fr = <span class="keyword">new</span> FileReader(file);</span><br><span class="line">    <span class="comment">// 处理load事件。该事件在读取操作完成时触发。</span></span><br><span class="line">    fr.addEventListener(<span class="string">'load'</span>,()=&gt;&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(fr.result);</span><br><span class="line">        axios.post(<span class="string">'/api/hello'</span>,&#123;</span><br><span class="line">            params: &#123;</span><br><span class="line">                value: fr.result</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).then(<span class="function"><span class="params">v</span>=&gt;</span>&#123;</span><br><span class="line">            <span class="built_in">console</span>.log(v);</span><br><span class="line">        &#125;).catch(<span class="function"><span class="params">err</span>=&gt;</span>&#123;</span><br><span class="line">            <span class="built_in">console</span>.log(err);</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="comment">// 开始读取指定的Blob中的内容。一旦完成，result属性中将包含一个data: URL格式的Base64字符串以表示所读取文件的内容。</span></span><br><span class="line">    fr.readAsDataURL(file);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="Node端处理文件上传"><a href="#Node端处理文件上传" class="headerlink" title="Node端处理文件上传"></a>Node端处理文件上传</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> http = <span class="built_in">require</span>(<span class="string">'http'</span>);</span><br><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>);</span><br><span class="line"><span class="keyword">const</span> queryString = <span class="built_in">require</span>(<span class="string">'queryString'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> list = [];</span><br><span class="line"><span class="keyword">let</span> length = <span class="number">0</span>;</span><br><span class="line">http.createServer(<span class="function">(<span class="params">req,res</span>)=&gt;</span>&#123;</span><br><span class="line">    req.on(<span class="string">'data'</span>,(chunk)=&gt;&#123;</span><br><span class="line">        list.push(chunk);</span><br><span class="line">        length+=chunk.length;</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    req.on(<span class="string">'end'</span>,()=&gt;&#123;</span><br><span class="line">        <span class="comment">// 获取得到的是utf-8编码的Buffer对象</span></span><br><span class="line">        <span class="keyword">let</span> buf = Buffer.concat(list,length);</span><br><span class="line">        <span class="comment">// 将该Buffer对象转化为utf-8编码的字符串，并且取出包含在该字符串中的base64编码的文件内容</span></span><br><span class="line">        <span class="keyword">let</span> data = <span class="built_in">JSON</span>.parse(buf.toString(<span class="string">'utf-8'</span>)).params.value.replace(<span class="regexp">/^data:text\/javascript;base64,/</span>,<span class="string">''</span>);</span><br><span class="line">        <span class="comment">// 接下来就需要将base64编码转化为utf-8编码，我们可以间接地通过Buffer对象来转换</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建以base64编码的Buffer对象</span></span><br><span class="line">        <span class="keyword">let</span> newBuf = Buffer.from(data,<span class="string">'base64'</span>);</span><br><span class="line">        <span class="comment">// 将该Buffer对象转化为base64编码的字符串</span></span><br><span class="line">        <span class="keyword">let</span> fileContent = newBuf.toString(<span class="string">'utf-8'</span>);</span><br><span class="line">        <span class="comment">// 将文件内容写进get.js文件</span></span><br><span class="line">        fs.writeFile(<span class="string">'get.js'</span>,fileContent,()=&gt;&#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">'文件已保存'</span>);</span><br><span class="line">        &#125;)</span><br><span class="line">        res.setHeader(<span class="string">'Content-Type'</span>,<span class="string">'application/JSON'</span>);</span><br><span class="line">        res.end(<span class="built_in">JSON</span>.stringify(&#123;<span class="attr">value</span>:<span class="string">'收到'</span>&#125;));</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;).listen(<span class="number">3000</span>,()=&gt;&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'Port 3000 is listenging'</span>);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>此时，我们就可以实现一个js文件的上传。</p><p>当然，为了能够上传更多格式的文件，我们修改以上的正则表达式就OK了</p><h3 id="Node端处理图片上传"><a href="#Node端处理图片上传" class="headerlink" title="Node端处理图片上传"></a>Node端处理图片上传</h3><p>因为图片的编码貌似都是base64编码，因此，我们在获得图片的base64编码后不需要像文件一样转化为utf-8编码，只需直接存储即可</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> http = <span class="built_in">require</span>(<span class="string">'http'</span>);</span><br><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>);</span><br><span class="line"><span class="keyword">const</span> queryString = <span class="built_in">require</span>(<span class="string">'queryString'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> list = [];</span><br><span class="line"><span class="keyword">let</span> length = <span class="number">0</span>;</span><br><span class="line">http.createServer(<span class="function">(<span class="params">req,res</span>)=&gt;</span>&#123;</span><br><span class="line">    req.on(<span class="string">'data'</span>,(chunk)=&gt;&#123;</span><br><span class="line">        list.push(chunk);</span><br><span class="line">        length+=chunk.length;</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    req.on(<span class="string">'end'</span>,()=&gt;&#123;</span><br><span class="line">        <span class="comment">// 获取得到的是utf-8编码的Buffer对象</span></span><br><span class="line">        <span class="keyword">let</span> buf = Buffer.concat(list,length);</span><br><span class="line">        <span class="comment">// 将该Buffer对象转化为utf-8编码的字符串，并且取出包含在该字符串中的base64编码的文件内容</span></span><br><span class="line">        <span class="keyword">let</span> data = <span class="built_in">JSON</span>.parse(buf.toString(<span class="string">'utf-8'</span>)).params.value.replace(<span class="regexp">/^data:((text\/(javascript|plain))|(image\/(png|jpg|jpeg|gif)));base64,/</span>,<span class="string">''</span>);</span><br><span class="line">        <span class="comment">// 接下来就需要将base64编码转化为utf-8编码，我们可以间接地通过Buffer对象来转换</span></span><br><span class="line">        <span class="built_in">console</span>.log(data);</span><br><span class="line">        <span class="comment">// 创建以base64编码的Buffer对象</span></span><br><span class="line">        <span class="keyword">let</span> newBuf = Buffer.from(data,<span class="string">'base64'</span>);</span><br><span class="line">        <span class="comment">// 不需要将该Buffer对象转化为base64编码的字符串</span></span><br><span class="line">        <span class="comment">//let fileContent = newBuf.toString('utf-8');</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 生成a.jpeg</span></span><br><span class="line">        fs.writeFile(<span class="string">'a.jpeg'</span>,newBuf,()=&gt;&#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">'文件已保存'</span>);</span><br><span class="line">        &#125;)</span><br><span class="line">        res.setHeader(<span class="string">'Content-Type'</span>,<span class="string">'application/JSON'</span>);</span><br><span class="line">        res.end(<span class="built_in">JSON</span>.stringify(&#123;<span class="attr">value</span>:<span class="string">'收到'</span>&#125;));</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;).listen(<span class="number">3000</span>,()=&gt;&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'Port 3000 is listenging'</span>);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Buffer（缓冲区）&quot;&gt;&lt;a href=&quot;#Buffer（缓冲区）&quot; class=&quot;headerlink&quot; title=&quot;Buffer（缓冲区）&quot;&gt;&lt;/a&gt;Buffer（缓冲区）&lt;/h2&gt;&lt;p&gt;在Node中，应用需要处理网络协议、操作数据库、处理图片、接收上传的
      
    
    </summary>
    
      <category term="Node" scheme="http://angellike_fairy.gitee.io/angellikefairy/categories/Node/"/>
    
    
  </entry>
  
  <entry>
    <title>V8的垃圾回收机制与内存管理</title>
    <link href="http://angellike_fairy.gitee.io/angellikefairy/2019/11/04/V8%E7%9A%84%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6/"/>
    <id>http://angellike_fairy.gitee.io/angellikefairy/2019/11/04/V8的垃圾回收机制/</id>
    <published>2019-11-04T12:11:14.000Z</published>
    <updated>2019-11-04T14:04:11.479Z</updated>
    
    <content type="html"><![CDATA[<h2 id="内存管理简介"><a href="#内存管理简介" class="headerlink" title="内存管理简介"></a>内存管理简介</h2><p>来自于MDN的简介：</p><blockquote><p>像C语言这样的底层语言一般都有底层的内存管理接口，比如 malloc()和free()。相反，JavaScript是在创建变量（对象，字符串等）时自动进行了分配内存，并且在不使用它们时“自动”释放。 释放的过程称为垃圾回收。这个“自动”是混乱的根源，并让JavaScript（和其他高级语言）开发者错误的感觉他们可以不关心内存管理。 </p></blockquote><h2 id="内存的生命周期"><a href="#内存的生命周期" class="headerlink" title="内存的生命周期"></a>内存的生命周期</h2><p>内存的生命周期基本如下：</p><ol><li>分配需要的内存</li><li>时候用分配到的内存进行读写操作</li><li>不需要是将该内存归还或释放</li></ol><h2 id="v8的内存模型"><a href="#v8的内存模型" class="headerlink" title="v8的内存模型"></a>v8的内存模型</h2><p>一个运行中的程序总是与内存中的一部分空间相对应，这部分空间被称为Resident Set（驻留集）。</p><p>其内存模型如下：</p><p><img src="https://s2.ax1x.com/2019/11/04/KxzhXF.png" alt></p><p>图中各名词的解释：</p><ul><li>Resident Segment 驻留集（当前程序所占用的全部空间）</li><li>Code Segment 存放正在执行的代码</li><li>Stack 栈 存放基本类型变量以及对象的指针（因为栈中的内存较小，栈中的每一块内存大小固定）</li><li>Heap 堆 存放复杂引用类型</li><li>Used Heap 堆中已经使用的内存量</li></ul><h2 id="Node中的内存查看方式"><a href="#Node中的内存查看方式" class="headerlink" title="Node中的内存查看方式"></a>Node中的内存查看方式</h2><p>Node中可以使用process.memoryUsage()方法来查看当前进程的内存使用情况</p><p>因为该方法输出的内存单位为字节，我们在下面的方法中将其封装从而输出以M为单位</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">format</span>(<span class="params">bytes</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (bytes/<span class="number">1024</span>/<span class="number">1024</span>).toFixed(<span class="number">2</span>)+<span class="string">'MB'</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> memoryUsage = process.memoryUsage();</span><br><span class="line"></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'rss'</span>,format(memoryUsage.rss));</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'heapTotal'</span>,format(memoryUsage.heapTotal));</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'heapUsed'</span>,format(memoryUsage.heapUsed));</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'external'</span>,format(memoryUsage.external));</span><br><span class="line">&#125;)()</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 输出结果</span></span><br><span class="line"><span class="comment">rss 17.60MB</span></span><br><span class="line"><span class="comment">heapTotal 4.05MB</span></span><br><span class="line"><span class="comment">heapUsed 2.01MB</span></span><br><span class="line"><span class="comment">external 0.61MB</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>其中，process.memoryUsage方法返回的对象中的所有属性说明如下：</p><ol><li>rss(resident set size): 当前进程占用的内存部分，包括之前提到过的代码本身、存储基本类型变量和对象指针的栈、存储复杂引用类型的堆</li><li>heapTotal: 堆中总共申请到的内存量</li><li>heapUsed: 堆中目前已经使用的内存量</li><li>external: v8引擎内部的C++对象占用的内存</li></ol><p>我们知道，Js中的所有复杂引用类型都是存储在堆中的。因此，当我们创建一个对象时，该对象所占用的内存就会被存放在堆中。如果，当前堆的空闲内存大小已经不够再分配一个新的对象，那么将会继续申请堆内存，直到堆的大小超过V8的限制为止。</p><p>在这里提一句，在默认情况下，v8堆内存的最大值在64位系统下大约为1.4G，在32位系统下大约为0.7G</p><h2 id="v8的垃圾回收机制"><a href="#v8的垃圾回收机制" class="headerlink" title="v8的垃圾回收机制"></a>v8的垃圾回收机制</h2><blockquote><p>垃圾回收是指回收那些在应用程序中不再被引用的对象</p></blockquote><p>例如，我们将一个对象指向null后该对象就会垃圾回收机制自动回收掉</p><p>v8的垃圾回收机制主要基于分代式垃圾回收机制</p><h3 id="新生代与老生代"><a href="#新生代与老生代" class="headerlink" title="新生代与老生代"></a>新生代与老生代</h3><p>在V8中，主要将内存分为新生代和老生代两代。新生代中的对象为存活时间较短的对象，老生代中的对象为存活时间较长或常驻内存中的对象</p><p><img src="https://s2.ax1x.com/2019/11/04/KzZCSH.png" alt></p><p>由此，我们可以看到v8申请到堆的大小就是新生代所用内存空间加上老生代所用内存空间</p><h4 id="新生代内存空间所使用的的垃圾回收算法（Scavenge算法）"><a href="#新生代内存空间所使用的的垃圾回收算法（Scavenge算法）" class="headerlink" title="新生代内存空间所使用的的垃圾回收算法（Scavenge算法）"></a>新生代内存空间所使用的的垃圾回收算法（Scavenge算法）</h4><p>在新生代内存空间中，v8主要使用Scavenge算法来进行垃圾回收。</p><p>该算法是一种采用复制的方式来实现的垃圾回收算法。</p><p>它会将新生代内存一份为二，其中一个空间称为From空间，该空间是当前正在使用的空间；另一个空间成为To空间，该空间是当前正在被闲置的空间（该空间中的内存没有被任何对象使用）</p><p><img src="https://s2.ax1x.com/2019/11/04/KzZpfe.png" alt></p><p>当开始进行垃圾回收时，v8会检查From空间是否还有存活的对象，如果有，那么将这些对象复制到当前空闲的To空间；而，其余非存活的对象则会被回收，它们所占用的空间也会被释放。完成复制后，From空间和To空间的角色将会被互换，也就是刚刚的From空间在复制后就会变为空闲的To空间；而刚刚空闲的To空间在复制后则变成From空间</p><p><img src="https://s2.ax1x.com/2019/11/04/KzZPld.png" alt></p><p>该算法的缺点是，将新生代内存空间一分为二后，新生代中的内存使用变为原来的一半。</p><p>但是，其有一个显著的优点。该算法只复制存活的对象，并且存活时间短的存活对象只占所有新生代中对象的极少一部分，因此，复制效率就会极其高</p><p>这便是典型的以空间换时间策略的算法。</p><p>另外，如果一个新生代中的对象经过多次SC垃圾回收算法的复制仍然存在，那么v8将会认为该对象已经是存活时间较长的对象了，它已经不适合再呆在新生代内存空间中了，更加确切的说，该对象已经不再适合用SC算法来进行管理了。那么,v8就会将该对象移动到老生代内存空间中，采用新的垃圾回收算法进行管理</p><h4 id="老生代内存空间所使用的垃圾回收算法"><a href="#老生代内存空间所使用的垃圾回收算法" class="headerlink" title="老生代内存空间所使用的垃圾回收算法"></a>老生代内存空间所使用的垃圾回收算法</h4><p>由于老生代内存空间中的对象生存事件较长。因此，如果仍旧采用SC算法就会有明显的两个缺点：</p><ol><li>因为对象存活时间长，因此当该算法运行时，存活对象所占的比例极高，那么复制对象的效率就会明显很低</li><li>另外，就是要有一半的内存空间是空闲出来的，这样就会造成浪费</li></ol><p>因此，v8中采用Mark-Sweep（标记清除）&amp;Mark-Compact（标记整理）</p><h5 id="标记清除"><a href="#标记清除" class="headerlink" title="标记清除"></a>标记清除</h5><p>标记清除算法分为标记和清除两个阶段。</p><ol><li>标记阶段 遍历堆中的所有对象，将存活的对象进行标记</li><li>清除阶段 清除没有进行标记的对象</li></ol><p>可以看出，该算法只清理已经不再存活的对象。由于，在老生代内存空间中，死对象所占的比例较少，因此，清除死对象的方式会极其高效</p><p><img src="https://s2.ax1x.com/2019/11/04/KzKHSO.png" alt></p><p>我们可以看到，该算法将死对象清除后会造成内存空间的不连续，这也将会对后续的内存分配造成问题，因为，很可能后续会有一个需要较大的内存空间的对象要被分配，但是所有的碎片空间都无法满足此次分配，因此，就会提前触发垃圾回收机制并将该大内存空间的对象回收</p><p>为了解决这个问题，标记整理的算法就被提了出来</p><h5 id="标记整理"><a href="#标记整理" class="headerlink" title="标记整理"></a>标记整理</h5><p>标记整理算法是标记清除算法的改进版。</p><p>标记的过程还是一样的，区别在于清除过程，标记清除算法只是直接回收死对象的内存空间；</p><p>而标记整理算法是在整理过程中，将活着的对象往一端移动，那么当移动完成后，另一端就都是死的对象，因此，此时只要直接清除掉那一整块死掉的对象内存空间即可</p><p><img src="https://s2.ax1x.com/2019/11/04/Kz18BQ.jpg" alt></p><p><img src="https://s2.ax1x.com/2019/11/04/KzKblD.png" alt></p><h5 id="v8对于标记清除和标记整理算法的考虑"><a href="#v8对于标记清除和标记整理算法的考虑" class="headerlink" title="v8对于标记清除和标记整理算法的考虑"></a>v8对于标记清除和标记整理算法的考虑</h5><p>由于在标记整理中，v8需要将对象移动，因此它的执行速度就会相对比标记清除算法要慢。</p><p>因此，v8对于这两个算法是结合使用的。v8主要使用标记清除算法，只有当老生代内存空间不足以应对即将要分配的占用大内存空间对象的时候才会使用标记整理算法</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;内存管理简介&quot;&gt;&lt;a href=&quot;#内存管理简介&quot; class=&quot;headerlink&quot; title=&quot;内存管理简介&quot;&gt;&lt;/a&gt;内存管理简介&lt;/h2&gt;&lt;p&gt;来自于MDN的简介：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;像C语言这样的底层语言一般都有底层的内存管理接
      
    
    </summary>
    
      <category term="浏览器" scheme="http://angellike_fairy.gitee.io/angellikefairy/categories/%E6%B5%8F%E8%A7%88%E5%99%A8/"/>
    
    
  </entry>
  
  <entry>
    <title>node.js的事件循环机制</title>
    <link href="http://angellike_fairy.gitee.io/angellikefairy/2019/11/03/node-js%E7%9A%84%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF%E6%9C%BA%E5%88%B6/"/>
    <id>http://angellike_fairy.gitee.io/angellikefairy/2019/11/03/node-js的事件循环机制/</id>
    <published>2019-11-03T07:20:19.000Z</published>
    <updated>2019-11-04T07:05:17.830Z</updated>
    
    <content type="html"><![CDATA[<h2 id="什么是事件循环"><a href="#什么是事件循环" class="headerlink" title="什么是事件循环"></a>什么是事件循环</h2><p>之前，我们了解了浏览器中的事件循环机制。现在，我们来看一下Node中的事件循环机制。</p><p>来自于Node官网的解释：</p><blockquote><p>The event loop is what allows Node.js to perform non-blocking I/O operations — despite the fact that JavaScript is single-threaded — by offloading operations to the system kernel whenever possible.</p></blockquote><p>大致意思是，事件循环可以使Node.js通过将操作转移到系统内核中来执行非阻塞I / O操作（尽管JavaScript是单线程的）。</p><p>另外，我们需要知道，Node事件循环的概念与浏览器事件循环的概念类似，都是用来处理异步任务的。虽然异步任务必须要等到主线程执行堆栈中的任务执行完毕后才能被执行，但是，事件循环在进程启动的时候就会被创建。</p><h2 id="事件循环的流程"><a href="#事件循环的流程" class="headerlink" title="事件循环的流程"></a>事件循环的流程</h2><p>在进程启动时，Node便会创建一个类似于While(true)的循环，每执行一次循环体的过程我们称之为Tick。在每个Tick中，我们查看是否还有事件待处理，如果有，那么就取出该事件及其相关回调函数。如果存在关联的回调函数就执行它们。然后再进入下一个循环，如果不再有事件处理，那么就退出该循环。</p><p>流程图如下：</p><p><img src="https://s2.ax1x.com/2019/11/03/KXUgYR.png" alt></p><h2 id="事件循环的详细步骤"><a href="#事件循环的详细步骤" class="headerlink" title="事件循环的详细步骤"></a>事件循环的详细步骤</h2><p>每一个事件循环都会包含以下6个阶段</p><p><img src="https://s2.ax1x.com/2019/11/03/KXduKf.png" alt></p><p>每个阶段都有一个当前阶段要执行的回调FIFO（先进先出）队列。虽然每个阶段都有其自己的特殊方式，但是通常，当事件循环进入给定阶段时，它将执行该阶段特定的任何操作，然后在该阶段的队列中执行回调，直到队列用尽或回调的最大数量为止。当队列已用完或达到回调限制时，事件循环将移至下一个阶段，依此类推。</p><h3 id="阶段概述"><a href="#阶段概述" class="headerlink" title="阶段概述"></a>阶段概述</h3><ol><li><p>timers阶段：该阶段执行setTimeout和setInterval设定的回调函数</p></li><li><p>pending callbacks阶段： 此阶段执行某些系统操作的回调，例如TCP错误的类型。例如，如果ECONNREFUSED尝试连接时收到TCP套接字，则某些* nix系统希望等待报告错误。这将排队等待在挂起的回调阶段执行。</p></li><li><p>idle,prepare阶段：该阶段仅在内部使用，我们不用关心</p></li><li><p>poll阶段：</p><ol><li>检索新的I / O事件；</li><li>执行与I / O相关的回调（除了close回调，计时器安排的回调和setImmediate()的回调）；</li><li>适当时，Node将在此处阻塞。</li></ol></li><li><p>check阶段：执行setImmediate()设置的回调</p></li><li><p>close callbacks阶段： 一些监听事件结束的回调，例如socket.destroy()和socket.on(‘close’, callback)等等</p></li></ol><h3 id="需要详细说明的几个阶段"><a href="#需要详细说明的几个阶段" class="headerlink" title="需要详细说明的几个阶段"></a>需要详细说明的几个阶段</h3><h4 id="timers阶段"><a href="#timers阶段" class="headerlink" title="timers阶段"></a>timers阶段</h4><p>我们在阶段概述的时候就提到过，该阶段用来执行setTimeout和setInterval设定的回调函数。</p><p>我们也知道，Node无法保证在定时器设定的时间正好响应该回调函数。那个时间更准确地说来，应该是当Node监听到当前时间已经过了预期设定的事件，那么就将该回调函数放到主线程执行队列去等待执行。</p><p>另外，我们需要知道的是，从技术上来说，计时器的执行时间是由poll阶段来控制的（具体内容我们在poll阶段来详细说明）。</p><h4 id="poll阶段"><a href="#poll阶段" class="headerlink" title="poll阶段"></a>poll阶段</h4><p>poll阶段主要有2个功能：</p><ol><li>处理poll队列的事件的回调</li><li>当有已超时的timer（定时器），那么就转去timers阶段执行定时器设定的回调函数（这一个功能是有条件的，条件是此时的poll阶段必须为空闲状态，事件循环才会去查看当前是否有已超时的定时器。否则，事件循环会同步执行poll队列里的回调函数）</li></ol><p>以下为详细说明：</p><p>如果事件循环进入了poll阶段，并且当前代码中没有设定定时器，那么就会发生以下两种情况：</p><ul><li><p>如果poll队列不为空，那么事件循环将会同步执行poll队列里的回调函数直到清空队列或者执行的回调数量到达规定的上限</p></li><li><p>如果poll队列为空，那么事件循环就会去检查是否有设定setImmediate()</p><ol><li>如果设定了setImmediate()，那么事件循环将立刻结束当前的poll阶段，并转入下一个check阶段执行check阶段的队列中的回调（check阶段中的队列包含的是setImmediate()的回调）</li><li>如果没有设定setImmediate()，那么事件循环则会阻塞在该阶段等待回调加入队列中（其中阻塞是有超时时间的，当阻塞的时间超过超时时间，那么还未执行的回调只能在下一轮或更后面的事件循环中被执行）</li></ol></li></ul><p>一旦poll任务队列为空，那么事件循环将会检查timers，如果有一个或多个定时器准备就绪，那么事件循环将会离开当前阶段并进入下一轮事件循环，在timers阶段去执行timers任务队列中的回调</p><h4 id="check阶段"><a href="#check阶段" class="headerlink" title="check阶段"></a>check阶段</h4><p>setImmediate()的回调会被加入check队列中，然后当事件循环进入check阶段时同步执行队列中的回调</p><h5 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h5><p>事件循环的每个阶段都有对应的任务队列。当异步任务完成后，它们所对应的回调函数将会根据异步任务的类型进入相应的任务队列。例如：</p><ul><li>定时器任务的回调进入timers阶段的任务<br>队列</li><li>异步I/O的回调进入poll阶段的任务队列</li><li>setImmediate的回调进入chck阶段的任务队列</li></ul><p>另外，对于上述复杂的poll阶段的规则。</p><p>我们可以总结得到：</p><ul><li>如果事件循环进入poll阶段时有任务，那么同步执行完所有的回调；</li><li>如果没有，那么查看是否有setImmediate，<ol><li>如果有，那么离开poll阶段进入下一个check阶段；</li><li>如果没有，那么Node进入阻塞状态，同时不断检查Timers阶段任务队列是否有任务，<ul><li>如果有那么离开当前阶段去到Timers阶段执行回调；</li><li>如果没有，那么一直保持阻塞状态直到有异步I/O的回调加入任务队列或者设置的限制阻塞的超时时间已到</li></ul></li></ol></li></ul><p>简单来说: 能够退出poll阶段阻塞态的只有以下几种方式</p><ol><li>阻塞时间超过了设定的超时时间</li><li>在阻塞状态时检查到timers队列中有任务</li><li>设定了setImmediate</li></ol><p>说了那么多，我们来看一下一个例子，就应该较好地理解Node中的事件循环机制</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 程序开始时间</span></span><br><span class="line"><span class="keyword">let</span> startTime = <span class="built_in">Date</span>.now();</span><br><span class="line"></span><br><span class="line"><span class="comment">// Node中读取文件的异步API</span></span><br><span class="line">fs.readFile(<span class="string">'./a.js'</span>,<span class="string">'utf-8'</span>,(err,data)=&gt;&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'readFileTime'</span>,<span class="built_in">Date</span>.now()-startTime);</span><br><span class="line">    <span class="keyword">if</span>(err) <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'error'</span>);</span><br><span class="line">    <span class="keyword">return</span> data;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定时器</span></span><br><span class="line">setTimeout(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'timeout'</span>,<span class="built_in">Date</span>.now()-startTime);</span><br><span class="line">&#125;,<span class="number">50</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// setImmediate()</span></span><br><span class="line">setImmediate(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'immediate'</span>,<span class="built_in">Date</span>.now()-startTime);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>来看下输出结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">immediate 2</span><br><span class="line">readFileTime 10</span><br><span class="line">timeout 54</span><br></pre></td></tr></table></figure><h2 id="setTimeout与setImmediate"><a href="#setTimeout与setImmediate" class="headerlink" title="setTimeout与setImmediate"></a>setTimeout与setImmediate</h2><p>在上面我们已经知道了setTimeout设定的回调会在timers阶段被执行，而setImmediate设定的回调会在check阶段被执行。</p><p>那么，接下来我们来看一段程序：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">setTimeout(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'timeout'</span>);</span><br><span class="line">&#125;,<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">setImmediate(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'immediate'</span>);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>事实上，这段代码的运行结果不是唯一的。主要是两个输出语句的输出顺序是不一定的。</p><p>有可能是：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">timeout</span><br><span class="line">immediate</span><br></pre></td></tr></table></figure><p>但也有可能是</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">immediate</span><br><span class="line">timeout</span><br></pre></td></tr></table></figure><p>但是，如果我们在一次I/O中在运行调用setTimeout和setImmediate，我们会发现setImmediate的回调永远比setTimeout的回调先执行</p><p>例如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>);</span><br><span class="line"></span><br><span class="line">fs.readFile(<span class="string">'./a.js'</span>,<span class="string">'utf-8'</span>,()=&gt;&#123;</span><br><span class="line">    setTimeout(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'timeout'</span>);</span><br><span class="line">    &#125;,<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">    setImmediate(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'immediate'</span>);</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 输出结果</span></span><br><span class="line"><span class="comment">immediate</span></span><br><span class="line"><span class="comment">timeout</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>那么，这是为什么呢?</p><p>搬用cnode社区里的一个大神的回答</p><pre><code>在node中，setTimeout(cb, 0) === setTimeout(cb, 1);而setImmediately属于uv_run_check的部分确实每次loop进来，都是先检查uv_run_timer的，但是由于cpu工作耗费时间，比如第一次获取的hrtime为0那么setTimeout(cb, 1)，超时时间就是loop-&gt;time = 1(ms，node定时器精确到1ms，但是hrtime是精确到纳秒级别的)所以第一次loop进来的时候就有两种情况：1.由于第一次loop前的准备耗时超过1ms，当前的loop-&gt;time &gt;=1 ，则uv_run_timer生效，timeout先执行2.由于第一次loop前的准备耗时小于1ms，当前的loop-&gt;time = 0，则本次loop中的第一次uv_run_timer不生效，那么io_poll后先执行uv_run_check，即immediate先执行，然后等close cb执行完后，继续执行uv_run_timer那么你说的为什么在回调中，一定是先immediate执行呢，其实也很容易理解你可以思考一下你写的场景由于你的timeout和immediate的事件注册是在readFile的回调执行时，触发是必然的，在readFile的回调执行前的每一次event loop进来的uv_run_timer都不会有超时事件触发那么当readFile执行完毕，kevent收到监听的fd事件完成后，执行了该回调，此时1.timeout事件注册2.immediate事件注册3.由于readFile的回调执行完毕，那么就会从uv_io_poll中出来，此时立即执行uv_run_check，所以immediate事件被执行掉4.最后的uv_run_timer检查timeout事件，执行timeout事件所以你会发现，在I/O回调中注册的两者，永远都是immediately先执行</code></pre><p><a href="https://cnodejs.org/topic/57d68794cb6f605d360105bf" target="_blank" rel="noopener">这里是大神文章的链接：</a></p><h2 id="process-nextTick"><a href="#process-nextTick" class="headerlink" title="process.nextTick()"></a>process.nextTick()</h2><p>Node官方文档是这样解释process.nextTick()的：</p><blockquote><p>process.nextTick() 方法将 callback 添加到下一个时间点的队列。 在 JavaScript 堆栈上的当前操作运行完成之后以及允许事件循环继续之前，此队列会被完全耗尽。 如果要递归地调用 process.nextTick()，则可以创建无限的循环。</p></blockquote><p>这就意味着：</p><ol><li><p>如果，process.nextTick定义在事件循环机制开始前，而非事件循环机制中，那么，process.nextTick定义的回调函数将在主线程执行队列中的所有任务执行完毕后被调用</p><p> 例如：</p> <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">setTimeout(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'timeout'</span>);</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">process.nextTick(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'tick'</span>);</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">setImmediate(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'immediate'</span>);</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 输出结果</span></span><br><span class="line"><span class="comment">1</span></span><br><span class="line"><span class="comment">2</span></span><br><span class="line"><span class="comment">tick</span></span><br><span class="line"><span class="comment">// 注意：timeout和Immediate的输出顺序是不一定的，原因在前文已经提过</span></span><br><span class="line"><span class="comment">timeout</span></span><br><span class="line"><span class="comment">immediate</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure></li><li><p>如果process.nextTick()在事件循环中被定义，那么process.nextTick定义的回调函数将会在下一个事件循环的阶段开始前被执行，也就是两个阶段切换时的中间过程</p><p> 来看一个例子：</p> <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>);</span><br><span class="line"></span><br><span class="line">fs.readFile(<span class="string">'./a.js'</span>,<span class="string">'utf-8'</span>,()=&gt;&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">1</span>);</span><br><span class="line">    setTimeout(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'timeout'</span>);</span><br><span class="line">    &#125;,<span class="number">0</span>)</span><br><span class="line">    setImmediate(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'immediate'</span>);</span><br><span class="line">    &#125;)</span><br><span class="line">    process.nextTick(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'tick1'</span>);</span><br><span class="line">    &#125;)</span><br><span class="line">    process.nextTick(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'tick2'</span>);</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 输出结果</span></span><br><span class="line"><span class="comment">1</span></span><br><span class="line"><span class="comment">tick1</span></span><br><span class="line"><span class="comment">tick2</span></span><br><span class="line"><span class="comment">immediate</span></span><br><span class="line"><span class="comment">timeout</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p> 当异步读取完文件后，此时位于poll阶段，执行回调函数，该回调函数设定了一个setTimeout，一个setImmediate，两个process.nextTick。加下来事件循环开始离开poll阶段，在从poll阶段切换到check阶段的中间，两个process.nextTick设定的回调函数将会被执行。接着，转换到check阶段执行setImmediate设定的回调函数。最后，在下一轮事件循环中执行setTimeout设定的回调函数。</p></li><li><p>如果process.nextTick()定义在某个阶段中要同步的执行当前队列的所有回调函数内部时，根据，官方文档的说明，在 JavaScript 执行堆栈上的当前操作运行完成之后以及允许事件循环继续之前，process.nextTick将会被执行</p></li></ol><p>例如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">setImmediate(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'immediate1'</span>);</span><br><span class="line">    process.nextTick(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'tick强势插入'</span>);</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">setImmediate(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'immediate2'</span>);</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 输出结果</span></span><br><span class="line"><span class="comment">immediate1</span></span><br><span class="line"><span class="comment">tick强势插入</span></span><br><span class="line"><span class="comment">immediate2</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>在事件循环机制中，此时位于check阶段，事件循环机制将按照同步的方式依次将setImmediate的回调函数放入主线程的执行堆栈中进行运行。但是第一个setImmediate的回调函数执行时又注册了process.nextTick()。因此，在事件循环机制继续运行（将下一个setImmediate回调放入主线程执行堆栈中进行执行）前，process.nextTick就优先被执行</p><p>另外，需要尤其注意的是，process.nextTick的回调一旦执行，必须要直到nextTick队列被清空，才会进入到下一个事件阶段，所以如果递归调用 process.nextTick()，会导致出现I/O starving（饥饿）的问题</p><p>例如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> index = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">let</span> startTime = <span class="built_in">Date</span>.now();</span><br><span class="line"></span><br><span class="line">fs.readFile(<span class="string">'./a.js'</span>,<span class="string">'utf-8'</span>,()=&gt;&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'File is readed'</span>);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`Time wasted <span class="subst">$&#123;<span class="built_in">Date</span>.now()-startTime&#125;</span>`</span>);</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">handle</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(index &gt; <span class="number">1000</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`tick <span class="subst">$&#123;index&#125;</span>`</span>);</span><br><span class="line">    index++;</span><br><span class="line">    process.nextTick(handle);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">handle();</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 输出结果</span></span><br><span class="line"><span class="comment">tick 0</span></span><br><span class="line"><span class="comment">tick 1</span></span><br><span class="line"><span class="comment">tick 2</span></span><br><span class="line"><span class="comment">...</span></span><br><span class="line"><span class="comment">...</span></span><br><span class="line"><span class="comment">tick 1000</span></span><br><span class="line"><span class="comment">File is readed</span></span><br><span class="line"><span class="comment">Time wasted 495</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>我们发现，在上述程序中，只有当process.nextTick()全部执行完毕后，fs。readFile()注册的回调函数才会被执行</p><h3 id="process-nextTick-与setImmediate"><a href="#process-nextTick-与setImmediate" class="headerlink" title="process.nextTick()与setImmediate()"></a>process.nextTick()与setImmediate()</h3><p>我们在前面已经分别介绍过了process.nextTick()与setImmediate()注册的回调函数的执行时机。</p><p>因此，如果，process.nextTick()与setImmediate()同时被注册，那么process.nextTick的优先级要高于setImmediate</p><p>例如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">setImmediate(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'immediate'</span>);</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">process.nextTick(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'tick'</span>);</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 输出结果</span></span><br><span class="line"><span class="comment">tick</span></span><br><span class="line"><span class="comment">immediate</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>其实，这段代码在上面的叙述中已经提过。那么，为什么还要将它们俩放在一起比较呢？</p><p>其实，是因为我们提到，process.nextTick()一旦执行就会将当前所有的nextTick()注册的回调执行完后才会进入下一个事件阶段，因此，很容易造成I/O饥饿现象</p><p>而setImmediate则会改变这种现象。因为，在事件循环中，每次在check阶段每个setImmedaite任务只会执行一次setImmediate的回调，如果回调里还有setImmediate任务，那么它将会在下一轮事件循环中执行</p><p>例如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>);</span><br><span class="line"></span><br><span class="line">fs.readFile(<span class="string">'./a.js'</span>,<span class="string">'utf-8'</span>,()=&gt;&#123;</span><br><span class="line">    setImmediate(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'immediate1'</span>);</span><br><span class="line">        setImmediate(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">'immediate2'</span>);</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">    setTimeout(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'timeout2'</span>);</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 输出结果</span></span><br><span class="line"><span class="comment">immediate1</span></span><br><span class="line"><span class="comment">timeout2</span></span><br><span class="line"><span class="comment">immediate2</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>我们可以看到,setImmediate第一个回调执行完毕后并没有立刻执行第二个setImmediate回调，而是进入了下一轮事件循环，先在timers阶段执行了setTimeout的回调，然后再在check阶段执行第二个setImmediate的回调。</p><p>因此，在解决多次调用process.nextTick所具有的的I/O饥饿问题，我们可以使用setImmediate来解决</p><p>下面的程序只是将上面的程序中的process.nextTick替换成setImmediate</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> index = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">let</span> startTime = <span class="built_in">Date</span>.now();</span><br><span class="line"></span><br><span class="line">fs.readFile(<span class="string">'./a.js'</span>,<span class="string">'utf-8'</span>,()=&gt;&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'File is readed'</span>);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`Time wasted <span class="subst">$&#123;<span class="built_in">Date</span>.now()-startTime&#125;</span>`</span>);</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">handle</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(index &gt; <span class="number">100</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`tick <span class="subst">$&#123;index&#125;</span>`</span>);</span><br><span class="line">    index++;</span><br><span class="line">    setImmediate(handle);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">handle();</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 输出结果</span></span><br><span class="line"><span class="comment">tick 0</span></span><br><span class="line"><span class="comment">tick 1</span></span><br><span class="line"><span class="comment">...</span></span><br><span class="line"><span class="comment">tick 7</span></span><br><span class="line"><span class="comment">File is readed</span></span><br><span class="line"><span class="comment">Time wasted 12</span></span><br><span class="line"><span class="comment">tick 8</span></span><br><span class="line"><span class="comment">tick 9</span></span><br><span class="line"><span class="comment">...</span></span><br><span class="line"><span class="comment">...</span></span><br><span class="line"><span class="comment">tick 100</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>我们可以看到,fs.readFile()的回调再setImmediate的递归中进行了输出，而不是等所有递归结束后再被执行。</p><p>我们来解释一下其中的原因：</p><ol><li>执行fs.readFile异步任务和handle()函数，同时输出tick 0</li><li>第一次事件循环，此时在poll阶段并没有得等到readFile的回调加入任务队列，而此时setImmediate函数被注册，那么立即离开poll阶段</li><li>进入check阶段，执行setImmediate注册的回调函数，在该程序中也就是再执行一遍，此时输出tick 1，但是，在该回调函数中又注册了一个setTimeout，但是该setTimeout并不会立即执行，而是等到下一轮事件循环中执行</li><li>…中途经过了几轮的事件循环，在这几轮中，pool阶段始终没有等到readFile的回调，因此，在check阶段一直输出到了tick 7</li><li>在这轮事件循环中，在poll阶段的任务队列中终于有了readFile()的回调，那么立即执行该回调，输出<blockquote><p>File is readed<br> Time wasted 12</p></blockquote></li><li>继续多轮事件循环，一直到退出handle()递归</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;什么是事件循环&quot;&gt;&lt;a href=&quot;#什么是事件循环&quot; class=&quot;headerlink&quot; title=&quot;什么是事件循环&quot;&gt;&lt;/a&gt;什么是事件循环&lt;/h2&gt;&lt;p&gt;之前，我们了解了浏览器中的事件循环机制。现在，我们来看一下Node中的事件循环机制。&lt;/p&gt;
&lt;p&gt;
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>深入了解Node的异步I/O</title>
    <link href="http://angellike_fairy.gitee.io/angellikefairy/2019/11/01/%E6%B7%B1%E5%85%A5%E4%BA%86%E8%A7%A3Node%E7%9A%84%E5%BC%82%E6%AD%A5I-O/"/>
    <id>http://angellike_fairy.gitee.io/angellikefairy/2019/11/01/深入了解Node的异步I-O/</id>
    <published>2019-11-01T06:35:42.000Z</published>
    <updated>2019-11-04T07:05:17.830Z</updated>
    
    <content type="html"><![CDATA[<h2 id="I-O"><a href="#I-O" class="headerlink" title="I/O"></a>I/O</h2><h3 id="什么是I-O"><a href="#什么是I-O" class="headerlink" title="什么是I/O"></a>什么是I/O</h3><blockquote><p>I/O（英语：Input/Output），即输入/输出，通常指数据在内部存储器和外部存储器或其他周边设备之间的输入和输出。</p></blockquote><p>另外，I/O又可以具体分为磁盘I/O和网络I/O。</p><p>它们一般具有以下两个步骤：</p><ol><li>等待数据准备 </li><li>将数据从内核拷贝到进程中</li></ol><p>对于一般的I/O读操作，我们可以进行以下的抽象：</p><ol><li>应用发起read系统调用</li><li>操作系统层面接受应用的请求，如果内核缓冲区中有该数据，那么将该数据拷贝到用户缓存区</li><li>如果内核缓存区中没有数据，那么内核会向io模块发送请求，让其从磁盘中读取数据。读取完毕后，将其存入内核缓存区，并拷贝到用户缓存区</li></ol><p><img src="https://s2.ax1x.com/2019/11/03/KOXjrq.jpg" alt></p><p>总结：</p><ol><li><p>当应用程序调用read接口时，操作系统检查在内核的高速缓存有没有需要的数据，如果已经缓存了，那么就直接从缓存中返回，如果没有，则从磁盘中读取，然后缓存在操作系统的缓存中。</p></li><li><p>应用程序调用write接口时，将数据从用户地址空间复制到内核地址空间的缓存中，这时对用户程序来说，写操作已经完成，至于什么时候再写到磁盘中，由操作系统决定，除非显示调用了sync同步命令</p></li></ol><h3 id="PIO与DMA"><a href="#PIO与DMA" class="headerlink" title="PIO与DMA"></a>PIO与DMA</h3><p>有必要提一下PIO与DMA两种I/O方式</p><ol><li><p>PIO<br>我们拿磁盘来说，很早以前，磁盘和内存之间的数据传输是需要CPU控制的，也就是说如果我们读取磁盘文件到内存中，数据要经过CPU存储转发，这种方式称为PIO。显然这种方式非常不合理，需要占用大量的CPU时间来读取文件，造成文件访问时系统几乎停止响应。</p></li><li><p>DMA<br>后来，DMA（直接内存访问，Direct Memory Access）取代了PIO，它可以不经过CPU而直接进行磁盘和内存的数据交换。在DMA模式下，CPU只需要向DMA控制器下达指令，让DMA控制器来处理数据的传送即可，DMA控制器通过系统总线来传输数据，传送完毕再通知CPU，这样就在很大程度上降低了CPU占有率，大大节省了系统资源，而它的传输速度与PIO的差异其实并不十分明显，因为这主要取决于慢速设备的速度。</p></li></ol><p>因此，在这里我们树立一个概念，现在的I/O操作在读写的过程中是不需要经过CPU进行处理的。</p><h2 id="异步与非阻塞，同步与阻塞是同一个概念吗"><a href="#异步与非阻塞，同步与阻塞是同一个概念吗" class="headerlink" title="异步与非阻塞，同步与阻塞是同一个概念吗"></a>异步与非阻塞，同步与阻塞是同一个概念吗</h2><p>在Node的文章中，我们经常可以看到异步，非阻塞；同步，阻塞这些概念。听起来，异步与非阻塞像是同一个概念，而且他们实现的效果好像是一样的。但是，实际上它们是两回事。</p><p>对于阻塞与非阻塞我们可以这样理解：</p><blockquote><p>阻塞和非阻塞关注的是程序在等待调用结果（消息，返回值）时的状态.阻塞调用是指调用结果返回之前，当前线程会被挂起。调用线程只有在得到结果之后才会返回。非阻塞调用指在不能立刻得到结果之前，该调用不会阻塞当前线程。</p></blockquote><p>而对于异步与同步：</p><blockquote><p>同步和异步关注的是消息通信机制。所谓同步，就是在发出一个调用时，在没有得到结果之前，该调用就不返回。但是一旦调用返回，就得到返回值了。换句话说，就是由调用者*动等待这个调用的结果。而异步则是相反，调用在发出之后，这个调用就直接返回了，当然不会有返回结果。换句话说，当一个异步过程调用发出后，调用者不会立刻得到结果。而是在调用发出后，被调用者通过状态、通知来通知调用者，或通过回调函数处理这个调用。</p></blockquote><p>总结来说：</p><ol><li>阻塞与非阻塞更多的考虑是对于自身的线程。阻塞即线程挂起等待结果返回；而非阻塞就是该线程继续往下执行，但是不会立即得到等待结果。我们只有通过轮询机制才能得到结果</li><li>同步与异步更多的是考虑双方的状态。例如，应用层向服务端发起一个请求，如果是同步请求，那么只有服务端得到结果之后才可以返回；而如果是异步请求，那么调用就直接返回，经过一定时间后，服务端的数据已经处理完毕，然后通过回调机制来通知应用层结果已经返回</li></ol><h2 id="Node的异步I-O"><a href="#Node的异步I-O" class="headerlink" title="Node的异步I/O"></a>Node的异步I/O</h2><h3 id="事件循环"><a href="#事件循环" class="headerlink" title="事件循环"></a>事件循环</h3><p>在这里可以去查看另一篇文章</p><h3 id="观察者"><a href="#观察者" class="headerlink" title="观察者"></a>观察者</h3><p>在每次事件循环中，Node如何判断是否有新的事件需要处理呢？</p><p>Node引入观察者来实现是否有事件需要处理的判断。每个事件循环中都会有1个或多个观察者，而判断是否有事件需要处理的过程就是向这些观察者询问是否有要处理的事件。</p><p>在Node中，事件主要来源于网络请求、文件I/O等，这些事件的对应观察者即网络I/O观察者，文件I/O观察者。</p><p>另外，事件循环是典型的生产者/消费者模型。异步I/O、网络请求等则是生产者，源源不断为Node提供不同类型的事件，这些事件会被传递到对应的观察者那里，然后事件循环则会从观察者那里取出事件并进行处理</p><h3 id="异步I-O的整体流程"><a href="#异步I-O的整体流程" class="headerlink" title="异步I/O的整体流程"></a>异步I/O的整体流程</h3><p>我们以fs.open()方法为例来探究以下异步I/O的整体流程。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>);</span><br><span class="line"></span><br><span class="line">fs.open(path,flags,mode,callback);</span><br></pre></td></tr></table></figure><p>fs.open()的作用是根据指定的路径和参数去打开一个文件，从而得到一个文件描述符。</p><h4 id="异步调用的第一个阶段"><a href="#异步调用的第一个阶段" class="headerlink" title="异步调用的第一个阶段"></a>异步调用的第一个阶段</h4><p>当Node调用fs.open()核心模块后，该核心模块将会去调用C++内建模块。然后通过libuv这一层为不同的平台（windows和*nix）调用分别系统级底层函数。</p><p><img src="https://s2.ax1x.com/2019/11/04/KvItQx.png" alt></p><p>在系统级底层函数uv_fs_open()的调用过程中，会创建一个FSReqWrap的请求对象，所有传递给js核心模块fs.open()的参数和回调方法都被作为该对象的属性被其封装。例如，回调函数会被设置在这个对象的oncomplete_sym上：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">req_wrap-&gt;object_-&gt;Set(oncomplete_sym,callback);</span><br></pre></td></tr></table></figure><p>请求对象包装完毕后，则会将该请求对象推入线程池中去等待执行。</p><p>至此，Js调用立即返回，有Js层面发起的异步调用的第一阶段到这里就结束了。Js主线程可以继续去执行其余任务，当前的I/O操作则会在线程池中等待执行，不管线程池中的该I/O线程是否阻塞，都不会影响Js主线程的后续执行，因此，异步就这样实现了。</p><h4 id="异步调用的第二个阶段"><a href="#异步调用的第二个阶段" class="headerlink" title="异步调用的第二个阶段"></a>异步调用的第二个阶段</h4><blockquote><p>回调通知则是异步调用的第二个阶段。</p></blockquote><p>当线程池中的I/O线程完成工作后，会将获取的结果储存在第一阶段定义的请求对象的req-&gt;result属性上，然后会通知IOCP（windows实现的异步I/O方案），告知当前对象操作已经完成，然后将线程归还线程池。</p><p>到这里，整个异步I/O的流程并没有结束。</p><p>事件循环中的I/O观察者将会在每次事件循环中去检查请求是否执行完成，如果执行完毕，那么就会取出请求对象的rq-&gt;result属性作为参数，取出oncomplete_sym属性作为方法，然后进行调用执行，以此来达到调用Js中传入的回调函数的目的。</p><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>至此，整个异步I/O的流程完全结束，流程图如下：</p><p><img src="https://s2.ax1x.com/2019/11/04/KvINy6.png" alt></p><p>简单来说，Node的异步I/O流程可以分为以下几步：</p><p>异步调用</p><ol><li>应用层发起异步调用，Node会从调用核心模块到内建模块一直到调用到底层系统级函数</li><li>将应用层传入的参数和回调封装给一个请求对象</li><li>将请求对象放入线程池等待执行</li><li>应用层发起的异步调用结束，立即返回</li></ol><p>线程池</p><ol><li>分配空闲线程来执行请求对象中的I/O操作</li><li>I/O线程执行完毕，将执行完毕的结果储存在请求对象中</li><li>在windows下通知IOCP已经执行完毕，然后归还该I/O线程</li></ol><p>事件循环</p><ol><li>事件循环中的I/O观察者观察到事件已完成，将该事件的回调推入任务队列中</li><li>取出回调函数和请求对象中的结果进行调用执行</li></ol><h2 id="事件驱动"><a href="#事件驱动" class="headerlink" title="事件驱动"></a>事件驱动</h2><p>Node中的事件驱动就是通过不断地进行事件循环然后当事件来临时进行触发的机制。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;I-O&quot;&gt;&lt;a href=&quot;#I-O&quot; class=&quot;headerlink&quot; title=&quot;I/O&quot;&gt;&lt;/a&gt;I/O&lt;/h2&gt;&lt;h3 id=&quot;什么是I-O&quot;&gt;&lt;a href=&quot;#什么是I-O&quot; class=&quot;headerlink&quot; title=&quot;什么是I/O&quot;&gt;&lt;
      
    
    </summary>
    
      <category term="Node" scheme="http://angellike_fairy.gitee.io/angellikefairy/categories/Node/"/>
    
    
  </entry>
  
  <entry>
    <title>浏览器渲染机制</title>
    <link href="http://angellike_fairy.gitee.io/angellikefairy/2019/10/29/%E6%B5%8F%E8%A7%88%E5%99%A8%E6%B8%B2%E6%9F%93%E6%9C%BA%E5%88%B6/"/>
    <id>http://angellike_fairy.gitee.io/angellikefairy/2019/10/29/浏览器渲染机制/</id>
    <published>2019-10-29T06:58:30.000Z</published>
    <updated>2019-10-29T12:58:26.581Z</updated>
    
    <content type="html"><![CDATA[<h2 id="浏览器渲染步骤"><a href="#浏览器渲染步骤" class="headerlink" title="浏览器渲染步骤"></a>浏览器渲染步骤</h2><p>浏览器的渲染机制一般分为以下几步：</p><ol><li>处理HTML并构建DOM树</li><li>处理CSS构建CSSOM树</li><li>将DOM和CSSOM合并生成Render Tree（渲染树）</li><li>根据渲染树计算节点的位置进行布局</li><li>通过显卡将画面绘制到屏幕上</li></ol><p>一个整体的流程图<br><img src="https://s2.ax1x.com/2019/10/29/KfV1eS.jpg" alt></p><h2 id="DOM树与CSSOM树的生成过程"><a href="#DOM树与CSSOM树的生成过程" class="headerlink" title="DOM树与CSSOM树的生成过程"></a>DOM树与CSSOM树的生成过程</h2><p>DOM树的生成过程（CSSOM树与之类似）：</p><ol><li>转换：浏览器从磁盘或网络上读取HTML的原始字节，并根据文件的指定编码（例如UTF-8）将它们转换为单个字符。</li><li>标记化：浏览器将字符串转换为W3C HTML5标准指定的不同标记；例如“ <html>”，“ <body>”以及尖括号内的其他字符串。每个令牌都有特殊的含义和自己的规则集。</body></html></li><li>节点生成：发出的令牌被转换为“对象”，以定义其属性和规则。</li><li>DOM构造：最后，由于HTML标记定义了不同标记之间的关系（某些标记包含在其他标记中），因此创建的对象以树形数据结构链接，该树数据结构还捕获了原始标记中定义的父子关系：HTML 对象是body对象的父对象，body是段落对象的父 对象，依此类推。</li></ol><p>DOM树示例</p><p><img src="https://s2.ax1x.com/2019/10/29/KRQVC4.png" alt></p><p>CSSOM树示例</p><p><img src="https://s2.ax1x.com/2019/10/29/KRQZ8J.png" alt></p><h2 id="Render-Tree（渲染树）"><a href="#Render-Tree（渲染树）" class="headerlink" title="Render Tree（渲染树）"></a>Render Tree（渲染树）</h2><p>在上面，我们得到了描述页面内容的DOM树和描述页面样式的CSSOM。接下来，我们就得需要将两者进行结合生成Render Tree</p><h3 id="渲染树的生成和渲染步骤"><a href="#渲染树的生成和渲染步骤" class="headerlink" title="渲染树的生成和渲染步骤"></a>渲染树的生成和渲染步骤</h3><ol><li><p>将DOM和CSSOM树合并以形成渲染树</p><pre><code>渲染树的生成步骤：1. 从DOM树的根节点开始，采取深度优先遍历的方式（也就是说当前节点的所有子节点都构建好后才会去构建当前节点的下一个兄弟节点）来遍历每一个可见节点&gt; 什么是不可见节点：     1. 一些节点不可见（例如，脚本标记，元标记等），由于它们未反映在渲染的输出中，因此将其省略。    2. 一些节点通过CSS隐藏，并且在渲染树中也被省略；例如，将一个节点设置了“ display：none”属性。（但是设置visibility: hidden就会将该CSSOM节点和属性添加到渲染树中）2. 对于每个可见节点，找到匹配CSSOM规则并应用它们。3. 生成具有内容及其计算样式的可见节点。</code></pre></li><li><p>布局：在生成的渲染树中，我们已经可以得知了那些节点是可见的，并且该节点的样式也是已知的。接下来我们需要计算它们在设备视口中的确切位置和大小，这就是“布局”阶段，也称为“重排”。 </p></li><li><p>将各个节点绘制到屏幕上</p></li></ol><p><img src="https://s2.ax1x.com/2019/10/29/KRwEmF.png" alt></p><p>需要注意的是：</p><blockquote><p>Render Tree与DOM树不一定是相同的。虽然，Renter Tree是按照DOM树的节点进行遍历生成的。但是，我们要记住，Render Tree中的所有节点都是可见节点（我们在前面已经提到过什么是不可见节点）。</p></blockquote><h2 id="阻塞渲染"><a href="#阻塞渲染" class="headerlink" title="阻塞渲染"></a>阻塞渲染</h2><p>我们知道HTML会阻塞渲染树的渲染，因为要是没有DOM，渲染树就无法渲染任何内容。那么对于css和JS呢？它们阻塞渲染吗？</p><p>掘金站点的html文档耗时情况<br><img src="https://s2.ax1x.com/2019/10/29/KfZ5j0.png" alt></p><p>我们可以看到阻塞了150ms</p><h3 id="css阻塞渲染"><a href="#css阻塞渲染" class="headerlink" title="css阻塞渲染"></a>css阻塞渲染</h3><p>在默认的情况下，css是阻塞渲染的。</p><p>我们在html文档里引入一个css文件，然后查看一下渲染过程，我们可以看到该css文件是阻塞的</p><p>在构建 CSSOM 树时，会阻塞渲染，直至 CSSOM 树构建完成。并且构建 CSSOM 树是一个十分消耗性能的过程，所以应该尽量保证层级扁平，减少过度层叠，越是具体的 CSS 选择器，执行速度越慢。</p><p><img src="https://s2.ax1x.com/2019/10/29/KRwkOU.png" alt></p><h3 id="js文件阻塞渲染"><a href="#js文件阻塞渲染" class="headerlink" title="js文件阻塞渲染"></a>js文件阻塞渲染</h3><blockquote><p>除非明确声明为异步，否则JavaScript会阻止DOM构建</p></blockquote><h4 id="非异步脚本"><a href="#非异步脚本" class="headerlink" title="非异步脚本"></a>非异步脚本</h4><p>无论我们使用的是&lt;script&gt;内联形式的代码块还是引入外部文件，浏览器都会暂停并执行js脚本，然后才能处理文档的其余部分。</p><p>另外，在使用外部JavaScript文件的情况下，浏览器必须暂停以等待从磁盘，缓存或远程服务器中获取脚本，这可能会增加关键渲染路径的数十到数千毫秒的延迟。</p><p>我们来试验一下：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">head</span>&gt;</span><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span> <span class="attr">src</span>=<span class="string">"./a.js"</span>&gt;</span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span></span><br></pre></td></tr></table></figure><p>结果</p><p><img src="https://s2.ax1x.com/2019/10/29/KRwVw4.png" alt></p><h4 id="异步脚本"><a href="#异步脚本" class="headerlink" title="异步脚本"></a>异步脚本</h4><p>HTML5为script元素定义了async属性。该属性可以让js文件异步加载。</p><blockquote><p>async只适用于外部脚本文件</p></blockquote><p>指定async属性的目的是不让页面等待脚本下载和执行，从而异步加载页面其他内容。因此，异步脚本不要在加载期间修改DOM</p><p>另外，异步脚本一定会在页面的load事件前执行。</p><p>来看一下加上async属性，该js脚本是否回阻塞后面的执行：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">head</span>&gt;</span><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">script</span> <span class="attr">async</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span> <span class="attr">src</span>=<span class="string">"./a.js"</span>&gt;</span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span></span><br></pre></td></tr></table></figure><p>结果</p><p><img src="https://s2.ax1x.com/2019/10/29/KRwZTJ.png" alt></p><h2 id="重绘与回流"><a href="#重绘与回流" class="headerlink" title="重绘与回流"></a>重绘与回流</h2><p>重绘与回流的基本概念</p><ol><li><p>当Render Tree中部分或全部元素的尺寸、结构、或某些属性发生改变时，浏览器重新渲染部分或全部文档的过程称为回流。</p></li><li><p>当页面中元素样式的改变并不影响它在文档流中的位置时（例如：color、background-color、visibility等），浏览器会将新样式赋予给元素并重新绘制它，这个过程称为重绘。</p></li></ol><p>由此我们可以得出一个结论：</p><blockquote><p>回流必定会发生重绘，重绘不一定会引发回流。</p></blockquote><p>我们来看一下回流具体发生的场景：</p><ol><li><p>添加或者删除可见的DOM元素；</p></li><li><p>元素位置改变；</p></li><li><p>元素尺寸改变——边距、填充、边框、宽度和高度</p></li><li><p>内容改变——比如文本改变或者图片大小改变而引起的计算值宽度和高度改变；</p></li><li><p>页面渲染初始化；</p></li><li><p>浏览器窗口尺寸改变——resize事件发生时；</p></li><li><p>查询或调用一些会引起回流的属性</p><pre><code>clientWidth、clientHeight、clientTop、clientLeftoffsetWidth、offsetHeight、offsetTop、offsetLeftscrollWidth、scrollHeight、scrollTop、scrollLeftscrollIntoView()、scrollIntoViewIfNeeded()getComputedStyle()getBoundingClientRect()scrollTo()</code></pre></li></ol><h3 id="重绘与回流的开销"><a href="#重绘与回流的开销" class="headerlink" title="重绘与回流的开销"></a>重绘与回流的开销</h3><blockquote><p>回流比重绘的开销要更大。</p></blockquote><p>另外，回流的开销也会因为操作的不同而有可能相差很大</p><p>假如，我们直接操纵body，并且在body前插入一个元素，那么整个Render Tree都会被重新构建</p><p>而如果只是在Render Tree的叶子节点后插入一个节点，那么前面的所有节点都不会影响。因此，开销会比上一个回流的开销小得多。</p><h3 id="减少重绘与回流（性能提高）"><a href="#减少重绘与回流（性能提高）" class="headerlink" title="减少重绘与回流（性能提高）"></a>减少重绘与回流（性能提高）</h3><h4 id="对于css"><a href="#对于css" class="headerlink" title="对于css"></a>对于css</h4><ol><li><p>避免使用table布局。 由于浏览器使用流式布局，对Render Tree的计算通常只需要遍历一次就可以完成，但table及其内部元素除外，他们可能需要多次计算，通常要花3倍于同等元素的时间。</p></li><li><p>使用 visibility：0 替换 display: none ，因为前者只会引起重绘，后者会引发回流（改变了布局–渲染树不会生成该节点）</p></li><li><p>CSS 选择符从右往左匹配查找，避免 DOM 深度过深</p></li><li><p>避免使用CSS表达式（例如：calc()）</p></li></ol><h4 id="对于js"><a href="#对于js" class="headerlink" title="对于js"></a>对于js</h4><ol><li><p>避免频繁操作样式，最好一次性重写style属性，或者将样式列表定义为class并一次性更改class属性。</p></li><li><p>避免频繁操作DOM，创建一个documentFragment，在它上面应用所有DOM操作，最后再把它添加到文档中。</p></li><li><p>避免频繁读取会引发回流/重绘的属性，如果确实需要多次使用，就用一个变量缓存起来。</p></li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++) &#123;</span><br><span class="line">    <span class="comment">// 获取 offsetTop 会导致回流，因为需要去获取正确的值</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">document</span>.querySelector(<span class="string">'.test'</span>).style.offsetTop)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="4"><li>也可以先为元素设置display: none，操作结束后再把它显示出来。因为在display属性为none的元素上进行的DOM操作不会引发回流和重绘（因为将display属性设置为none的节点为不可见节点，不可见节点不会被添加到渲染树中）。</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;浏览器渲染步骤&quot;&gt;&lt;a href=&quot;#浏览器渲染步骤&quot; class=&quot;headerlink&quot; title=&quot;浏览器渲染步骤&quot;&gt;&lt;/a&gt;浏览器渲染步骤&lt;/h2&gt;&lt;p&gt;浏览器的渲染机制一般分为以下几步：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;处理HTML并构建DOM树&lt;/li&gt;

      
    
    </summary>
    
      <category term="浏览器" scheme="http://angellike_fairy.gitee.io/angellikefairy/categories/%E6%B5%8F%E8%A7%88%E5%99%A8/"/>
    
    
  </entry>
  
  <entry>
    <title>循环中的async与await处理</title>
    <link href="http://angellike_fairy.gitee.io/angellikefairy/2019/10/28/%E5%BE%AA%E7%8E%AF%E4%B8%AD%E7%9A%84async%E4%B8%8Eawait%E5%A4%84%E7%90%86/"/>
    <id>http://angellike_fairy.gitee.io/angellikefairy/2019/10/28/循环中的async与await处理/</id>
    <published>2019-10-28T10:18:25.000Z</published>
    <updated>2019-10-28T14:30:38.717Z</updated>
    
    <content type="html"><![CDATA[<h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p>之前在做项目的时候，遇到一个场景：</p><p>给定了一个数组类似于这样：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">    &#123;</span><br><span class="line">        hallId: <span class="number">1</span></span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">        hallId: <span class="number">2</span></span><br><span class="line">    &#125;,</span><br><span class="line">    ...</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>需求是这样的，我们需要遍历整个数组，获得每个对象中的hallId值，再通过该ID值请求某接口得到hallName，再将该hallName存入对象</p><p>结果类似于这样</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">    &#123;</span><br><span class="line">        hallId: <span class="number">1</span>,</span><br><span class="line">        hallName: <span class="string">'1号'</span></span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">        hallId: <span class="number">2</span>,</span><br><span class="line">        hallName: <span class="string">'2号'</span></span><br><span class="line">    &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>然后就遇到了循环中使用async和await遇到的一些问题，以下就是探究的过程</p><h2 id="前期准备"><a href="#前期准备" class="headerlink" title="前期准备"></a>前期准备</h2><p>我们首先准备要获取的数据</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> ha = [</span><br><span class="line">    &#123;</span><br><span class="line">        hallId: <span class="number">1</span></span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">        hallId: <span class="number">2</span></span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">        hallId: <span class="number">3</span></span><br><span class="line">    &#125;</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> hall = [</span><br><span class="line">    &#123;</span><br><span class="line">        hallId: <span class="number">1</span>,</span><br><span class="line">        hallName: <span class="string">'1号'</span></span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">        hallId: <span class="number">2</span>,</span><br><span class="line">        hallName: <span class="string">'2号'</span></span><br><span class="line">    &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">        hallId: <span class="number">3</span>,</span><br><span class="line">        hallName: <span class="string">'3号'</span></span><br><span class="line">    &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>以及使用setTimeout来模拟异步请求</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getHallName</span>(<span class="params">id</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve,reject</span>)=&gt;</span>&#123;</span><br><span class="line">        setTimeout(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">let</span> v of hall) &#123;</span><br><span class="line">                <span class="keyword">if</span>(v.hallId===id) &#123;</span><br><span class="line">                    resolve(v.hallName);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,<span class="number">1000</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="for循环中使用await"><a href="#for循环中使用await" class="headerlink" title="for循环中使用await"></a>for循环中使用await</h2><p>我们首先来看下在for循环中使用await</p><p>我们可以很自然地写出以下异步函数：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> v of ha) &#123;</span><br><span class="line">        <span class="keyword">let</span> value = <span class="keyword">await</span> getHallName(v.hallId);</span><br><span class="line">        <span class="built_in">console</span>.log(value);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">test();</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 执行结果</span></span><br><span class="line"><span class="comment">// 等待1000ms</span></span><br><span class="line"><span class="comment">1号</span></span><br><span class="line"><span class="comment">// 等待1000ms</span></span><br><span class="line"><span class="comment">2号</span></span><br><span class="line"><span class="comment">// 等待1000ms</span></span><br><span class="line"><span class="comment">3号</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h2 id="在forEach中使用await"><a href="#在forEach中使用await" class="headerlink" title="在forEach中使用await"></a>在forEach中使用await</h2><p>一开始的写的异步函数如下</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    ha.forEach(<span class="function"><span class="params">v</span>=&gt;</span>&#123;</span><br><span class="line">        <span class="keyword">let</span> value = <span class="keyword">await</span> getHallName(v.hallId);</span><br><span class="line">        <span class="built_in">console</span>.log(value);</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">test();</span><br></pre></td></tr></table></figure><p>但是当我们兴致冲冲去查看运行结果的时候却傻了眼，得到的输出结果却是如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SyntaxError: await is only valid in async function</span><br></pre></td></tr></table></figure><p>这时候，我们一拍脑袋，回想起来forEach() 方法是对数组的每个元素执行一次提供的函数。</p><p>现在，我又将函数修改为以下的形式</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    ha.forEach(<span class="keyword">async</span> v =&gt; &#123;</span><br><span class="line">        <span class="keyword">let</span> value = <span class="keyword">await</span> getHallName(v.hallId);</span><br><span class="line">        <span class="built_in">console</span>.log(value);</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">test();</span><br></pre></td></tr></table></figure><p>现在结果总该是正确的吧，但是，令人失望的是，结果还是错的</p><p>输出结果如下：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 输出结果</span></span><br><span class="line"><span class="comment">// 等待1000ms,然后直接输出下面的三项，而不是每一项之间间隔1000ms</span></span><br><span class="line"><span class="comment">1号</span></span><br><span class="line"><span class="comment">2号</span></span><br><span class="line"><span class="comment">3号</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>查阅资料后，才得到了一个结论</p><blockquote><p>JavaScript 中的 forEach不支持 promise 感知，也不支持 async 和await，所以不能在 forEach 使用 await 。</p></blockquote><h2 id="在map中使用await"><a href="#在map中使用await" class="headerlink" title="在map中使用await"></a>在map中使用await</h2><p>既然在forEach中无法使用await，那么map()方法呢？</p><p>这次我们有了forEach()的教训，</p><blockquote><p>map() 方法创建一个新数组，其结果是该数组中的每个元素都调用一个提供的函数后返回的结果。</p></blockquote><p>我们就记住了要让提供给map()方法的函数为异步函数</p><p>我们写出来以下的方法来进行试验：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    ha.map(<span class="keyword">async</span> v=&gt; &#123;</span><br><span class="line">        <span class="keyword">let</span> value = <span class="keyword">await</span> getHallName(v.hallId);</span><br><span class="line">        <span class="built_in">console</span>.log(value);</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">test();</span><br></pre></td></tr></table></figure><p>输出结果如下：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 输出结果</span></span><br><span class="line"><span class="comment">// 等待1000ms，然后直接一次性输出下列三个值</span></span><br><span class="line"><span class="comment">1号</span></span><br><span class="line"><span class="comment">2号</span></span><br><span class="line"><span class="comment">3号</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>我们查看一下mdn文档对于map()方法的说明：</p><blockquote><p>map 方法会给原数组中的每个元素都按顺序调用一次  callback 函数。callback 每次执行后的返回值（包括 undefined）组合起来形成一个新数组。</p></blockquote><p>也就是说，在不考虑返回数组的情况下，map()方法就可以表示为以下的形式</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">map1</span>(<span class="params">v</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> value = <span class="keyword">await</span> getHallName(v.hallId);</span><br><span class="line">    <span class="built_in">console</span>.log(value);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">map2</span>(<span class="params">v</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> value = <span class="keyword">await</span> getHallName(v.hallId);</span><br><span class="line">    <span class="built_in">console</span>.log(value);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">map3</span>(<span class="params">v</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> value = <span class="keyword">await</span> getHallName(v.hallId);</span><br><span class="line">    <span class="built_in">console</span>.log(value);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">map1(ha[<span class="number">0</span>]);</span><br><span class="line">map2(ha[<span class="number">1</span>]);</span><br><span class="line">map3(ha[<span class="number">2</span>]);</span><br></pre></td></tr></table></figure><p>我们首先注册了三个异步函数，然后并行调用了它们。因此，输出结果也就是如上述所述，等待一段时间后，然后按照任务队列中的顺序依次输出</p><p>那么，如果再考虑map()方法的特性，其可以将每次函数执行后的返回值组合起来形成一个新的数组。另外，我们又知道</p><blockquote><p>异步函数返回一个promise对象</p></blockquote><p>因此，使用map()方法就可以返回一个包含promise对象的数组</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[ <span class="built_in">Promise</span> &#123; &lt;pending&gt; &#125;, <span class="built_in">Promise</span> &#123; &lt;pending&gt; &#125;, <span class="built_in">Promise</span> &#123; &lt;pending&gt; &#125; ]</span><br></pre></td></tr></table></figure><p>因此，我们可以利用Promise.all()方法来进行后续的处理</p><p>现在，我们来重写之前的方法</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> promiseArr = ha.map(<span class="keyword">async</span> v =&gt; &#123;</span><br><span class="line">        <span class="keyword">let</span> value = <span class="keyword">await</span> getHallName(v.hallId);</span><br><span class="line">        <span class="keyword">return</span> value;</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    <span class="built_in">Promise</span>.all(promiseArr).then( <span class="function"><span class="params">v</span>=&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(v);</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">test();</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 输出结果</span></span><br><span class="line"><span class="comment">// 等待1000ms</span></span><br><span class="line"><span class="comment">[ '1号', '2号', '3号' ]</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>根据以上的分析，我们可以看到：<br>对于async和await来控制异步流程</p><ol><li>如果想要在循环中让异步任务串行（继发运行），那么使用for循环(包括for的一些列循环: for…of , for…in)</li><li>如果想要在循环中让异步任务并行，那么我们除了Promise.all()方法外，还可以使用map()方法来使异步任务并行</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;引言&quot;&gt;&lt;a href=&quot;#引言&quot; class=&quot;headerlink&quot; title=&quot;引言&quot;&gt;&lt;/a&gt;引言&lt;/h2&gt;&lt;p&gt;之前在做项目的时候，遇到一个场景：&lt;/p&gt;
&lt;p&gt;给定了一个数组类似于这样：&lt;/p&gt;
&lt;figure class=&quot;highlight ty
      
    
    </summary>
    
      <category term="ES6" scheme="http://angellike_fairy.gitee.io/angellikefairy/categories/ES6/"/>
    
    
  </entry>
  
</feed>
