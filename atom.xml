<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Hexo</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2019-07-27T09:45:44.292Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>Angel</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>leetcode-852 山脉数组的峰顶索引</title>
    <link href="http://yoursite.com/2019/07/27/leetcode-852/"/>
    <id>http://yoursite.com/2019/07/27/leetcode-852/</id>
    <published>2019-07-27T07:42:56.000Z</published>
    <updated>2019-07-27T09:45:44.292Z</updated>
    
    <content type="html"><![CDATA[<h1 id="山脉数组的峰顶索引"><a href="#山脉数组的峰顶索引" class="headerlink" title="山脉数组的峰顶索引"></a>山脉数组的峰顶索引</h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>我们把符合下列属性的数组 A 称作山脉：</p><ol><li>A.length &gt;= 3</li><li>存在 0 &lt; i &lt; A.length - 1 使得A[0] &lt; A[1] &lt; … A[i-1] &lt; A[i] &gt; A[i+1] &gt; … &gt; A[A.length - 1]</li></ol><p>给定一个确定为山脉的数组，返回任何满足 A[0] &lt; A[1] &lt; … A[i-1] &lt; A[i] &gt; A[i+1] &gt; … &gt; A[A.length - 1] 的 i 的值。</p><p>示例 1：</p><blockquote><p>输入：[0,1,0]<br>输出：1</p></blockquote><p>示例 2：</p><blockquote><p>输入：[0,2,1,0]<br>输出：1</p></blockquote><p>提示：</p><ol><li>3&lt;= A.length &lt;= 10000</li><li>0&lt;= A[i] &lt;= 10^6</li><li>A是如上定义的山脉<a id="more"></a>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/peak-index-in-a-mountain-array" target="_blank" rel="noopener">https://leetcode-cn.com/problems/peak-index-in-a-mountain-array</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</li></ol><h2 id="核心思路"><a href="#核心思路" class="headerlink" title="核心思路"></a>核心思路</h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>要找某个特定的值，都可以使用二分查找来提高效率</p><h3 id="解题步骤"><a href="#解题步骤" class="headerlink" title="解题步骤"></a>解题步骤</h3><ol><li>二分法查找山脉的下标</li><li>一开始设定left为0，right为A.length-1,mid为Math.floor((left+right)/2)</li><li>如果A[mid]&gt;A[mid+1]&amp;&amp;A[mid]&gt;A[mid-1],那么此时mid就是山脉的下标</li><li>如果A[mid]&lt;A[mid+1]，那么就说明山脉应该在mid的右边区间，故left=mid+1</li><li>如果A[mid]&gt;A[mid+1]，那么就说明山脉应该在mid的右边区间，故right=mid-1</li></ol><h2 id="Coding实现"><a href="#Coding实现" class="headerlink" title="Coding实现"></a>Coding实现</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @param &#123;number[]&#125; A</span></span><br><span class="line"><span class="comment"> * @return &#123;number&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> peakIndexInMountainArray = <span class="function"><span class="keyword">function</span>(<span class="params">A</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> left=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">let</span> right=A.length<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">while</span>(left&lt;=right)&#123;</span><br><span class="line">        <span class="keyword">let</span> mid=<span class="built_in">Math</span>.floor((left+right)/<span class="number">2</span>);</span><br><span class="line">        <span class="keyword">if</span>(A[mid]&gt;A[mid+<span class="number">1</span>]&amp;&amp;A[mid]&gt;A[mid<span class="number">-1</span>])&#123;</span><br><span class="line">            <span class="keyword">return</span> mid;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(A[mid]&lt;A[mid+<span class="number">1</span>])&#123;</span><br><span class="line">            left=mid+<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            right=mid<span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h3><p>时间复杂度为O(log2N);</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;山脉数组的峰顶索引&quot;&gt;&lt;a href=&quot;#山脉数组的峰顶索引&quot; class=&quot;headerlink&quot; title=&quot;山脉数组的峰顶索引&quot;&gt;&lt;/a&gt;山脉数组的峰顶索引&lt;/h1&gt;&lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h2&gt;&lt;p&gt;我们把符合下列属性的数组 A 称作山脉：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;A.length &amp;gt;= 3&lt;/li&gt;
&lt;li&gt;存在 0 &amp;lt; i &amp;lt; A.length - 1 使得A[0] &amp;lt; A[1] &amp;lt; … A[i-1] &amp;lt; A[i] &amp;gt; A[i+1] &amp;gt; … &amp;gt; A[A.length - 1]&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;给定一个确定为山脉的数组，返回任何满足 A[0] &amp;lt; A[1] &amp;lt; … A[i-1] &amp;lt; A[i] &amp;gt; A[i+1] &amp;gt; … &amp;gt; A[A.length - 1] 的 i 的值。&lt;/p&gt;
&lt;p&gt;示例 1：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;输入：[0,1,0]&lt;br&gt;输出：1&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;示例 2：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;输入：[0,2,1,0]&lt;br&gt;输出：1&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;提示：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;3&amp;lt;= A.length &amp;lt;= 10000&lt;/li&gt;
&lt;li&gt;0&amp;lt;= A[i] &amp;lt;= 10^6&lt;/li&gt;
&lt;li&gt;A是如上定义的山脉
    
    </summary>
    
      <category term="leetcode题解与算法" scheme="http://yoursite.com/categories/leetcode%E9%A2%98%E8%A7%A3%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="二分查找" scheme="http://yoursite.com/tags/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/"/>
    
  </entry>
  
  <entry>
    <title>leetcode-944 删列造序</title>
    <link href="http://yoursite.com/2019/07/26/leetcode-944/"/>
    <id>http://yoursite.com/2019/07/26/leetcode-944/</id>
    <published>2019-07-26T02:55:29.000Z</published>
    <updated>2019-07-26T03:05:06.927Z</updated>
    
    <content type="html"><![CDATA[<h1 id="删列造序"><a href="#删列造序" class="headerlink" title="删列造序"></a>删列造序</h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>给定由 N 个小写字母字符串组成的数组 A，其中每个字符串长度相等。</p><p>删除 操作的定义是：选出一组要删掉的列，删去 A 中对应列中的所有字符，形式上，第 n 列为 [A[0][n], A[1][n], …, A[A.length-1][n]]）。</p><p>比如，有 A = [“abcdef”, “uvwxyz”]，</p><p><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2019/07/06/944_1.png" alt></p><p>要删掉的列为 {0, 2, 3}，删除后 A 为[“bef”, “vyz”]， A 的列分别为[“b”,”v”], [“e”,”y”], [“f”,”z”]。</p><p><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2019/07/06/944_2.png" alt></p><p>你需要选出一组要删掉的列 D，对 A 执行删除操作，使 A 中剩余的每一列都是 非降序 排列的，然后请你返回 D.length 的最小可能值。</p><p>示例 1：</p><blockquote><p>输入：[“cba”, “daf”, “ghi”]<br>输出：1<br>解释：<br>当选择 D = {1}，删除后 A 的列为：[“c”,”d”,”g”] 和 [“a”,”f”,”i”]，均为非降序排列。<br>若选择 D = {}，那么 A 的列 [“b”,”a”,”h”] 就不是非降序排列了。</p></blockquote><p>示例 2：</p><blockquote><p>输入：[“a”, “b”]<br>输出：0<br>解释：D = {}</p></blockquote><p>示例 3：</p><blockquote><p>输入：[“zyx”, “wvu”, “tsr”]<br>输出：3<br>解释：D = {0, 1, 2}</p></blockquote><p>提示：</p><ol><li>1&lt;= A.length &lt;= 100</li><li>1&lt;= A[i].length &lt;= 1000<a id="more"></a>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/delete-columns-to-make-sorted" target="_blank" rel="noopener">https://leetcode-cn.com/problems/delete-columns-to-make-sorted</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</li></ol><h2 id="核心思路"><a href="#核心思路" class="headerlink" title="核心思路"></a>核心思路</h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>题目要求得到删去列数的最小值来使剩余的每一列都是非降序的，那么对于贪心思想，只要找到某些列存在降序的删除即可，而无需删除那些已经是非降序的列</p><h3 id="解题步骤"><a href="#解题步骤" class="headerlink" title="解题步骤"></a>解题步骤</h3><ol><li>根据数组第一个字符串元素长度来确认列数</li><li>根据列数，遍历每一个字符串中的那一列</li><li>如果某一列存在降序则将ans加1</li><li>返回ans</li></ol><h2 id="Coding实现"><a href="#Coding实现" class="headerlink" title="Coding实现"></a>Coding实现</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @param &#123;string[]&#125; A</span></span><br><span class="line"><span class="comment"> * @return &#123;number&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> minDeletionSize = <span class="function"><span class="keyword">function</span>(<span class="params">A</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> ans=<span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">0</span>;i&lt;A[<span class="number">0</span>].length;i++)&#123;</span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">let</span> k=<span class="number">0</span>;k&lt;A.length<span class="number">-1</span>;k++)&#123;</span><br><span class="line">          <span class="keyword">if</span>(A[k+<span class="number">1</span>][i].charCodeAt()-A[k][i].charCodeAt()&lt;<span class="number">0</span>)&#123;</span><br><span class="line">              ans++;</span><br><span class="line">              <span class="keyword">break</span>;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;  </span><br><span class="line">    <span class="keyword">return</span> ans; </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;删列造序&quot;&gt;&lt;a href=&quot;#删列造序&quot; class=&quot;headerlink&quot; title=&quot;删列造序&quot;&gt;&lt;/a&gt;删列造序&lt;/h1&gt;&lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h2&gt;&lt;p&gt;给定由 N 个小写字母字符串组成的数组 A，其中每个字符串长度相等。&lt;/p&gt;
&lt;p&gt;删除 操作的定义是：选出一组要删掉的列，删去 A 中对应列中的所有字符，形式上，第 n 列为 [A[0][n], A[1][n], …, A[A.length-1][n]]）。&lt;/p&gt;
&lt;p&gt;比如，有 A = [“abcdef”, “uvwxyz”]，&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2019/07/06/944_1.png&quot; alt&gt;&lt;/p&gt;
&lt;p&gt;要删掉的列为 {0, 2, 3}，删除后 A 为[“bef”, “vyz”]， A 的列分别为[“b”,”v”], [“e”,”y”], [“f”,”z”]。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2019/07/06/944_2.png&quot; alt&gt;&lt;/p&gt;
&lt;p&gt;你需要选出一组要删掉的列 D，对 A 执行删除操作，使 A 中剩余的每一列都是 非降序 排列的，然后请你返回 D.length 的最小可能值。&lt;/p&gt;
&lt;p&gt;示例 1：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;输入：[“cba”, “daf”, “ghi”]&lt;br&gt;输出：1&lt;br&gt;解释：&lt;br&gt;当选择 D = {1}，删除后 A 的列为：[“c”,”d”,”g”] 和 [“a”,”f”,”i”]，均为非降序排列。&lt;br&gt;若选择 D = {}，那么 A 的列 [“b”,”a”,”h”] 就不是非降序排列了。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;示例 2：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;输入：[“a”, “b”]&lt;br&gt;输出：0&lt;br&gt;解释：D = {}&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;示例 3：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;输入：[“zyx”, “wvu”, “tsr”]&lt;br&gt;输出：3&lt;br&gt;解释：D = {0, 1, 2}&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;提示：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;1&amp;lt;= A.length &amp;lt;= 100&lt;/li&gt;
&lt;li&gt;1&amp;lt;= A[i].length &amp;lt;= 1000
    
    </summary>
    
      <category term="leetcode题解与算法" scheme="http://yoursite.com/categories/leetcode%E9%A2%98%E8%A7%A3%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="贪心" scheme="http://yoursite.com/tags/%E8%B4%AA%E5%BF%83/"/>
    
  </entry>
  
  <entry>
    <title>贪心</title>
    <link href="http://yoursite.com/2019/07/26/%E8%B4%AA%E5%BF%83/"/>
    <id>http://yoursite.com/2019/07/26/贪心/</id>
    <published>2019-07-26T01:34:08.000Z</published>
    <updated>2019-07-26T02:54:43.732Z</updated>
    
    <content type="html"><![CDATA[<p>##简单贪心</p><blockquote><p>贪心法是求解一类最优化问题的方法，它总是考虑在当前状态下局部最优（或较优）的策略，来使全局的结果达到最优（或较优）</p></blockquote><p>简单来说，也就是，在对问题求解时，总是做出在当前看来是最好的选择。</p><h3 id="贪心算法的基本思路"><a href="#贪心算法的基本思路" class="headerlink" title="贪心算法的基本思路"></a>贪心算法的基本思路</h3><ol><li>将求解的问题分成若干子问题</li><li>对于每一个子问题，考虑得到该子问题的局部最优解</li><li>把所有子问题的局部最优解合成一个原问题的解</li></ol><h3 id="贪心算法的适用前提和问题"><a href="#贪心算法的适用前提和问题" class="headerlink" title="贪心算法的适用前提和问题"></a>贪心算法的适用前提和问题</h3><ol><li>局部最优解能够影响全局最优解</li><li>贪心算法得到的不一定就是问题的最优解</li></ol><h3 id="贪心算法题目"><a href="#贪心算法题目" class="headerlink" title="贪心算法题目"></a>贪心算法题目</h3><p>设有n个正整数，将它们连接成一排，组成一个最大的多位整数。</p><p>例如：n=3时，3个整数13，312，343，连成的最大整数为34331213。<br><br>又如：n=4时，4个整数7，13，4，246，连成的最大整数为7424613。</p><blockquote><p>输入：n<br><br>N个数<br><br>输出：连成的多位数</p></blockquote><h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><p>因为要得到最大的正整数，那么高位数据越大则值越大。因此，使用贪心算法，每次选值的时候优先选择最高位最大的，如若相同，则比较次高位，直到选出较优值</p><p>因此，通过这个思路，比较高位可以利用字符串UniCode码来比较，比如’7’&gt;’432’</p><p>js的sort()函数可以完美解决，利用sort函数对输入值由高到低进行排序，最后转化为数值进行返回</p><h4 id="Coding实现"><a href="#Coding实现" class="headerlink" title="Coding实现"></a>Coding实现</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">F</span>(<span class="params">n</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">parseInt</span>(n.sort().reverse().join(<span class="string">''</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="区间贪心"><a href="#区间贪心" class="headerlink" title="区间贪心"></a>区间贪心</h2>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;##简单贪心&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;贪心法是求解一类最优化问题的方法，它总是考虑在当前状态下局部最优（或较优）的策略，来使全局的结果达到最优（或较优）&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;简单来说，也就是，在对问题求解时，总是做出在当前看来是最好的选
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>排序</title>
    <link href="http://yoursite.com/2019/07/25/%E6%8E%92%E5%BA%8F/"/>
    <id>http://yoursite.com/2019/07/25/排序/</id>
    <published>2019-07-25T01:27:08.000Z</published>
    <updated>2019-07-25T06:39:51.926Z</updated>
    
    <content type="html"><![CDATA[<h2 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>选择排列是指，对一个序列A中的元素，令i从0到n-1枚举，进行n趟操作，每趟从待排序部分（i+1,n）中选择最小的元素，令其与待排序部分的第一个元素A[i]进行交换，这样在n趟操作后，所有元素都会是有序的</p><h3 id="动图演示"><a href="#动图演示" class="headerlink" title="动图演示"></a>动图演示</h3><p><img src="https://lc-api-gold-cdn.xitu.io/9c3e16e6e5d0a5ac7721?imageView2/0/w/1280/h/960/ignore-error/1" alt></p><h3 id="Coding实现"><a href="#Coding实现" class="headerlink" title="Coding实现"></a>Coding实现</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">selectSort</span>(<span class="params">n</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">0</span>;i&lt;n.length<span class="number">-1</span>;i++)&#123;</span><br><span class="line">    <span class="keyword">let</span> min=i;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> k=i;k&lt;n.length;k++)&#123;</span><br><span class="line">      <span class="keyword">if</span>(n[k]&lt;n[min])&#123;</span><br><span class="line">       min=k;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">let</span> temp=n[min];</span><br><span class="line">    n[min]=n[i];</span><br><span class="line">    n[i]=temp;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> n;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h2><h3 id="直接插入排序"><a href="#直接插入排序" class="headerlink" title="直接插入排序"></a>直接插入排序</h3><h4 id="定义-1"><a href="#定义-1" class="headerlink" title="定义"></a>定义</h4><p>直接插入排序是指，对序列A的n个元素A[0]到A[n-1],令n从1到n-1枚举，进行n-1趟操作。每一趟排序时，该待排列元素之前的所有元素已经是有序的，则在该有序队列中寻找一个位置进行插入，使得该序列依旧有序</p><h4 id="动图演示-1"><a href="#动图演示-1" class="headerlink" title="动图演示"></a>动图演示</h4><p><img src="https://lc-api-gold-cdn.xitu.io/9a1264832cad9bfd4100?imageView2/0/w/1280/h/960/ignore-error/1" alt></p><h4 id="Coding实现-1"><a href="#Coding实现-1" class="headerlink" title="Coding实现"></a>Coding实现</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">insertionSort</span>(<span class="params">n</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">1</span>;i&lt;n.length;i++)&#123;</span><br><span class="line">    <span class="keyword">let</span> num=n[i];</span><br><span class="line">    <span class="keyword">while</span>(num&lt;n[i<span class="number">-1</span>])&#123;</span><br><span class="line">      n[i]=n[i<span class="number">-1</span>];</span><br><span class="line">      i--;</span><br><span class="line">    &#125;</span><br><span class="line">    n[i]=num;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> n;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="折半插入排序"><a href="#折半插入排序" class="headerlink" title="折半插入排序"></a>折半插入排序</h3><h4 id="定义-2"><a href="#定义-2" class="headerlink" title="定义"></a>定义</h4><blockquote><p>有一组数据待排序，排序区间为Array[0] ~ Array[n-1]。将数据分为有序数据和无序数据，第一次排序时默认Array[0]为有序数据，Array[1]~Array[n-1]为无序数据。有序数据分区的第一个元素位置为low，最后一个元素的位置为high。</p></blockquote><blockquote><p>遍历无序区间的所有元素，每次取无序区间的第一个元素Array[i]，因为0 ~ i-1是有序排列的，所以用中点m将其平分为两部分，然后将待排序数据同中间位置为m的数据进行比较，若待排序数据较大，则low ~ m-1分区的数据都比待排序数据小，反之，若待排序数据较小，则m+1 ~ high分区的数据都比 待排序数据大，此时将low或high重新定义为新的合适分区的边界，对新的小分区重复上面操作。直到low和high 的前后顺序改变，此时high+1所处位置为待排序数据的合适位置。</p></blockquote><hr><p>作者：weixin_42245157<br>来源：CSDN<br>原文：<a href="https://blog.csdn.net/weixin_42245157/article/details/80458542" target="_blank" rel="noopener">https://blog.csdn.net/weixin_42245157/article/details/80458542</a><br>版权声明：本文为博主原创文章，转载请附上博文链接！</p><h3 id="Coding实现-2"><a href="#Coding实现-2" class="headerlink" title="Coding实现"></a>Coding实现</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">BinaryInsertSortup</span>(<span class="params">n</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">1</span>;i&lt;n.length;i++)&#123;</span><br><span class="line">    <span class="keyword">let</span> low=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">let</span> high=i<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">let</span> num=n[i];</span><br><span class="line">    <span class="keyword">while</span>(low&lt;=high)&#123;</span><br><span class="line">      <span class="keyword">let</span> mid=<span class="built_in">Math</span>.floor((low+high)/<span class="number">2</span>);</span><br><span class="line">      <span class="keyword">if</span>(num&lt;n[mid])&#123;</span><br><span class="line">        high=mid<span class="number">-1</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span>&#123;</span><br><span class="line">        low=mid+<span class="number">1</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(k=i;k&gt;low;k--)&#123;</span><br><span class="line">        n[k]=n[k<span class="number">-1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    n[k]=num;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> n;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h2><h3 id="定义-3"><a href="#定义-3" class="headerlink" title="定义"></a>定义</h3><p>冒泡排序旨在每次冒泡一个最大或最小的元素到顶端，因此需遍历n次。（若冒泡较大元素）则每次遍历，比较相邻两个元素大小，若底部元素（数组下标较小）大于其相邻顶部元素，则两元素交换位置，直至最大的元素冒泡到最顶端</p><h3 id="动图演示-2"><a href="#动图演示-2" class="headerlink" title="动图演示"></a>动图演示</h3><p><img src="https://lc-api-gold-cdn.xitu.io/ffef8bdf5a3b0dd54859?imageView2/0/w/1280/h/960/ignore-error/1" alt></p><h3 id="Coding实现-3"><a href="#Coding实现-3" class="headerlink" title="Coding实现"></a>Coding实现</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bubbleSort</span>(<span class="params">n</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">let</span> flag;</span><br><span class="line">  <span class="keyword">do</span>&#123;</span><br><span class="line">    flag=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">0</span>;i&lt;n.length;i++)&#123;</span><br><span class="line">      <span class="keyword">let</span> temp;</span><br><span class="line">      <span class="keyword">if</span>(n[i]&gt;n[i+<span class="number">1</span>])&#123;</span><br><span class="line">        temp=n[i];</span><br><span class="line">        n[i]=n[i+<span class="number">1</span>];</span><br><span class="line">        n[i+<span class="number">1</span>]=temp;</span><br><span class="line">        flag=<span class="number">1</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;<span class="keyword">while</span>(flag===<span class="number">1</span>)</span><br><span class="line">  <span class="keyword">return</span> n;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;选择排序&quot;&gt;&lt;a href=&quot;#选择排序&quot; class=&quot;headerlink&quot; title=&quot;选择排序&quot;&gt;&lt;/a&gt;选择排序&lt;/h2&gt;&lt;h3 id=&quot;定义&quot;&gt;&lt;a href=&quot;#定义&quot; class=&quot;headerlink&quot; title=&quot;定义&quot;&gt;&lt;/a&gt;定义&lt;/h
      
    
    </summary>
    
      <category term="算法笔记" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/"/>
    
    
  </entry>
  
  <entry>
    <title>leetcode-1002 查找常用字符</title>
    <link href="http://yoursite.com/2019/07/24/leetcode-1002/"/>
    <id>http://yoursite.com/2019/07/24/leetcode-1002/</id>
    <published>2019-07-24T06:51:44.000Z</published>
    <updated>2019-07-24T07:05:22.438Z</updated>
    
    <content type="html"><![CDATA[<h1 id="查找常用字符"><a href="#查找常用字符" class="headerlink" title="查找常用字符"></a>查找常用字符</h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>给定仅有小写字母组成的字符串数组 A，返回列表中的每个字符串中都显示的全部字符（包括重复字符）组成的列表。例如，如果一个字符在每个字符串中出现 3 次，但不是 4 次，则需要在最终答案中包含该字符 3 次。</p><p>你可以按任意顺序返回答案。</p><p>示例 1：</p><blockquote><p>输入：[“bella”,”label”,”roller”]<br>输出：[“e”,”l”,”l”]</p></blockquote><p>示例 2：</p><blockquote><p>输入：[“cool”,”lock”,”cook”]<br>输出：[“c”,”o”]</p></blockquote><p>提示：</p><ol><li>1&lt;= A.length &lt;= 100</li><li>1&lt;= A[i].length &lt;= 100</li><li>A[i][j] 是小写字母<a id="more"></a>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/find-common-characters" target="_blank" rel="noopener">https://leetcode-cn.com/problems/find-common-characters</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</li></ol><h2 id="核心思路"><a href="#核心思路" class="headerlink" title="核心思路"></a>核心思路</h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>统计每个字符串中字符的出现个数，返回出现相同字符的最少个数字符</p><h3 id="解题步骤"><a href="#解题步骤" class="headerlink" title="解题步骤"></a>解题步骤</h3><ol><li>建立哈希表A，存储第一个字符串个字符的出现次数</li><li>遍历后面的字符串，在每个循环中建立新的哈希表，存储该字符串中第一个字符串所有字符的个数；比较新哈希表与步骤1建立的哈希表A，更新A哈希表中的键值为两者较小值</li><li>遍历A哈希表，存储value次key到ans数组并返回</li></ol><h2 id="Coding实现"><a href="#Coding实现" class="headerlink" title="Coding实现"></a>Coding实现</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @param &#123;string[]&#125; A</span></span><br><span class="line"><span class="comment"> * @return &#123;string[]&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> commonChars = <span class="function"><span class="keyword">function</span>(<span class="params">A</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> map=<span class="keyword">new</span> <span class="built_in">Map</span>();</span><br><span class="line">    <span class="keyword">let</span> ans=[];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">0</span>;i&lt;A[<span class="number">0</span>].length;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(!map.has(A[<span class="number">0</span>][i]))&#123;</span><br><span class="line">            map.set(A[<span class="number">0</span>][i],<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            map.set(A[<span class="number">0</span>][i],map.get(A[<span class="number">0</span>][i])+<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">1</span>;i&lt;A.length;i++)&#123;</span><br><span class="line">        <span class="keyword">let</span> mapEve=<span class="keyword">new</span> <span class="built_in">Map</span>();</span><br><span class="line">        map.forEach(<span class="function">(<span class="params">value,key</span>)=&gt;</span>&#123;</span><br><span class="line">            mapEve.set(key,<span class="number">0</span>);</span><br><span class="line">        &#125;)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">let</span> k=<span class="number">0</span>;k&lt;A[i].length;k++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(map.has(A[i][k]))&#123;</span><br><span class="line">                 mapEve.set(A[i][k],mapEve.get(A[i][k])+<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        map.forEach(<span class="function">(<span class="params">value,key</span>)=&gt;</span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(value&gt;mapEve.get(key))&#123;</span><br><span class="line">                map.set(key,mapEve.get(key));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">    map.forEach(<span class="function">(<span class="params">value,key</span>)=&gt;</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(value&gt;<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">0</span>;i&lt;value;i++)&#123;</span><br><span class="line">                ans.push(key);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;查找常用字符&quot;&gt;&lt;a href=&quot;#查找常用字符&quot; class=&quot;headerlink&quot; title=&quot;查找常用字符&quot;&gt;&lt;/a&gt;查找常用字符&lt;/h1&gt;&lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h2&gt;&lt;p&gt;给定仅有小写字母组成的字符串数组 A，返回列表中的每个字符串中都显示的全部字符（包括重复字符）组成的列表。例如，如果一个字符在每个字符串中出现 3 次，但不是 4 次，则需要在最终答案中包含该字符 3 次。&lt;/p&gt;
&lt;p&gt;你可以按任意顺序返回答案。&lt;/p&gt;
&lt;p&gt;示例 1：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;输入：[“bella”,”label”,”roller”]&lt;br&gt;输出：[“e”,”l”,”l”]&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;示例 2：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;输入：[“cool”,”lock”,”cook”]&lt;br&gt;输出：[“c”,”o”]&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;提示：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;1&amp;lt;= A.length &amp;lt;= 100&lt;/li&gt;
&lt;li&gt;1&amp;lt;= A[i].length &amp;lt;= 100&lt;/li&gt;
&lt;li&gt;A[i][j] 是小写字母
    
    </summary>
    
      <category term="leetcode题解与算法" scheme="http://yoursite.com/categories/leetcode%E9%A2%98%E8%A7%A3%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="哈希表" scheme="http://yoursite.com/tags/%E5%93%88%E5%B8%8C%E8%A1%A8/"/>
    
  </entry>
  
  <entry>
    <title>递归与分治</title>
    <link href="http://yoursite.com/2019/07/24/%E9%80%92%E5%BD%92%E4%B8%8E%E5%88%86%E6%B2%BB/"/>
    <id>http://yoursite.com/2019/07/24/递归与分治/</id>
    <published>2019-07-24T01:04:47.000Z</published>
    <updated>2019-07-24T01:18:43.131Z</updated>
    
    <content type="html"><![CDATA[<h1 id="分治"><a href="#分治" class="headerlink" title="分治"></a>分治</h1><p>分治的全称为“分而治之”。分治法将原问题划分为若干个规模较小而结构与原问题相同或类似的子问题，然后分别解决这些子问题，最后合并子问题的解，即可得到原问题的解</p><h2 id="减治、分治"><a href="#减治、分治" class="headerlink" title="减治、分治"></a>减治、分治</h2><ol><li><p>一般把子问题个数为1的情况称为减治（例如对n!的求解）</p> <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">F</span>(<span class="params">n</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(n===<span class="number">1</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> F(n<span class="number">-1</span>)*n;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>子问题个数大于1的情况称为分治（例如对Fibonacci数列的求解）</p> <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">F</span>(<span class="params">n</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(n===<span class="number">1</span>||n===<span class="number">0</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> F(n<span class="number">-1</span>)+F(n<span class="number">-2</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h1 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h1><blockquote><p>递归适合用来实现分治思想</p></blockquote><h2 id="递归的两个核心概念"><a href="#递归的两个核心概念" class="headerlink" title="递归的两个核心概念"></a>递归的两个核心概念</h2><ol><li>递归边界</li><li>递归式（递归调用）</li></ol><p>对于n!的求解，可以很容易的到F(n)=F(n-1)*n ;这就是递归式<br>而F(1)=1; 这是递归的边界</p><h1 id="分治思想的应用"><a href="#分治思想的应用" class="headerlink" title="分治思想的应用"></a>分治思想的应用</h1><h2 id="全排列"><a href="#全排列" class="headerlink" title="全排列"></a>全排列</h2><h2 id="n皇后问题"><a href="#n皇后问题" class="headerlink" title="n皇后问题"></a>n皇后问题</h2>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;分治&quot;&gt;&lt;a href=&quot;#分治&quot; class=&quot;headerlink&quot; title=&quot;分治&quot;&gt;&lt;/a&gt;分治&lt;/h1&gt;&lt;p&gt;分治的全称为“分而治之”。分治法将原问题划分为若干个规模较小而结构与原问题相同或类似的子问题，然后分别解决这些子问题，最后合并子问题的解，即
      
    
    </summary>
    
      <category term="算法笔记" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/"/>
    
    
  </entry>
  
  <entry>
    <title>leetcode-349 两个数组的交集</title>
    <link href="http://yoursite.com/2019/07/23/leetcode-349/"/>
    <id>http://yoursite.com/2019/07/23/leetcode-349/</id>
    <published>2019-07-23T03:14:11.000Z</published>
    <updated>2019-07-23T03:19:44.629Z</updated>
    
    <content type="html"><![CDATA[<h1 id="两个数组的交集"><a href="#两个数组的交集" class="headerlink" title="两个数组的交集"></a>两个数组的交集</h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>给定两个数组，编写一个函数来计算它们的交集。</p><p>示例 1:</p><blockquote><p>输入: nums1 = [1,2,2,1], nums2 = [2,2]<br>输出: [2]</p></blockquote><p>示例 2:</p><blockquote><p>输入: nums1 = [4,9,5], nums2 = [9,4,9,8,4]<br>输出: [9,4]</p></blockquote><p>说明:</p><p>输出结果中的每个元素一定是唯一的。<br>我们可以不考虑输出结果的顺序。</p><a id="more"></a><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/intersection-of-two-arrays" target="_blank" rel="noopener">https://leetcode-cn.com/problems/intersection-of-two-arrays</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p><h2 id="核心思路"><a href="#核心思路" class="headerlink" title="核心思路"></a>核心思路</h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>将两个数组都去重后，比较另一个数组是否包含这个数组的某些元素，返回即可</p><h3 id="解题步骤"><a href="#解题步骤" class="headerlink" title="解题步骤"></a>解题步骤</h3><ol><li>使用set将两个数组去重</li><li>比较去重后的两个数组的大小，遍历较小的那个数组，查看另一个数组是否includes这个数组中的某些元素，有则添加到ans数组返回</li></ol><h2 id="Coding实现"><a href="#Coding实现" class="headerlink" title="Coding实现"></a>Coding实现</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @param &#123;number[]&#125; nums1</span></span><br><span class="line"><span class="comment"> * @param &#123;number[]&#125; nums2</span></span><br><span class="line"><span class="comment"> * @return &#123;number[]&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> intersection = <span class="function"><span class="keyword">function</span>(<span class="params">nums1, nums2</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> ans=[];</span><br><span class="line">    nums1=[...new <span class="built_in">Set</span>(nums1)];</span><br><span class="line">    nums2=[...new <span class="built_in">Set</span>(nums2)];</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">inter</span>(<span class="params">nums1,nums2</span>)</span>&#123;</span><br><span class="line">        nums1.forEach(<span class="function"><span class="params">value</span>=&gt;</span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums2.includes(value))&#123;</span><br><span class="line">                ans.push(value);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">    nums1.length&gt;nums2.length?inter(nums2,nums1):inter(nums1,nums2);</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;两个数组的交集&quot;&gt;&lt;a href=&quot;#两个数组的交集&quot; class=&quot;headerlink&quot; title=&quot;两个数组的交集&quot;&gt;&lt;/a&gt;两个数组的交集&lt;/h1&gt;&lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h2&gt;&lt;p&gt;给定两个数组，编写一个函数来计算它们的交集。&lt;/p&gt;
&lt;p&gt;示例 1:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;输入: nums1 = [1,2,2,1], nums2 = [2,2]&lt;br&gt;输出: [2]&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;示例 2:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;输入: nums1 = [4,9,5], nums2 = [9,4,9,8,4]&lt;br&gt;输出: [9,4]&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;说明:&lt;/p&gt;
&lt;p&gt;输出结果中的每个元素一定是唯一的。&lt;br&gt;我们可以不考虑输出结果的顺序。&lt;/p&gt;
    
    </summary>
    
      <category term="leetcode题解与算法" scheme="http://yoursite.com/categories/leetcode%E9%A2%98%E8%A7%A3%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="数组" scheme="http://yoursite.com/tags/%E6%95%B0%E7%BB%84/"/>
    
  </entry>
  
  <entry>
    <title>leetcode-961 重复 N 次的元素</title>
    <link href="http://yoursite.com/2019/07/23/leetcode-961/"/>
    <id>http://yoursite.com/2019/07/23/leetcode-961/</id>
    <published>2019-07-23T02:48:57.000Z</published>
    <updated>2019-07-23T02:54:24.612Z</updated>
    
    <content type="html"><![CDATA[<h1 id="重复-N-次的元素"><a href="#重复-N-次的元素" class="headerlink" title="重复 N 次的元素"></a>重复 N 次的元素</h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>在大小为 2N 的数组 A 中有 N+1 个不同的元素，其中有一个元素重复了 N 次。</p><p>返回重复了 N 次的那个元素。</p><p>示例 1：</p><blockquote><p>输入：[1,2,3,3]<br>输出：3</p></blockquote><p>示例 2：</p><blockquote><p>输入：[2,1,2,5,3,2]<br>输出：2</p></blockquote><p>示例 3：</p><blockquote><p>输入：[5,1,5,2,5,3,5,4]<br>输出：5</p></blockquote><p>提示：</p><p>4 &lt;= A.length &lt;= 10000<br>0 &lt;= A[i] &lt; 10000<br>A.length 为偶数</p><a id="more"></a><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/n-repeated-element-in-size-2n-array" target="_blank" rel="noopener">https://leetcode-cn.com/problems/n-repeated-element-in-size-2n-array</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p><h2 id="核心思路"><a href="#核心思路" class="headerlink" title="核心思路"></a>核心思路</h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>因为该数组大小为2N，其中由N+1个不同的元素，并且有一个元素重复了N次，那么剩余的N个数都是不同的</p><p>所以题目可转化为返回有重复的那个数</p><h3 id="解题步骤"><a href="#解题步骤" class="headerlink" title="解题步骤"></a>解题步骤</h3><ol><li>建立哈希表</li><li>遍历给定数组，若哈希表中没有该键名，则加入哈希表；若有，则直接返回该数组元素</li></ol><h2 id="Coding实现"><a href="#Coding实现" class="headerlink" title="Coding实现"></a>Coding实现</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @param &#123;number[]&#125; A</span></span><br><span class="line"><span class="comment"> * @return &#123;number&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> repeatedNTimes = <span class="function"><span class="keyword">function</span>(<span class="params">A</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> map=<span class="keyword">new</span> <span class="built_in">Map</span>();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">0</span>;i&lt;A.length;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(!map.has(A[i]))&#123;</span><br><span class="line">            map.set(A[i],<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> A[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;重复-N-次的元素&quot;&gt;&lt;a href=&quot;#重复-N-次的元素&quot; class=&quot;headerlink&quot; title=&quot;重复 N 次的元素&quot;&gt;&lt;/a&gt;重复 N 次的元素&lt;/h1&gt;&lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h2&gt;&lt;p&gt;在大小为 2N 的数组 A 中有 N+1 个不同的元素，其中有一个元素重复了 N 次。&lt;/p&gt;
&lt;p&gt;返回重复了 N 次的那个元素。&lt;/p&gt;
&lt;p&gt;示例 1：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;输入：[1,2,3,3]&lt;br&gt;输出：3&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;示例 2：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;输入：[2,1,2,5,3,2]&lt;br&gt;输出：2&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;示例 3：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;输入：[5,1,5,2,5,3,5,4]&lt;br&gt;输出：5&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;提示：&lt;/p&gt;
&lt;p&gt;4 &amp;lt;= A.length &amp;lt;= 10000&lt;br&gt;0 &amp;lt;= A[i] &amp;lt; 10000&lt;br&gt;A.length 为偶数&lt;/p&gt;
    
    </summary>
    
      <category term="leetcode题解与算法" scheme="http://yoursite.com/categories/leetcode%E9%A2%98%E8%A7%A3%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="哈希表" scheme="http://yoursite.com/tags/%E5%93%88%E5%B8%8C%E8%A1%A8/"/>
    
  </entry>
  
  <entry>
    <title>leetcode-500 键盘行</title>
    <link href="http://yoursite.com/2019/07/23/leetcode-500/"/>
    <id>http://yoursite.com/2019/07/23/leetcode-500/</id>
    <published>2019-07-23T02:11:14.000Z</published>
    <updated>2019-07-23T02:26:49.127Z</updated>
    
    <content type="html"><![CDATA[<h1 id="键盘行"><a href="#键盘行" class="headerlink" title="键盘行"></a>键盘行</h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p> 给定一个单词列表，只返回可以使用在键盘同一行的字母打印出来的单词。键盘如下图所示。</p><p><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/10/12/keyboard.png" alt></p><p>示例：</p><blockquote><p>输入: [“Hello”, “Alaska”, “Dad”, “Peace”]<br>输出: [“Alaska”, “Dad”]</p></blockquote><p>注意：</p><p>你可以重复使用键盘上同一字符。<br>你可以假设输入的字符串将只包含字母。</p><a id="more"></a><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/keyboard-row" target="_blank" rel="noopener">https://leetcode-cn.com/problems/keyboard-row</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p><h2 id="核心思路"><a href="#核心思路" class="headerlink" title="核心思路"></a>核心思路</h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>利用哈希表,分别即字母为键名，字母所在行号为键值建立哈希表。遍历给定字符串，若字符串的所有字符的所在哈希表的键值都一样，则说明该字符串的字符都在同一行上</p><h3 id="解题步骤"><a href="#解题步骤" class="headerlink" title="解题步骤"></a>解题步骤</h3><ol><li>建立哈希表以及键盘字符数组</li><li>将每个字符以字符为键名，字符所在行号为键值建立哈希表。</li><li>遍历题目给定字符串数组，若每个字符串中的字符在哈希表中的键值都一样，则将该字符串加入到要返回的数组中</li><li>遍历字符串方法：先得到字符串的第一个字符的所在行号，接着循环得到后面的字符的行号，若不一样则直接退出该循环</li></ol><p>注意</p><p>将所有字符都转换为小写形式再去得到字符的键值</p><h2 id="Coding实现"><a href="#Coding实现" class="headerlink" title="Coding实现"></a>Coding实现</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @param &#123;string&#125; J</span></span><br><span class="line"><span class="comment"> * @param &#123;string&#125; S</span></span><br><span class="line"><span class="comment"> * @return &#123;number&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @param &#123;string[]&#125; words</span></span><br><span class="line"><span class="comment"> * @return &#123;string[]&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> findWords = <span class="function"><span class="keyword">function</span>(<span class="params">words</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> str=[<span class="string">'qwertyuiop'</span>,<span class="string">'asdfghjkl'</span>,<span class="string">'zxcvbnm'</span>];</span><br><span class="line">    <span class="keyword">let</span> ans=[];</span><br><span class="line">    <span class="keyword">let</span> map=<span class="keyword">new</span> <span class="built_in">Map</span>();</span><br><span class="line">    str.forEach(<span class="function">(<span class="params">value,index</span>)=&gt;</span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">0</span>;i&lt;value.length;i++)&#123;</span><br><span class="line">            map.set(value[i],index+<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    words.forEach(<span class="function"><span class="params">value</span>=&gt;</span>&#123;</span><br><span class="line">        <span class="keyword">let</span> flag=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">let</span> first=map.get(value[<span class="number">0</span>].toLowerCase());</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">1</span>;i&lt;value.length;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(map.get(value[i].toLowerCase())!=first)&#123;</span><br><span class="line">                flag=<span class="number">1</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(flag===<span class="number">0</span>)&#123;</span><br><span class="line">            ans.push(value);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;键盘行&quot;&gt;&lt;a href=&quot;#键盘行&quot; class=&quot;headerlink&quot; title=&quot;键盘行&quot;&gt;&lt;/a&gt;键盘行&lt;/h1&gt;&lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h2&gt;&lt;p&gt; 给定一个单词列表，只返回可以使用在键盘同一行的字母打印出来的单词。键盘如下图所示。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/10/12/keyboard.png&quot; alt&gt;&lt;/p&gt;
&lt;p&gt;示例：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;输入: [“Hello”, “Alaska”, “Dad”, “Peace”]&lt;br&gt;输出: [“Alaska”, “Dad”]&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;注意：&lt;/p&gt;
&lt;p&gt;你可以重复使用键盘上同一字符。&lt;br&gt;你可以假设输入的字符串将只包含字母。&lt;/p&gt;
    
    </summary>
    
      <category term="leetcode题解与算法" scheme="http://yoursite.com/categories/leetcode%E9%A2%98%E8%A7%A3%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="哈希表" scheme="http://yoursite.com/tags/%E5%93%88%E5%B8%8C%E8%A1%A8/"/>
    
  </entry>
  
  <entry>
    <title>散列</title>
    <link href="http://yoursite.com/2019/07/22/%E6%95%A3%E5%88%97/"/>
    <id>http://yoursite.com/2019/07/22/散列/</id>
    <published>2019-07-22T08:53:04.000Z</published>
    <updated>2019-07-22T14:01:33.355Z</updated>
    
    <content type="html"><![CDATA[<h2 id="散列的定义"><a href="#散列的定义" class="headerlink" title="散列的定义"></a>散列的定义</h2><blockquote><p>简单来说：就是将某个元素通过一个函数转换为整数，使得该整数可以尽量唯一地代表这个元素</p></blockquote><h2 id="常用的散列函数"><a href="#常用的散列函数" class="headerlink" title="常用的散列函数"></a>常用的散列函数</h2><ol><li>直接定址法<blockquote><p>直接把key值作为哈希表的下标</p></blockquote></li><li>平方取中法<blockquote><p>取key的平方的中间若干位作为哈希表的下标</p></blockquote></li><li>除留余数法（常用）<blockquote><p>指把key除以一个数得到的余数作为hash值的方法</p></blockquote></li></ol><h2 id="冲突处理"><a href="#冲突处理" class="headerlink" title="冲突处理"></a>冲突处理</h2><ol><li><p>线性探查法</p><blockquote><p>如果该hash值已经被占用，那么就不断检查下一个位置，直到找到没被占用的。如果检查过程中超过了表长，则返回到哈希表的首位继续循环查找，或是发现所有的位置都被占用</p></blockquote><p> 该方法容易造成扎堆现象，即表中的若干个连续位置都被使用</p></li><li><p>平方探查法</p><blockquote><p>按照下列的顺序进行探查：<br> H(key)+1^2,H(key)-1^2,<br> H(key)+2^2,H(key)-2^2,<br> H(key)+3^2,H(key)-3^2,<br> …  …</p></blockquote><p> 如果，检查过程中H(key)+k^2超过了表长Tsize，那么就把(H(key)+k^2) % Tsize 作为hash值</p></li><li><p>链地址法</p><blockquote><p>链地址法不计算新的hash值，而是把所有H(key)相同的key连接成一条单链表</p></blockquote><p> <img src="https://gss1.bdstatic.com/-vo3dSag_xI4khGkpoWK1HF6hhy/baike/c0%3Dbaike80%2C5%2C5%2C80%2C26/sign=249bc83ec45c10383073c690d378f876/c9fcc3cec3fdfc035f8e2b9cd63f8794a4c22624.jpg" alt></p></li></ol><h2 id="字符串hash"><a href="#字符串hash" class="headerlink" title="字符串hash"></a>字符串hash</h2><p>字符串hash是指将字符串S映射为一个整数，使得该整数尽可能唯一地代表该字符串</p><p>假设字符串只由A<del>Z构成，那么可以将A</del>Z映射为0~25；比如，ABC则就可以看作是012。显然，与二进制类似，我们可以把其看作为26进制，再将其转化为10进制，即可得到该字符串唯一地hash映射。</p><blockquote><p>代码</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> hashFunc(str,length)&#123;</span><br><span class="line">    <span class="keyword">let</span> hash=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">0</span>;i&lt;length;i++)&#123;</span><br><span class="line">        hash=hash*<span class="number">26</span>+str[i].charCodeAt()-<span class="string">'A'</span>.charCodeAt();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> hash;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果外加有小写字母，则就是52进制转换<br>若还有数字，则就是62进制转换</p><h2 id="一些散列表算法题"><a href="#一些散列表算法题" class="headerlink" title="一些散列表算法题"></a>一些散列表算法题</h2><p><a href="http://angellikefairy.coding.me/tags/%E5%93%88%E5%B8%8C%E8%A1%A8/" target="_blank" rel="noopener">散列表相关算法题</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;散列的定义&quot;&gt;&lt;a href=&quot;#散列的定义&quot; class=&quot;headerlink&quot; title=&quot;散列的定义&quot;&gt;&lt;/a&gt;散列的定义&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;简单来说：就是将某个元素通过一个函数转换为整数，使得该整数可以尽量唯一地代表这个元素&lt;/p
      
    
    </summary>
    
      <category term="算法笔记" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/"/>
    
    
  </entry>
  
  <entry>
    <title>leetcode-771 宝石与石头</title>
    <link href="http://yoursite.com/2019/07/22/leetcode-771/"/>
    <id>http://yoursite.com/2019/07/22/leetcode-771/</id>
    <published>2019-07-22T08:44:27.000Z</published>
    <updated>2019-07-22T08:50:43.498Z</updated>
    
    <content type="html"><![CDATA[<h1 id="宝石与石头"><a href="#宝石与石头" class="headerlink" title="宝石与石头"></a>宝石与石头</h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p> 给定字符串J 代表石头中宝石的类型，和字符串 S代表你拥有的石头。 S 中每个字符代表了一种你拥有的石头的类型，你想知道你拥有的石头中有多少是宝石。</p><p>J 中的字母不重复，J 和 S中的所有字符都是字母。字母区分大小写，因此”a”和”A”是不同类型的石头。</p><p>示例 1:</p><blockquote><p>输入: J = “aA”, S = “aAAbbbb”<br>输出: 3</p></blockquote><p>示例 2:</p><blockquote><p>输入: J = “z”, S = “ZZ”<br>输出: 0</p></blockquote><p>注意:</p><p>S 和 J 最多含有50个字母。<br> J 中的字符不重复。</p><a id="more"></a><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/jewels-and-stones" target="_blank" rel="noopener">https://leetcode-cn.com/problems/jewels-and-stones</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p><h2 id="核心思路"><a href="#核心思路" class="headerlink" title="核心思路"></a>核心思路</h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>利用哈希表，遍历宝石类型字符串，建立以宝石类型为键名，宝石数量为值的哈希表。哈希表中的所有键值之和就是所拥有的宝石的数量。</p><h3 id="解题步骤"><a href="#解题步骤" class="headerlink" title="解题步骤"></a>解题步骤</h3><ol><li>建立哈希表，声明所拥有的宝石数量为ans=0</li><li>遍历J字符串，以字符为键名，0为键值建立哈希表</li><li>遍历S字符串，若哈希表中存在该键名，则ans++</li><li>返回ans</li></ol><h2 id="Coding实现"><a href="#Coding实现" class="headerlink" title="Coding实现"></a>Coding实现</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @param &#123;string&#125; J</span></span><br><span class="line"><span class="comment"> * @param &#123;string&#125; S</span></span><br><span class="line"><span class="comment"> * @return &#123;number&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> numJewelsInStones = <span class="function"><span class="keyword">function</span>(<span class="params">J, S</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> map=<span class="keyword">new</span> <span class="built_in">Map</span>();</span><br><span class="line">    <span class="keyword">let</span> ans=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">0</span>;i&lt;J.length;i++)&#123;</span><br><span class="line">        map.set(J[i],<span class="number">0</span>);</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">0</span>;i&lt;S.length;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(map.has(S[i]))&#123;</span><br><span class="line">            ans++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;宝石与石头&quot;&gt;&lt;a href=&quot;#宝石与石头&quot; class=&quot;headerlink&quot; title=&quot;宝石与石头&quot;&gt;&lt;/a&gt;宝石与石头&lt;/h1&gt;&lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h2&gt;&lt;p&gt; 给定字符串J 代表石头中宝石的类型，和字符串 S代表你拥有的石头。 S 中每个字符代表了一种你拥有的石头的类型，你想知道你拥有的石头中有多少是宝石。&lt;/p&gt;
&lt;p&gt;J 中的字母不重复，J 和 S中的所有字符都是字母。字母区分大小写，因此”a”和”A”是不同类型的石头。&lt;/p&gt;
&lt;p&gt;示例 1:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;输入: J = “aA”, S = “aAAbbbb”&lt;br&gt;输出: 3&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;示例 2:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;输入: J = “z”, S = “ZZ”&lt;br&gt;输出: 0&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;注意:&lt;/p&gt;
&lt;p&gt;S 和 J 最多含有50个字母。&lt;br&gt; J 中的字符不重复。&lt;/p&gt;
    
    </summary>
    
      <category term="leetcode题解与算法" scheme="http://yoursite.com/categories/leetcode%E9%A2%98%E8%A7%A3%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="哈希表" scheme="http://yoursite.com/tags/%E5%93%88%E5%B8%8C%E8%A1%A8/"/>
    
  </entry>
  
  <entry>
    <title>leetcode-219 存在重复元素 II</title>
    <link href="http://yoursite.com/2019/07/21/leetcode-219/"/>
    <id>http://yoursite.com/2019/07/21/leetcode-219/</id>
    <published>2019-07-21T07:58:31.000Z</published>
    <updated>2019-07-21T08:54:46.131Z</updated>
    
    <content type="html"><![CDATA[<h1 id="存在重复元素-II"><a href="#存在重复元素-II" class="headerlink" title="存在重复元素 II"></a>存在重复元素 II</h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>给定一个整数数组和一个整数 k，判断数组中是否存在两个不同的索引 i 和 j，使得 nums [i] = nums [j]，并且 i 和 j 的差的绝对值最大为 k。</p><p>示例 1:</p><blockquote><p>输入: nums = [1,2,3,1], k = 3<br>输出: true</p></blockquote><p>示例 2:</p><blockquote><p>输入: nums = [1,0,1,1], k = 1<br>输出: true</p></blockquote><p>示例 3:</p><blockquote><p>输入: nums = [1,2,3,1,2,3], k = 2<br>输出: false</p></blockquote><a id="more"></a><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/contains-duplicate-ii" target="_blank" rel="noopener">https://leetcode-cn.com/problems/contains-duplicate-ii</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p><h2 id="核心思路"><a href="#核心思路" class="headerlink" title="核心思路"></a>核心思路</h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>利用哈希表，存储以值为键，下标为键值的哈希表。当某个键值需要更新时，比较当前下标与键值的差值是否小于题目给定值，若是则返回true;</p><h3 id="解题步骤"><a href="#解题步骤" class="headerlink" title="解题步骤"></a>解题步骤</h3><ol><li>建立哈希表</li><li>当以当前数组元素的值为键名的键不存在时，则以值为键，下标为键值添加到哈希表中。若存在，则比较当前下标与键值的差值是否小于题目给定值，若是则返回true;</li></ol><h2 id="Coding实现"><a href="#Coding实现" class="headerlink" title="Coding实现"></a>Coding实现</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @param &#123;number[]&#125; nums</span></span><br><span class="line"><span class="comment"> * @param &#123;number&#125; k</span></span><br><span class="line"><span class="comment"> * @return &#123;boolean&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> containsNearbyDuplicate = <span class="function"><span class="keyword">function</span>(<span class="params">nums, k</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> map = <span class="keyword">new</span> <span class="built_in">Map</span>();</span><br><span class="line">  <span class="keyword">return</span> nums.some(<span class="function">(<span class="params">value, index</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!map.has(value)) &#123;</span><br><span class="line">      map.set(value, index);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (index - map.get(value) &lt;= k) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        map.set(value, index);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;存在重复元素-II&quot;&gt;&lt;a href=&quot;#存在重复元素-II&quot; class=&quot;headerlink&quot; title=&quot;存在重复元素 II&quot;&gt;&lt;/a&gt;存在重复元素 II&lt;/h1&gt;&lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h2&gt;&lt;p&gt;给定一个整数数组和一个整数 k，判断数组中是否存在两个不同的索引 i 和 j，使得 nums [i] = nums [j]，并且 i 和 j 的差的绝对值最大为 k。&lt;/p&gt;
&lt;p&gt;示例 1:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;输入: nums = [1,2,3,1], k = 3&lt;br&gt;输出: true&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;示例 2:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;输入: nums = [1,0,1,1], k = 1&lt;br&gt;输出: true&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;示例 3:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;输入: nums = [1,2,3,1,2,3], k = 2&lt;br&gt;输出: false&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="leetcode题解与算法" scheme="http://yoursite.com/categories/leetcode%E9%A2%98%E8%A7%A3%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="哈希表" scheme="http://yoursite.com/tags/%E5%93%88%E5%B8%8C%E8%A1%A8/"/>
    
  </entry>
  
  <entry>
    <title>leetcode-217 存在重复元素</title>
    <link href="http://yoursite.com/2019/07/20/leetcode-217/"/>
    <id>http://yoursite.com/2019/07/20/leetcode-217/</id>
    <published>2019-07-20T07:39:40.000Z</published>
    <updated>2019-07-20T07:45:18.358Z</updated>
    
    <content type="html"><![CDATA[<h1 id="存在重复元素"><a href="#存在重复元素" class="headerlink" title="存在重复元素"></a>存在重复元素</h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>给定一个整数数组，判断是否存在重复元素。</p><p>如果任何值在数组中出现至少两次，函数返回 true。如果数组中每个元素都不相同，则返回 false。</p><p>示例 1:</p><blockquote><p>输入: [1,2,3,1]<br>输出: true</p></blockquote><p>示例 2:</p><blockquote><p>输入: [1,2,3,4]<br>输出: false</p></blockquote><p>示例 3:</p><blockquote><p>输入: [1,1,1,3,3,4,3,2,4,2]<br>输出: true</p></blockquote><a id="more"></a><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/contains-duplicate" target="_blank" rel="noopener">https://leetcode-cn.com/problems/contains-duplicate</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p><h2 id="核心思路"><a href="#核心思路" class="headerlink" title="核心思路"></a>核心思路</h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>将该数组去重之后的元素个数与原数组长度进行比较，不一样则有重复；</p><h3 id="解题步骤"><a href="#解题步骤" class="headerlink" title="解题步骤"></a>解题步骤</h3><ol><li>建立set集合，用于数组去重</li><li>将set集合的size与数组长度进行比较</li><li>不相同则有重复,返回true;反之,false</li></ol><h2 id="Coding实现"><a href="#Coding实现" class="headerlink" title="Coding实现"></a>Coding实现</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @param &#123;number[]&#125; nums</span></span><br><span class="line"><span class="comment"> * @return &#123;boolean&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> containsDuplicate = <span class="function"><span class="keyword">function</span>(<span class="params">nums</span>) </span>&#123;</span><br><span class="line">   <span class="keyword">let</span> <span class="keyword">set</span>=new Set(nums);</span><br><span class="line">    if(<span class="keyword">set</span>.size===nums.length) return false;</span><br><span class="line">    else return true;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;存在重复元素&quot;&gt;&lt;a href=&quot;#存在重复元素&quot; class=&quot;headerlink&quot; title=&quot;存在重复元素&quot;&gt;&lt;/a&gt;存在重复元素&lt;/h1&gt;&lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h2&gt;&lt;p&gt;给定一个整数数组，判断是否存在重复元素。&lt;/p&gt;
&lt;p&gt;如果任何值在数组中出现至少两次，函数返回 true。如果数组中每个元素都不相同，则返回 false。&lt;/p&gt;
&lt;p&gt;示例 1:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;输入: [1,2,3,1]&lt;br&gt;输出: true&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;示例 2:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;输入: [1,2,3,4]&lt;br&gt;输出: false&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;示例 3:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;输入: [1,1,1,3,3,4,3,2,4,2]&lt;br&gt;输出: true&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="leetcode题解与算法" scheme="http://yoursite.com/categories/leetcode%E9%A2%98%E8%A7%A3%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
  </entry>
  
  <entry>
    <title>Java解决算法题一些记录(杂)</title>
    <link href="http://yoursite.com/2019/07/20/Java%E8%A7%A3%E5%86%B3%E7%AE%97%E6%B3%95%E9%A2%98/"/>
    <id>http://yoursite.com/2019/07/20/Java解决算法题/</id>
    <published>2019-07-20T06:30:02.000Z</published>
    <updated>2019-07-20T06:38:27.726Z</updated>
    
    <content type="html"><![CDATA[<h1 id="ArrayList"><a href="#ArrayList" class="headerlink" title="ArrayList"></a>ArrayList</h1><h2 id="ArrayList的一些方法"><a href="#ArrayList的一些方法" class="headerlink" title="ArrayList的一些方法"></a>ArrayList的一些方法</h2><table><thead><tr><th>方法</th><th>描述</th></tr></thead><tbody><tr><td>add()</td><td>在list的末尾添加一个元素</td></tr><tr><td>add(index: int, o: E)</td><td>在指定的index处插入元素</td></tr><tr><td>clear()</td><td>从list中删除所有元素</td></tr><tr><td>contains(o: Object)</td><td>如果list含有元素o，返回true</td></tr><tr><td>get(index: int)</td><td>返回指定index处的元素</td></tr><tr><td>indexOf(o: Object)</td><td>返回list中第一个匹配元素的index</td></tr><tr><td>isEmpty()</td><td>如果list不含元素，返回true</td></tr><tr><td>lastIndexOf(o: Object)</td><td>返回list中最后一个匹配元素的index</td></tr><tr><td>remove(o: Object)</td><td>删除list中的第一个元素o，如果元素被删除，返回true</td></tr><tr><td>size()</td><td>返回list中元素个数</td></tr><tr><td>remove(index: int)</td><td>删除指定index处的元素，如果元素被删除，返回true</td></tr><tr><td>set(index: int, o: E)</td><td>设置指定index处的元素为o</td></tr></tbody></table>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;ArrayList&quot;&gt;&lt;a href=&quot;#ArrayList&quot; class=&quot;headerlink&quot; title=&quot;ArrayList&quot;&gt;&lt;/a&gt;ArrayList&lt;/h1&gt;&lt;h2 id=&quot;ArrayList的一些方法&quot;&gt;&lt;a href=&quot;#ArrayList的一
      
    
    </summary>
    
      <category term="Java" scheme="http://yoursite.com/categories/Java/"/>
    
    
  </entry>
  
  <entry>
    <title>leetcode-206 反转链表</title>
    <link href="http://yoursite.com/2019/07/19/leetcode-206/"/>
    <id>http://yoursite.com/2019/07/19/leetcode-206/</id>
    <published>2019-07-19T11:08:47.000Z</published>
    <updated>2019-07-20T07:45:18.444Z</updated>
    
    <content type="html"><![CDATA[<h1 id="反转链表"><a href="#反转链表" class="headerlink" title="反转链表"></a>反转链表</h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>反转一个单链表。</p><p>示例:</p><blockquote><p>输入: 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL<br>输出: 5-&gt;4-&gt;3-&gt;2-&gt;1-&gt;NULL</p></blockquote><p>进阶:<br>你可以迭代或递归地反转链表。你能否用两种方法解决这道题？</p><a id="more"></a><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/reverse-linked-list" target="_blank" rel="noopener">https://leetcode-cn.com/problems/reverse-linked-list</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p><h2 id="核心思路"><a href="#核心思路" class="headerlink" title="核心思路"></a>核心思路</h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>将链表所有的元素取出并倒序放到数组，按照数组元素创建新链表并返回</p><h3 id="解题步骤"><a href="#解题步骤" class="headerlink" title="解题步骤"></a>解题步骤</h3><ol><li>遍历链表，并将数组元素unshift入数组</li><li>按照数组元素添加节点到新创建的链表上</li></ol><h2 id="Coding实现"><a href="#Coding实现" class="headerlink" title="Coding实现"></a>Coding实现</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * function ListNode(val) &#123;</span></span><br><span class="line"><span class="comment"> *     this.val = val;</span></span><br><span class="line"><span class="comment"> *     this.next = null;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @param &#123;ListNode&#125; head</span></span><br><span class="line"><span class="comment"> * @return &#123;ListNode&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> reverseList = <span class="function"><span class="keyword">function</span>(<span class="params">head</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> newList=<span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">let</span> newHead=newList;</span><br><span class="line">    <span class="keyword">let</span> numArray=[];</span><br><span class="line">    <span class="keyword">while</span>(head)&#123;</span><br><span class="line">        numArray.unshift(head.val);</span><br><span class="line">        head=head.next;</span><br><span class="line">    &#125;</span><br><span class="line">    numArray.forEach(<span class="function"><span class="params">value</span>=&gt;</span>&#123;</span><br><span class="line">        newHead.next=<span class="keyword">new</span> ListNode(value);</span><br><span class="line">        newHead=newHead.next;</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="keyword">return</span> newList.next;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;反转链表&quot;&gt;&lt;a href=&quot;#反转链表&quot; class=&quot;headerlink&quot; title=&quot;反转链表&quot;&gt;&lt;/a&gt;反转链表&lt;/h1&gt;&lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h2&gt;&lt;p&gt;反转一个单链表。&lt;/p&gt;
&lt;p&gt;示例:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;输入: 1-&amp;gt;2-&amp;gt;3-&amp;gt;4-&amp;gt;5-&amp;gt;NULL&lt;br&gt;输出: 5-&amp;gt;4-&amp;gt;3-&amp;gt;2-&amp;gt;1-&amp;gt;NULL&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;进阶:&lt;br&gt;你可以迭代或递归地反转链表。你能否用两种方法解决这道题？&lt;/p&gt;
    
    </summary>
    
      <category term="leetcode题解与算法" scheme="http://yoursite.com/categories/leetcode%E9%A2%98%E8%A7%A3%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="链表" scheme="http://yoursite.com/tags/%E9%93%BE%E8%A1%A8/"/>
    
  </entry>
  
  <entry>
    <title>leetcode-205 同构字符串</title>
    <link href="http://yoursite.com/2019/07/18/leetcode-205/"/>
    <id>http://yoursite.com/2019/07/18/leetcode-205/</id>
    <published>2019-07-18T05:46:10.000Z</published>
    <updated>2019-07-19T14:07:08.978Z</updated>
    
    <content type="html"><![CDATA[<h1 id="同构字符串"><a href="#同构字符串" class="headerlink" title="同构字符串"></a>同构字符串</h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>给定两个字符串 s 和 t，判断它们是否是同构的。</p><p>如果 s 中的字符可以被替换得到 t ，那么这两个字符串是同构的。</p><p>所有出现的字符都必须用另一个字符替换，同时保留字符的顺序。两个字符不能映射到同一个字符上，但字符可以映射自己本身。</p><p>示例 1:</p><blockquote><p>输入: s = “egg”, t = “add”<br>输出: true</p></blockquote><p>示例 2:</p><blockquote><p>输入: s = “foo”, t = “bar”<br>输出: false</p></blockquote><p>示例 3:</p><blockquote><p>输入: s = “paper”, t = “title”<br>输出: true</p></blockquote><p>说明:<br>你可以假设 s 和 t 具有相同的长度。</p><a id="more"></a><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/isomorphic-strings" target="_blank" rel="noopener">https://leetcode-cn.com/problems/isomorphic-strings</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p><h2 id="核心思路"><a href="#核心思路" class="headerlink" title="核心思路"></a>核心思路</h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><h4 id="解法1"><a href="#解法1" class="headerlink" title="解法1"></a>解法1</h4><p>利用哈希表进行映射，两个字符串相互映射</p><h4 id="解法2"><a href="#解法2" class="headerlink" title="解法2"></a>解法2</h4><p>对比两个字符串对应位置的字符在字符串内第一次出现的位置，若不同则返回false</p><h3 id="解题步骤"><a href="#解题步骤" class="headerlink" title="解题步骤"></a>解题步骤</h3><h4 id="解法1-1"><a href="#解法1-1" class="headerlink" title="解法1"></a>解法1</h4><ol><li>建立哈希映射函数，若哈希表中没有该键值对，则插入表中；若有，则比较值是否相同，不同则返回fasle</li><li>两个字符串依次使用哈希映射函数进行比较</li></ol><h4 id="解法2-1"><a href="#解法2-1" class="headerlink" title="解法2"></a>解法2</h4><ol><li>同时遍历两字符串，若当前字符的第一次出现的位置不相同则返回false</li></ol><h2 id="Coding实现"><a href="#Coding实现" class="headerlink" title="Coding实现"></a>Coding实现</h2><h3 id="解法1-2"><a href="#解法1-2" class="headerlink" title="解法1"></a>解法1</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @param &#123;string&#125; s</span></span><br><span class="line"><span class="comment"> * @param &#123;string&#125; t</span></span><br><span class="line"><span class="comment"> * @return &#123;boolean&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">match</span>(<span class="params">map,s,t</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">0</span>;i&lt;s.length;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(!map.has(s[i]))&#123;</span><br><span class="line">            map.set(s[i],t[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(map.get(s[i])!=t[i])&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> isIsomorphic = <span class="function"><span class="keyword">function</span>(<span class="params">s, t</span>) </span>&#123;</span><br><span class="line">    s=s.split(<span class="string">''</span>);</span><br><span class="line">    t=t.split(<span class="string">''</span>);</span><br><span class="line">    <span class="keyword">let</span> map=<span class="keyword">new</span> <span class="built_in">Map</span>();</span><br><span class="line">    <span class="keyword">if</span>(!match(map,s,t)) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    map.clear();</span><br><span class="line">    <span class="keyword">return</span> match(map,t,s);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="解法2-2"><a href="#解法2-2" class="headerlink" title="解法2"></a>解法2</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @param &#123;string&#125; s</span></span><br><span class="line"><span class="comment"> * @param &#123;string&#125; t</span></span><br><span class="line"><span class="comment"> * @return &#123;boolean&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> isIsomorphic = <span class="function"><span class="keyword">function</span>(<span class="params">s, t</span>) </span>&#123;</span><br><span class="line">   <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; s.length; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (s.indexOf(s[i]) !== t.indexOf(t[i])) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;同构字符串&quot;&gt;&lt;a href=&quot;#同构字符串&quot; class=&quot;headerlink&quot; title=&quot;同构字符串&quot;&gt;&lt;/a&gt;同构字符串&lt;/h1&gt;&lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h2&gt;&lt;p&gt;给定两个字符串 s 和 t，判断它们是否是同构的。&lt;/p&gt;
&lt;p&gt;如果 s 中的字符可以被替换得到 t ，那么这两个字符串是同构的。&lt;/p&gt;
&lt;p&gt;所有出现的字符都必须用另一个字符替换，同时保留字符的顺序。两个字符不能映射到同一个字符上，但字符可以映射自己本身。&lt;/p&gt;
&lt;p&gt;示例 1:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;输入: s = “egg”, t = “add”&lt;br&gt;输出: true&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;示例 2:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;输入: s = “foo”, t = “bar”&lt;br&gt;输出: false&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;示例 3:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;输入: s = “paper”, t = “title”&lt;br&gt;输出: true&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;说明:&lt;br&gt;你可以假设 s 和 t 具有相同的长度。&lt;/p&gt;
    
    </summary>
    
      <category term="leetcode题解与算法" scheme="http://yoursite.com/categories/leetcode%E9%A2%98%E8%A7%A3%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
  </entry>
  
  <entry>
    <title>leetcode-204 计数质数</title>
    <link href="http://yoursite.com/2019/07/17/leetcode-204/"/>
    <id>http://yoursite.com/2019/07/17/leetcode-204/</id>
    <published>2019-07-17T02:45:31.000Z</published>
    <updated>2019-07-17T03:27:21.958Z</updated>
    
    <content type="html"><![CDATA[<h1 id="计数质数"><a href="#计数质数" class="headerlink" title="计数质数"></a>计数质数</h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>统计所有小于非负整数 n 的质数的数量。</p><p>示例:</p><blockquote><p>输入: 10<br>输出: 4<br>解释: 小于 10 的质数一共有 4 个, 它们是 2, 3, 5, 7 。</p></blockquote><a id="more"></a><h2 id="核心思路"><a href="#核心思路" class="headerlink" title="核心思路"></a>核心思路</h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>质数的定义</p><blockquote><p>质数又称素数。一个大于1的自然数，除了1和它自身外，不能被其他自然数整除的数叫做质数；否则称为合数。</p></blockquote><p>此题的基本解法即为遍历给定数之前的数，若为质数则计数加一</p><h3 id="解题步骤"><a href="#解题步骤" class="headerlink" title="解题步骤"></a>解题步骤</h3><ol><li>建立一个函数用来判断当前数是否为质数</li><li>对于1中的函数质数判断条件，若在1~开根号n的左开右闭的区间内无法被整除，那么该数即为质数。</li><li>遍历给定数之前的数，若为质数则计数加一</li></ol><h2 id="Coding实现"><a href="#Coding实现" class="headerlink" title="Coding实现"></a>Coding实现</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @param &#123;number&#125; n</span></span><br><span class="line"><span class="comment"> * @return &#123;number&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">const</span> checkPrimes=<span class="function"><span class="keyword">function</span>(<span class="params">n</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(n===<span class="number">2</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">if</span>(n===<span class="number">1</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">if</span>(n%<span class="number">2</span>===<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">1</span>;i&lt;=<span class="built_in">Math</span>.sqrt(n);i=i+<span class="number">2</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(n%i===<span class="number">0</span>&amp;&amp;i!==<span class="number">1</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> countPrimes = <span class="function"><span class="keyword">function</span>(<span class="params">n</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> count=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">2</span>;i&lt;n;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(checkPrimes(i))&#123;</span><br><span class="line">            count++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;计数质数&quot;&gt;&lt;a href=&quot;#计数质数&quot; class=&quot;headerlink&quot; title=&quot;计数质数&quot;&gt;&lt;/a&gt;计数质数&lt;/h1&gt;&lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h2&gt;&lt;p&gt;统计所有小于非负整数 n 的质数的数量。&lt;/p&gt;
&lt;p&gt;示例:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;输入: 10&lt;br&gt;输出: 4&lt;br&gt;解释: 小于 10 的质数一共有 4 个, 它们是 2, 3, 5, 7 。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="leetcode题解与算法" scheme="http://yoursite.com/categories/leetcode%E9%A2%98%E8%A7%A3%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
  </entry>
  
  <entry>
    <title>leetcode-203 移除链表元素</title>
    <link href="http://yoursite.com/2019/07/16/leetcode-203/"/>
    <id>http://yoursite.com/2019/07/16/leetcode-203/</id>
    <published>2019-07-16T05:43:19.000Z</published>
    <updated>2019-07-17T03:27:57.330Z</updated>
    
    <content type="html"><![CDATA[<h1 id="移除链表元素"><a href="#移除链表元素" class="headerlink" title="移除链表元素"></a>移除链表元素</h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>删除链表中等于给定值 val 的所有节点。</p><p>示例:</p><blockquote><p>输入: 1-&gt;2-&gt;6-&gt;3-&gt;4-&gt;5-&gt;6, val = 6<br>输出: 1-&gt;2-&gt;3-&gt;4-&gt;5</p></blockquote><a id="more"></a><h2 id="核心思路"><a href="#核心思路" class="headerlink" title="核心思路"></a>核心思路</h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>此题为单链表删除指定元素</p><h3 id="解题步骤"><a href="#解题步骤" class="headerlink" title="解题步骤"></a>解题步骤</h3><h4 id="单独考虑头节点（因为头节点之前没有节点）"><a href="#单独考虑头节点（因为头节点之前没有节点）" class="headerlink" title="单独考虑头节点（因为头节点之前没有节点）"></a>单独考虑头节点（因为头节点之前没有节点）</h4><ol><li>考虑头节点即为指定需删除元素，那么应当将头指针指向下一个元素。循环检验，当头节点不是指定需删除元素时则退出循环</li><li>若步骤1之后，该链表为空链表则直接返回该空链表</li><li>1、2步骤之后，当前链表则为头节点不为指定需删除元素的非空链表。遍历当前链表，设置pre和cur指针方便删除链表节点。</li></ol><h4 id="设置虚拟头节点（指向头节点的节点）"><a href="#设置虚拟头节点（指向头节点的节点）" class="headerlink" title="设置虚拟头节点（指向头节点的节点）"></a>设置虚拟头节点（指向头节点的节点）</h4><ol><li>创建新节点指向当前头节点</li><li>遍历该链表，删除指定元素</li><li>返回以创建的新节点的下一个节点为头节点所在的链表</li></ol><h2 id="Coding实现"><a href="#Coding实现" class="headerlink" title="Coding实现"></a>Coding实现</h2><h3 id="单独处理头节点的Coding"><a href="#单独处理头节点的Coding" class="headerlink" title="单独处理头节点的Coding"></a>单独处理头节点的Coding</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * function ListNode(val) &#123;</span></span><br><span class="line"><span class="comment"> *     this.val = val;</span></span><br><span class="line"><span class="comment"> *     this.next = null;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @param &#123;ListNode&#125; head</span></span><br><span class="line"><span class="comment"> * @param &#123;number&#125; val</span></span><br><span class="line"><span class="comment"> * @return &#123;ListNode&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> removeElements = <span class="function"><span class="keyword">function</span>(<span class="params">head, val</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(head&amp;&amp;head.val===val)&#123;</span><br><span class="line">        head=head.next</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(head===<span class="literal">null</span>) <span class="keyword">return</span> head;</span><br><span class="line">    <span class="keyword">let</span> cur=head;</span><br><span class="line">    <span class="keyword">let</span> pre=head;</span><br><span class="line">    <span class="keyword">while</span>(cur.next)&#123;</span><br><span class="line">        pre=cur;</span><br><span class="line">        cur=cur.next;     </span><br><span class="line">        <span class="keyword">if</span>(cur.val===val)&#123;</span><br><span class="line">            pre.next=cur.next;</span><br><span class="line">            cur=pre;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> head;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="设置指向头节点的指针节点的Coding"><a href="#设置指向头节点的指针节点的Coding" class="headerlink" title="设置指向头节点的指针节点的Coding"></a>设置指向头节点的指针节点的Coding</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * function ListNode(val) &#123;</span></span><br><span class="line"><span class="comment"> *     this.val = val;</span></span><br><span class="line"><span class="comment"> *     this.next = null;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @param &#123;ListNode&#125; head</span></span><br><span class="line"><span class="comment"> * @param &#123;number&#125; val</span></span><br><span class="line"><span class="comment"> * @return &#123;ListNode&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> removeElements = <span class="function"><span class="keyword">function</span>(<span class="params">head, val</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> listNode=<span class="keyword">new</span> ListNode(val<span class="number">-1</span>);</span><br><span class="line">    listNode.next=head;</span><br><span class="line">    <span class="keyword">let</span> list=listNode;</span><br><span class="line">    <span class="keyword">while</span>(list.next)&#123;</span><br><span class="line">        <span class="keyword">if</span>(list.next.val===val)&#123;</span><br><span class="line">            list.next=list.next.next;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        list=list.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> listNode.next;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;移除链表元素&quot;&gt;&lt;a href=&quot;#移除链表元素&quot; class=&quot;headerlink&quot; title=&quot;移除链表元素&quot;&gt;&lt;/a&gt;移除链表元素&lt;/h1&gt;&lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h2&gt;&lt;p&gt;删除链表中等于给定值 val 的所有节点。&lt;/p&gt;
&lt;p&gt;示例:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;输入: 1-&amp;gt;2-&amp;gt;6-&amp;gt;3-&amp;gt;4-&amp;gt;5-&amp;gt;6, val = 6&lt;br&gt;输出: 1-&amp;gt;2-&amp;gt;3-&amp;gt;4-&amp;gt;5&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="leetcode题解与算法" scheme="http://yoursite.com/categories/leetcode%E9%A2%98%E8%A7%A3%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="链表" scheme="http://yoursite.com/tags/%E9%93%BE%E8%A1%A8/"/>
    
  </entry>
  
  <entry>
    <title>leetcode-202 快乐数</title>
    <link href="http://yoursite.com/2019/07/15/leetcode-202/"/>
    <id>http://yoursite.com/2019/07/15/leetcode-202/</id>
    <published>2019-07-15T08:44:13.000Z</published>
    <updated>2019-07-16T05:42:00.535Z</updated>
    
    <content type="html"><![CDATA[<h1 id="快乐数"><a href="#快乐数" class="headerlink" title="快乐数"></a>快乐数</h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>编写一个算法来判断一个数是不是“快乐数”。</p><p>一个“快乐数”定义为：对于一个正整数，每一次将该数替换为它每个位置上的数字的平方和，然后重复这个过程直到这个数变为 1，也可能是无限循环但始终变不到 1。如果可以变为 1，那么这个数就是快乐数。</p><p>示例: </p><blockquote><p>输入: 19<br>输出: true<br>解释: <br>12 + 92 = 82<br>82 + 22 = 68<br>62 + 82 = 100<br>12 + 02 + 02 = 1</p></blockquote><a id="more"></a><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/happy-number" target="_blank" rel="noopener">https://leetcode-cn.com/problems/happy-number</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p><h2 id="核心思路"><a href="#核心思路" class="headerlink" title="核心思路"></a>核心思路</h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><ol><li><p>正面解题，寻找快乐数。当重复过程变为1则为快乐数，若当循环过程中得到的数与之前出现过的数相重复，则表示之后会在这两数之间无限循环，此时即可返回false.</p></li><li><p>快慢指针解法：使用快慢指针来判断该循环是否为无限死循环。</p></li></ol><h3 id="解题步骤"><a href="#解题步骤" class="headerlink" title="解题步骤"></a>解题步骤</h3><h4 id="正面解题法-遇到重复数字则退出"><a href="#正面解题法-遇到重复数字则退出" class="headerlink" title="正面解题法(遇到重复数字则退出)"></a>正面解题法(遇到重复数字则退出)</h4><ol><li>若输入为1，则直接返回true</li><li>设置set集合用来存储循环过程中得到的数</li><li>进入do-while循环，将参数转化为数组，利用reduce函数进行平方和累加，判断该得到的数是否存在于set集合中，若存在则返回false，否则则将该数放入set集合中。同时,若该数为1则返回true退出函数<h4 id="快慢指针法"><a href="#快慢指针法" class="headerlink" title="快慢指针法"></a>快慢指针法</h4></li><li>设置两个指针，一个指针移动较快，一个指针移动较慢，若两指针相遇，则代表该循环中存在死循环，则应退出该函数。<h2 id="Coding实现"><a href="#Coding实现" class="headerlink" title="Coding实现"></a>Coding实现</h2><h3 id="正面解题的Coding"><a href="#正面解题的Coding" class="headerlink" title="正面解题的Coding"></a>正面解题的Coding</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> isHappy = <span class="function"><span class="keyword">function</span>(<span class="params">n</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(n===<span class="number">1</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">let</span> arr;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">set</span>=new Set([n]);</span><br><span class="line">    do&#123;</span><br><span class="line">        arr=n.toString().split(<span class="string">''</span>);</span><br><span class="line">        n=arr.reduce(<span class="function">(<span class="params">pre,value</span>)=&gt;</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> pre+<span class="built_in">Math</span>.pow(<span class="built_in">parseInt</span>(value),<span class="number">2</span>)</span><br><span class="line">        &#125;,<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">set</span>.has(n))&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">set</span>.add(n);</span><br><span class="line">    &#125;while(n!=1)</span><br><span class="line">    return true;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ol><h3 id="递归法的Coding"><a href="#递归法的Coding" class="headerlink" title="递归法的Coding"></a>递归法的Coding</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;快乐数&quot;&gt;&lt;a href=&quot;#快乐数&quot; class=&quot;headerlink&quot; title=&quot;快乐数&quot;&gt;&lt;/a&gt;快乐数&lt;/h1&gt;&lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h2&gt;&lt;p&gt;编写一个算法来判断一个数是不是“快乐数”。&lt;/p&gt;
&lt;p&gt;一个“快乐数”定义为：对于一个正整数，每一次将该数替换为它每个位置上的数字的平方和，然后重复这个过程直到这个数变为 1，也可能是无限循环但始终变不到 1。如果可以变为 1，那么这个数就是快乐数。&lt;/p&gt;
&lt;p&gt;示例: &lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;输入: 19&lt;br&gt;输出: true&lt;br&gt;解释: &lt;br&gt;12 + 92 = 82&lt;br&gt;82 + 22 = 68&lt;br&gt;62 + 82 = 100&lt;br&gt;12 + 02 + 02 = 1&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="leetcode题解与算法" scheme="http://yoursite.com/categories/leetcode%E9%A2%98%E8%A7%A3%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="快慢指针" scheme="http://yoursite.com/tags/%E5%BF%AB%E6%85%A2%E6%8C%87%E9%92%88/"/>
    
  </entry>
  
  <entry>
    <title>var、let与const的比较以及作用域</title>
    <link href="http://yoursite.com/2019/07/15/var%E3%80%81let%E4%B8%8Econst/"/>
    <id>http://yoursite.com/2019/07/15/var、let与const/</id>
    <published>2019-07-15T01:58:31.000Z</published>
    <updated>2019-07-15T08:56:08.469Z</updated>
    
    <content type="html"><![CDATA[<h1 id="var、let与const的比较以及作用域"><a href="#var、let与const的比较以及作用域" class="headerlink" title="var、let与const的比较以及作用域"></a>var、let与const的比较以及作用域</h1><a id="more"></a><h2 id="提升机制"><a href="#提升机制" class="headerlink" title="提升机制"></a>提升机制</h2><h3 id="对于用var定义的变量会被提升到当前作用域的顶端并赋值为undefined"><a href="#对于用var定义的变量会被提升到当前作用域的顶端并赋值为undefined" class="headerlink" title="对于用var定义的变量会被提升到当前作用域的顶端并赋值为undefined"></a>对于用var定义的变量会被提升到当前作用域的顶端并赋值为undefined</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(a);   <span class="comment">//undefined</span></span><br><span class="line"><span class="keyword">var</span> a=<span class="string">'hello'</span>;</span><br><span class="line"><span class="built_in">console</span>.log(a);   <span class="comment">//hello</span></span><br></pre></td></tr></table></figure><h3 id="函数声明整体提升"><a href="#函数声明整体提升" class="headerlink" title="函数声明整体提升"></a>函数声明整体提升</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">a();   <span class="comment">//hello</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">a</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'hello'</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(a);  <span class="comment">//undefined</span></span><br><span class="line">a();  <span class="comment">//报错：a is not a function</span></span><br><span class="line"><span class="keyword">var</span> a=<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;   </span><br><span class="line">    <span class="comment">/*遇见var a=  会直接将a当作一个变量提升并赋值为undefined;*/</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'hello'</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(a);  <span class="comment">/*报错：Cannot access 'a' before initialization*/</span></span><br><span class="line">a();  </span><br><span class="line"><span class="keyword">let</span> a=<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;   </span><br><span class="line">    <span class="comment">/*这里为let a= ,不会有变量提升机制*/</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'hello'</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="预编译与词法分析"><a href="#预编译与词法分析" class="headerlink" title="预编译与词法分析"></a>预编译与词法分析</h2><h3 id="预编译"><a href="#预编译" class="headerlink" title="预编译"></a>预编译</h3><blockquote><p>JS引擎会在正式执行代码之前进行一次”预编译“，预编译简单理解就是在内存中开辟一些空间，存放一些变量和函数。</p></blockquote><h4 id="具体步骤"><a href="#具体步骤" class="headerlink" title="具体步骤"></a>具体步骤</h4><ol><li><p>页面创建全局对象（Global Object）对象（window对象）。</p></li><li><p>加载第一个脚本文件</p></li><li><p>脚本加载完毕后，进行语法分析。</p></li><li><p>开始预编译</p><ol><li><p>查找函数声明，作为GO属性，值赋予函数体（函数声明优先）</p></li><li><p>查找变量声明（除了函数内部的），作为GO属性，值赋予undefined</p><blockquote><p>若函数声明与变量声明同名，则函数声明会优先于变量声明。具体来说即是1. 函数声明替换变量声明 2. 后面的函数声明替换前面的函数声明 3. 后面的变量声明无效</p></blockquote><p>例如</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(a);   <span class="comment">//[function: a]</span></span><br><span class="line">a();   <span class="comment">//hello</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">a</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'hello'</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> a=<span class="number">1</span>;</span><br><span class="line"><span class="built_in">console</span>.log(a);   <span class="comment">//1</span></span><br></pre></td></tr></table></figure></li></ol></li></ol><h3 id="词法分析"><a href="#词法分析" class="headerlink" title="词法分析"></a>词法分析</h3><ol><li>创建AO活动对象（Active Object）</li><li>查找形参和变量声明，值赋予undefined</li><li>实参值赋给形参</li><li>查找函数声明，值赋给函数体</li><li>解释执行函数中的代码</li></ol><h2 id="块级声明与块级作用域"><a href="#块级声明与块级作用域" class="headerlink" title="块级声明与块级作用域"></a>块级声明与块级作用域</h2><p>块级作用域存在于：</p><blockquote><p>1.函数内部<br>2.块中（{ }之间的区域）</p></blockquote><p>例如</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(a);  <span class="comment">//报错：a is not defined</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">        <span class="keyword">let</span> a=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)()</span><br></pre></td></tr></table></figure><p>用let声明变量，会将变量的作用域限制在当前代码块中（即块级作用域）;因此块级作用域外部无法访问</p><h2 id="临时死区"><a href="#临时死区" class="headerlink" title="临时死区"></a>临时死区</h2><blockquote><p>javascript引擎在预编译阶段时，要么将变量提升至作用域顶部（var）,要么就将其放到TDZ（临时死区中）。访问临时死区的变量会触发运行错误。</p></blockquote><p>例如</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">typeof</span> a);  <span class="comment">//报错</span></span><br><span class="line">    <span class="keyword">let</span> a=<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="var、let与const的比较"><a href="#var、let与const的比较" class="headerlink" title="var、let与const的比较"></a>var、let与const的比较</h2><table><thead><tr><th>\</th><th>var</th><th>let</th><th>const</th></tr></thead><tbody><tr><td>变量提升机制</td><td>有</td><td>无</td><td>无</td></tr><tr><td>重声明</td><td>允许</td><td>在同个作用域下禁止,不同作用域下允许</td><td>同let</td></tr><tr><td>能否更改</td><td>允许</td><td>允许</td><td>不允许</td></tr><tr><td>初始化</td><td>可以不用</td><td>可以不用</td><td>必须</td></tr></tbody></table>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;var、let与const的比较以及作用域&quot;&gt;&lt;a href=&quot;#var、let与const的比较以及作用域&quot; class=&quot;headerlink&quot; title=&quot;var、let与const的比较以及作用域&quot;&gt;&lt;/a&gt;var、let与const的比较以及作用域&lt;/h1&gt;
    
    </summary>
    
      <category term="javaScript基础" scheme="http://yoursite.com/categories/javaScript%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="基础语法" scheme="http://yoursite.com/tags/%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/"/>
    
  </entry>
  
</feed>
