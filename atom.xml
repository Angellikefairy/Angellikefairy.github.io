<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Hexo</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2019-09-13T14:52:02.367Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>Angel</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>js事件循环机制 event loop</title>
    <link href="http://yoursite.com/2019/09/13/%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF%E6%9C%BA%E5%88%B6/"/>
    <id>http://yoursite.com/2019/09/13/事件循环机制/</id>
    <published>2019-09-13T12:36:20.000Z</published>
    <updated>2019-09-13T14:52:02.367Z</updated>
    
    <content type="html"><![CDATA[<h2 id="为什么js是单线程的"><a href="#为什么js是单线程的" class="headerlink" title="为什么js是单线程的"></a>为什么js是单线程的</h2><p>众所周知，JavaScript是一门单线程语言。那么，为什么js必须是单线程的呢？</p><p>因为，js主要的宿主环境就是浏览器，并且其一个重要的用途就是来操作Dom。反过来思考，如果js是多线程的，那么就会允许同一时间有多个代码块运行。那么，如果这多个代码块同时操作同一个Dom，比如，一个代码块要修改某dom元素，而另一个代码块又要删除这个元素，那么浏览器该如何处理这个元素。因此，为了避免这种复杂性，js必须是单线程的</p><h2 id="执行栈与任务队列"><a href="#执行栈与任务队列" class="headerlink" title="执行栈与任务队列"></a>执行栈与任务队列</h2><h3 id="什么是执行栈"><a href="#什么是执行栈" class="headerlink" title="什么是执行栈"></a>什么是执行栈</h3><p>执行栈，也就是“调用栈”，是一种拥有 LIFO（后进先出）数据结构的栈，被用来存储代码运行时创建的所有执行上下文（全局执行上下文，局部函数执行上下文以及eval函数执行上下文）。</p><h3 id="任务"><a href="#任务" class="headerlink" title="任务"></a>任务</h3><p>为了解决js单线程在执行大量耗时代码时的问题，程序员将js的任务分为两大类：</p><h4 id="同步任务"><a href="#同步任务" class="headerlink" title="同步任务"></a>同步任务</h4><p>进入主线程执行</p><h4 id="异步任务"><a href="#异步任务" class="headerlink" title="异步任务"></a>异步任务</h4><ol><li>进入Event Table执行</li><li>当指定的事件完成时，Event Table会将这个回调函数移入Event Queue</li><li>主线程内的任务执行完毕为空，会去Event Queue读取对应的函数，进入主线程执行</li><li>上述过程会不断重复，也就是常说的Event Loop(事件循环)</li></ol><p>上述的event queue指的是就是任务队列，任务队列内存放的都是异步任务完成后要执行的函数</p><h4 id="宏任务与微任务"><a href="#宏任务与微任务" class="headerlink" title="宏任务与微任务"></a>宏任务与微任务</h4><p>任务也可以被分为宏任务与微任务两种，具体如下</p><ol><li>宏任务(macrotask)：<br> script(整体代码)、setTimeout、setInterval、UI 渲染、 I/O、postMessage、 MessageChannel、setImmediate(Node.js 环境)</li><li>微任务(microtask)：<br> Promise.then/catch、 MutaionObserver、process.nextTick(Node.js环境）</li></ol><p>那么宏任务与微任务的执行顺序是怎么样的呢？</p><p>网络上有两种说法，目前我还没有看到权威文章</p><ol><li><p>如果，我们将整个script(整体代码)也算做是一个宏任务，那么执行顺序会是</p><blockquote><p>宏任务-&gt;所有微任务-&gt;下一个宏任务</p></blockquote></li><li><p>但是如果不是的话，那么就是(目前我比较倾向于这一种)</p><blockquote><p>所有微任务-&gt;下一个宏任务</p></blockquote></li></ol><p>总之这些并不会影响代码的执行顺序</p><p>例如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">setTimeout(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">1</span>)</span><br><span class="line">&#125;,<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve,reject</span>)=&gt;</span>&#123;</span><br><span class="line">    resolve(<span class="number">2</span>);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">3</span>);</span><br><span class="line">&#125;).then(<span class="function"><span class="params">v</span>=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(v);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">4</span>;</span><br><span class="line">&#125;).then(<span class="function"><span class="params">v</span>=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(v);</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">5</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 执行结果</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="number">5</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">4</span></span><br><span class="line"><span class="number">1</span></span><br></pre></td></tr></table></figure><p>在多设置几个计时器</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">setTimeout(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">1</span>)</span><br><span class="line">&#125;,<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve,reject</span>)=&gt;</span>&#123;</span><br><span class="line">    resolve(<span class="number">2</span>);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">3</span>);</span><br><span class="line">&#125;).then(<span class="function"><span class="params">v</span>=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(v);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">4</span>;</span><br><span class="line">&#125;).then(<span class="function"><span class="params">v</span>=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(v);</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">setTimeout(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">6</span>)</span><br><span class="line">&#125;,<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve,reject</span>)=&gt;</span>&#123;</span><br><span class="line">    resolve(<span class="number">2</span>);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">3</span>);</span><br><span class="line">&#125;).then(<span class="function"><span class="params">v</span>=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(v);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">4</span>;</span><br><span class="line">&#125;).then(<span class="function"><span class="params">v</span>=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(v);</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">setTimeout(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">7</span>)</span><br><span class="line">&#125;,<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 执行结果</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="number">5</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">4</span></span><br><span class="line"><span class="number">4</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">6</span></span><br><span class="line"><span class="number">7</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;为什么js是单线程的&quot;&gt;&lt;a href=&quot;#为什么js是单线程的&quot; class=&quot;headerlink&quot; title=&quot;为什么js是单线程的&quot;&gt;&lt;/a&gt;为什么js是单线程的&lt;/h2&gt;&lt;p&gt;众所周知，JavaScript是一门单线程语言。那么，为什么js必须是单线程
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>leetcode-303 区域和检索 - 数组不可变</title>
    <link href="http://yoursite.com/2019/09/13/leetcode-303/"/>
    <id>http://yoursite.com/2019/09/13/leetcode-303/</id>
    <published>2019-09-13T11:49:46.000Z</published>
    <updated>2019-09-13T11:55:00.064Z</updated>
    
    <content type="html"><![CDATA[<h1 id="区域和检索-数组不可变"><a href="#区域和检索-数组不可变" class="headerlink" title="区域和检索 - 数组不可变"></a>区域和检索 - 数组不可变</h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>给定一个整数数组  nums，求出数组从索引 i 到 j  (i ≤ j) 范围内元素的总和，包含 i,  j 两点。</p><p>示例：</p><pre><code>给定 nums = [-2, 0, 3, -5, 2, -1]，求和函数为 sumRange()sumRange(0, 2) -&gt; 1sumRange(2, 5) -&gt; -1sumRange(0, 5) -&gt; -3</code></pre><p>说明:</p><ol><li>你可以假设数组不可变。</li><li>会多次调用 sumRange 方法。<a id="more"></a>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/range-sum-query-immutable" target="_blank" rel="noopener">https://leetcode-cn.com/problems/range-sum-query-immutable</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</li></ol><h2 id="核心思路"><a href="#核心思路" class="headerlink" title="核心思路"></a>核心思路</h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>求数组中给定范围之间的和，比如说是求i&lt;=j之间范围的和，我们可以使用前j个元素的和减去前i-1个元素的和。</p><p>题目说明会多次调用求和方法，因此，我们可以在构造函数中就将前1个元素的和到第n个元素的和保存在哈希表中</p><h3 id="解题步骤"><a href="#解题步骤" class="headerlink" title="解题步骤"></a>解题步骤</h3><ol><li>遍历数组，以当前元素下标为键名，以从第一个元素到当前元素的和作为键值来建立哈希表</li><li>返回前j个元素的和减去前i-1个元素的和</li></ol><h2 id="Coding实现"><a href="#Coding实现" class="headerlink" title="Coding实现"></a>Coding实现</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @param &#123;number[]&#125; nums</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> NumArray = <span class="function"><span class="keyword">function</span>(<span class="params">nums</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.nums=nums;</span><br><span class="line">    <span class="keyword">let</span> map=<span class="keyword">new</span> <span class="built_in">Map</span>([[<span class="number">-1</span>,<span class="number">0</span>]]),sum=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">0</span>;i&lt;nums.length;i++) &#123;</span><br><span class="line">        sum+=nums[i];</span><br><span class="line">        map.set(i,sum);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">this</span>.map=map;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** </span></span><br><span class="line"><span class="comment"> * @param &#123;number&#125; i </span></span><br><span class="line"><span class="comment"> * @param &#123;number&#125; j</span></span><br><span class="line"><span class="comment"> * @return &#123;number&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">NumArray.prototype.sumRange = <span class="function"><span class="keyword">function</span>(<span class="params">i, j</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.map.get(j)-<span class="keyword">this</span>.map.get(i<span class="number">-1</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** </span></span><br><span class="line"><span class="comment"> * Your NumArray object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * var obj = new NumArray(nums)</span></span><br><span class="line"><span class="comment"> * var param_1 = obj.sumRange(i,j)</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;区域和检索-数组不可变&quot;&gt;&lt;a href=&quot;#区域和检索-数组不可变&quot; class=&quot;headerlink&quot; title=&quot;区域和检索 - 数组不可变&quot;&gt;&lt;/a&gt;区域和检索 - 数组不可变&lt;/h1&gt;&lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h2&gt;&lt;p&gt;给定一个整数数组  nums，求出数组从索引 i 到 j  (i ≤ j) 范围内元素的总和，包含 i,  j 两点。&lt;/p&gt;
&lt;p&gt;示例：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;给定 nums = [-2, 0, 3, -5, 2, -1]，求和函数为 sumRange()

sumRange(0, 2) -&amp;gt; 1
sumRange(2, 5) -&amp;gt; -1
sumRange(0, 5) -&amp;gt; -3&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;说明:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;你可以假设数组不可变。&lt;/li&gt;
&lt;li&gt;会多次调用 sumRange 方法。
    
    </summary>
    
      <category term="leetcode题解与算法" scheme="http://yoursite.com/categories/leetcode%E9%A2%98%E8%A7%A3%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="哈希表" scheme="http://yoursite.com/tags/%E5%93%88%E5%B8%8C%E8%A1%A8/"/>
    
  </entry>
  
  <entry>
    <title>leetcode-290 单词规律</title>
    <link href="http://yoursite.com/2019/09/12/leetcode-290/"/>
    <id>http://yoursite.com/2019/09/12/leetcode-290/</id>
    <published>2019-09-12T15:02:17.000Z</published>
    <updated>2019-09-12T15:07:13.808Z</updated>
    
    <content type="html"><![CDATA[<h1 id="单词规律"><a href="#单词规律" class="headerlink" title="单词规律"></a>单词规律</h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>给定一种规律 pattern 和一个字符串 str ，判断 str 是否遵循相同的规律。</p><p>这里的 遵循 指完全匹配，例如， pattern 里的每个字母和字符串 str 中的每个非空单词之间存在着双向连接的对应规律。</p><p>示例1:</p><blockquote><p>输入: pattern = “abba”, str = “dog cat cat dog”<br>输出: true</p></blockquote><p>示例 2:</p><blockquote><p>输入:pattern = “abba”, str = “dog cat cat fish”<br>输出: false</p></blockquote><p>示例 3:</p><blockquote><p>输入: pattern = “aaaa”, str = “dog cat cat dog”<br>输出: false</p></blockquote><p>示例 4:</p><blockquote><p>输入: pattern = “abba”, str = “dog dog dog dog”<br>输出: false</p></blockquote><p>说明:<br>你可以假设 pattern 只包含小写字母， str 包含了由单个空格分隔的小写字母。 </p><a id="more"></a><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/word-pattern" target="_blank" rel="noopener">https://leetcode-cn.com/problems/word-pattern</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p><h2 id="核心思路"><a href="#核心思路" class="headerlink" title="核心思路"></a>核心思路</h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>判断两个字符串是否完全匹配，也就是二者中的每个元素要互相对应，因此，我们可以使用哈希表来进行配对与比较</p><h3 id="解题步骤"><a href="#解题步骤" class="headerlink" title="解题步骤"></a>解题步骤</h3><ol><li>将str字符串通过split(‘ ‘)方法转化为字符串数组</li><li>遍历两个字符串，以pattern元素为键名，字符串数组对应元素作为键值，如果遇到冲突那么返回false</li><li>遍历两个字符串，以字符串数组元素为键名，pattern对应元素作为键值，如果遇到冲突那么返回false</li><li>返回true</li></ol><h2 id="Coding实现"><a href="#Coding实现" class="headerlink" title="Coding实现"></a>Coding实现</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @param &#123;string&#125; pattern</span></span><br><span class="line"><span class="comment"> * @param &#123;string&#125; str</span></span><br><span class="line"><span class="comment"> * @return &#123;boolean&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> wordPattern = <span class="function"><span class="keyword">function</span>(<span class="params">pattern, str</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> strArr=str.split(<span class="string">' '</span>);</span><br><span class="line">    <span class="keyword">let</span> map=<span class="keyword">new</span> <span class="built_in">Map</span>();</span><br><span class="line">    <span class="keyword">if</span>(pattern.length!==strArr.length) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">0</span>;i&lt;pattern.length;i++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(!map.has(pattern[i])) &#123;</span><br><span class="line">            map.set(pattern[i],strArr[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span>(map.get(pattern[i])!==strArr[i]) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    map.clear();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">0</span>;i&lt;strArr.length;i++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(!map.has(strArr[i])) &#123;</span><br><span class="line">            map.set(strArr[i],pattern[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span>(map.get(strArr[i])!==pattern[i]) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;单词规律&quot;&gt;&lt;a href=&quot;#单词规律&quot; class=&quot;headerlink&quot; title=&quot;单词规律&quot;&gt;&lt;/a&gt;单词规律&lt;/h1&gt;&lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h2&gt;&lt;p&gt;给定一种规律 pattern 和一个字符串 str ，判断 str 是否遵循相同的规律。&lt;/p&gt;
&lt;p&gt;这里的 遵循 指完全匹配，例如， pattern 里的每个字母和字符串 str 中的每个非空单词之间存在着双向连接的对应规律。&lt;/p&gt;
&lt;p&gt;示例1:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;输入: pattern = “abba”, str = “dog cat cat dog”&lt;br&gt;输出: true&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;示例 2:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;输入:pattern = “abba”, str = “dog cat cat fish”&lt;br&gt;输出: false&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;示例 3:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;输入: pattern = “aaaa”, str = “dog cat cat dog”&lt;br&gt;输出: false&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;示例 4:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;输入: pattern = “abba”, str = “dog dog dog dog”&lt;br&gt;输出: false&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;说明:&lt;br&gt;你可以假设 pattern 只包含小写字母， str 包含了由单个空格分隔的小写字母。 &lt;/p&gt;
    
    </summary>
    
      <category term="leetcode题解与算法" scheme="http://yoursite.com/categories/leetcode%E9%A2%98%E8%A7%A3%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="哈希表" scheme="http://yoursite.com/tags/%E5%93%88%E5%B8%8C%E8%A1%A8/"/>
    
  </entry>
  
  <entry>
    <title>leetcode-278 第一个错误的版本</title>
    <link href="http://yoursite.com/2019/09/11/leetcode-278/"/>
    <id>http://yoursite.com/2019/09/11/leetcode-278/</id>
    <published>2019-09-11T13:00:50.000Z</published>
    <updated>2019-09-11T13:07:27.386Z</updated>
    
    <content type="html"><![CDATA[<h1 id="第一个错误的版本"><a href="#第一个错误的版本" class="headerlink" title="第一个错误的版本"></a>第一个错误的版本</h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>你是产品经理，目前正在带领一个团队开发新的产品。不幸的是，你的产品的最新版本没有通过质量检测。由于每个版本都是基于之前的版本开发的，所以错误的版本之后的所有版本都是错的。</p><p>假设你有 n 个版本 [1, 2, …, n]，你想找出导致之后所有版本出错的第一个错误的版本。</p><p>你可以通过调用 bool isBadVersion(version) 接口来判断版本号 version 是否在单元测试中出错。实现一个函数来查找第一个错误的版本。你应该尽量减少对调用 API 的次数。</p><p>示例:</p><pre><code>给定 n = 5，并且 version = 4 是第一个错误的版本。调用 isBadVersion(3) -&gt; false调用 isBadVersion(5) -&gt; true调用 isBadVersion(4) -&gt; true所以，4 是第一个错误的版本。 </code></pre><a id="more"></a><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/first-bad-version" target="_blank" rel="noopener">https://leetcode-cn.com/problems/first-bad-version</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p><h2 id="核心思路"><a href="#核心思路" class="headerlink" title="核心思路"></a>核心思路</h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>该题考查的是二分查找的思想。不过需要注意边界处理。当isBadVersion(mid)的值为false时说明，第一个坏掉的产品肯定在mid后，因此left=mid+1;注意的是：当isBadVersion(mid)的值为true时，此时的mid值可能就是那个坏掉的第一个产品，因此，right=mid，而不是right=mid-1</p><h3 id="解题步骤"><a href="#解题步骤" class="headerlink" title="解题步骤"></a>解题步骤</h3><ol><li>设立left=1,right=n</li><li>取mid=Math.floor((left+right)/2)</li><li>如果isBadVersion(mid)的值为false时则left=mid+1;</li><li>如果isBadVersion(mid)的值为true时则right=mid</li><li>重复2,3步骤直到left===right</li><li>返回left</li></ol><h2 id="Coding实现"><a href="#Coding实现" class="headerlink" title="Coding实现"></a>Coding实现</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for isBadVersion()</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * @param &#123;integer&#125; version number</span></span><br><span class="line"><span class="comment"> * @return &#123;boolean&#125; whether the version is bad</span></span><br><span class="line"><span class="comment"> * isBadVersion = function(version) &#123;</span></span><br><span class="line"><span class="comment"> *     ...</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @param &#123;function&#125; isBadVersion()</span></span><br><span class="line"><span class="comment"> * @return &#123;function&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> solution = <span class="function"><span class="keyword">function</span>(<span class="params">isBadVersion</span>) </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * @param &#123;integer&#125; n Total versions</span></span><br><span class="line"><span class="comment">     * @return &#123;integer&#125; The first bad version</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">n</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">let</span> left=<span class="number">1</span>,right=n,mid;</span><br><span class="line">        <span class="keyword">while</span>(left&lt;right) &#123;</span><br><span class="line">            mid=<span class="built_in">Math</span>.floor((left+right)/<span class="number">2</span>);</span><br><span class="line">            <span class="keyword">if</span>(isBadVersion(mid)===<span class="literal">false</span>) &#123;</span><br><span class="line">                left=mid+<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                right=mid;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> left;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;第一个错误的版本&quot;&gt;&lt;a href=&quot;#第一个错误的版本&quot; class=&quot;headerlink&quot; title=&quot;第一个错误的版本&quot;&gt;&lt;/a&gt;第一个错误的版本&lt;/h1&gt;&lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h2&gt;&lt;p&gt;你是产品经理，目前正在带领一个团队开发新的产品。不幸的是，你的产品的最新版本没有通过质量检测。由于每个版本都是基于之前的版本开发的，所以错误的版本之后的所有版本都是错的。&lt;/p&gt;
&lt;p&gt;假设你有 n 个版本 [1, 2, …, n]，你想找出导致之后所有版本出错的第一个错误的版本。&lt;/p&gt;
&lt;p&gt;你可以通过调用 bool isBadVersion(version) 接口来判断版本号 version 是否在单元测试中出错。实现一个函数来查找第一个错误的版本。你应该尽量减少对调用 API 的次数。&lt;/p&gt;
&lt;p&gt;示例:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;给定 n = 5，并且 version = 4 是第一个错误的版本。

调用 isBadVersion(3) -&amp;gt; false
调用 isBadVersion(5) -&amp;gt; true
调用 isBadVersion(4) -&amp;gt; true

所以，4 是第一个错误的版本。 &lt;/code&gt;&lt;/pre&gt;
    
    </summary>
    
      <category term="leetcode题解与算法" scheme="http://yoursite.com/categories/leetcode%E9%A2%98%E8%A7%A3%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="二分查找" scheme="http://yoursite.com/tags/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/"/>
    
  </entry>
  
  <entry>
    <title>mpvue踩坑记</title>
    <link href="http://yoursite.com/2019/09/11/mpvue%E8%B8%A9%E5%9D%91%E8%AE%B0/"/>
    <id>http://yoursite.com/2019/09/11/mpvue踩坑记/</id>
    <published>2019-09-11T08:15:57.000Z</published>
    <updated>2019-09-11T10:13:21.723Z</updated>
    
    <content type="html"><![CDATA[<h2 id="页面跳转"><a href="#页面跳转" class="headerlink" title="页面跳转"></a>页面跳转</h2><ol><li>微信官方接口</li><li>mpvue接口</li></ol><h2 id="组件传值"><a href="#组件传值" class="headerlink" title="组件传值"></a>组件传值</h2><p>当将其他子组件引入到某个父组件中的时候，那么就需要组件之间进行传值，否则父组件无法获得子组件定义的值</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;页面跳转&quot;&gt;&lt;a href=&quot;#页面跳转&quot; class=&quot;headerlink&quot; title=&quot;页面跳转&quot;&gt;&lt;/a&gt;页面跳转&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;微信官方接口&lt;/li&gt;
&lt;li&gt;mpvue接口&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&quot;组件传值&quot;&gt;&lt;a href
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Promise与异步编程</title>
    <link href="http://yoursite.com/2019/09/10/Promise%E4%B8%8E%E5%BC%82%E6%AD%A5%E7%BC%96%E7%A8%8B/"/>
    <id>http://yoursite.com/2019/09/10/Promise与异步编程/</id>
    <published>2019-09-10T05:49:09.000Z</published>
    <updated>2019-09-13T12:20:54.745Z</updated>
    
    <content type="html"><![CDATA[<h2 id="什么是异步编程"><a href="#什么是异步编程" class="headerlink" title="什么是异步编程"></a>什么是异步编程</h2><p>异步编程是什么？为什么需要异步编程；这都要从同步说起</p><p>因为JavaScript语言是一门单线程语言。我们只能在一个线程上运行任务，该线程被称之为主线程。就像下面的例子一样，代码是按照顺序执行的</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span> <span class="title">getA</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    a=<span class="number">1</span>;</span><br><span class="line">&#125;)()</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(a); <span class="comment">// 1</span></span><br></pre></td></tr></table></figure><p>显然的是，以上会先执行getA函数并设置全局变量a=1，然后就会输出a=1;</p><p>但是，我们有没有想过一个问题，如果a的值不是我们自己先行设置的，而是向某服务器请求某资源后再赋值的呢？就像下面这样：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 引入axios</span></span><br><span class="line"><span class="keyword">const</span> axios=<span class="built_in">require</span>(<span class="string">"axios"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 声明变量a</span></span><br><span class="line"><span class="keyword">let</span> a;</span><br><span class="line"></span><br><span class="line">(<span class="function"><span class="keyword">function</span> <span class="title">getA</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    axios.get(<span class="string">'http://www.baidu.com'</span>).then(<span class="function">(<span class="params">content</span>)=&gt;</span>&#123;</span><br><span class="line">        a=<span class="number">1</span>;</span><br><span class="line">    &#125;).catch(<span class="function">(<span class="params">err</span>)=&gt;</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(err);</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;)()</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(a); <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure><p>我们会发现，这时候输出并不是1，而是undefined。这是为什么呢？难道代码不是顺序执行的吗？我们尝试着分析一下以上代码，我们首先声明了变量a但未定义，之后我们进入了getA()函数，在该函数中我们利用了axios工具去请求百度站点的信息。到这里，都没有任何问题。但是，去请求资源，我们都知道网络情况是不确定的，我们不知道这一过程会花费多少时间，因此我们会将该异步任务放入另一个任务队列中，当该任务完成后（也就是请求成功或请求失败）再放入主线程队列去执行相应的函数。但是，主线程也是按照队列的顺序依次来执行的，因此只有当主线程内的所有任务执行完毕后我们才能执行异步任务返回的函数代码。</p><p>getA()函数与console.log(a)都是主线程内的任务，因此，执行顺序就会是：</p><blockquote><p>getA() -&gt; console.log(a) -&gt; 异步任务完成后要执行的操作</p></blockquote><p>这就是异步编程，我们的程序中可能会有一些要造成阻塞的代码（请求外部资源之类），如果是同步的话，那么在请求完成之前我们都无法继续执行下面的程序，但是如果异步编程。将异步任务放入一个异步任务队列，等该异步任务完成后再将其放入主线程任务队列，这样的话，在请求资源的过程中，我们仍旧可以运行后面的程序</p><h2 id="异步编程具有的几种形式"><a href="#异步编程具有的几种形式" class="headerlink" title="异步编程具有的几种形式"></a>异步编程具有的几种形式</h2><h3 id="事件监听"><a href="#事件监听" class="headerlink" title="事件监听"></a>事件监听</h3><p>在进行事件操作的时候，例如用户点击按钮就会触发一个click事件。当点击按钮之后，onclick事件所要执行的任务就会放入异步任务队列中，只有当主线程内的所有任务完成后它才会被执行</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">let</span> button=<span class="built_in">document</span>.getElementById(<span class="string">'btn'</span>);</span><br><span class="line">button.onclick=<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'Button is clicked'</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(a); </span><br><span class="line"></span><br><span class="line"><span class="comment">// 执行结果</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line">Button is clicked</span><br></pre></td></tr></table></figure><p>click单击事件一开始就会被注册，但是只有被监听到click事件发生后才会执行click需要响应的操作</p><h3 id="回调模式"><a href="#回调模式" class="headerlink" title="回调模式"></a>回调模式</h3><p>什么是回调函数？</p><p>一个回调函数，也被称为高阶函数，是一个被作为参数传递给另一个函数的函数，回调函数在另外一个函数中被调用。一个回调函数本质上是一种编程模式（为一个常见问题创建的解决方案），因此，使用回调函数也叫做回调模式。</p><p>例如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">func</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'回调函数'</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">(<span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params">a,func</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(a); <span class="comment">// 1</span></span><br><span class="line">    func(); <span class="comment">// '回调函数'</span></span><br><span class="line">&#125;)(<span class="number">1</span>,func)</span><br></pre></td></tr></table></figure><p>func函数被作为参数传递给test函数并被其调用，那么func函数就被称之为回调函数</p><p>在Node.js中有大量的异步代码，因此，会大量使用回调函数来优化异步编程</p><p>例如，下面的读取文件操作</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> fs=<span class="built_in">require</span>(<span class="string">'fs'</span>);</span><br><span class="line"></span><br><span class="line">fs.readfile(<span class="string">'example.txt'</span>,<span class="function"><span class="keyword">function</span>(<span class="params">err,contents</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(err) &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(err);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="built_in">console</span>.log(contents);</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 执行结果</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line">example.txt内的内容或者是报错内容</span><br></pre></td></tr></table></figure><p>上述代码在执行readFile()函数后，发现这是一个异步任务，那么就将该异步任务放入异步任务队列，等到执行完毕后再放入到主线程任务队列等待执行。</p><p>readFile()函数的功能：</p><p>readFile()函数执行，然后就去读取给定的文件，读取结束后会执行回调函数。如果出现错误，就会将错误对象赋值给回调函数中的err参数；如果一切正常，文件内容就会字符串的形式赋值给contents参数</p><p>可能有些人会不理解为什么在一个函数a中将另一个函数b作为参数，这个函数b会被执行。因为，这个readFile()函数是Node.js中的一个api</p><p>接口大致意思可能如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">readFile</span>(<span class="params">fileName,func</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 读取fileName文件</span></span><br><span class="line">    <span class="keyword">if</span>(success) &#123;</span><br><span class="line">        contents=<span class="string">'文件内容'</span>;</span><br><span class="line">        err=<span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> err=<span class="string">'失败原因'</span>;</span><br><span class="line">    func(err,contents);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="事件发布与订阅"><a href="#事件发布与订阅" class="headerlink" title="事件发布与订阅"></a>事件发布与订阅</h3><h3 id="Promise"><a href="#Promise" class="headerlink" title="Promise"></a>Promise</h3><p>Promise 对象是一个代理对象（代理一个值），被代理的值在Promise对象创建时可能是未知的。它允许你为异步操作的成功和失败分别绑定相应的处理方法。 这让异步方法可以像同步方法那样返回值，但并不是立即返回最终执行结果，而是一个能代表未来出现的结果的promise对象</p><h4 id="Promise的生命周期"><a href="#Promise的生命周期" class="headerlink" title="Promise的生命周期"></a>Promise的生命周期</h4><p>promise对象的生命周期包括以下三种：</p><ol><li>进行中 pending</li><li>已完成 fulfilled/resolved</li><li>被拒绝(未能成功完成) rejected</li></ol><h4 id="Promise构造函数创建promise"><a href="#Promise构造函数创建promise" class="headerlink" title="Promise构造函数创建promise"></a>Promise构造函数创建promise</h4><p>用Promise构造函数可以创建一个promise，构造函数只接受一个参数，也就是包含初始化Promise代码的执行器函数。该执行器函数接受两个参数，分别是resolve函数和rejected函数。执行器成功完成时调用resolve函数，失败时调用reject函数</p><p>例如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> fs=<span class="built_in">require</span>(<span class="string">'fs'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 异步读取文件内容</span></span><br><span class="line"><span class="keyword">let</span> promise=<span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve,reject</span>)=&gt;</span>&#123;</span><br><span class="line">    fs.readFile(<span class="string">'test.js'</span>,<span class="string">'utf8'</span>,(err,contents)=&gt;&#123;</span><br><span class="line">        <span class="keyword">if</span>(err) &#123;</span><br><span class="line">            reject(err);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            resolve(contents);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">promise.then(<span class="function"><span class="params">contents</span>=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(contents); <span class="comment">// test</span></span><br><span class="line">&#125;,err=&gt;&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(err);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>通过Promise构造函数创建了一个promise对象，之后便会执行执行器函数，同时异步操作开始。当异步操作结束后，会调用异步操作中的回调函数，如果操作成功那么将成功获得的数据作为参数传递给resolved函数，如果失败那么将失败信息传递给rejected函数。</p><p>promise对象调用then()方法和catch()方法时，会创建一个新任务放入一个任务队列中，只有监听到promise被解决后才会被执行</p><h4 id="then-与catch"><a href="#then-与catch" class="headerlink" title="then()与catch()"></a>then()与catch()</h4><p>then() 方法返回一个  Promise 。它最多需要有两个参数：Promise 的成功和失败情况的回调函数。</p><p>catch() 方法返回一个  Promise 。它接受一个参数：失败情况的回调函数。</p><p>then()方法和catch()方法一起使用才更加方便和清晰地处理异步操作结果</p><p>例如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> fs=<span class="built_in">require</span>(<span class="string">'fs'</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> promise=<span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve,reject</span>)=&gt;</span>&#123;</span><br><span class="line">    fs.readFile(<span class="string">'test.js'</span>,<span class="string">'utf8'</span>,(err,contents)=&gt;&#123;</span><br><span class="line">        <span class="keyword">if</span>(err) &#123;</span><br><span class="line">            reject(err);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            resolve(contents);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">promise.then(<span class="function"><span class="params">contents</span>=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(contents);</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">promise.catch(<span class="function"><span class="params">err</span>=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(err);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h4 id="Promise-resolve-和Promise-reject-创建已处理的promise"><a href="#Promise-resolve-和Promise-reject-创建已处理的promise" class="headerlink" title="Promise.resolve()和Promise.reject()创建已处理的promise"></a>Promise.resolve()和Promise.reject()创建已处理的promise</h4><p>我们可以使用Promise.resolve()来创建已处理的成功完成的promise</p><blockquote><p>Promise.resolve(value)方法返回一个以给定值解析后的Promise 对象。如果该值为promise，返回这个promise；如果这个值是thenable（即带有”then” 方法)），返回的promise会“跟随”这个thenable的对象，采用它的最终状态；否则返回的promise将以此值完成。此函数将类promise对象的多层嵌套展平。</p></blockquote><p>我们也可以使用Promise.reject()来创建已处理的拒绝态的promise</p><p>例如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 返回给定的promise对象</span></span><br><span class="line"><span class="keyword">let</span> promise=<span class="built_in">Promise</span>.resolve(<span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve,reject</span>)=&gt;</span>&#123;</span><br><span class="line">    resolve(<span class="number">1</span>);</span><br><span class="line">&#125;))</span><br><span class="line"></span><br><span class="line">promise.then(<span class="function"><span class="params">v</span>=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(v); <span class="comment">// 1</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h4 id="执行器错误"><a href="#执行器错误" class="headerlink" title="执行器错误"></a>执行器错误</h4><p>如果执行器函数内部发生错误，那么promise的拒绝处理程序就会被调用。</p><p>例如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> promise=<span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve,reject</span>)=&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'err'</span>);</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">promise.catch(<span class="function"><span class="params">err</span>=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(err); <span class="comment">// 'err'</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>因为，每个执行器函数中都隐含着一个try…catch块，所以所有的错误都会被捕获并传入拒绝处理程序,以上示例相当于：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> promise=<span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve,reject</span>)=&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'err'</span>); </span><br><span class="line">    &#125; <span class="keyword">catch</span> (err) &#123;</span><br><span class="line">        reject(err);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">promise.catch(<span class="function"><span class="params">err</span>=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(err); <span class="comment">// 'err'</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h4 id="串联Promise"><a href="#串联Promise" class="headerlink" title="串联Promise"></a>串联Promise</h4><p>前面提到过每次调用then()方法或者catch()方法都会创建并返回了另一个Promise，只有当第一个promise完成或被拒绝后才会去解决之后的promise</p><p>调用then()方法返回的promise按照以下规则被创建：<br>当一个Promise完成（fulfilled）或者失败（rejected），返回函数将被异步调用（由当前的线程循环来调度完成）。具体的返回值依据以下规则返回：</p><ol><li>如果then中的回调函数返回一个值，那么then返回的Promise将会成为接受状态，并且将返回的值作为接受状态的回调函数的参数值。</li><li>如果then中的回调函数没有返回值，那么then返回的Promise将会成为接受状态，并且该接受状态的回调函数的参数值为 undefined。</li><li>如果then中的回调函数抛出一个错误，那么then返回的Promise将会成为拒绝状态，并且将抛出的错误作为拒绝状态的回调函数的参数值。</li><li>如果then中的回调函数返回一个已经是接受状态的Promise，那么then返回的Promise也会成为接受状态，并且将那个Promise的接受状态的回调函数的参数值作为该被返回的Promise的接受状态回调函数的参数值。</li><li>如果then中的回调函数返回一个已经是拒绝状态的Promise，那么then返回的Promise也会成为拒绝状态，并且将那个Promise的拒绝状态的回调函数的参数值作为该被返回的Promise的拒绝状态回调函数的参数值。</li><li>如果then中的回调函数返回一个未定状态（pending）的Promise，那么then返回Promise的状态也是未定的，并且它的终态与那个Promise的终态相同；同时，它变为终态时调用的回调函数参数与那个Promise变为终态时的回调函数的参数是相同的。</li></ol><p>调用catch()方法返回的是一个带有错误原因的promise</p><p>例如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建一个已处理的promise</span></span><br><span class="line"><span class="keyword">let</span> promise=<span class="built_in">Promise</span>.resolve(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 不返回任何值</span></span><br><span class="line">promise.then(<span class="function"><span class="params">v</span>=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(v); <span class="comment">// 1</span></span><br><span class="line">&#125;).then(<span class="function"><span class="params">v</span>=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(v); <span class="comment">// undefined</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回一个值</span></span><br><span class="line">promise.then(<span class="function"><span class="params">v</span>=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(v); <span class="comment">// 1</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">&#125;).then(<span class="function"><span class="params">v</span>=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(v); <span class="comment">// 2</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 抛出错误在promise链的下一个拒绝处理程序中捕获</span></span><br><span class="line">promise.then(<span class="function"><span class="params">v</span>=&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'err'</span>);</span><br><span class="line">&#125;).catch(<span class="function"><span class="params">v</span>=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(v); <span class="comment">// err</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>就像上述的第三个例子，在已完成处理程序中抛出了错误，我们可以使用then…catch来捕获错误。因此，在实际编程时，为了防止某些未知的错误而造成程序崩溃，我们要使用then…catch来捕获未知错误</p><h5 id="promise链中传递数据"><a href="#promise链中传递数据" class="headerlink" title="promise链中传递数据"></a>promise链中传递数据</h5><p>在上面提过，在调用then()方法和catch()方法的处理程序中，如果return某些值，是会作为返回的promise对象的执行函数的参数值，因此，我们可以在promise链中往下游传递数据</p><p>例如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> promise=<span class="built_in">Promise</span>.resolve(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">promise.then(<span class="function"><span class="params">v</span>=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(v); <span class="comment">// 1</span></span><br><span class="line">    <span class="keyword">return</span> v+<span class="number">1</span>; <span class="comment">// 返回一个值</span></span><br><span class="line">&#125;).then(<span class="function"><span class="params">v</span>=&gt;</span>&#123; <span class="comment">// 接收到这个值</span></span><br><span class="line">    <span class="built_in">console</span>.log(v); <span class="comment">// 2</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h4 id="在处理程序中return一个promise"><a href="#在处理程序中return一个promise" class="headerlink" title="在处理程序中return一个promise"></a>在处理程序中return一个promise</h4><ol><li>如果then中的回调函数返回一个已经是接受状态的Promise，那么then返回的Promise也会成为接受状态，并且将那个Promise的接受状态的回调函数的参数值作为该被返回的Promise的接受状态回调函数的参数值。</li><li>如果then中的回调函数返回一个已经是拒绝状态的Promise，那么then返回的Promise也会成为拒绝状态，并且将那个Promise的拒绝状态的回调函数的参数值作为该被返回的Promise的拒绝状态回调函数的参数值。</li><li>如果then中的回调函数返回一个未定状态（pending）的Promise，那么then返回Promise的状态也是未定的，并且它的终态与那个Promise的终态相同；同时，它变为终态时调用的回调函数参数与那个Promise变为终态时的回调函数的参数是相同的。</li></ol><p>例如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> p1=<span class="built_in">Promise</span>.resolve(<span class="number">1</span>);</span><br><span class="line"><span class="keyword">let</span> p2=<span class="built_in">Promise</span>.reject(<span class="string">'err'</span>);</span><br><span class="line"></span><br><span class="line">p1.then(<span class="function"><span class="params">v</span>=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(v); <span class="comment">// 1</span></span><br><span class="line">    <span class="keyword">return</span> p2; <span class="comment">// 返回一个拒绝态的promise</span></span><br><span class="line">&#125;).catch(<span class="function"><span class="params">v</span>=&gt;</span>&#123; <span class="comment">// 接收到拒绝态promise传过来的错误原因</span></span><br><span class="line">    <span class="built_in">console</span>.log(v); <span class="comment">// 'err'</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h4 id="响应多个Promise"><a href="#响应多个Promise" class="headerlink" title="响应多个Promise"></a>响应多个Promise</h4><h5 id="Promise-all"><a href="#Promise-all" class="headerlink" title="Promise.all()"></a>Promise.all()</h5><p>Promise.all()方法接受一个参数并返回一个promise，该参数是一个含有多个受监视Promise的可迭代对象（例如，一个数组），只有可迭代对象中的所有promise被成功解决(resolved态)后返回的promise才会被解决</p><p>注意：</p><ol><li>如果传入的可迭代对象为空，Promise.all 会同步地返回一个已完成（resolved）状态的promise。</li><li>在任何情况下，Promise.all 返回的 promise 的完成状态的结果都是一个数组，它包含所有的传入迭代参数对象的值（也包括非 promise 值）。</li></ol><p>例如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> p1=<span class="built_in">Promise</span>.resolve(<span class="number">1</span>);</span><br><span class="line"><span class="keyword">let</span> p2=<span class="built_in">Promise</span>.resolve(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">Promise</span>.all([p1,p2]).then(<span class="function"><span class="params">v</span>=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(v); <span class="comment">// [1,2]</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>当然，只要所有传入的promise对象中有一个被拒绝，那么Promise.all()方法返回的promise对象就会被立刻拒绝</p><p>拒绝处理程序总是接受一个值而非数组，该值来自于被拒绝promise的拒绝值</p><p>例如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> p1=<span class="built_in">Promise</span>.resolve(<span class="number">1</span>);</span><br><span class="line"><span class="keyword">let</span> p2=<span class="built_in">Promise</span>.resolve(<span class="number">2</span>);</span><br><span class="line"><span class="comment">// 拒绝态promise</span></span><br><span class="line"><span class="keyword">let</span> p3=<span class="built_in">Promise</span>.reject(<span class="number">3</span>);</span><br><span class="line"><span class="keyword">let</span> p4=<span class="built_in">Promise</span>.resolve(<span class="number">4</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="keyword">set</span>=new Set([p1,p2,p3,p4]);</span><br><span class="line"></span><br><span class="line">Promise.all(<span class="keyword">set</span>).then(v=&gt;&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(v);</span><br><span class="line">&#125;).catch(<span class="function"><span class="params">err</span>=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(err); <span class="comment">// 3</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h5 id="Promise-race"><a href="#Promise-race" class="headerlink" title="Promise.race()"></a>Promise.race()</h5><p>Promise.race()同样也是接受一个包含多个promise的可迭代对象，但是，一旦迭代器中的某个promise解决或拒绝，返回的 promise就会解决或拒绝。</p><blockquote><p>一个待定的 Promise 只要给定的迭代中的一个promise解决或拒绝，返回的promise就采用第一个promise的值作为它的值，从而异步地解析或拒绝</p></blockquote><p>例如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// p1在2000毫秒后成为已成功处理的promise</span></span><br><span class="line"><span class="keyword">let</span> p1=<span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve,reject</span>)=&gt;</span>&#123;</span><br><span class="line">    setTimeout(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">        resolve(<span class="number">1</span>);</span><br><span class="line">    &#125;,<span class="number">2000</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建已完成拒绝态promise</span></span><br><span class="line"><span class="keyword">let</span> p2=<span class="built_in">Promise</span>.reject(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建已完成resolved态promise</span></span><br><span class="line"><span class="keyword">let</span> p3=<span class="built_in">Promise</span>.resolve(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">Promise</span>.race([p1,p2,p3]).then(<span class="function"><span class="params">v</span>=&gt;</span>&#123;</span><br><span class="line">    consoel.log(v);</span><br><span class="line">&#125;).catch(<span class="function"><span class="params">err</span>=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(err); <span class="comment">// 2</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>因为，p1在2000毫秒后才会成为已成功处理的promise,p2,p3都是已完成处理程序，但是p2先于p3被添加到处理队列中</p><p>需要注意的是，可迭代对象中promise的顺序也可能会对结果产生影响</p><p>例如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> p1=<span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve,reject</span>)=&gt;</span>&#123;</span><br><span class="line">    setTimeout(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">        resolve(<span class="number">1</span>);</span><br><span class="line">    &#125;,<span class="number">2000</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> p2=<span class="built_in">Promise</span>.reject(<span class="number">2</span>);</span><br><span class="line"><span class="keyword">let</span> p3=<span class="built_in">Promise</span>.resolve(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调换p2,p3的先后顺序</span></span><br><span class="line"><span class="built_in">Promise</span>.race([p1,p3,p2]).then(<span class="function"><span class="params">v</span>=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(v); <span class="comment">// 3</span></span><br><span class="line">&#125;).catch(<span class="function"><span class="params">err</span>=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(err);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="async-await"><a href="#async-await" class="headerlink" title="async/await"></a>async/await</h3><ol><li><p>async function 用来定义一个返回 AsyncFunction 对象的异步函数。异步函数是指通过事件循环异步执行的函数，它会通过一个隐式的 Promise 返回其结果。</p></li><li><p>await  操作符用于等待一个Promise 对象。它只能在异步函数 async function 中使用。</p></li><li><p>async 函数返回一个 Promise 对象</p></li><li><p>async 函数内部 return 返回的值。会成为 then 方法回调函数的参数。</p></li></ol><p>例如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">await</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve,reject</span>)=&gt;</span>&#123;</span><br><span class="line">        resolve(<span class="number">1</span>);</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">f().then(<span class="function"><span class="params">v</span>=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(v); <span class="comment">// 1</span></span><br><span class="line">&#125;).catch(<span class="function"><span class="params">err</span>=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(err);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;什么是异步编程&quot;&gt;&lt;a href=&quot;#什么是异步编程&quot; class=&quot;headerlink&quot; title=&quot;什么是异步编程&quot;&gt;&lt;/a&gt;什么是异步编程&lt;/h2&gt;&lt;p&gt;异步编程是什么？为什么需要异步编程；这都要从同步说起&lt;/p&gt;
&lt;p&gt;因为JavaScript语言是一
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>数组创建的改进</title>
    <link href="http://yoursite.com/2019/09/09/%E6%95%B0%E7%BB%84%E5%88%9B%E5%BB%BA%E7%9A%84%E6%94%B9%E8%BF%9B/"/>
    <id>http://yoursite.com/2019/09/09/数组创建的改进/</id>
    <published>2019-09-09T08:05:36.000Z</published>
    <updated>2019-09-09T08:57:11.923Z</updated>
    
    <content type="html"><![CDATA[<h2 id="ES6之前数组创建的一些问题"><a href="#ES6之前数组创建的一些问题" class="headerlink" title="ES6之前数组创建的一些问题"></a>ES6之前数组创建的一些问题</h2><p>在ES6之前，数组的创建具有以下的一些问题</p><ol><li>通过Array构造函数创建数组时具有一些怪异的行为</li><li>没有现成的方法可以将类数组对象（具有数值型索引和length属性的对象）和可迭代对象转化为数组</li></ol><h3 id="Array构造函数的一些怪异行为"><a href="#Array构造函数的一些怪异行为" class="headerlink" title="Array构造函数的一些怪异行为"></a>Array构造函数的一些怪异行为</h3><p>Array构造函数具有以下怪异行为</p><ol><li><p>如果给Array构造函数传入一个数值型的值，此时，并不是创建一个包含该数值的数组，而是创建一个数组，将该数组的length属性设置为该值。那么显然数组内的所有元素都会是undefined</p> <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr=<span class="keyword">new</span> <span class="built_in">Array</span>(<span class="number">2</span>);</span><br><span class="line"><span class="built_in">console</span>.log(arr); <span class="comment">// [undefined,undefined]</span></span><br><span class="line"><span class="built_in">console</span>.log(arr.length); <span class="comment">// 2</span></span><br></pre></td></tr></table></figure></li><li><p>相对于上一点，如果传入一个非数值类型的值，那么就符合常规的想法，会创建一个包含该值的数组</p> <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr=<span class="keyword">new</span> <span class="built_in">Array</span>(<span class="string">'man'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(arr); <span class="comment">// ['man']</span></span><br><span class="line"><span class="built_in">console</span>.log(arr.length); <span class="comment">// 1</span></span><br></pre></td></tr></table></figure></li><li><p>最后，如果传入了多个值，那么不管这些值中是否有数值类型，所有的值都会变为创建的数组的元素</p> <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr=<span class="keyword">new</span> <span class="built_in">Array</span>(<span class="number">2</span>,<span class="string">'man'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(arr); <span class="comment">// [2,'man']</span></span><br><span class="line"><span class="built_in">console</span>.log(arr.length); <span class="comment">// 2</span></span><br></pre></td></tr></table></figure></li></ol><p>因为Array构造函数具有以上的一些怪异特性，因此ES6通过引入Array.of()方法来解决这个问题</p><h3 id="ES5实现将类数组对象转化为数组对象"><a href="#ES5实现将类数组对象转化为数组对象" class="headerlink" title="ES5实现将类数组对象转化为数组对象"></a>ES5实现将类数组对象转化为数组对象</h3><p>对于类数组对象，在ES5中我们可以采用以下的方式来将其转化为数组对象</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a=&#123;</span><br><span class="line">    <span class="number">0</span>:<span class="number">1</span>,</span><br><span class="line">    <span class="number">1</span>:<span class="number">2</span>,</span><br><span class="line">    length:<span class="number">2</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getArray</span>(<span class="params">obj</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> ans=[];</span><br><span class="line">    <span class="comment">// 类数组对象具有数值型索引和length属性</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">0</span>;i&lt;obj.length;i++) &#123;</span><br><span class="line">        ans.push(obj[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(getArray(a)); <span class="comment">// [1,2]</span></span><br></pre></td></tr></table></figure><p>除此之外，我们还可以利用数组方法slice()的一个特性：</p><blockquote><p>slice 方法可以用来将一个类数组（Array-like）对象/集合转换成一个新数组。</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a=&#123;</span><br><span class="line">    <span class="number">0</span>:<span class="number">1</span>,</span><br><span class="line">    <span class="number">1</span>:<span class="number">2</span>,</span><br><span class="line">    length:<span class="number">2</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getArray</span>(<span class="params">obj</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Array</span>.prototype.slice.call(obj);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(getArray(a)); <span class="comment">// [1,2]</span></span><br></pre></td></tr></table></figure><h2 id="ES6对于数组创建的改进"><a href="#ES6对于数组创建的改进" class="headerlink" title="ES6对于数组创建的改进"></a>ES6对于数组创建的改进</h2><h3 id="Array-of-方法对于Array构造函数的改进"><a href="#Array-of-方法对于Array构造函数的改进" class="headerlink" title="Array.of()方法对于Array构造函数的改进"></a>Array.of()方法对于Array构造函数的改进</h3><p>ES6通过引入Array.of()方法来解决Array构造函数出现的一些怪异行为</p><h4 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h4><p>Array.of() 方法创建一个具有可变数量参数的新数组实例，而不考虑参数的数量或类型。</p><p> Array.of() 和 Array 构造函数之间的区别在于处理整数参数：Array.of(7) 创建一个具有单个元素 7 的数组，而 Array(7) 创建一个长度为7的空数组（注意：这是指一个有7个空位(empty)的数组，而不是由7个undefined组成的数组）。</p><h4 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h4><blockquote><p>Array.of(element0[, element1[, …[, elementN]]])</p></blockquote><p>参数</p><p>elementN:任意个参数，将按顺序成为返回数组中的元素。</p><p>返回值</p><p>新的 Array 实例。</p><h4 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用Array构造函数并传入一个数值类型值</span></span><br><span class="line"><span class="keyword">let</span> arr=<span class="keyword">new</span> <span class="built_in">Array</span>(<span class="number">2</span>);</span><br><span class="line"><span class="built_in">console</span>.log(arr); <span class="comment">// [undefined,undefined]</span></span><br><span class="line"><span class="built_in">console</span>.log(arr.length); <span class="comment">// 2</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用Array.of()方法并传入一个数值类型值</span></span><br><span class="line"><span class="keyword">let</span> array=<span class="built_in">Array</span>.of(<span class="number">2</span>);</span><br><span class="line"><span class="built_in">console</span>.log(array); <span class="comment">// [2]</span></span><br><span class="line"><span class="built_in">console</span>.log(array.length); <span class="comment">// 1</span></span><br></pre></td></tr></table></figure><h3 id="Array-from-方法将非数组对象转化为数组对象"><a href="#Array-from-方法将非数组对象转化为数组对象" class="headerlink" title="Array.from()方法将非数组对象转化为数组对象"></a>Array.from()方法将非数组对象转化为数组对象</h3><h4 id="概述-1"><a href="#概述-1" class="headerlink" title="概述"></a>概述</h4><p>Array.from() 方法从一个类似数组或可迭代对象中创建一个新的，浅拷贝的数组实例。</p><h4 id="语法-1"><a href="#语法-1" class="headerlink" title="语法"></a>语法</h4><blockquote><p>Array.from(arrayLike[, mapFn[, thisArg]])</p></blockquote><p><strong>参数</strong></p><p>arrayLike<br>    想要转换成数组的伪数组对象或可迭代对象。</p><p>mapFn (可选参数)<br>    如果指定了该参数，新数组中的每个元素会执行该回调函数。</p><p>thisArg (可选参数)<br>    可选参数，执行回调函数 mapFn 时 this 对象。</p><p><strong>返回值</strong></p><p>一个新的数组实例</p><h4 id="例子-1"><a href="#例子-1" class="headerlink" title="例子"></a>例子</h4><p>使用Array.from()方法将类数组对象转化为数组对象</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a=&#123;</span><br><span class="line">    <span class="number">0</span>:<span class="number">1</span>,</span><br><span class="line">    <span class="number">1</span>:<span class="number">2</span>,</span><br><span class="line">    length:<span class="number">2</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用Array.from()方法将类数组对象转化为数组对象</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> arr=<span class="built_in">Array</span>.from(a);</span><br><span class="line"><span class="built_in">console</span>.log(arr); <span class="comment">// [1,2]</span></span><br></pre></td></tr></table></figure><p>使用Array.from()方法将可迭代对象转化为数组对象</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 将字符串转化为数组</span></span><br><span class="line"><span class="keyword">let</span> str=<span class="string">'hello'</span>;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Array</span>.from(str)); <span class="comment">// ['h','e','l','l','o']</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 将Set集合转化为数组</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Array</span>.from(<span class="keyword">new</span> <span class="built_in">Set</span>([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]))); <span class="comment">// [1,2,3]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 将Map集合转化为数组</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Array</span>.from(<span class="keyword">new</span> <span class="built_in">Map</span>([[<span class="string">'a'</span>,<span class="number">1</span>],[<span class="string">'b'</span>,<span class="number">2</span>],[<span class="string">'c'</span>,<span class="number">3</span>]]))); <span class="comment">// [['a',1],['b',2],['c',3]]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 将普通自定义对象利用生成器转化为可迭代对象之后再转化为数组</span></span><br><span class="line"><span class="keyword">let</span> test=&#123;</span><br><span class="line">    a:<span class="string">'a'</span>,</span><br><span class="line">    c:<span class="string">'c'</span>,</span><br><span class="line">    *[<span class="built_in">Symbol</span>.iterator]() &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">let</span> i <span class="keyword">in</span> test) &#123;</span><br><span class="line">            <span class="keyword">yield</span> test[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Array</span>.from(test)); <span class="comment">// ['a','c']</span></span><br></pre></td></tr></table></figure><p>映射转化：使用Array.from()的第二个参数将被转化对象的每一个值转化为其他形式</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> test=&#123;</span><br><span class="line">    a:<span class="string">'a'</span>,</span><br><span class="line">    c:<span class="string">'c'</span>,</span><br><span class="line">    *[<span class="built_in">Symbol</span>.iterator]() &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">let</span> i <span class="keyword">in</span> test) &#123;</span><br><span class="line">            <span class="keyword">yield</span> test[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Array</span>.from(test,(v)=&gt;<span class="string">'hello '</span>+v)); <span class="comment">// ['hello a','hello c']</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;ES6之前数组创建的一些问题&quot;&gt;&lt;a href=&quot;#ES6之前数组创建的一些问题&quot; class=&quot;headerlink&quot; title=&quot;ES6之前数组创建的一些问题&quot;&gt;&lt;/a&gt;ES6之前数组创建的一些问题&lt;/h2&gt;&lt;p&gt;在ES6之前，数组的创建具有以下的一些问题&lt;
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>leetcode-263 丑数</title>
    <link href="http://yoursite.com/2019/09/09/leetcode-263/"/>
    <id>http://yoursite.com/2019/09/09/leetcode-263/</id>
    <published>2019-09-09T07:51:06.000Z</published>
    <updated>2019-09-09T07:58:23.372Z</updated>
    
    <content type="html"><![CDATA[<h1 id="丑数"><a href="#丑数" class="headerlink" title="丑数"></a>丑数</h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>编写一个程序判断给定的数是否为丑数。</p><p>丑数就是只包含质因数 2, 3, 5 的正整数。</p><p>示例 1:</p><blockquote><p>输入: 6<br>输出: true<br>解释: 6 = 2 × 3</p></blockquote><p>示例 2:</p><blockquote><p>输入: 8<br>输出: true<br>解释: 8 = 2 × 2 × 2</p></blockquote><p>示例 3:</p><blockquote><p>输入: 14<br>输出: false <br>解释: 14 不是丑数，因为它包含了另外一个质因数 7。</p></blockquote><p>说明：</p><ol><li>1是丑数。</li><li>输入不会超过 32 位有符号整数的范围: [−231,  231 − 1]。<a id="more"></a>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/ugly-number" target="_blank" rel="noopener">https://leetcode-cn.com/problems/ugly-number</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。<h2 id="核心思路"><a href="#核心思路" class="headerlink" title="核心思路"></a>核心思路</h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3>题目说明只包含质因数2,3,5的整数位丑数（且1为丑数）。那么，我们先排除掉小于等于0的数。那么对于正整数来说，如果该数只包含质因数2,3,5；那么我们只要将该数不断地除以2（如果可以整除），不断地除以3（如果可以整除），不断地除以5（如果可以整除）；如果最后的结果为1的话，那么该数就是丑数</li></ol><h3 id="解题步骤"><a href="#解题步骤" class="headerlink" title="解题步骤"></a>解题步骤</h3><ol><li>如果给定数小于等于0，返回false</li><li>如果该数可以整除2，那么不断将该数除以2</li><li>如果该数可以整除3，那么不断将该数除以3</li><li>如果该数可以整除5，那么不断将该数除以5</li><li>执行完2,3,4步骤后如果结果为1，那么该数为丑数，返回true；否则返回false</li></ol><h2 id="Coding实现"><a href="#Coding实现" class="headerlink" title="Coding实现"></a>Coding实现</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @param &#123;number&#125; num</span></span><br><span class="line"><span class="comment"> * @return &#123;boolean&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> isUgly = <span class="function"><span class="keyword">function</span>(<span class="params">num</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(num&lt;=<span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">while</span>(num%<span class="number">2</span>===<span class="number">0</span>) &#123;</span><br><span class="line">        num=num/<span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(num%<span class="number">3</span>===<span class="number">0</span>) &#123;</span><br><span class="line">        num=num/<span class="number">3</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(num%<span class="number">5</span>===<span class="number">0</span>) &#123;</span><br><span class="line">        num=num/<span class="number">5</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(num===<span class="number">1</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;丑数&quot;&gt;&lt;a href=&quot;#丑数&quot; class=&quot;headerlink&quot; title=&quot;丑数&quot;&gt;&lt;/a&gt;丑数&lt;/h1&gt;&lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h2&gt;&lt;p&gt;编写一个程序判断给定的数是否为丑数。&lt;/p&gt;
&lt;p&gt;丑数就是只包含质因数 2, 3, 5 的正整数。&lt;/p&gt;
&lt;p&gt;示例 1:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;输入: 6&lt;br&gt;输出: true&lt;br&gt;解释: 6 = 2 × 3&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;示例 2:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;输入: 8&lt;br&gt;输出: true&lt;br&gt;解释: 8 = 2 × 2 × 2&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;示例 3:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;输入: 14&lt;br&gt;输出: false &lt;br&gt;解释: 14 不是丑数，因为它包含了另外一个质因数 7。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;说明：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;1是丑数。&lt;/li&gt;
&lt;li&gt;输入不会超过 32 位有符号整数的范围: [−231,  231 − 1]。
    
    </summary>
    
      <category term="leetcode题解与算法" scheme="http://yoursite.com/categories/leetcode%E9%A2%98%E8%A7%A3%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
  </entry>
  
  <entry>
    <title>类语法不得不知的几点</title>
    <link href="http://yoursite.com/2019/09/08/%E7%B1%BB%E8%AF%AD%E6%B3%95%E4%B8%8D%E5%BE%97%E4%B8%8D%E7%9F%A5%E7%9A%84%E5%87%A0%E7%82%B9/"/>
    <id>http://yoursite.com/2019/09/08/类语法不得不知的几点/</id>
    <published>2019-09-08T08:25:41.000Z</published>
    <updated>2019-09-08T13:03:35.824Z</updated>
    
    <content type="html"><![CDATA[<h2 id="ES5实现模拟类"><a href="#ES5实现模拟类" class="headerlink" title="ES5实现模拟类"></a>ES5实现模拟类</h2><p>ES5是通过构造函数和原型来是模拟实现类的</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Test</span>(<span class="params">item</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.item=item;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Test.prototype.getItem=<span class="function"><span class="keyword">function</span> (<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.item;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> test=<span class="keyword">new</span> Test(<span class="number">123</span>);</span><br><span class="line"><span class="built_in">console</span>.log(test); <span class="comment">// &#123;item:123&#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(test.getItem()); <span class="comment">// 123</span></span><br></pre></td></tr></table></figure><h2 id="ES6类的声明"><a href="#ES6类的声明" class="headerlink" title="ES6类的声明"></a>ES6类的声明</h2><h3 id="基本类声明语法"><a href="#基本类声明语法" class="headerlink" title="基本类声明语法"></a>基本类声明语法</h3><p>要声明一个类，可以按照如下的方法</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span></span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(item) &#123;</span><br><span class="line">        <span class="keyword">this</span>.item=item;</span><br><span class="line">    &#125;</span><br><span class="line">    getItem() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.item;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> test=<span class="keyword">new</span> Test(<span class="number">123</span>);</span><br><span class="line"><span class="built_in">console</span>.log(test); <span class="comment">// &#123;item:123&#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(test.getItem()); <span class="comment">// 123</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 查看test实例原型上的属性</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.getOwnPropertyNames(<span class="built_in">Object</span>.getPrototypeOf(test))); <span class="comment">// [ 'constructor', 'getItem' ]</span></span><br></pre></td></tr></table></figure><p>其中，constructor方法用来定义构造函数，除此之外的所有方法就是定义在原型上的方法</p><p>另外，类声明其实是基于已有自定义类型声明的语法糖。如果使用typeof Test最终返回的结果会是’function’，因此，类其实就是创建了一个具有构造函数方法行为的函数</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span></span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(item) &#123;</span><br><span class="line">        <span class="keyword">this</span>.item=item;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> Test); <span class="comment">// function</span></span><br></pre></td></tr></table></figure><h3 id="类表达式语法"><a href="#类表达式语法" class="headerlink" title="类表达式语法"></a>类表达式语法</h3><p>类和函数一样(类实质上就是一个函数)，它在声明的时候也具有表达式语法</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用匿名类赋值给Test</span></span><br><span class="line"><span class="keyword">let</span> Test=<span class="class"><span class="keyword">class</span></span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(item) &#123;</span><br><span class="line">        <span class="keyword">this</span>.item=item;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用命名类赋值给Test</span></span><br><span class="line"><span class="keyword">let</span> Test=<span class="class"><span class="keyword">class</span> <span class="title">A</span></span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(item) &#123;</span><br><span class="line">        <span class="keyword">this</span>.item=item;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="类的一些特性"><a href="#类的一些特性" class="headerlink" title="类的一些特性"></a>类的一些特性</h2><p>类声明具有的一些特性</p><ol><li><p>虽然类实质上是函数，函数声明可以被提升，但是类声明却是与let声明类似不能被提升</p></li><li><p>因为类实质上是函数，因此类可以作为参数传递给函数，也可以作为值赋给变量</p> <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span></span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(item) &#123;</span><br><span class="line">        <span class="keyword">this</span>.item=item;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> M=Test;</span><br><span class="line"><span class="keyword">let</span> m=<span class="keyword">new</span> M(<span class="number">1</span>);</span><br><span class="line"><span class="built_in">console</span>.log(m); <span class="comment">// &#123;item:1&#125;</span></span><br></pre></td></tr></table></figure></li><li><p>类方法与函数一样同样支持使用可计算属性名</p> <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a=<span class="string">'get Item'</span>;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span></span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(item) &#123;</span><br><span class="line">        <span class="keyword">this</span>.item=item;</span><br><span class="line">    &#125;</span><br><span class="line">    [a]() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.item;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> M=Test;</span><br><span class="line"><span class="keyword">let</span> m=<span class="keyword">new</span> M(<span class="number">1</span>);</span><br><span class="line"><span class="built_in">console</span>.log(m[a]()); <span class="comment">// 1</span></span><br></pre></td></tr></table></figure></li><li><p>类是个函数，那么它也就是个对象，因此，我们可以在类中定义生成器方法</p> <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span></span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(...item) &#123;</span><br><span class="line">        <span class="keyword">this</span>.a=item[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">this</span>.b=item[<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">this</span>.c=item[<span class="number">2</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 建立生成器方法</span></span><br><span class="line">    *[<span class="built_in">Symbol</span>.iterator]() &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">let</span> i <span class="keyword">in</span> <span class="keyword">this</span>) &#123;</span><br><span class="line">            <span class="keyword">yield</span> <span class="keyword">this</span>[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> test=<span class="keyword">new</span> Test(<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 可以用for...of进行迭代</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> v <span class="keyword">of</span> test) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(v); <span class="comment">// 3,4,5</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h2 id="静态成员"><a href="#静态成员" class="headerlink" title="静态成员"></a>静态成员</h2><p>静态成员通过static关键字来声明，它会作为类的一个方法属性。无法被类的实例调用，只能通过类本身被调用</p><p>例如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> Test=<span class="class"><span class="keyword">class</span></span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(item) &#123;</span><br><span class="line">        <span class="keyword">this</span>.item=item;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> getValue() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> test=<span class="keyword">new</span> Test(<span class="number">1</span>);</span><br><span class="line"><span class="built_in">console</span>.log(test);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 通过类本身来调用静态成员</span></span><br><span class="line"><span class="built_in">console</span>.log(Test.getValue()); <span class="comment">// 1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 无法通过类的实例来调用，因为静态成员不会出现在构造函数的原型对象上，所以实例无法访问到该方法</span></span><br><span class="line"><span class="built_in">console</span>.log(test.getValue()); <span class="comment">// 报错：test.getValue is not a function</span></span><br></pre></td></tr></table></figure><p>那么，静态成员一般用来做什么呢？他们通常是一些实用程序方法，例如创建或克隆对象</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> Test=<span class="class"><span class="keyword">class</span></span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(item) &#123;</span><br><span class="line">        <span class="keyword">this</span>.item=item;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 实用静态成员来创建对象</span></span><br><span class="line">    <span class="keyword">static</span> create(item) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Test(item);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 实用静态成员来创建对象</span></span><br><span class="line"><span class="keyword">let</span> test=Test.create(<span class="number">1</span>);</span><br><span class="line"><span class="built_in">console</span>.log(test); <span class="comment">// &#123;item:1&#125;</span></span><br></pre></td></tr></table></figure><h3 id="静态成员的继承"><a href="#静态成员的继承" class="headerlink" title="静态成员的继承"></a>静态成员的继承</h3><p>如果基类有静态成员，那么这些静态成员在派生类中也可以被使用</p><p>例如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> Person=<span class="class"><span class="keyword">class</span></span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(item) &#123;</span><br><span class="line">        <span class="keyword">this</span>.item=item;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 实用静态成员来创建对象</span></span><br><span class="line">    <span class="keyword">static</span> create(item) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Person(item);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Man</span> <span class="keyword">extends</span> <span class="title">Person</span></span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(item) &#123;</span><br><span class="line">        <span class="keyword">super</span>(item);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> man=Man.create(<span class="string">'man'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(man); <span class="comment">// &#123;item:'man'&#125;</span></span><br></pre></td></tr></table></figure><h2 id="继承与派生类"><a href="#继承与派生类" class="headerlink" title="继承与派生类"></a>继承与派生类</h2><h3 id="ES5模拟实现继承"><a href="#ES5模拟实现继承" class="headerlink" title="ES5模拟实现继承"></a>ES5模拟实现继承</h3><p>ES5模拟实现继承主要是通过利用原型链</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">item</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.item=item;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Person.prototype.sayPerson=<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'person'</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 利用call来继承父类的构造函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Man</span>(<span class="params">item</span>) </span>&#123;</span><br><span class="line">    Person.call(<span class="keyword">this</span>,item);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 原型对象的继承</span></span><br><span class="line">Man.prototype=<span class="keyword">new</span> Person();</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> man=<span class="keyword">new</span> Man(<span class="string">'man'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(man); <span class="comment">// &#123;item:'man'&#125;</span></span><br><span class="line">man.sayPerson(); <span class="comment">// 'person'</span></span><br></pre></td></tr></table></figure><h3 id="ES6的继承"><a href="#ES6的继承" class="headerlink" title="ES6的继承"></a>ES6的继承</h3><p>ES6使用extends关键字来指定类继承的函数，并且通过super()方法即可访问基类的构造函数</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span></span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(item) &#123;</span><br><span class="line">        <span class="keyword">this</span>.item=item;</span><br><span class="line">    &#125;</span><br><span class="line">    getItem() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.item;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Man</span> <span class="keyword">extends</span> <span class="title">Person</span></span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(item) &#123;</span><br><span class="line">        <span class="keyword">super</span>(item);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> man=<span class="keyword">new</span> Man(<span class="string">'man'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(man); <span class="comment">// &#123;item:'man'&#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(man.getItem()); <span class="comment">// 'man'</span></span><br></pre></td></tr></table></figure><p>继承自其它类的类被称为派生类，因此，对于上述代码，Person类被称为基类（父类），Man类被称为派生类（子类）</p><p><strong>注意</strong>：</p><blockquote><p>如果在派生类中指定了构造函数，那么在构造函数中就必须要调用super()方法，如果不这样做程序就会报错；<br>当然，你也可以不指定构造函数，那么派生类就会默认执行构造函数并调用super()方法并传入所有参数</p></blockquote><p>例如:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Man</span> <span class="keyword">extends</span> <span class="title">Person</span></span>&#123;</span><br><span class="line">    <span class="comment">// 没有构造函数</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 等价于</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Man</span> <span class="keyword">extends</span> <span class="title">Person</span></span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(...items)&#123;</span><br><span class="line">        <span class="keyword">super</span>(...items);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>为了避免一些参数传入引起的问题，我们最好是手动建立构造函数</p><h3 id="super-的一些注意点"><a href="#super-的一些注意点" class="headerlink" title="super()的一些注意点"></a>super()的一些注意点</h3><p>super()方法有一些注意点</p><ol><li>我们只能在派生类的构造函数中使用super()方法，如果尝试在非派生类（不适用extends声明的类）或函数中使用就会导致程序抛出错误</li><li>在构造函数中访问this前一定要调用super()，它负责初始化this</li></ol><h3 id="类方法的遮蔽"><a href="#类方法的遮蔽" class="headerlink" title="类方法的遮蔽"></a>类方法的遮蔽</h3><p>派生类的同名方法会覆盖基类中的同名方法，因为继承的本质就是原型链来实现的；而原型链的查找是从底端向上查找的，如果找到了一个符合要求的便不会再向上查找</p><p>例如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span></span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(item) &#123;</span><br><span class="line">        <span class="keyword">this</span>.item=item;</span><br><span class="line">    &#125;</span><br><span class="line">    sayHello() &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'Person say hello'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Man</span> <span class="keyword">extends</span> <span class="title">Person</span></span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(item) &#123;</span><br><span class="line">        <span class="keyword">super</span>(item);</span><br><span class="line">    &#125;</span><br><span class="line">    sayHello() &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'Man say hello'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> man=<span class="keyword">new</span> Man(<span class="string">'man'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(man); <span class="comment">// &#123;item:'man'&#125;</span></span><br><span class="line">man.sayHello(); <span class="comment">// 'Man say hello'</span></span><br></pre></td></tr></table></figure><h3 id="继承自表达式的类"><a href="#继承自表达式的类" class="headerlink" title="继承自表达式的类"></a>继承自表达式的类</h3><p>只要表达式可以被解析为一个函数并且具有[[construct]]属性（箭头函数不具有该属性）和原型，那么就可以用extends进行派生</p><p>例如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 该函数为构造函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">item</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.item=item;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Person.prototype.sayHello=<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'hello'</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 继承自构造函数而非基本类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Man</span> <span class="keyword">extends</span> <span class="title">Person</span></span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(item) &#123;</span><br><span class="line">        <span class="keyword">super</span>(item);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> man=<span class="keyword">new</span> Man(<span class="string">'man'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(man); <span class="comment">// &#123;item:'man'&#125;</span></span><br><span class="line">man.sayHello(); <span class="comment">// 'hello'</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;ES5实现模拟类&quot;&gt;&lt;a href=&quot;#ES5实现模拟类&quot; class=&quot;headerlink&quot; title=&quot;ES5实现模拟类&quot;&gt;&lt;/a&gt;ES5实现模拟类&lt;/h2&gt;&lt;p&gt;ES5是通过构造函数和原型来是模拟实现类的&lt;/p&gt;
&lt;figure class=&quot;highl
      
    
    </summary>
    
      <category term="ES6" scheme="http://yoursite.com/categories/ES6/"/>
    
    
      <category term="基础语法" scheme="http://yoursite.com/tags/%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>leetcode-258 各位相加</title>
    <link href="http://yoursite.com/2019/09/08/leetcode-258/"/>
    <id>http://yoursite.com/2019/09/08/leetcode-258/</id>
    <published>2019-09-08T06:21:30.000Z</published>
    <updated>2019-09-08T07:24:05.907Z</updated>
    
    <content type="html"><![CDATA[<h1 id="各位相加"><a href="#各位相加" class="headerlink" title="各位相加"></a>各位相加</h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>给定一个非负整数 num，反复将各个位上的数字相加，直到结果为一位数。</p><p>示例:</p><blockquote><p>输入: 38<br>输出: 2 <br>解释: 各位相加的过程为：3 + 8 = 11, 1 + 1 = 2。 由于 2 是一位数，所以返回 2。</p></blockquote><p>进阶:<br>你可以不使用循环或者递归，且在 O(1) 时间复杂度内解决这个问题吗？</p><a id="more"></a><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/add-digits" target="_blank" rel="noopener">https://leetcode-cn.com/problems/add-digits</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p><h2 id="核心思路"><a href="#核心思路" class="headerlink" title="核心思路"></a>核心思路</h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><ol><li>如果不考虑进阶的要求的话，那么第一直觉就会是使用循环或者递归，将数的各位和一直相加，直到和为个位数</li><li>如果需要满足进阶的要求的话，那么我们需要一些数学的技巧。对于一个数abc,它等于a*100+b*10+c。将它求和的话，就会变为a+b+c,也就是求和之后减少了99*a+9*b=9*(11*a+b);因此，每次求和这个数就会减少9的倍数的值；也就是相当于，原数-9*未知值=和；这个式子可以转化为：原数%9=和；因此，若结果为 0 则考虑num本身是否为 0，若本身不为不为 0，则返回 9；此外，返回结果</li></ol><h3 id="解题步骤"><a href="#解题步骤" class="headerlink" title="解题步骤"></a>解题步骤</h3><h2 id="Coding实现"><a href="#Coding实现" class="headerlink" title="Coding实现"></a>Coding实现</h2><p>循环版</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @param &#123;number&#125; num</span></span><br><span class="line"><span class="comment"> * @return &#123;number&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> addDigits = <span class="function"><span class="keyword">function</span>(<span class="params">num</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(num&gt;=<span class="number">10</span>) &#123;</span><br><span class="line">        num=num.toString().split(<span class="string">''</span>).reduce(<span class="function">(<span class="params">pre,value</span>)=&gt;</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> pre+<span class="built_in">parseInt</span>(value);</span><br><span class="line">        &#125;,<span class="number">0</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> num;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>数学推断版</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @param &#123;number&#125; num</span></span><br><span class="line"><span class="comment"> * @return &#123;number&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> addDigits = <span class="function"><span class="keyword">function</span>(<span class="params">num</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(num&gt;<span class="number">9</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span>(num%<span class="number">9</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> num%<span class="number">9</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> <span class="number">9</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> num;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;各位相加&quot;&gt;&lt;a href=&quot;#各位相加&quot; class=&quot;headerlink&quot; title=&quot;各位相加&quot;&gt;&lt;/a&gt;各位相加&lt;/h1&gt;&lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h2&gt;&lt;p&gt;给定一个非负整数 num，反复将各个位上的数字相加，直到结果为一位数。&lt;/p&gt;
&lt;p&gt;示例:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;输入: 38&lt;br&gt;输出: 2 &lt;br&gt;解释: 各位相加的过程为：3 + 8 = 11, 1 + 1 = 2。 由于 2 是一位数，所以返回 2。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;进阶:&lt;br&gt;你可以不使用循环或者递归，且在 O(1) 时间复杂度内解决这个问题吗？&lt;/p&gt;
    
    </summary>
    
      <category term="leetcode题解与算法" scheme="http://yoursite.com/categories/leetcode%E9%A2%98%E8%A7%A3%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
  </entry>
  
  <entry>
    <title>迭代器与生成器</title>
    <link href="http://yoursite.com/2019/09/07/%E8%BF%AD%E4%BB%A3%E5%99%A8%E4%B8%8E%E7%94%9F%E6%88%90%E5%99%A8/"/>
    <id>http://yoursite.com/2019/09/07/迭代器与生成器/</id>
    <published>2019-09-07T06:34:17.000Z</published>
    <updated>2019-09-07T08:41:37.115Z</updated>
    
    <content type="html"><![CDATA[<h2 id="什么是迭代器"><a href="#什么是迭代器" class="headerlink" title="什么是迭代器"></a>什么是迭代器</h2><p>首先，迭代器是一个对象，一个专门为迭代过程设计的对象。所有的迭代器对象都会具有一个next()方法，用来返回一个结果对象（该结果对象包括两个属性，一个是下一个要返回的值，一个是done属性。在返回最后一个值及之前时，done值为false，否则为true）。</p><h3 id="使用ES5模拟一个迭代器"><a href="#使用ES5模拟一个迭代器" class="headerlink" title="使用ES5模拟一个迭代器"></a>使用ES5模拟一个迭代器</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 利用闭包的特性，使得next()方法一直保存着index的变量值</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createIterator</span>(<span class="params">items</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> index=<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        next : <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">            index++;</span><br><span class="line">            <span class="keyword">return</span> &#123;</span><br><span class="line">                value:items[index],</span><br><span class="line">                done:index&lt;=items.length<span class="number">-1</span>?<span class="literal">false</span>:<span class="literal">true</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> iterator=createIterator([<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>]);</span><br><span class="line"><span class="built_in">console</span>.log(iterator.next());</span><br><span class="line"><span class="built_in">console</span>.log(iterator.next());</span><br><span class="line"><span class="built_in">console</span>.log(iterator.next());</span><br><span class="line"><span class="built_in">console</span>.log(iterator.next());</span><br><span class="line"><span class="built_in">console</span>.log(iterator.next());</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 输出结果</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">&#123; value: 3, done: false &#125;</span></span><br><span class="line"><span class="comment">&#123; value: 4, done: false &#125;</span></span><br><span class="line"><span class="comment">&#123; value: 5, done: false &#125;</span></span><br><span class="line"><span class="comment">&#123; value: undefined, done: true &#125;</span></span><br><span class="line"><span class="comment">&#123; value: undefined, done: true &#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h2 id="什么是生成器"><a href="#什么是生成器" class="headerlink" title="什么是生成器"></a>什么是生成器</h2><p>生成器是一个可以返回迭代器对象的函数，通过*关键字来表示该函数为生成器函数。</p><p>在生成器函数中，我们一般需要使用yield关键字来指定调用迭代器的next()方法的返回值和返回顺序。</p><p>yield关键字可以返回任何值或者表达式</p><p>例如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用生成器函数来返回一个迭代器，其中的yield关键字来指定调用此迭代器中的next()方法的返回值与返回顺序</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> *<span class="title">createIterator</span>(<span class="params">items</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">0</span>;i&lt;items.length;i++) &#123;</span><br><span class="line">        <span class="keyword">yield</span> items[i];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> iterator=createIterator([<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>]);</span><br><span class="line"><span class="built_in">console</span>.log(iterator.next());</span><br><span class="line"><span class="built_in">console</span>.log(iterator.next());</span><br><span class="line"><span class="built_in">console</span>.log(iterator.next());</span><br><span class="line"><span class="built_in">console</span>.log(iterator.next());</span><br><span class="line"><span class="built_in">console</span>.log(iterator.next());</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 输出结果</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">&#123; value: 3, done: false &#125;</span></span><br><span class="line"><span class="comment">&#123; value: 4, done: false &#125;</span></span><br><span class="line"><span class="comment">&#123; value: 5, done: false &#125;</span></span><br><span class="line"><span class="comment">&#123; value: undefined, done: true &#125;</span></span><br><span class="line"><span class="comment">&#123; value: undefined, done: true &#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>对于生成器函数中的yield，每当执行完一个yield语句后，该函数就会自动停止执行，直到再次调用返回的迭代器的next()方法</p><h3 id="生成器函数表达式"><a href="#生成器函数表达式" class="headerlink" title="生成器函数表达式"></a>生成器函数表达式</h3><p>上面的例子是使用函数声明的方式来创建生成器，同样我们也可以使用函数表达式的方式来创建生成器。此时，我们只需要在function关键字和小括号中间添加*号即可</p><p>例如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 匿名函数</span></span><br><span class="line"><span class="keyword">let</span> createIterator=<span class="function"><span class="keyword">function</span> *(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">yield</span> <span class="number">3</span>;</span><br><span class="line">    <span class="keyword">yield</span> <span class="number">4</span>;</span><br><span class="line">    <span class="keyword">yield</span> <span class="number">5</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 非匿名函数</span></span><br><span class="line"><span class="keyword">let</span> createIterator=<span class="function"><span class="keyword">function</span> *<span class="title">test</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">yield</span> <span class="number">3</span>;</span><br><span class="line">    <span class="keyword">yield</span> <span class="number">4</span>;</span><br><span class="line">    <span class="keyword">yield</span> <span class="number">5</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="生成器函数作为一个对象的方法"><a href="#生成器函数作为一个对象的方法" class="headerlink" title="生成器函数作为一个对象的方法"></a>生成器函数作为一个对象的方法</h3><p>由于生成器本身就是一个函数，因此我们可以将生成器作为一个对象的方法。</p><p>这样，我们可以使用ES6对象的简写方法来创建生成器，只需要在方法名前加上*即可</p><p>例如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> test=&#123;</span><br><span class="line">    *createIterator() &#123;</span><br><span class="line">        <span class="keyword">yield</span> <span class="number">3</span>;</span><br><span class="line">        <span class="keyword">yield</span> <span class="number">4</span>;</span><br><span class="line">        <span class="keyword">yield</span> <span class="number">5</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="可迭代对象与for…of循环"><a href="#可迭代对象与for…of循环" class="headerlink" title="可迭代对象与for…of循环"></a>可迭代对象与for…of循环</h2><h3 id="什么是可迭代对象"><a href="#什么是可迭代对象" class="headerlink" title="什么是可迭代对象"></a>什么是可迭代对象</h3><p>可迭代对象都会有Symbol.iterator属性。该属性可以通过指定的函数来返回一个迭代器。</p><p>在ES6中，所有的集合对象（数组，Set集合，Map集合）和字符串都是可迭代对象。这些对象都有默认的迭代器。</p><p>而我们自己创建的对象一般都不是可迭代对象，当然我们可以将他们转变为可迭代对象</p><blockquote><p>注意：由于生成器默认会为Symbol.iterator属性赋值，因此所有通过生成器创建的迭代器都会是可迭代对象。因此，我们可以这一特性将不可迭代对象转化为可迭代对象</p></blockquote><h4 id="判断一个对象是否为可迭代对象"><a href="#判断一个对象是否为可迭代对象" class="headerlink" title="判断一个对象是否为可迭代对象"></a>判断一个对象是否为可迭代对象</h4><p>因为可迭代对象都会有Symbol.iterator方法属性，所以我们可以判断某对象中是否具有该方法来判断是否为可迭代对象</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">isIterable</span>(<span class="params">object</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">typeof</span> object[<span class="built_in">Symbol</span>.iterator] === <span class="string">'function'</span></span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(isIterable([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>])); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(isIterable(<span class="keyword">new</span> <span class="built_in">Set</span>([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]))); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(isIterable(<span class="keyword">new</span> <span class="built_in">Map</span>([[<span class="number">1</span>,<span class="number">1</span>],[<span class="number">2</span>,<span class="number">2</span>]]))); <span class="comment">//true</span></span><br><span class="line"><span class="built_in">console</span>.log(isIterable(<span class="string">'hello'</span>)); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(isIterable(&#123;<span class="attr">a</span>:<span class="number">1</span>,<span class="attr">b</span>:<span class="number">2</span>&#125;)); <span class="comment">// false</span></span><br></pre></td></tr></table></figure><h3 id="for…of循环"><a href="#for…of循环" class="headerlink" title="for…of循环"></a>for…of循环</h3><p>for…of循环只能循环可迭代对象。</p><p>其实质上是会调用可迭代对象的Symbol.iterator的属性方法来获取到一个迭代器，然后不断调用迭代器的next()方法直到done属性值为true时退出</p><p>例如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> test=[<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> v <span class="keyword">of</span> test) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(v);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 输出结果</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">3</span></span><br><span class="line"><span class="comment">4</span></span><br><span class="line"><span class="comment">5</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h3 id="访问默认迭代器"><a href="#访问默认迭代器" class="headerlink" title="访问默认迭代器"></a>访问默认迭代器</h3><p>每个可迭代对象都会有一个Symbol.iterator的方法属性，该方法被调用后可以返回一个迭代器。</p><p>因此，我们可以通过该属性去访问一个可迭代对象的默认迭代器</p><p>例如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> test=[<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>];</span><br><span class="line"><span class="comment">// 获得数组对象的默认迭代器</span></span><br><span class="line"><span class="keyword">let</span> iterator=test[<span class="built_in">Symbol</span>.iterator]();</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(iterator.next());</span><br><span class="line"><span class="built_in">console</span>.log(iterator.next());</span><br><span class="line"><span class="built_in">console</span>.log(iterator.next());</span><br><span class="line"><span class="built_in">console</span>.log(iterator.next());</span><br><span class="line"><span class="built_in">console</span>.log(iterator.next());</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 输出结果</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">&#123; value: 3, done: false &#125;</span></span><br><span class="line"><span class="comment">&#123; value: 4, done: false &#125;</span></span><br><span class="line"><span class="comment">&#123; value: 5, done: false &#125;</span></span><br><span class="line"><span class="comment">&#123; value: undefined, done: true &#125;</span></span><br><span class="line"><span class="comment">&#123; value: undefined, done: true &#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h3 id="将不可迭代对象转化为可迭代对象"><a href="#将不可迭代对象转化为可迭代对象" class="headerlink" title="将不可迭代对象转化为可迭代对象"></a>将不可迭代对象转化为可迭代对象</h3><h4 id="通过添加Symbol-iterator属性"><a href="#通过添加Symbol-iterator属性" class="headerlink" title="通过添加Symbol.iterator属性"></a>通过添加Symbol.iterator属性</h4><p>因为一个对象是否可迭代是根据是否有Symbol.iterator属性的，因此，我们可以手动添加该生成器</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> test=&#123;</span><br><span class="line">    a:<span class="number">1</span>,</span><br><span class="line">    b:<span class="number">2</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 自建对象一般都是不可迭代的</span></span><br><span class="line"><span class="built_in">console</span>.log(test[<span class="built_in">Symbol</span>.iterator]); <span class="comment">// undefined</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 为不可迭代对象创建Symbol.iterator并赋予一个生成器,使其成为一个可迭代对象</span></span><br><span class="line">test[<span class="built_in">Symbol</span>.iterator]=<span class="function"><span class="keyword">function</span> *(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// this指向test对象</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i <span class="keyword">in</span> <span class="keyword">this</span>) &#123;</span><br><span class="line">        <span class="keyword">yield</span> <span class="keyword">this</span>[i];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 验证是否成为了一个可迭代对象</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> v <span class="keyword">of</span> test) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(v); <span class="comment">// 1 2</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="通过生成器函数"><a href="#通过生成器函数" class="headerlink" title="通过生成器函数"></a>通过生成器函数</h4><p>在前文提到过，由于生成器默认会为传入的对象Symbol.iterator属性赋值，因此，我们只需向生成器函数传入不可迭代对象即可</p><p>例如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> *<span class="title">createIterator</span>(<span class="params">object</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i <span class="keyword">in</span> object) &#123;</span><br><span class="line">        <span class="keyword">yield</span> object[i];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> test=&#123;</span><br><span class="line">    a:<span class="number">1</span>,</span><br><span class="line">    b:<span class="number">2</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> iterator=createIterator(test);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> v <span class="keyword">of</span> iterator) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(v); <span class="comment">// 1,2</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;什么是迭代器&quot;&gt;&lt;a href=&quot;#什么是迭代器&quot; class=&quot;headerlink&quot; title=&quot;什么是迭代器&quot;&gt;&lt;/a&gt;什么是迭代器&lt;/h2&gt;&lt;p&gt;首先，迭代器是一个对象，一个专门为迭代过程设计的对象。所有的迭代器对象都会具有一个next()方法，用来返回
      
    
    </summary>
    
      <category term="ES6" scheme="http://yoursite.com/categories/ES6/"/>
    
    
      <category term="基础语法" scheme="http://yoursite.com/tags/%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>leetcode-257 二叉树的所有路径</title>
    <link href="http://yoursite.com/2019/09/07/leetcode-257/"/>
    <id>http://yoursite.com/2019/09/07/leetcode-257/</id>
    <published>2019-09-07T04:49:58.000Z</published>
    <updated>2019-09-07T04:57:43.739Z</updated>
    
    <content type="html"><![CDATA[<h1 id="二叉树的所有路径"><a href="#二叉树的所有路径" class="headerlink" title="二叉树的所有路径"></a>二叉树的所有路径</h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>给定一个二叉树，返回所有从根节点到叶子节点的路径。</p><p>说明: 叶子节点是指没有子节点的节点。</p><p>示例:</p><p><img src="https://s2.ax1x.com/2019/09/07/nlmn4s.png" alt></p><a id="more"></a><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/binary-tree-paths" target="_blank" rel="noopener">https://leetcode-cn.com/problems/binary-tree-paths</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p><h2 id="核心思路"><a href="#核心思路" class="headerlink" title="核心思路"></a>核心思路</h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>二叉树的路径是根节点到叶子节点上的路径。因此，我们可以传入一个数组，在递归的时候存储每个节点当前的路径，如果遇到叶子节点，就将叶子节点上的路径加入到ans数组</p><h3 id="解题步骤"><a href="#解题步骤" class="headerlink" title="解题步骤"></a>解题步骤</h3><ol><li>设立一个ans数组，用来存放二叉树的路径</li><li>先序遍历二叉树，同时传入一个数组，用来保存当前节点的路径</li><li>如果遇到叶子节点，则将数组存入ans数组中，并return</li><li>访问其左子树和右子树</li><li>递归2,3,4步骤，直到二叉树遍历完毕</li><li>利用map()方法和join()方法将输出满足题目要求</li></ol><h2 id="Coding实现"><a href="#Coding实现" class="headerlink" title="Coding实现"></a>Coding实现</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * function TreeNode(val) &#123;</span></span><br><span class="line"><span class="comment"> *     this.val = val;</span></span><br><span class="line"><span class="comment"> *     this.left = this.right = null;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @param &#123;TreeNode&#125; root</span></span><br><span class="line"><span class="comment"> * @return &#123;string[]&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> binaryTreePaths = <span class="function"><span class="keyword">function</span>(<span class="params">root</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> ans=[];</span><br><span class="line">    (<span class="function"><span class="keyword">function</span> <span class="title">getPath</span>(<span class="params">root,arr</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root===<span class="literal">null</span>) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            arr.push(root.val);</span><br><span class="line">            <span class="keyword">let</span> arrLeft=arr.concat();</span><br><span class="line">            <span class="keyword">let</span> arrRight=arr.concat();</span><br><span class="line">            <span class="keyword">if</span>(!root.left&amp;&amp;!root.right) &#123;</span><br><span class="line">                ans.push(arr);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            getPath(root.left,arrLeft);</span><br><span class="line">            getPath(root.right,arrRight);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)(root,[])</span><br><span class="line">    ans=ans.map(<span class="function"><span class="params">v</span>=&gt;</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> v.join(<span class="string">'-&gt;'</span>);</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;二叉树的所有路径&quot;&gt;&lt;a href=&quot;#二叉树的所有路径&quot; class=&quot;headerlink&quot; title=&quot;二叉树的所有路径&quot;&gt;&lt;/a&gt;二叉树的所有路径&lt;/h1&gt;&lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h2&gt;&lt;p&gt;给定一个二叉树，返回所有从根节点到叶子节点的路径。&lt;/p&gt;
&lt;p&gt;说明: 叶子节点是指没有子节点的节点。&lt;/p&gt;
&lt;p&gt;示例:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://s2.ax1x.com/2019/09/07/nlmn4s.png&quot; alt&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="leetcode题解与算法" scheme="http://yoursite.com/categories/leetcode%E9%A2%98%E8%A7%A3%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="树" scheme="http://yoursite.com/tags/%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>leetcode-242 有效的字母异位词</title>
    <link href="http://yoursite.com/2019/09/05/leetcode-242/"/>
    <id>http://yoursite.com/2019/09/05/leetcode-242/</id>
    <published>2019-09-05T11:58:38.000Z</published>
    <updated>2019-09-05T12:03:39.170Z</updated>
    
    <content type="html"><![CDATA[<h1 id="有效的字母异位词"><a href="#有效的字母异位词" class="headerlink" title="有效的字母异位词"></a>有效的字母异位词</h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>给定两个字符串 s 和 t ，编写一个函数来判断 t 是否是 s 的字母异位词。</p><p>示例 1:</p><blockquote><p>输入: s = “anagram”, t = “nagaram”<br>输出: true</p></blockquote><p>示例 2:</p><blockquote><p>输入: s = “rat”, t = “car”<br>输出: false</p></blockquote><p>说明:<br>你可以假设字符串只包含小写字母。</p><p>进阶:<br>如果输入字符串包含 unicode 字符怎么办？你能否调整你的解法来应对这种情况？</p><a id="more"></a><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/valid-anagram" target="_blank" rel="noopener">https://leetcode-cn.com/problems/valid-anagram</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p><h2 id="核心思路"><a href="#核心思路" class="headerlink" title="核心思路"></a>核心思路</h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>判断两个字符串互相是不是字母异位词，这也就意味着，两个字符串内的每个字符数量都是相同的。因此，我们只需要设定一个map集合来存储每个字符的数量即可</p><h3 id="解题步骤"><a href="#解题步骤" class="headerlink" title="解题步骤"></a>解题步骤</h3><ol><li>如果两字符的长度不一样则返回false</li><li>如果两字符相等，返回true</li><li>设定map集合，遍历其中一个字符串，以字符和字符个数为键值对存入哈希表中</li><li>遍历另一个字符串，如果出现哈希表中没有的字符，则返回false；如果是哈希表中已有的字符，那么将该键值减一</li><li>遍历哈希表，如果所有的键值都为0，那么返回true；否则返回false</li></ol><h2 id="Coding实现"><a href="#Coding实现" class="headerlink" title="Coding实现"></a>Coding实现</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @param &#123;string&#125; s</span></span><br><span class="line"><span class="comment"> * @param &#123;string&#125; t</span></span><br><span class="line"><span class="comment"> * @return &#123;boolean&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> isAnagram = <span class="function"><span class="keyword">function</span>(<span class="params">s, t</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(s.length!==t.length) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">if</span>(s===t) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">let</span> map=<span class="keyword">new</span> <span class="built_in">Map</span>();</span><br><span class="line">    <span class="keyword">let</span> flag=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> v <span class="keyword">of</span> s) &#123;</span><br><span class="line">        <span class="keyword">if</span>(map.has(v)) &#123;</span><br><span class="line">            map.set(v,map.get(v)+<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            map.set(v,<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> v <span class="keyword">of</span> t) &#123;</span><br><span class="line">        <span class="keyword">if</span>(map.has(v)) &#123;</span><br><span class="line">            map.set(v,map.get(v)<span class="number">-1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    map.forEach(<span class="function"><span class="params">v</span>=&gt;</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(v!==<span class="number">0</span>) flag=<span class="number">0</span>; </span><br><span class="line">    &#125;)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Boolean</span>(flag);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;有效的字母异位词&quot;&gt;&lt;a href=&quot;#有效的字母异位词&quot; class=&quot;headerlink&quot; title=&quot;有效的字母异位词&quot;&gt;&lt;/a&gt;有效的字母异位词&lt;/h1&gt;&lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h2&gt;&lt;p&gt;给定两个字符串 s 和 t ，编写一个函数来判断 t 是否是 s 的字母异位词。&lt;/p&gt;
&lt;p&gt;示例 1:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;输入: s = “anagram”, t = “nagaram”&lt;br&gt;输出: true&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;示例 2:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;输入: s = “rat”, t = “car”&lt;br&gt;输出: false&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;说明:&lt;br&gt;你可以假设字符串只包含小写字母。&lt;/p&gt;
&lt;p&gt;进阶:&lt;br&gt;如果输入字符串包含 unicode 字符怎么办？你能否调整你的解法来应对这种情况？&lt;/p&gt;
    
    </summary>
    
      <category term="leetcode题解与算法" scheme="http://yoursite.com/categories/leetcode%E9%A2%98%E8%A7%A3%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="哈希表" scheme="http://yoursite.com/tags/%E5%93%88%E5%B8%8C%E8%A1%A8/"/>
    
  </entry>
  
  <entry>
    <title>set集合与map集合</title>
    <link href="http://yoursite.com/2019/09/05/set%E9%9B%86%E5%90%88%E4%B8%8Emap%E9%9B%86%E5%90%88/"/>
    <id>http://yoursite.com/2019/09/05/set集合与map集合/</id>
    <published>2019-09-05T10:31:41.000Z</published>
    <updated>2019-09-05T11:37:29.172Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Set集合"><a href="#Set集合" class="headerlink" title="Set集合"></a>Set集合</h2><h3 id="Set集合的使用"><a href="#Set集合的使用" class="headerlink" title="Set集合的使用"></a>Set集合的使用</h3><p>语法</p><p>new Set([iterable]);</p><p>参数</p><p>iterable<br>    如果传递一个可迭代对象，它的所有元素将不重复地被添加到新的 Set中。如果不指定此参数或其值为null，则新的 Set为空。</p><p>返回值</p><p>一个新的Set对象</p><h3 id="set的一些基本操作"><a href="#set的一些基本操作" class="headerlink" title="set的一些基本操作"></a>set的一些基本操作</h3><p>Set对象的一些基本方法</p><ol><li>add() 向集合添加一个元素</li><li>delete() 向集合删除某个指定元素</li><li>clear() 清除集合内所有元素</li><li>has() 检查集合内是否有指定元素</li></ol><p>Set对象的一些属性</p><ol><li>size 集合大小</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="keyword">set</span>=new Set();</span><br><span class="line"><span class="keyword">set</span>.add(1);</span><br><span class="line"><span class="keyword">set</span>.add('1');</span><br><span class="line"></span><br><span class="line">console.log(<span class="keyword">set</span>.size); // 2</span><br><span class="line"><span class="keyword">set</span>.delete('1'); </span><br><span class="line">console.log(<span class="keyword">set</span>); // Set &#123; <span class="number">1</span> &#125;</span><br></pre></td></tr></table></figure><h3 id="Set的特性"><a href="#Set的特性" class="headerlink" title="Set的特性"></a>Set的特性</h3><p>在set集合内，存入元素的时候不会对值进行任何强制的类型转换，这也意味着，5和’5’在set集合内是两个不同的独立的元素</p><p>另外,如果往set集合内多次传入同一数据，那么后面的操作就会被忽略。因此，set集合内的元素是不重复的</p><h3 id="利用Set特性来实现数组去重"><a href="#利用Set特性来实现数组去重" class="headerlink" title="利用Set特性来实现数组去重"></a>利用Set特性来实现数组去重</h3><p>因为展开运算符可以将诸如set集合的可迭代对象转化为数组</p><p>因此，我们可以将数组传入set集合内，利用set内元素不能重复的特性实现去重。之后利用展开运算符，将set集合转化回数组、</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> test=[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">1</span>,<span class="number">3</span>,<span class="number">2</span>]; <span class="comment">// 创建一个具有重复元素的数组</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="keyword">set</span>=new Set(test);</span><br><span class="line">console.log([...<span class="keyword">set</span>]); // [1,2,3,4]</span><br></pre></td></tr></table></figure><h3 id="Set集合的遍历"><a href="#Set集合的遍历" class="headerlink" title="Set集合的遍历"></a>Set集合的遍历</h3><p>set集合使用forEach()方法来实现遍历</p><p>该方法的回调函数接受三个参数</p><ol><li>元素的值</li><li>元素的键名</li><li>自身set集合</li></ol><p>因为set集合存储的是单个元素而不是键值对，但是为了大多数方法中回调参数的统一，该回调函数的参数也按照键值的形式传参。</p><blockquote><p>但，值得注意的是，元素的键名与键值相同</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="keyword">set</span>=new Set([3,4,5]);</span><br><span class="line"><span class="keyword">set</span>.forEach((value,key,ownerSet)=&gt;&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(value,key,ownerSet);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3,3,&#123;3,4,5&#125;</span></span><br><span class="line"><span class="comment">// 4,4,&#123;3,4,5&#125;</span></span><br><span class="line"><span class="comment">// 5,5,&#123;3,4,5&#125;</span></span><br></pre></td></tr></table></figure><h3 id="WeakSet集合"><a href="#WeakSet集合" class="headerlink" title="WeakSet集合"></a>WeakSet集合</h3><h4 id="什么是WeakSet集合"><a href="#什么是WeakSet集合" class="headerlink" title="什么是WeakSet集合"></a>什么是WeakSet集合</h4><p>WeakSet 集合是一个弱引用Set集合，里面只能存储的弱引用，而不能存储基本类型值</p><h4 id="为什么要使用WeakSet"><a href="#为什么要使用WeakSet" class="headerlink" title="为什么要使用WeakSet"></a>为什么要使用WeakSet</h4><p>如果往set集合内加入某个引用类型值，那么set集合中的该元素也有了某个对象的引用。那么，就算在set集合外部释放了该对象（令该对象的值为null），set集合内部的那个元素仍然保持着那个对象的引用。因此，这会很容易造成内存泄漏</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a=&#123;</span><br><span class="line">    item:<span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 往set内传入a对象</span></span><br><span class="line"><span class="keyword">let</span> <span class="keyword">set</span>=new Set([a]);</span><br><span class="line"></span><br><span class="line">// 将a对象置为空对象</span><br><span class="line">a=null;</span><br><span class="line"></span><br><span class="line">// 但是<span class="keyword">set</span>集合中的元素仍然保持着该对象的引用</span><br><span class="line">console.log([...<span class="keyword">set</span>][0]); // &#123; item: <span class="number">1</span> &#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(a); <span class="comment">// null</span></span><br></pre></td></tr></table></figure><p>对于上述程序，显然我们可以看到，我们在set集合外部想要释放对象a，但是set集合引用着该对象，因此该对象的内存无法被释放</p><h4 id="WeakSet的使用"><a href="#WeakSet的使用" class="headerlink" title="WeakSet的使用"></a>WeakSet的使用</h4><p>WeakSet 对象中存储的对象值都是被弱引用的, 如果没有其他的变量或属性引用这个对象值, 则这个对象值会被当成垃圾回收掉. 正因为这样, WeakSet 对象是无法被枚举的, 没有办法拿到它包含的所有元素.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a=&#123;</span><br><span class="line">    item:<span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 往weakSet内传入a对象</span></span><br><span class="line"><span class="keyword">let</span> <span class="keyword">set</span>=new WeakSet([a]);</span><br><span class="line"></span><br><span class="line">// 将a对象置为空对象</span><br><span class="line">a=null;</span><br><span class="line"></span><br><span class="line">console.log(a); // null</span><br></pre></td></tr></table></figure><p>当WeakSet集合外部的引用被释放后，该引用就会被真正地完全释放</p><h4 id="weakSet集合的一些注意点"><a href="#weakSet集合的一些注意点" class="headerlink" title="weakSet集合的一些注意点"></a>weakSet集合的一些注意点</h4><p>weakSet只支持3个方法</p><ol><li>add()</li><li>has()</li><li>delete</li></ol><p>weakSet集合不可迭代和枚举，因此其不支持</p><ol><li>for…of循环</li><li>…展开运算符</li><li>forEach()方法</li><li>size属性</li></ol><h2 id="Map集合"><a href="#Map集合" class="headerlink" title="Map集合"></a>Map集合</h2><p>Map类型是一种存储着许多键值对的有序列表，其中的键名和键值支持所有的数据类型。</p><p>键名的等价性判断是通过Object.is()方法来进行判断的，所以数字5和字符串’5’会被判定为两种类型，可以分IE作为独立的两个键名来存储在Map结合内</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> map=<span class="keyword">new</span> <span class="built_in">Map</span>();</span><br><span class="line">map.set(<span class="string">'1'</span>,<span class="number">1</span>);</span><br><span class="line">map.set(<span class="number">1</span>,<span class="number">1</span>);</span><br><span class="line"><span class="built_in">console</span>.log(map); <span class="comment">// Map &#123; '1' =&gt; 1, 1 =&gt; 1 &#125;</span></span><br></pre></td></tr></table></figure><h3 id="Map集合的使用"><a href="#Map集合的使用" class="headerlink" title="Map集合的使用"></a>Map集合的使用</h3><p>语法</p><p>new Map([iterable])</p><p>参数</p><p>iterable<br>    Iterable 可以是一个数组或者其他 iterable 对象，其元素为键值对(两个元素的数组，例如: [[ 1, ‘one’ ],[ 2, ‘two’ ]])。 每个键值对都会添加到新的 Map。null 会被当做 undefined。 </p><h3 id="Map的一些基本方法"><a href="#Map的一些基本方法" class="headerlink" title="Map的一些基本方法"></a>Map的一些基本方法</h3><p>Map集合具有以下一些基本方法</p><ol><li>set() 传入键名和键值来设定一个键值对</li><li>delete() 删除指定键值对</li><li>clear() 删除全部键值对</li><li>has() 判断某个键值对是否存在</li><li>get() 传入键名来获取键值</li></ol><p>Map集合具有以下一些属性</p><ol><li>size Map集合的大小</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> map=<span class="keyword">new</span> <span class="built_in">Map</span>();</span><br><span class="line">map.set(<span class="string">'a'</span>,<span class="string">'a'</span>);</span><br><span class="line">map.set(<span class="string">'b'</span>,<span class="string">'b'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(map.get(<span class="string">'a'</span>)); <span class="comment">// 'a'</span></span><br><span class="line">map.delete(<span class="string">'a'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(map.size); <span class="comment">// 1</span></span><br><span class="line"><span class="built_in">console</span>.log(map.has(<span class="string">'a'</span>)); <span class="comment">// false</span></span><br></pre></td></tr></table></figure><h3 id="Map集合的遍历"><a href="#Map集合的遍历" class="headerlink" title="Map集合的遍历"></a>Map集合的遍历</h3><p>Map集合也是使用forEach()方法来进行遍历</p><p>其回调函数接受三个参数</p><ol><li>value 键值</li><li>key 键名<br>3，ownerMap 自身map集合</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> map=<span class="keyword">new</span> <span class="built_in">Map</span>([[<span class="number">1</span>,<span class="number">1</span>],[<span class="string">'1'</span>,<span class="string">'1'</span>]]);</span><br><span class="line">map.forEach(<span class="function">(<span class="params">value,key,ownerMap</span>)=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(value,key,ownerMap);</span><br><span class="line">&#125;);</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 1 1 Map &#123; 1 =&gt; 1, '1' =&gt; '1' &#125;</span></span><br><span class="line"><span class="comment">// '1' '1' Map &#123; 1 =&gt; 1, '1' =&gt; '1' &#125;</span></span><br></pre></td></tr></table></figure><h3 id="WeakMap集合"><a href="#WeakMap集合" class="headerlink" title="WeakMap集合"></a>WeakMap集合</h3><p>类似于WeakSet集合，WeakMap是弱引用Map集合。其中，它的键名必须是非null类型的对象，键值则可以使任意类型的值</p><p>WeakMap集合中保存的是键名弱引用着的引用对象，如果在弱引用之外不再有任何其他强引用，那么垃圾回收机制就会自动回收这个对象</p><p>只有集合的键名遵守以上规则，如果键值是一个对象，那么该引用是强引用，不会触发垃圾回收机制</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Set集合&quot;&gt;&lt;a href=&quot;#Set集合&quot; class=&quot;headerlink&quot; title=&quot;Set集合&quot;&gt;&lt;/a&gt;Set集合&lt;/h2&gt;&lt;h3 id=&quot;Set集合的使用&quot;&gt;&lt;a href=&quot;#Set集合的使用&quot; class=&quot;headerlink&quot; titl
      
    
    </summary>
    
      <category term="ES6" scheme="http://yoursite.com/categories/ES6/"/>
    
    
      <category term="基础语法" scheme="http://yoursite.com/tags/%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>解构</title>
    <link href="http://yoursite.com/2019/09/04/%E8%A7%A3%E6%9E%84/"/>
    <id>http://yoursite.com/2019/09/04/解构/</id>
    <published>2019-09-04T11:42:42.000Z</published>
    <updated>2019-09-04T13:35:46.501Z</updated>
    
    <content type="html"><![CDATA[<h2 id="为什么需要解构"><a href="#为什么需要解构" class="headerlink" title="为什么需要解构"></a>为什么需要解构</h2><p>在Es6之前，当我们需要从一个对象中取出某个属性的值时，我们通常会这么做：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> test=&#123;</span><br><span class="line">    a:<span class="number">1</span>,</span><br><span class="line">    b:<span class="number">2</span>,</span><br><span class="line">    c:<span class="number">3</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(test.a); <span class="comment">// 1</span></span><br><span class="line"><span class="built_in">console</span>.log(test.b); <span class="comment">// 2</span></span><br><span class="line"><span class="built_in">console</span>.log(test.c); <span class="comment">// 3</span></span><br></pre></td></tr></table></figure><p>显然我们可以看到，我们重复写了很多同样的代码；况且这只是仅仅只有一层，如果其中还包含更多的嵌套解构的话，那么我们就需要编写更长更多的代码</p><p>然而，Es6的解构就很好地解决了这些问题</p><h2 id="对象解构"><a href="#对象解构" class="headerlink" title="对象解构"></a>对象解构</h2><p>对象解构的语法形式是在一个赋值操作符左边放置一个对象字面量,那么左边对象字面量中的变量就可以获得右边对象中的同名变量的属性值</p><p>例如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> test=&#123;</span><br><span class="line">    a:<span class="number">1</span>,</span><br><span class="line">    b:<span class="number">2</span>,</span><br><span class="line">    c:<span class="number">3</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 变量声明的时候，解构对象获得对应属性值</span></span><br><span class="line"><span class="keyword">let</span> &#123;a,b,c&#125;=test;</span><br><span class="line"><span class="built_in">console</span>.log(a,b,c); <span class="comment">// 1,2,3</span></span><br></pre></td></tr></table></figure><p>注意：<br>只要使用了解构来声明变量，那么就必须要给该表达式初始化（即提供等号右侧的值）</p><h3 id="解构赋值"><a href="#解构赋值" class="headerlink" title="解构赋值"></a>解构赋值</h3><p>不同于上面的那段程序，是在变量声明的时候就解构对象来得到相应的属性值。解构赋值，是在变量已经声明结束后，在普通赋值表达式的时候进行解构</p><blockquote><p>但此时，一定要记住，需要用一对<strong>小括号</strong>来包裹解构赋值表达式；</p></blockquote><p>因为，在之前提过，JavaScritp将一对花括号之间的区域视为一个代码块，但是代码块语句不允许出现在赋值表达式左侧。因此，我们通过在解构赋值语句外包裹一对小括号来讲该块语句转化为一个表达式</p><p>例如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> test=&#123;</span><br><span class="line">    a:<span class="number">1</span>,</span><br><span class="line">    b:<span class="number">2</span>,</span><br><span class="line">    c:<span class="number">3</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> a,b,c;</span><br><span class="line">(&#123;a,b,c&#125;=test);</span><br><span class="line"><span class="built_in">console</span>.log(a,b,c);</span><br></pre></td></tr></table></figure><h4 id="给函数传递参数的同时解构"><a href="#给函数传递参数的同时解构" class="headerlink" title="给函数传递参数的同时解构"></a>给函数传递参数的同时解构</h4><p>只要你想获得对象中某些参数的值，无论是在哪里你都可以利用解构，比如在函数传参的环节</p><p>例：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> test=&#123;</span><br><span class="line">    a:<span class="number">1</span>,</span><br><span class="line">    b:<span class="number">2</span>,</span><br><span class="line">    c:<span class="number">3</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getValue</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(getValue(&#123;a,b,c&#125;=test)); <span class="comment">// &#123; a: 1, b: 2, c: 3 &#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(a,b,c); <span class="comment">// 1,2,3</span></span><br></pre></td></tr></table></figure><p>因为JavaScript表达式的结果会是等号右边的值，因此实参的表达式 {a,b,c}=test的结果会是test对象，因此传递给getValue函数的是test对象，但是在此表达式的执行过程中，也进行了解构操作，因此也得到了a,b,c的值</p><h3 id="解构赋值也可以使用默认值"><a href="#解构赋值也可以使用默认值" class="headerlink" title="解构赋值也可以使用默认值"></a>解构赋值也可以使用默认值</h3><p>在使用解构赋值表达式的时候，如果指定的局部变量名称在对象中并没有该属性，那么该变量会被赋予undefined</p><p>例如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> test=&#123;</span><br><span class="line">    a:<span class="number">1</span>,</span><br><span class="line">    b:<span class="number">2</span>,</span><br><span class="line">    c:<span class="number">3</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> &#123;a,b,c,d,e&#125;=test;</span><br><span class="line"><span class="built_in">console</span>.log(a,b,c,d,e); <span class="comment">// 1,2,3,undefined,undefined</span></span><br></pre></td></tr></table></figure><p>但其实，类似于之前提到过的默认参数（当形参没有获得实参时，那些提前被赋予默认值的参数就可以使用默认值），在解构赋值时也可以使用默认值</p><p>例如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> test=&#123;</span><br><span class="line">    a:<span class="number">1</span>,</span><br><span class="line">    b:<span class="number">2</span>,</span><br><span class="line">    c:<span class="number">3</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> &#123;a=<span class="string">'aaa'</span>,b=<span class="string">'bbb'</span>,c=<span class="string">'ccc'</span>,d=<span class="string">'ddd'</span>,e=<span class="string">'eee'</span>&#125;=test;</span><br><span class="line"><span class="built_in">console</span>.log(a,b,c,d,e); <span class="comment">// 1,2,3,'ddd','eee'</span></span><br></pre></td></tr></table></figure><p>当指定的属性不存在时，我们变量就会获得预先设定的默认值</p><h3 id="为非同名局部变量赋值"><a href="#为非同名局部变量赋值" class="headerlink" title="为非同名局部变量赋值"></a>为非同名局部变量赋值</h3><p>有些时候，我们只想取得某个对象中的属性值而不是命名与属性名相同的变量名，也就是为非同名局部变量解构赋值</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> test=&#123;</span><br><span class="line">    a:<span class="number">1</span>,</span><br><span class="line">    b:<span class="number">2</span>,</span><br><span class="line">    c:<span class="number">3</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用冒号语法来为非同名变量赋值</span></span><br><span class="line"><span class="keyword">let</span> &#123;<span class="attr">a</span>:itemA,<span class="attr">b</span>:itemB,<span class="attr">c</span>:itemC&#125;=test;</span><br><span class="line"><span class="built_in">console</span>.log(itemA,itemB,itemC); <span class="comment">// 1,2,3</span></span><br><span class="line"><span class="built_in">console</span>.log(a,b,c); <span class="comment">// 报错：a is not defined</span></span><br></pre></td></tr></table></figure><h3 id="嵌套对象解构"><a href="#嵌套对象解构" class="headerlink" title="嵌套对象解构"></a>嵌套对象解构</h3><p>无论嵌套多少层，我们只需要记住将赋值操作符左边的解构对象看作是一个对象字面量，这个对象字面量等于右边给定的对象，那么我们就可以很容易对比两个对象得到需要的属性值</p><p>例如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> test=&#123;</span><br><span class="line">    a:<span class="number">1</span>,</span><br><span class="line">    b:<span class="number">2</span>,</span><br><span class="line">    c:&#123;</span><br><span class="line">        a:<span class="string">'a'</span>,</span><br><span class="line">        b:<span class="string">'b'</span>,</span><br><span class="line">        c:<span class="string">'c'</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 解构嵌套对象时，我们只能获得当前解构对象内的最深层变量赋值</span></span><br><span class="line"><span class="keyword">let</span> &#123;<span class="attr">c</span>:&#123;b&#125;&#125;=test;</span><br><span class="line"><span class="built_in">console</span>.log(b); <span class="comment">// 'b'</span></span><br><span class="line"><span class="built_in">console</span>.log(c); <span class="comment">// 报错 c is not defined</span></span><br></pre></td></tr></table></figure><h2 id="数组解构"><a href="#数组解构" class="headerlink" title="数组解构"></a>数组解构</h2><p>数组解构使用的数组字面量，且解构操作全部在数组内完成</p><p>在数组解构语法中，我们是通过值在数组中的位置来进行获取数组元素值的</p><p>例如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> test=[<span class="number">1</span>,<span class="number">2</span>,&#123;<span class="attr">item</span>:<span class="number">3</span>&#125;];</span><br><span class="line"><span class="keyword">let</span> [a,b,c]=test;</span><br><span class="line"><span class="built_in">console</span>.log(a,b,c); <span class="comment">// 1,2,&#123; item: 3 &#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(c===test[<span class="number">2</span>]); <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>当然我们也可以只取得其中的几项，未显示声明的元素都会被忽略（通过设置空白占位符）</p><p>例如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> test=[<span class="number">1</span>,<span class="number">2</span>,&#123;<span class="attr">item</span>:<span class="number">3</span>&#125;];</span><br><span class="line"><span class="keyword">let</span> [a, ,c]=test;</span><br><span class="line"><span class="built_in">console</span>.log(a,c); <span class="comment">// 1,&#123;item:3&#125;</span></span><br></pre></td></tr></table></figure><h3 id="数组解构赋值"><a href="#数组解构赋值" class="headerlink" title="数组解构赋值"></a>数组解构赋值</h3><p>数组解构不像对象解构，因为数组使用[]包裹的，而不是对象字面量的{}，因此，数组的解构赋值会被当做一个表达式</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> test=[<span class="number">1</span>,<span class="number">2</span>,&#123;<span class="attr">item</span>:<span class="number">3</span>&#125;];</span><br><span class="line"><span class="keyword">let</span> a,b,c; <span class="comment">// 声明a,b,c</span></span><br><span class="line"></span><br><span class="line">[a,b,c]=test;</span><br><span class="line"><span class="built_in">console</span>.log(a,b,c); <span class="comment">// 1,2,&#123;item:3&#125;</span></span><br></pre></td></tr></table></figure><h4 id="交换变量"><a href="#交换变量" class="headerlink" title="交换变量"></a>交换变量</h4><p>数组解构赋值语法有一个独特的用例，可以用来交换两个变量的值</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a=<span class="number">1</span>,b=<span class="number">2</span>;</span><br><span class="line">[a,b]=[b,a];</span><br><span class="line"><span class="built_in">console</span>.log(a,b); <span class="comment">// 2,1</span></span><br></pre></td></tr></table></figure><p>对于上述代码，在表达式赋值之前，我们会先求得表达式左右两侧的值之后在进行赋值。右侧根据a,b生成一个数组对象，因此，这就符合了数组解构赋值的语法</p><p>因为在数组解构语法中，我们是通过值在数组中的位置来进行获取数组元素值的，而不是像对象解构是根据同名变量来的，因此，在这里，局部变量a会获得数组[b,a]的第一个元素也就是2，局部变量b会获得数组[b,a]的第二个元素也就是1</p><p>上述代码可以转化为</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a=<span class="number">1</span>,b=<span class="number">2</span>;</span><br><span class="line"><span class="keyword">let</span> arr=[b,a];</span><br><span class="line"><span class="built_in">console</span>.log(arr); <span class="comment">// [2,1]</span></span><br><span class="line">[a,b]=arr;</span><br><span class="line"><span class="built_in">console</span>.log(a,b); <span class="comment">// 2,1</span></span><br></pre></td></tr></table></figure><h3 id="数组解构赋值中的默认值"><a href="#数组解构赋值中的默认值" class="headerlink" title="数组解构赋值中的默认值"></a>数组解构赋值中的默认值</h3><p>类似于对象解构赋值我们可以使用默认值，在数组解构赋值中我们同样也可以使用默认值</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> test=[<span class="number">1</span>,<span class="number">2</span>,&#123;<span class="attr">item</span>:<span class="number">3</span>&#125;];</span><br><span class="line"><span class="keyword">let</span> [a=<span class="string">'aaa'</span>,b=<span class="string">'bbb'</span>,c=<span class="string">'ccc'</span>,d=<span class="string">'ddd'</span>,e=<span class="string">'eee'</span>]=test;</span><br><span class="line"><span class="built_in">console</span>.log(a,b,c,d,e); <span class="comment">// 1,2,&#123;item:3&#125;,ddd,eee</span></span><br></pre></td></tr></table></figure><h3 id="嵌套数组解构"><a href="#嵌套数组解构" class="headerlink" title="嵌套数组解构"></a>嵌套数组解构</h3><p>类似于对象的嵌套解构</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> test=[<span class="number">1</span>,<span class="number">2</span>,[<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>]];</span><br><span class="line"><span class="keyword">let</span> [a, ,[ , ,c]]=test;</span><br><span class="line"><span class="built_in">console</span>.log(a,c); <span class="comment">// 1,5</span></span><br></pre></td></tr></table></figure><h3 id="不定元素"><a href="#不定元素" class="headerlink" title="不定元素"></a>不定元素</h3><p>在数组中，我们可以通过…语法将数组中的其余元素都赋值给一个特定的变量。我们把这称之为不定元素</p><p><strong>注意</strong>：<br>在被解构的数组中，不定元素必须为最后一个条目，在不定元素后面继续添加都好会导致程序抛出语法错误</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> test=[<span class="number">1</span>,<span class="number">2</span>,&#123;<span class="attr">item</span>:<span class="number">3</span>&#125;,[<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>]];</span><br><span class="line"><span class="keyword">let</span> [a, , ,[...d]]=test;</span><br><span class="line"><span class="built_in">console</span>.log(a,d); <span class="comment">// 1,[4,5,6]</span></span><br></pre></td></tr></table></figure><h2 id="混合解构"><a href="#混合解构" class="headerlink" title="混合解构"></a>混合解构</h2><p>顾名思义，就是在任何混杂真对象和数组的数据解构得到某些值</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> test=&#123;</span><br><span class="line">    a:<span class="number">1</span>,</span><br><span class="line">    b:<span class="number">2</span>,</span><br><span class="line">    c:&#123;</span><br><span class="line">        a:<span class="number">1</span>,</span><br><span class="line">        b:&#123;</span><br><span class="line">            b:<span class="number">2</span></span><br><span class="line">        &#125;,</span><br><span class="line">        c:[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> &#123;<span class="attr">c</span>:&#123;b,<span class="attr">c</span>:[ , ,d]&#125;&#125;=test;</span><br><span class="line"><span class="built_in">console</span>.log(b,d); <span class="comment">// &#123;b:2&#125;,3</span></span><br></pre></td></tr></table></figure><p>在上述代码中的冒号前的变量代表对象的属性，并不是声明的局部变量</p><h2 id="解构参数"><a href="#解构参数" class="headerlink" title="解构参数"></a>解构参数</h2><p>解构可以用在函数参数的传递过程中，我们可以使用对象或数组解构模式来替代命名参数</p><p>例如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getValue</span>(<span class="params">&#123;a,b,c&#125;</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(a,b,c); <span class="comment">// 1,2,3</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> test=&#123;</span><br><span class="line">    a:<span class="number">1</span>,</span><br><span class="line">    b:<span class="number">2</span>,</span><br><span class="line">    c:<span class="number">3</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">getValue(test);</span><br></pre></td></tr></table></figure><blockquote><p>注意，解构参数必须传值，对于上述代码，我们就不能穿一个null空对象或者undefined，不然就会使程序抛出语法错误</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;为什么需要解构&quot;&gt;&lt;a href=&quot;#为什么需要解构&quot; class=&quot;headerlink&quot; title=&quot;为什么需要解构&quot;&gt;&lt;/a&gt;为什么需要解构&lt;/h2&gt;&lt;p&gt;在Es6之前，当我们需要从一个对象中取出某个属性的值时，我们通常会这么做：&lt;/p&gt;
&lt;figure 
      
    
    </summary>
    
      <category term="ES6" scheme="http://yoursite.com/categories/ES6/"/>
    
    
      <category term="基础语法" scheme="http://yoursite.com/tags/%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>leetcode-235 二叉搜索树的最近公共祖先</title>
    <link href="http://yoursite.com/2019/09/04/leetcode-235/"/>
    <id>http://yoursite.com/2019/09/04/leetcode-235/</id>
    <published>2019-09-04T11:09:34.000Z</published>
    <updated>2019-09-04T11:31:40.138Z</updated>
    
    <content type="html"><![CDATA[<h1 id="二叉搜索树的最近公共祖先"><a href="#二叉搜索树的最近公共祖先" class="headerlink" title="二叉搜索树的最近公共祖先"></a>二叉搜索树的最近公共祖先</h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>给定一个二叉搜索树, 找到该树中两个指定节点的最近公共祖先。</p><p>百度百科中最近公共祖先的定义为：“对于有根树 T 的两个结点 p、q，最近公共祖先表示为一个结点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（一个节点也可以是它自己的祖先）。”</p><p>例如，给定如下二叉搜索树:  root = [6,2,8,0,4,7,9,null,null,3,5]</p><p>示例 1:</p><p>输入: root = [6,2,8,0,4,7,9,null,null,3,5], p = 2, q = 8<br>输出: 6<br>解释: 节点 2 和节点 8 的最近公共祖先是 6。<br>示例 2:</p><p>输入: root = [6,2,8,0,4,7,9,null,null,3,5], p = 2, q = 4<br>输出: 2<br>解释: 节点 2 和节点 4 的最近公共祖先是 2, 因为根据定义最近公共祖先节点可以为节点本身。</p><p>说明:</p><p>所有节点的值都是唯一的。<br>p、q 为不同节点且均存在于给定的二叉搜索树中。</p><a id="more"></a><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/lowest-common-ancestor-of-a-binary-search-tree" target="_blank" rel="noopener">https://leetcode-cn.com/problems/lowest-common-ancestor-of-a-binary-search-tree</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p><h2 id="核心思路"><a href="#核心思路" class="headerlink" title="核心思路"></a>核心思路</h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>因为该树为二叉搜索树，因此，每个节点的左子树均小于等于它的值；每个节点的右子树均大于等于它的值；那么，如果当给定的节点分别位于某节点的两侧时，则该节点为给定两节点的最近公共祖先</p><h3 id="解题步骤"><a href="#解题步骤" class="headerlink" title="解题步骤"></a>解题步骤</h3><ol><li>先序遍历该二叉搜索树，如果给定两节点的值均小于该节点，那么遍历该节点的左子树</li><li>如果给定两节点的值均大于该节点，那么遍历该节点的右子树</li><li>如果该节点的值小于某节点的值又大于另一节点的值，那么返回该节点</li></ol><h2 id="Coding实现"><a href="#Coding实现" class="headerlink" title="Coding实现"></a>Coding实现</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * function TreeNode(val) &#123;</span></span><br><span class="line"><span class="comment"> *     this.val = val;</span></span><br><span class="line"><span class="comment"> *     this.left = this.right = null;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @param &#123;TreeNode&#125; root</span></span><br><span class="line"><span class="comment"> * @param &#123;TreeNode&#125; p</span></span><br><span class="line"><span class="comment"> * @param &#123;TreeNode&#125; q</span></span><br><span class="line"><span class="comment"> * @return &#123;TreeNode&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> lowestCommonAncestor = <span class="function"><span class="keyword">function</span>(<span class="params">root, p, q</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root===<span class="literal">null</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(p.val&gt;root.val&amp;&amp;q.val&gt;root.val) &#123;</span><br><span class="line">            <span class="keyword">return</span> lowestCommonAncestor(root.right,p,q);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(p.val&lt;root.val&amp;&amp;q.val&lt;root.val) &#123;</span><br><span class="line">            <span class="keyword">return</span> lowestCommonAncestor(root.left,p,q);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> root;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;二叉搜索树的最近公共祖先&quot;&gt;&lt;a href=&quot;#二叉搜索树的最近公共祖先&quot; class=&quot;headerlink&quot; title=&quot;二叉搜索树的最近公共祖先&quot;&gt;&lt;/a&gt;二叉搜索树的最近公共祖先&lt;/h1&gt;&lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h2&gt;&lt;p&gt;给定一个二叉搜索树, 找到该树中两个指定节点的最近公共祖先。&lt;/p&gt;
&lt;p&gt;百度百科中最近公共祖先的定义为：“对于有根树 T 的两个结点 p、q，最近公共祖先表示为一个结点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（一个节点也可以是它自己的祖先）。”&lt;/p&gt;
&lt;p&gt;例如，给定如下二叉搜索树:  root = [6,2,8,0,4,7,9,null,null,3,5]&lt;/p&gt;
&lt;p&gt;示例 1:&lt;/p&gt;
&lt;p&gt;输入: root = [6,2,8,0,4,7,9,null,null,3,5], p = 2, q = 8&lt;br&gt;输出: 6&lt;br&gt;解释: 节点 2 和节点 8 的最近公共祖先是 6。&lt;br&gt;示例 2:&lt;/p&gt;
&lt;p&gt;输入: root = [6,2,8,0,4,7,9,null,null,3,5], p = 2, q = 4&lt;br&gt;输出: 2&lt;br&gt;解释: 节点 2 和节点 4 的最近公共祖先是 2, 因为根据定义最近公共祖先节点可以为节点本身。&lt;/p&gt;
&lt;p&gt;说明:&lt;/p&gt;
&lt;p&gt;所有节点的值都是唯一的。&lt;br&gt;p、q 为不同节点且均存在于给定的二叉搜索树中。&lt;/p&gt;
    
    </summary>
    
      <category term="leetcode题解与算法" scheme="http://yoursite.com/categories/leetcode%E9%A2%98%E8%A7%A3%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="树" scheme="http://yoursite.com/tags/%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>原型对象的设置与访问</title>
    <link href="http://yoursite.com/2019/09/03/%E5%8E%9F%E5%9E%8B%E5%AF%B9%E8%B1%A1%E7%9A%84%E8%AE%BE%E7%BD%AE%E4%B8%8E%E8%AE%BF%E9%97%AE/"/>
    <id>http://yoursite.com/2019/09/03/原型对象的设置与访问/</id>
    <published>2019-09-03T13:17:58.000Z</published>
    <updated>2019-09-03T13:47:07.254Z</updated>
    
    <content type="html"><![CDATA[<h2 id="原型对象的访问"><a href="#原型对象的访问" class="headerlink" title="原型对象的访问"></a>原型对象的访问</h2><h3 id="proto"><a href="#proto" class="headerlink" title="__proto__"></a>__proto__</h3><p><strong>proto</strong>属性是Object.prototype 一个简单的访问器属性，其中包含了get（获取）和set（设置）的方法</p><p><strong>proto</strong>的读取器(getter)暴露了一个对象的内部 [[Prototype]] 。对于使用对象字面量创建的对象，这个值是 Object.prototype。对于使用数组字面量创建的对象，这个值是 Array.prototype。对于functions，这个值是Function.prototype。</p><p><strong>proto</strong> 的设置器(setter)允许对象的 [[Prototype]]被变更。要变更的值必须是一个object或null，提供其它值将不起任何作用。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Test</span>(<span class="params">item</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.item=item;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Test.prototype.sayHello=<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'hello'</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> test=<span class="keyword">new</span> Test();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用__proto__属性访问原型</span></span><br><span class="line"><span class="built_in">console</span>.log(test.__proto__); <span class="comment">// Test &#123; sayHello: [Function] &#125;</span></span><br><span class="line">test.sayHello(); <span class="comment">// 'hello'</span></span><br></pre></td></tr></table></figure><h3 id="Object-getPrototypeOf"><a href="#Object-getPrototypeOf" class="headerlink" title="Object.getPrototypeOf()"></a>Object.getPrototypeOf()</h3><h4 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h4><p>Object.getPrototypeOf() 方法返回指定对象的原型（内部[[Prototype]]属性的值）。</p><h4 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h4><blockquote><p>Object.getPrototypeOf(object)</p></blockquote><p>参数：<br>obj: 要返回的对象的原型</p><h4 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Test</span>(<span class="params">item</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.item=item;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Test.prototype.sayHello=<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'hello'</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> test=<span class="keyword">new</span> Test();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用Object.getPrototypeOf()方法访问原型</span></span><br><span class="line"><span class="keyword">let</span> proto=<span class="built_in">Object</span>.getPrototypeOf(test);</span><br><span class="line"><span class="built_in">console</span>.log(proto); <span class="comment">// Test &#123; sayHello: [Function] &#125;</span></span><br></pre></td></tr></table></figure><h2 id="原型对象的设置"><a href="#原型对象的设置" class="headerlink" title="原型对象的设置"></a>原型对象的设置</h2><h3 id="Object-setPrototypeOf"><a href="#Object-setPrototypeOf" class="headerlink" title="Object.setPrototypeOf()"></a>Object.setPrototypeOf()</h3><h4 id="概述-1"><a href="#概述-1" class="headerlink" title="概述"></a>概述</h4><p>Object.setPrototypeOf() 方法设置一个指定的对象的原型 ( 即, 内部[[Prototype]]属性）到另一个对象或  null。</p><h4 id="语法-1"><a href="#语法-1" class="headerlink" title="语法"></a>语法</h4><blockquote><p>Object.setPrototypeOf(obj, prototype)</p></blockquote><p>参数：<br>obj: 要设置其原型的对象</p><p>prototype: 该对象的新原型（一个对象或null）</p><h4 id="例子-1"><a href="#例子-1" class="headerlink" title="例子"></a>例子</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Test</span>(<span class="params">item</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.item=item;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Test.prototype.sayHello=<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'hello'</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> test=<span class="keyword">new</span> Test();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用Object.setPrototypeOf()方法修改对象的原型</span></span><br><span class="line"><span class="keyword">let</span> a=&#123;</span><br><span class="line">    sayHello() &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'say hello'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.setPrototypeOf(test,a);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.getPrototypeOf(test)===a); <span class="comment">// true</span></span><br><span class="line">test.sayHello(); <span class="comment">// 'say hello'</span></span><br></pre></td></tr></table></figure><h3 id="Object-create"><a href="#Object-create" class="headerlink" title="Object.create()"></a>Object.create()</h3><h4 id="概述-2"><a href="#概述-2" class="headerlink" title="概述"></a>概述</h4><p>Object.create()方法创建一个新对象，使用现有的对象来提供新创建的对象的<strong>proto</strong>。 </p><h4 id="语法-2"><a href="#语法-2" class="headerlink" title="语法"></a>语法</h4><blockquote><p>Object.create(proto[, propertiesObject])</p></blockquote><p>参数：<br>proto<br>    新创建对象的原型对象。</p><p>propertiesObject<br>    可选。如果没有指定为 undefined，则是要添加到新创建对象的可枚举属性（即其自身定义的属性，而不是其原型链上的枚举属性）对象的属性描述符以及相应的属性名称。这些属性对应Object.defineProperties()的第二个参数。</p><p>返回值</p><p>一个新对象，带着指定的原型对象和属性。</p><h4 id="例子-2"><a href="#例子-2" class="headerlink" title="例子"></a>例子</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Test</span>(<span class="params">item</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.item=item;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Test.prototype.sayHello=<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'hello'</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用Object.create创建一个新对象，该新对象的原型对象为给定值</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> test=<span class="built_in">Object</span>.create(Test.prototype);</span><br><span class="line">Test.call(test,<span class="number">1</span>);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.getPrototypeOf(test)===Test.prototype); <span class="comment">// true</span></span><br><span class="line">test.sayHello(); <span class="comment">// 'hello'</span></span><br><span class="line"><span class="built_in">console</span>.log(test.item); <span class="comment">// 1</span></span><br><span class="line"><span class="built_in">console</span>.log(test); <span class="comment">// Test &#123; item: 1 &#125;</span></span><br></pre></td></tr></table></figure><h3 id="proto-1"><a href="#proto-1" class="headerlink" title="__proto__"></a>__proto__</h3><h4 id="例子-3"><a href="#例子-3" class="headerlink" title="例子"></a>例子</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Test</span>(<span class="params">item</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.item=item;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Test.prototype.sayHello=<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'hello'</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用__Proto__属性来设置原型</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> test=&#123;&#125;;</span><br><span class="line">test.__proto__=Test.prototype;</span><br><span class="line">Test.call(test,<span class="number">1</span>);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.getPrototypeOf(test)===Test.prototype); <span class="comment">// true</span></span><br><span class="line">test.sayHello(); <span class="comment">// 'hello'</span></span><br><span class="line"><span class="built_in">console</span>.log(test.item); <span class="comment">// 1</span></span><br><span class="line"><span class="built_in">console</span>.log(test); <span class="comment">// Test &#123; item: 1 &#125;</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;原型对象的访问&quot;&gt;&lt;a href=&quot;#原型对象的访问&quot; class=&quot;headerlink&quot; title=&quot;原型对象的访问&quot;&gt;&lt;/a&gt;原型对象的访问&lt;/h2&gt;&lt;h3 id=&quot;proto&quot;&gt;&lt;a href=&quot;#proto&quot; class=&quot;headerlink&quot; ti
      
    
    </summary>
    
      <category term="javaScript基础" scheme="http://yoursite.com/categories/javaScript%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="基础语法" scheme="http://yoursite.com/tags/%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>获取对象属性名的几种方法</title>
    <link href="http://yoursite.com/2019/09/03/%E8%8E%B7%E5%8F%96%E5%AF%B9%E8%B1%A1%E5%B1%9E%E6%80%A7%E5%90%8D%E7%9A%84%E5%87%A0%E7%A7%8D%E6%96%B9%E6%B3%95/"/>
    <id>http://yoursite.com/2019/09/03/获取对象属性名的几种方法/</id>
    <published>2019-09-03T08:07:40.000Z</published>
    <updated>2019-09-03T08:43:36.571Z</updated>
    
    <content type="html"><![CDATA[<h2 id="什么是可枚举属性和不可枚举属性"><a href="#什么是可枚举属性和不可枚举属性" class="headerlink" title="什么是可枚举属性和不可枚举属性"></a>什么是可枚举属性和不可枚举属性</h2><p>可枚举属性是指那些内部 “可枚举” 标志（[[ Enumerable]]）设置为 true 的属性。</p><p>对于通过直接的赋值和属性初始化的属性，该标识值默认为即为 true;</p><p>对于通过 Object.defineProperty 等定义的属性，该标识值默认为 false（当然该方法也可以设置 enumerable的值为true，使其变为可枚举属性）。</p><h2 id="Object-keys-–只返回自身对象的可枚举属性"><a href="#Object-keys-–只返回自身对象的可枚举属性" class="headerlink" title="Object.keys() –只返回自身对象的可枚举属性"></a>Object.keys() –只返回自身对象的可枚举属性</h2><p>Object.keys() 方法会返回一个由一个给定对象的自身可枚举属性组成的数组，数组中属性名的排列顺序和使用 for…in 循环遍历该对象时返回的顺序一致 。如果对象的键-值都不可枚举，那么将返回由键组成的数组。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a=&#123;</span><br><span class="line">    item:<span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> b=&#123;</span><br><span class="line">    b:<span class="number">2</span>,</span><br><span class="line">    c() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.b;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置a对象的不可枚举属性</span></span><br><span class="line"><span class="built_in">Object</span>.defineProperty(a,<span class="string">'_item'</span>,&#123;</span><br><span class="line">    <span class="keyword">get</span>:function() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.item;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="keyword">set</span>:function(item) &#123;</span><br><span class="line">        <span class="keyword">this</span>.item=item;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置b对象为a的原型对象</span></span><br><span class="line"><span class="built_in">Object</span>.setPrototypeOf(a,b);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 只会返回当前对象的所有可枚举属性，而不会返回其原型对象上的可枚举属性</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.keys(a)); <span class="comment">// ['item']</span></span><br></pre></td></tr></table></figure><h2 id="for…in-–返回整条原型链上的可枚举属性"><a href="#for…in-–返回整条原型链上的可枚举属性" class="headerlink" title="for…in –返回整条原型链上的可枚举属性"></a>for…in –返回整条原型链上的可枚举属性</h2><p>for…in语句以任意顺序遍历一个对象的除Symbol以外的可枚举属性。</p><p>循环将遍历对象本身的所有可枚举属性，以及对象从其构造函数原型中继承的属性（更接近原型链中对象的属性覆盖原型属性）。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a=&#123;</span><br><span class="line">    item:<span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> b=&#123;</span><br><span class="line">    b:<span class="number">2</span>,</span><br><span class="line">    c() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.b;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置a对象的不可枚举属性</span></span><br><span class="line"><span class="built_in">Object</span>.defineProperty(a,<span class="string">'_item'</span>,&#123;</span><br><span class="line">    <span class="keyword">get</span>:function() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.item;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="keyword">set</span>:function(item) &#123;</span><br><span class="line">        <span class="keyword">this</span>.item=item;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置b对象为a对象的原型对象</span></span><br><span class="line"><span class="built_in">Object</span>.setPrototypeOf(a,b);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 会返回其自身的所有可枚举属性以及其原型链上的所有可枚举属性(包括其原型对象，其原型对象的原型对象一直到除Object,prototype的顶端原型对象)</span></span><br><span class="line"><span class="keyword">let</span> ans=[];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> i <span class="keyword">in</span> a) &#123;</span><br><span class="line">    ans.push(i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(ans); <span class="comment">// ['item','b','c']</span></span><br></pre></td></tr></table></figure><h2 id="getOwnPropertyNames-–返回自身对象的所有属性（包括不可枚举但不包括Symbol值）"><a href="#getOwnPropertyNames-–返回自身对象的所有属性（包括不可枚举但不包括Symbol值）" class="headerlink" title="getOwnPropertyNames() –返回自身对象的所有属性（包括不可枚举但不包括Symbol值）"></a>getOwnPropertyNames() –返回自身对象的所有属性（包括不可枚举但不包括Symbol值）</h2><p>Object.getOwnPropertyNames()方法返回一个由指定对象的所有自身属性的属性名（包括不可枚举属性但不包括Symbol值作为名称的属性）组成的数组。</p><p>它与上述两种方法的不同之处在于其可以返回不可枚举属性</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a=&#123;</span><br><span class="line">    item:<span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> b=&#123;</span><br><span class="line">    b:<span class="number">2</span>,</span><br><span class="line">    c() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.b;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置a对象的不可枚举属性</span></span><br><span class="line"><span class="built_in">Object</span>.defineProperty(a,<span class="string">'_item'</span>,&#123;</span><br><span class="line">    <span class="keyword">get</span>:function() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.item;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="keyword">set</span>:function(item) &#123;</span><br><span class="line">        <span class="keyword">this</span>.item=item;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置b对象为a对象的原型对象</span></span><br><span class="line"><span class="built_in">Object</span>.setPrototypeOf(a,b);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回自身对象的所有属性，包括可枚举属性和不可枚举属性</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.getOwnpropertyNames(a)); <span class="comment">//['item','_item']</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;什么是可枚举属性和不可枚举属性&quot;&gt;&lt;a href=&quot;#什么是可枚举属性和不可枚举属性&quot; class=&quot;headerlink&quot; title=&quot;什么是可枚举属性和不可枚举属性&quot;&gt;&lt;/a&gt;什么是可枚举属性和不可枚举属性&lt;/h2&gt;&lt;p&gt;可枚举属性是指那些内部 “可枚举” 
      
    
    </summary>
    
      <category term="javaScript基础" scheme="http://yoursite.com/categories/javaScript%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="基础语法" scheme="http://yoursite.com/tags/%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>leetcode-234 回文链表</title>
    <link href="http://yoursite.com/2019/09/03/leetcode-234/"/>
    <id>http://yoursite.com/2019/09/03/leetcode-234/</id>
    <published>2019-09-03T07:44:13.000Z</published>
    <updated>2019-09-03T07:50:08.375Z</updated>
    
    <content type="html"><![CDATA[<h1 id="回文链表"><a href="#回文链表" class="headerlink" title="回文链表"></a>回文链表</h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>请判断一个链表是否为回文链表。</p><p>示例 1:</p><blockquote><p>输入: 1-&gt;2<br>输出: false</p></blockquote><p>示例 2:</p><blockquote><p>输入: 1-&gt;2-&gt;2-&gt;1<br>输出: true</p></blockquote><p>进阶：<br>你能否用 O(n) 时间复杂度和 O(1) 空间复杂度解决此题？</p><a id="more"></a><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/palindrome-linked-list" target="_blank" rel="noopener">https://leetcode-cn.com/problems/palindrome-linked-list</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p><h2 id="核心思路"><a href="#核心思路" class="headerlink" title="核心思路"></a>核心思路</h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>一个简单的想法就是，将该链表的所有节点值都取出来，然后判断是否回文。但是，题目要求为O(1)的空间复杂度，因此不能使用数组来存储。因此，我们可以使用哈希表来存储，以链表节点的下标为键名，节点值为键值来存入哈希表</p><p>之后利用双指针来判断是否回文</p><h3 id="解题步骤"><a href="#解题步骤" class="headerlink" title="解题步骤"></a>解题步骤</h3><ol><li>建立哈希表</li><li>遍历该链表，以链表节点的下标为键名，节点值为键值来存入哈希表</li><li>设置前后双指针，如果指针未相遇时，前后指针在哈希表中的键值不相同的话那么返回false</li><li>否则，返回true</li></ol><h2 id="Coding实现"><a href="#Coding实现" class="headerlink" title="Coding实现"></a>Coding实现</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * function ListNode(val) &#123;</span></span><br><span class="line"><span class="comment"> *     this.val = val;</span></span><br><span class="line"><span class="comment"> *     this.next = null;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @param &#123;ListNode&#125; head</span></span><br><span class="line"><span class="comment"> * @return &#123;boolean&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> isPalindrome = <span class="function"><span class="keyword">function</span>(<span class="params">head</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> cur=head;</span><br><span class="line">    <span class="keyword">let</span> map=<span class="keyword">new</span> <span class="built_in">Map</span>();</span><br><span class="line">    <span class="keyword">let</span> index=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(cur) &#123;</span><br><span class="line">        map.set(index,cur.val);</span><br><span class="line">        index++;</span><br><span class="line">        cur=cur.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">let</span> left=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">let</span> right=index<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">while</span>(left&lt;right) &#123;</span><br><span class="line">        <span class="keyword">if</span>(map.get(left)!==map.get(right)) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        left++;</span><br><span class="line">        right--;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;回文链表&quot;&gt;&lt;a href=&quot;#回文链表&quot; class=&quot;headerlink&quot; title=&quot;回文链表&quot;&gt;&lt;/a&gt;回文链表&lt;/h1&gt;&lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h2&gt;&lt;p&gt;请判断一个链表是否为回文链表。&lt;/p&gt;
&lt;p&gt;示例 1:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;输入: 1-&amp;gt;2&lt;br&gt;输出: false&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;示例 2:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;输入: 1-&amp;gt;2-&amp;gt;2-&amp;gt;1&lt;br&gt;输出: true&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;进阶：&lt;br&gt;你能否用 O(n) 时间复杂度和 O(1) 空间复杂度解决此题？&lt;/p&gt;
    
    </summary>
    
      <category term="leetcode题解与算法" scheme="http://yoursite.com/categories/leetcode%E9%A2%98%E8%A7%A3%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="链表" scheme="http://yoursite.com/tags/%E9%93%BE%E8%A1%A8/"/>
    
  </entry>
  
  <entry>
    <title>浅拷贝与深拷贝</title>
    <link href="http://yoursite.com/2019/09/02/%E6%B5%85%E6%8B%B7%E8%B4%9D%E4%B8%8E%E6%B7%B1%E6%8B%B7%E8%B4%9D/"/>
    <id>http://yoursite.com/2019/09/02/浅拷贝与深拷贝/</id>
    <published>2019-09-02T13:02:23.000Z</published>
    <updated>2019-09-04T13:14:47.092Z</updated>
    
    <content type="html"><![CDATA[<h2 id="什么是浅拷贝与深拷贝"><a href="#什么是浅拷贝与深拷贝" class="headerlink" title="什么是浅拷贝与深拷贝"></a>什么是浅拷贝与深拷贝</h2><blockquote><p>浅拷贝与深拷贝是只针对Object和Array这样的引用数据类型的</p></blockquote><p>浅拷贝指的是在复制对象的时候，对第一层键值进行独立的复制。若键值为基本类型值，则复制该基本类型值；若键值为引用类型值，则复制该引用类型值的引用</p><p>深拷贝则会创造另一个对象，只是这个对象与被拷贝的对象一模一样，但是并没有占用同一块内存</p><h2 id="赋值操作是浅拷贝吗"><a href="#赋值操作是浅拷贝吗" class="headerlink" title="赋值操作是浅拷贝吗"></a>赋值操作是浅拷贝吗</h2><p>在将一个对象赋值给另一个对象的时候，其实是将该对象的引用地址复制给了它。因此两个对象占用同一个内存</p><p>但是，浅拷贝是在复制对象的时候，对第一层键值进行独立的复制。因此，新旧对象并不占用同一个内存，所以，原对象在浅拷贝之后做的任何操作都不会影响浅拷贝得到的对象</p><p>例如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a=&#123;</span><br><span class="line">    item:<span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用赋值操作得到的对象</span></span><br><span class="line"><span class="keyword">let</span> b=a;</span><br><span class="line"><span class="built_in">console</span>.log(b); <span class="comment">// &#123;item:1&#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(b===a); <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用浅拷贝得到的对象</span></span><br><span class="line"><span class="keyword">let</span> c=&#123;&#125;;</span><br><span class="line"><span class="built_in">Object</span>.assign(c,a);</span><br><span class="line"><span class="built_in">console</span>.log(c); <span class="comment">// &#123;item:1&#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(c===a); <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 修改原对象</span></span><br><span class="line">a.item=<span class="number">2</span>;</span><br><span class="line"><span class="built_in">console</span>.log(b.item); <span class="comment">// 2</span></span><br><span class="line"><span class="built_in">console</span>.log(c.item); <span class="comment">// 1</span></span><br></pre></td></tr></table></figure><p>显然，赋值得到的对象与原对象占用同一个内存；而浅拷贝得到的对象与原对象并没有占有同一个内存，因此，原对象做出的任何修改都不会影响浅拷贝得到的对象</p><h2 id="实现浅拷贝的几种方法"><a href="#实现浅拷贝的几种方法" class="headerlink" title="实现浅拷贝的几种方法"></a>实现浅拷贝的几种方法</h2><h3 id="Object-assign"><a href="#Object-assign" class="headerlink" title="Object.assign()"></a>Object.assign()</h3><h4 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h4><p>Object.assign() 方法用于将所有可枚举属性的值从<strong>一个或多个</strong>源对象复制到目标对象。它将返回目标对象。</p><p>如果目标对象中的属性具有相同的键，则属性将被源对象中的属性覆盖。后面的源对象的属性将类似地覆盖前面的源对象的属性。</p><h4 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h4><blockquote><p>Object.assign(target, …sources)</p></blockquote><p>参数：<br>target: 拷贝得到的对象<br>sources: 被拷贝的对象，可以是多个</p><p>Object.assign()方法主要做的工作就是，遍历要拷贝对象的属性，如果该属性值为基本类型值，那么就复制该属性值；如果，该属性值为引用类型值，那么就复制该引用类型值的引用。</p><p>因此，该方法只拷贝对象的第一层属性</p><h4 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a=&#123;</span><br><span class="line">    item:<span class="number">1</span>,</span><br><span class="line">    tree:&#123;</span><br><span class="line">        k:<span class="number">2</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用浅拷贝得到的对象</span></span><br><span class="line"><span class="keyword">let</span> c=&#123;&#125;;</span><br><span class="line"><span class="built_in">Object</span>.assign(c,a);</span><br><span class="line"><span class="built_in">console</span>.log(c); <span class="comment">// &#123;item:1,tree:&#123;k:2&#125;&#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(c===a); <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 修改原对象的第一层基本类型值</span></span><br><span class="line">a.item=<span class="number">2</span>;</span><br><span class="line"><span class="built_in">console</span>.log(c.item); <span class="comment">// 1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 修改原对象的第二层基本类型值</span></span><br><span class="line">a.tree.k=<span class="number">3</span>;</span><br><span class="line"><span class="built_in">console</span>.log(c.tree.k); <span class="comment">// 3</span></span><br></pre></td></tr></table></figure><p>因此，使用浅拷贝得到的对象，如果其第一层属性值为基本类型值，那么原对象修改后，不会影响浅拷贝得到的对象；</p><p>如果其第一层属性值为引用类型值，那么原对象修改后会影响拷贝得到的对象</p><h3 id="实现Object-assign-方法"><a href="#实现Object-assign-方法" class="headerlink" title="实现Object.assign()方法"></a>实现Object.assign()方法</h3><p>知道浅拷贝的思想之后，那么实现Object.assign()方法就很容易了</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">shallowCopy</span>(<span class="params">receiver=&#123;&#125;,supplier</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> keys=<span class="built_in">Object</span>.keys(supplier);</span><br><span class="line">    keys.forEach(<span class="function"><span class="params">v</span>=&gt;</span>&#123;</span><br><span class="line">        receiver[v]=supplier[v];</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="keyword">return</span> receiver;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="使用展开运算符"><a href="#使用展开运算符" class="headerlink" title="使用展开运算符"></a>使用展开运算符</h3><p>展开运算符在构造字面量对象时，可以进行克隆或者属性拷贝（ECMAScript 2018规范新增特性）：</p><blockquote><p>let objClone = { …obj };</p></blockquote><p>其行为是, 将已有对象的所有可枚举(enumerable)属性拷贝到新构造的对象中.</p><p>浅拷贝(Shallow-cloning, 不包含 prototype) 和对象合并, 可以使用更简短的展开语法。而不必再使用 Object.assign() 方式.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a=&#123;</span><br><span class="line">    item:<span class="number">1</span>,</span><br><span class="line">    tree:&#123;</span><br><span class="line">        item:<span class="number">2</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> b=&#123;...a&#125;;</span><br><span class="line"><span class="built_in">console</span>.log(b); <span class="comment">// &#123;item:1,tree:&#123;item:2&#125;&#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(b===a); <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line">a.item=<span class="number">2</span>;</span><br><span class="line"><span class="built_in">console</span>.log(b.item); <span class="comment">// 1</span></span><br><span class="line"></span><br><span class="line">a.tree.item=<span class="number">3</span>;</span><br><span class="line"><span class="built_in">console</span>.log(b.tree.item); <span class="comment">// 3</span></span><br></pre></td></tr></table></figure><p>当然，使用展开运算符也可以拷贝多个对象。它像Object.assign方法一样，可以接受任意数量的原对象，并按指定顺序将属性复制到接受对象中。所以，如果多个原对象具有相同的属性名，那么排位靠后的原对象的属性值会覆盖排位靠前的</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a=&#123;</span><br><span class="line">    item:<span class="number">1</span>,</span><br><span class="line">    tree:&#123;</span><br><span class="line">        item:<span class="number">2</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> b=&#123;</span><br><span class="line">    item:<span class="number">2</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> c=&#123;...a,...b&#125;;</span><br><span class="line"><span class="built_in">console</span>.log(c); <span class="comment">// &#123; item: 2, tree: &#123; item: 2 &#125; &#125;</span></span><br></pre></td></tr></table></figure><h3 id="对于数组对象"><a href="#对于数组对象" class="headerlink" title="对于数组对象"></a>对于数组对象</h3><p>对于数组对象，可以使用以下方法</p><ol><li>Array.prototype.concat()</li><li>Array.prototype.slice()</li><li>new Array()结合不定参数</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> test=[<span class="number">1</span>,&#123;<span class="attr">item</span>:<span class="number">1</span>&#125;]</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用concat()方法</span></span><br><span class="line"><span class="keyword">let</span> arr1=test.concat();</span><br><span class="line"><span class="built_in">console</span>.log(arr1); <span class="comment">// [1,&#123;item:1&#125;]</span></span><br><span class="line"><span class="built_in">console</span>.log(arr1===test); <span class="comment">// false</span></span><br><span class="line"><span class="built_in">console</span>.log(arr1[<span class="number">1</span>]===test[<span class="number">1</span>]); <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用slice()方法</span></span><br><span class="line"><span class="keyword">let</span> arr2=test.concat();</span><br><span class="line"><span class="built_in">console</span>.log(arr2); <span class="comment">// [1,&#123;item:1&#125;]</span></span><br><span class="line"><span class="built_in">console</span>.log(arr2===test); <span class="comment">// false</span></span><br><span class="line"><span class="built_in">console</span>.log(arr2[<span class="number">1</span>]===test[<span class="number">1</span>]); <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用new Array()方法</span></span><br><span class="line"><span class="keyword">let</span> arr3=<span class="keyword">new</span> <span class="built_in">Array</span>(...arr1);</span><br><span class="line"><span class="built_in">console</span>.log(arr3); <span class="comment">// [1,&#123;item:1&#125;]</span></span><br><span class="line"><span class="built_in">console</span>.log(arr3===test); <span class="comment">// false</span></span><br><span class="line"><span class="built_in">console</span>.log(arr3[<span class="number">1</span>]===test[<span class="number">1</span>]); <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 修改数组中引用类型元素的值</span></span><br><span class="line">test[<span class="number">1</span>].item=<span class="number">2</span>;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">`</span></span><br><span class="line"><span class="string"><span class="subst">$&#123;arr1[<span class="number">1</span>].item&#125;</span></span></span><br><span class="line"><span class="string"><span class="subst">$&#123;arr2[<span class="number">1</span>].item&#125;</span> </span></span><br><span class="line"><span class="string"><span class="subst">$&#123;arr3[<span class="number">1</span>].item&#125;</span></span></span><br><span class="line"><span class="string">`</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2</span></span><br><span class="line"><span class="comment">// 2</span></span><br><span class="line"><span class="comment">// 2</span></span><br></pre></td></tr></table></figure><p>数组对象的浅拷贝实质上就是，遍历整个数组将数组元素复制到另一个新的数组对象中去；</p><p>因此，当数组元素为基本类型值时，复制的就是基本类型值，原数组改变该值不会影响新数组</p><p>但是当数组元素为引用类型值时，复制的就是引用类型值的引用，那么原数组修改该值就会影响新的数组</p><h2 id="实现深拷贝的几种方法"><a href="#实现深拷贝的几种方法" class="headerlink" title="实现深拷贝的几种方法"></a>实现深拷贝的几种方法</h2><h3 id="利用JSON"><a href="#利用JSON" class="headerlink" title="利用JSON"></a>利用JSON</h3><p>我们可以使用JSON.stringify将对象转成JSON字符串，再用JSON.parse()把字符串解析成对象。此时生成的对象与原对象会是完全不同的对象，里面的任何属性都不会占用同一个内存</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a=&#123;</span><br><span class="line">    item:<span class="number">1</span>,</span><br><span class="line">    tree:&#123;</span><br><span class="line">        item:<span class="number">2</span>,</span><br><span class="line">        tree:&#123;</span><br><span class="line">            item:<span class="number">3</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用JSON方法深拷贝</span></span><br><span class="line"><span class="keyword">let</span> b=<span class="built_in">JSON</span>.parse(<span class="built_in">JSON</span>.stringify(a));</span><br><span class="line"><span class="built_in">console</span>.log(b); <span class="comment">// &#123; item: 1, tree: &#123; item: 2, tree: &#123; item: 3 &#125; &#125; &#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(a===b); <span class="comment">// false</span></span><br><span class="line"><span class="built_in">console</span>.log(a.tree===b.tree); <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 修改原对象的引用类型属性</span></span><br><span class="line">a.tree.tree.item=<span class="number">4</span>；</span><br><span class="line"><span class="built_in">console</span>.log(b.tree.tree.item); <span class="comment">// 3</span></span><br></pre></td></tr></table></figure><p>这种方法虽然简便，但还是有一些缺点，比如</p><ol><li>会忽略undefined</li><li>不能序列化函数<blockquote><p>这是因为JSON.stringify() 方法是将一个JavaScript值(对象或者数组)转换为一个 JSON字符串，不能接受函数</p></blockquote></li><li>无法拷贝Symbol</li></ol><h3 id="递归拷贝"><a href="#递归拷贝" class="headerlink" title="递归拷贝"></a>递归拷贝</h3><p>在深拷贝一个对象时，我们需要考虑要拷贝的这个对象时常规<strong>键值对</strong>对象还是数组对象。因为，遇到前者我们需要生成一个新的空对象{}，而遇到后者时我们需要生成一个新的空数组对象[]</p><p>那么，我们需要通过什么方法来检测，某个对象究竟是数组对象还是常规对象呢?可以采用如下方式：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">check</span>(<span class="params">target</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Object</span>.prototype.toString.call(target).slice(<span class="number">8</span>,<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(check(<span class="keyword">new</span> <span class="built_in">Object</span>())); <span class="comment">// Object</span></span><br><span class="line"><span class="built_in">console</span>.log(check(<span class="keyword">new</span> <span class="built_in">Array</span>())); <span class="comment">// Array</span></span><br></pre></td></tr></table></figure><p>因此，深拷贝完整代码如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">deepClone</span>(<span class="params">target</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> ans;</span><br><span class="line">    <span class="keyword">if</span>(check(target)===<span class="string">'Array'</span>) ans=[];</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(check(target)===<span class="string">'Object'</span>) ans=&#123;&#125;;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> target;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i <span class="keyword">in</span> target) &#123;</span><br><span class="line">        <span class="keyword">if</span>(check(target[i])===<span class="string">'Array'</span>||check(target[i])===<span class="string">'Object'</span>) &#123;</span><br><span class="line">            ans[i]=deepClone(target[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            ans[i]=target[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">check</span>(<span class="params">obj</span>) </span>&#123;</span><br><span class="line">   <span class="keyword">return</span>  <span class="built_in">Object</span>.prototype.toString.call(obj).slice(<span class="number">8</span>,<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> target=&#123;<span class="attr">item</span>:<span class="number">1</span>,<span class="attr">a</span>:[<span class="number">1</span>,<span class="number">2</span>,&#123;<span class="attr">item</span>:<span class="number">2</span>&#125;],<span class="attr">tree</span>:&#123;<span class="attr">tree</span>:&#123;<span class="attr">item</span>:<span class="number">3</span>&#125;&#125;&#125;;</span><br><span class="line"><span class="keyword">let</span> rev=deepClone(target);</span><br><span class="line"><span class="built_in">console</span>.log(rev); <span class="comment">// &#123; item: 1, a: [ 1, 2, &#123; item: 2 &#125; ], tree: &#123; tree: &#123; item: 3 &#125; &#125; &#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(rev.a===target.a); <span class="comment">// false</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;什么是浅拷贝与深拷贝&quot;&gt;&lt;a href=&quot;#什么是浅拷贝与深拷贝&quot; class=&quot;headerlink&quot; title=&quot;什么是浅拷贝与深拷贝&quot;&gt;&lt;/a&gt;什么是浅拷贝与深拷贝&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;浅拷贝与深拷贝是只针对Object和Array这样
      
    
    </summary>
    
      <category term="javaScript基础" scheme="http://yoursite.com/categories/javaScript%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="基础语法" scheme="http://yoursite.com/tags/%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/"/>
    
  </entry>
  
</feed>
