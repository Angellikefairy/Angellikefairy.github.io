<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Hexo</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2019-11-15T08:47:40.647Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>Angel</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>相等==与全等===的区别</title>
    <link href="http://yoursite.com/2019/11/15/%E7%9B%B8%E7%AD%89-%E4%B8%8E%E5%85%A8%E7%AD%89-%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
    <id>http://yoursite.com/2019/11/15/相等-与全等-的区别/</id>
    <published>2019-11-15T06:44:33.000Z</published>
    <updated>2019-11-15T08:47:40.647Z</updated>
    
    <content type="html"><![CDATA[<h2 id="概要"><a href="#概要" class="headerlink" title="概要"></a>概要</h2><p>JavaScript 有两种比较方式：严格比较运算符和转换类型比较运算符。对于严格比较运算符（===）来说，仅当两个操作数的类型相同且值相等为 true，而对于被广泛使用的比较运算符（==）来说，会在进行比较之前，将两个操作数转换成相同的类型。</p><h2 id="全等运算符（-）"><a href="#全等运算符（-）" class="headerlink" title="全等运算符（===）"></a>全等运算符（===）</h2><p>全等运算符（===）的规则相对简单，我们先来看全等运算符的运算规则</p><ol><li>如果两个操作数有不同的类型，它们不是严格相等的</li><li>如果两个操作数都为 null，则它们是严格相等的</li><li>如果两个操作数都为 undefined，它们是严格相等的</li><li>如果一个或两个操作数都是 NaN，它们就不是严格相等的</li><li>如果两个操作数都为 true 或都为 false，它们是严格相等的</li><li>如果两个操作数都是 number 类型并且具有相同的值，则它们是严格相等的</li><li>如果两个操作数都是 string 类型并且具有相同的值，则它们是严格相等的</li><li>如果两个操作数都引用相同的对象或函数，则它们是严格相等的</li><li>以上所有其他情况下操作数都不是严格相等的。</li></ol><p>简单概括来说，对于全等运算符来说，操作数双方必须是同一类型并且具有相同的值（引用的指向必须指向同一个引用）（除了NaN）以外。因为，NaN与任何值都不相等包括其本身。</p><p>例如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="literal">undefined</span>===<span class="literal">undefined</span>); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">1</span>===<span class="string">'1'</span>); <span class="comment">// false</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="literal">null</span>===<span class="literal">null</span>); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(&#123;<span class="attr">a</span>:<span class="number">1</span>&#125;===&#123;<span class="attr">a</span>:<span class="number">1</span>&#125;); <span class="comment">// false</span></span><br></pre></td></tr></table></figure><h2 id="数值转换"><a href="#数值转换" class="headerlink" title="数值转换"></a>数值转换</h2><p>我们使用Number()转型函数来将其他类型转化为数值型</p><p>具体规则如下：</p><ol><li>如果是布尔值，那么true转化为1，false转化为0<br>2，如果是null值，那么转化为0</li><li>如果是undefined，返回NaN</li><li>如果是字符串，又会分以下几种情况<ul><li>如果字符串只包含数字（包括带正负号，整数或者是浮点数），那么就会返回该数值</li><li>如果字符串是空的，那么返回数字0</li></ul><ol start="3"><li>其余情况返回NaN</li></ol></li><li>如果是对象，那么调用对象的valueOf()方法，然后再依照前面的规则转换返回的值</li></ol><h2 id="对象转化为基本类型值"><a href="#对象转化为基本类型值" class="headerlink" title="对象转化为基本类型值"></a>对象转化为基本类型值</h2><p>在将相等运算符的规则之前，我们需要弄清楚对象转化为基本类型值会变成怎么样？因为，这会出现在相等运算符的比较规则中</p><blockquote><p>对象在转换基本类型时，首先会调用 valueOf 然后调用 toString</p></blockquote><h3 id="valueOf-NaN"><a href="#valueOf-NaN" class="headerlink" title="valueOf"></a>valueOf</h3><blockquote><p>valueOf() 方法返回指定对象的原始值。</p></blockquote><p>具体规则如下：<br>对象|返回值<br>–|–<br>Array|返回数组本身对象<br>Boolean|布尔值<br>Date|存储的时间是从 1970 年 1 月 1 日午夜开始计的毫秒数 UTC<br>Function|函数本身<br>Number|数字值<br>Object|对象本身<br>String|字符串值</p><p>例如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>].valueOf()); <span class="comment">// [1,2,3]</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">new</span> <span class="built_in">Boolean</span>(<span class="literal">false</span>).valueOf()); <span class="comment">//false</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">new</span> <span class="built_in">Date</span>().valueOf()); <span class="comment">// 1573803246103</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="function"><span class="keyword">function</span> <span class="title">a</span>(<span class="params"></span>)</span>&#123;&#125;.valueOf()); <span class="comment">// function a()&#123;&#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">new</span> <span class="built_in">Number</span>(<span class="number">1</span>).valueOf()); <span class="comment">// 1</span></span><br><span class="line"><span class="built_in">console</span>.log(&#123;<span class="attr">a</span>:<span class="number">1</span>&#125;.valueOf()); <span class="comment">// &#123;a:1&#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">new</span> <span class="built_in">String</span>(<span class="string">'nice'</span>).valueOf()); <span class="comment">// 'nice'</span></span><br></pre></td></tr></table></figure><h3 id="toString-NaN"><a href="#toString-NaN" class="headerlink" title="toString"></a>toString</h3><blockquote><p>toString() 方法返回一个表示该对象的字符串。</p></blockquote><p>例如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>].toString()); <span class="comment">// '1,2,3'</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">new</span> <span class="built_in">Boolean</span>(<span class="literal">false</span>).toString()); <span class="comment">//'false'</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">new</span> <span class="built_in">Date</span>().toString()); <span class="comment">// 'Fri Nov 15 2019 15:41:22 GMT+0800 (GMT+08:00)'</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="function"><span class="keyword">function</span> <span class="title">a</span>(<span class="params"></span>)</span>&#123;&#125;.toString()); <span class="comment">// 'function a()&#123;&#125;'</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">new</span> <span class="built_in">Number</span>(<span class="number">1</span>).toString()); <span class="comment">// '1'</span></span><br><span class="line"><span class="built_in">console</span>.log(&#123;<span class="attr">a</span>:<span class="number">1</span>&#125;.toString()); <span class="comment">// [object Object]</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">new</span> <span class="built_in">String</span>(<span class="string">'nice'</span>).toString()); <span class="comment">// 'nice'</span></span><br></pre></td></tr></table></figure><h2 id="相等运算符（-）"><a href="#相等运算符（-）" class="headerlink" title="相等运算符（==）"></a>相等运算符（==）</h2><p>使用相等运算符时，都会先转换操作数（通常称为强制转型）为相同的类型，然后再比较他们的相等性</p><p>相等运算符遵循以下规则：</p><ol><li>如果操作数具有相同的类型，请使用上面的 IEA 测试它们是否严格相等。 如果它们不严格相等，则它们不相等，否则相等。</li><li>如果操作数有不同的类型：<ul><li>如果一个操作数为 null 而另一个 undefined，则它们相等</li><li>如果一个值是数字，另一个是字符串，先将字符串转换为数字，然后使用转换后的值比较</li><li>如果一个操作数是布尔值，则将 true 转换为 1，将 false 转换为 0，然后使用转换后的值比较</li><li>如果一个操作数是一个对象，而另一个操作数是一个数字或字符串，则调用valueOf()将该对象转换为基本类型值，再使用转换后的值进行比较</li></ul></li><li>在以上的其他情况下，操作数都不相等</li></ol><p>注意：</p><blockquote><p>在进行相等比较操作中,undefined和null是不能进行类型转化的。因此,undefined和null只能互相相等或者它们自身相等</p></blockquote><p>例如：</p><h3 id="其中一个操作数为布尔值"><a href="#其中一个操作数为布尔值" class="headerlink" title="其中一个操作数为布尔值"></a>其中一个操作数为布尔值</h3><blockquote><p>如果一个操作数为布尔值，那么将true转化为1，将false转化为0。然后，再利用其余规则进行比较</p></blockquote><h4 id="布尔值与数值比较"><a href="#布尔值与数值比较" class="headerlink" title="布尔值与数值比较"></a>布尔值与数值比较</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="number">1</span>==<span class="literal">true</span>); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">3</span>==<span class="literal">false</span>); <span class="comment">// false</span></span><br></pre></td></tr></table></figure><h4 id="布尔值与字符串比较"><a href="#布尔值与字符串比较" class="headerlink" title="布尔值与字符串比较"></a>布尔值与字符串比较</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="string">'1'</span>==<span class="literal">true</span>); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'123'</span>==<span class="literal">false</span>); <span class="comment">// false</span></span><br></pre></td></tr></table></figure><h4 id="布尔值与其余基本类型值比较"><a href="#布尔值与其余基本类型值比较" class="headerlink" title="布尔值与其余基本类型值比较"></a>布尔值与其余基本类型值比较</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="literal">undefined</span>==<span class="literal">true</span>); <span class="comment">// false</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="literal">null</span>==<span class="literal">false</span>); <span class="comment">// false</span></span><br></pre></td></tr></table></figure><p>因为，在进行相等比较操作中，undefined和null是不能进行转化的，而布尔值需要转化为数值型，因此，两者不可能相等</p><h4 id="布尔值与数组比较"><a href="#布尔值与数组比较" class="headerlink" title="布尔值与数组比较"></a>布尔值与数组比较</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log([]==<span class="literal">false</span>); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]==<span class="literal">false</span>); <span class="comment">// false</span></span><br><span class="line"><span class="built_in">console</span>.log([<span class="number">1</span>]==<span class="literal">true</span>); <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>是不是感觉很奇怪？</p><p>我们在前面提过，如果其中一个操作数为对象，那么就要该对象先通过valueOf()再通过toString()转化为基本类型值（确切来说是字符串型）然后再利用其余规则进行比较</p><p>又因为另一个操作数为布尔值，那么，布尔值就会被转化为数值型，true转化为1，false转化为0</p><p>因此，已经转化为字符串的对象还需要将字符串转化为数值型</p><p>具体过程如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line">比较[]与false</span><br><span class="line">1. [].valueOf() --&gt; &apos;&apos;</span><br><span class="line">2. &apos;&apos;.toString() --&gt; &apos;&apos;</span><br><span class="line">3. Number(&apos;&apos;) --&gt; 0</span><br><span class="line"></span><br><span class="line">4. Number(false) --&gt; 0</span><br><span class="line"></span><br><span class="line">5. 0===0 --&gt;true</span><br><span class="line"></span><br><span class="line">*/</span><br></pre></td></tr></table></figure><p>其余几个过程类似，因此不再赘述</p><h4 id="布尔值与其余对象"><a href="#布尔值与其余对象" class="headerlink" title="布尔值与其余对象"></a>布尔值与其余对象</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(&#123;<span class="attr">a</span>:<span class="number">1</span>&#125; == <span class="literal">false</span>); <span class="comment">// false</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">new</span> <span class="built_in">Date</span>()=== <span class="literal">true</span>); <span class="comment">// false</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="function"><span class="keyword">function</span> (<span class="params"></span>)</span>&#123;&#125; == <span class="literal">false</span>); <span class="comment">// false</span></span><br></pre></td></tr></table></figure><h3 id="其中一个操作数为字符串"><a href="#其中一个操作数为字符串" class="headerlink" title="其中一个操作数为字符串"></a>其中一个操作数为字符串</h3><p>在进行操作数比较前，我们需要明确，只有另一个操作数为数值型的情况下（可能发生了转换变为了数值型），我们才需要将该字符串转化为数值；否则，该字符串不会进行转化</p><p>例如：</p><h4 id="另一个操作数为数值"><a href="#另一个操作数为数值" class="headerlink" title="另一个操作数为数值"></a>另一个操作数为数值</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="string">'123'</span>==<span class="number">123</span>); <span class="comment">// true</span></span><br></pre></td></tr></table></figure><h4 id="另一个操作数为布尔值"><a href="#另一个操作数为布尔值" class="headerlink" title="另一个操作数为布尔值"></a>另一个操作数为布尔值</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="string">'1'</span>==<span class="literal">true</span>); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'0'</span>==<span class="literal">false</span>); <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>因为布尔值在进行相等比较的前一定会转换为数值型，因此，字符串也会被通过Number转型函数变为数值型。</p><h4 id="另一个操作数为其他基本类型值"><a href="#另一个操作数为其他基本类型值" class="headerlink" title="另一个操作数为其他基本类型值"></a>另一个操作数为其他基本类型值</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="string">'0'</span>==<span class="literal">null</span>); <span class="comment">// false</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'0'</span>==<span class="literal">undefined</span>); <span class="comment">// false</span></span><br></pre></td></tr></table></figure><p>在相等比较前，null和undefined不能被转换为其他类型值</p><h4 id="另一个操作数为数组"><a href="#另一个操作数为数组" class="headerlink" title="另一个操作数为数组"></a>另一个操作数为数组</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="string">'0'</span>==[]); <span class="comment">// false</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'1'</span>==[<span class="number">1</span>]); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'123'</span>==[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]); <span class="comment">// false</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'1,2,3'</span>==[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]); <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>首先，必须明确地是，如果其中一个操作数为字符串类型，那么我们先去看另一个操作数为什么类型。</p><p>在这里，另一个操作数为引用类型值，那么引用类型值会通过valueOf和toString转换为字符串型。那么，另一个字符型操作数就不需要进行转换，两个字符串类型进行比较即可。（因为，相等操作符在比较比较之前的目的就是将两个操作数的类型转换为一致，然后再进行比较）</p><h4 id="另一个操作数为对象"><a href="#另一个操作数为对象" class="headerlink" title="另一个操作数为对象"></a>另一个操作数为对象</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(&#123;<span class="attr">a</span>:<span class="number">1</span>&#125;==<span class="string">'a:1'</span>); <span class="comment">// false</span></span><br><span class="line"><span class="built_in">console</span>.log(&#123;&#125;==<span class="string">''</span>); <span class="comment">// false</span></span><br></pre></td></tr></table></figure><p>在这里，我们千万不要忘记自定义对象通过toString()方法转换得到的都是：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(&#123;<span class="attr">a</span>:<span class="number">1</span>&#125;.valueOf().toString()); <span class="comment">// '[object Object]'</span></span><br></pre></td></tr></table></figure><h3 id="其中一个操作数为数组"><a href="#其中一个操作数为数组" class="headerlink" title="其中一个操作数为数组"></a>其中一个操作数为数组</h3><p>大致的比较方法差不多在前面都提及了，这里看一个奇葩的题目：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log([]=![]); <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>是不是很奇怪，但是，如果仔细进行分析就不会觉得奇怪了。</p><p>具体过程：</p><ol><li>第一个操作数为[]，那么将其通过valueOf和toString转换为字符串得到空字符串’’</li><li>第二个操作数![]，因为有逻辑非布尔操作符，因此第二个操作数实际上是布尔值false</li><li>布尔值需要转换为数值型,false转换为0</li><li>因为第二个操作数转换为数值型了，因此，第一个操作数也要将得到的字符串转换为数值型，空字符串’’通过Number转型函数得到的是0</li><li>0===0 返回true</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;概要&quot;&gt;&lt;a href=&quot;#概要&quot; class=&quot;headerlink&quot; title=&quot;概要&quot;&gt;&lt;/a&gt;概要&lt;/h2&gt;&lt;p&gt;JavaScript 有两种比较方式：严格比较运算符和转换类型比较运算符。对于严格比较运算符（===）来说，仅当两个操作数的类型相同且值相等
      
    
    </summary>
    
      <category term="javaScript基础" scheme="http://yoursite.com/categories/javaScript%E5%9F%BA%E7%A1%80/"/>
    
    
  </entry>
  
  <entry>
    <title>TypeScript零散知识点总结</title>
    <link href="http://yoursite.com/2019/11/15/TypeScript%E9%9B%B6%E6%95%A3%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/"/>
    <id>http://yoursite.com/2019/11/15/TypeScript零散知识点总结/</id>
    <published>2019-11-15T05:26:14.000Z</published>
    <updated>2019-11-15T06:10:05.964Z</updated>
    
    <content type="html"><![CDATA[<h2 id="如何注解二维数组"><a href="#如何注解二维数组" class="headerlink" title="如何注解二维数组"></a>如何注解二维数组</h2><p>我们一般会使用一下两种方式来注解一维数组：</p><ol><li><p>类型+方括号</p> <figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr: <span class="built_in">number</span>[];</span><br></pre></td></tr></table></figure></li><li><p>数组泛型</p> <figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr: <span class="built_in">Array</span>&lt;<span class="built_in">number</span>&gt;;</span><br></pre></td></tr></table></figure></li></ol><p>那么，以此类推，我们也可以用以上两种方式来注解二维数组：</p><ol><li><p>类型+两个方括号</p> <figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr: <span class="built_in">number</span>[][];</span><br></pre></td></tr></table></figure></li><li><p>泛型中类型为泛型数组</p> <figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr: <span class="built_in">Array</span>&lt;<span class="built_in">Array</span>&lt;<span class="built_in">number</span>&gt;&gt;</span><br></pre></td></tr></table></figure></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;如何注解二维数组&quot;&gt;&lt;a href=&quot;#如何注解二维数组&quot; class=&quot;headerlink&quot; title=&quot;如何注解二维数组&quot;&gt;&lt;/a&gt;如何注解二维数组&lt;/h2&gt;&lt;p&gt;我们一般会使用一下两种方式来注解一维数组：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;类型+方括号&lt;/
      
    
    </summary>
    
      <category term="TypeScript" scheme="http://yoursite.com/categories/TypeScript/"/>
    
    
  </entry>
  
  <entry>
    <title>Vue的一些零散知识点总结</title>
    <link href="http://yoursite.com/2019/11/11/Vue%E7%9A%84%E4%B8%80%E4%BA%9B%E9%9B%B6%E6%95%A3%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/"/>
    <id>http://yoursite.com/2019/11/11/Vue的一些零散知识点总结/</id>
    <published>2019-11-11T05:47:44.000Z</published>
    <updated>2019-11-13T11:17:19.725Z</updated>
    
    <content type="html"><![CDATA[<h2 id="v-if与v-show的区别"><a href="#v-if与v-show的区别" class="headerlink" title="v-if与v-show的区别"></a>v-if与v-show的区别</h2><p>官方文档对于这两个指令的定义：</p><ul><li><p>v-show：根据表达式之真假值，切换元素的 display CSS属性。</p></li><li><p>v-if: 根据表达式的值的真假条件渲染元素。在切换时元素及它的数据绑定 / 组件被销毁并重建。如果元素是 &lt;template&gt; ，将提出它的内容作为条件块。</p></li></ul><p>我们通过实际的例子来区分这两个指令的区别：</p><h3 id="v-show的渲染情况"><a href="#v-show的渲染情况" class="headerlink" title="v-show的渲染情况"></a>v-show的渲染情况</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span> <span class="attr">v-show</span>=<span class="string">"bool"</span>&gt;</span>&#123;&#123;value&#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p>当bool值为真时，渲染情况如下：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>123<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure><p>当bool值为假时，渲染情况发生了如下变化：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">styel</span>=<span class="string">"display:none;"</span>&gt;</span>123<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure><p>我们可以看到，当使用v-show时，该节点会被添加到DOM树中，始终会被渲染。切换v-show的值只是简单的切换元素的display元素而已</p><h4 id="display与opacity与visibility的区别"><a href="#display与opacity与visibility的区别" class="headerlink" title="display与opacity与visibility的区别"></a>display与opacity与visibility的区别</h4><p>当v-show为false时，vue会将该元素的style属性的display属性设置为none。</p><p>那么，对于其他两种也可以将元素隐藏的css方式，这三种有什么区别呢？</p><table><thead><tr><th>属性</th><th>属性值</th><th>是否可见</th><th>是否占用布局</th><th>是否可以被点击</th></tr></thead><tbody><tr><td>display</td><td>none</td><td>不可见</td><td>不占用</td><td>不能</td></tr><tr><td>opacity</td><td>0</td><td>不可见</td><td>占用</td><td>能</td></tr><tr><td>visibility</td><td>hidden</td><td>不可见</td><td>占用</td><td>不能</td></tr></tbody></table><h3 id="v-if的渲染情况"><a href="#v-if的渲染情况" class="headerlink" title="v-if的渲染情况"></a>v-if的渲染情况</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span> <span class="attr">v-if</span>=<span class="string">"bool"</span>&gt;</span>&#123;&#123;value&#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p>当bool值为真时，渲染情况如下：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>123<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure><p>当bool值为假时，渲染情况发生了如下变化：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app"</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!----&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p>我们可以看到，当使用v-if时，如果v-if的值为false，那么该节点就不会被添加到DOM树中，当然也不会被渲染。只有，当v-if的值为true时，该节点才会被正常渲染</p><p>另外，我们也可以使用v-else与v-if进行配合</p><p>例如：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">v-if</span>=<span class="string">"bool"</span>&gt;</span>&#123;&#123;value&#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">v-else</span>&gt;</span>&#123;&#123;anotherValue&#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="多元素条件渲染（v-if支持-v-show不支持）"><a href="#多元素条件渲染（v-if支持-v-show不支持）" class="headerlink" title="多元素条件渲染（v-if支持,v-show不支持）"></a>多元素条件渲染（v-if支持,v-show不支持）</h3><p>以上我们使用v-if和v-show都是对单个元素进行条件渲染，那么如果想对多个元素一起进行条件渲染呢？</p><p>vue允许我们在&lt;template&gt;元素上使用v-if来对多个元素进行一起条件渲染。</p><p>此时vue会把 &lt;template&gt; 元素当做不可见的包裹元素，并在上面使用 v-if。最终的渲染结果将不包含 &lt;template&gt; 元素。</p><p>例如：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">template</span> <span class="attr">v-if</span>=<span class="string">"bool"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">p</span>&gt;</span>&#123;&#123;value1&#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">p</span>&gt;</span>&#123;&#123;value2&#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">p</span>&gt;</span>&#123;&#123;value3&#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">template</span> <span class="attr">v-else</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">p</span>&gt;</span>&#123;&#123;anotherValue&#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">"changeIf"</span>&gt;</span>change<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p>那么v-show呢？它支持多元素条件渲染吗？遗憾的是，它并不支持。</p><blockquote><p>注意，v-show 不支持 &lt;template&gt; 元素，也不支持 v-else</p></blockquote><h3 id="v-if与v-show区别总结"><a href="#v-if与v-show区别总结" class="headerlink" title="v-if与v-show区别总结"></a>v-if与v-show区别总结</h3><p>由以上的示例我们可以看到：</p><ol><li>v-if是真正的条件渲染，它会根据条件的真值来决定是否将该DOM元素加入或移除DOM树</li><li>v-show会一直渲染该DOM元素，也就是该DOM元素一直在DOM树上。只是，简单地切换该元素的style属性中的display而已</li></ol><p>因此，v-if有更高的切换开销，而v-show有更高的初始渲染开销。如果，元素需要频繁的切换的话，那么使用v-show更好，反之，使用v-if较好</p><h2 id="除了数组，我们还可以给v-for传递什么参数"><a href="#除了数组，我们还可以给v-for传递什么参数" class="headerlink" title="除了数组，我们还可以给v-for传递什么参数"></a>除了数组，我们还可以给v-for传递什么参数</h2><p>通常来说，我们一般会传递v-for一个数组来让vue进行列表渲染</p><p>但事实上，除了数组，我们还可以传递给v-for更多类型的参数。官方文档并没有太多的提及传递的参数类型限制。但是，我们可以从源码中找到答案：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; isObject, isDef, hasSymbol &#125; <span class="keyword">from</span> <span class="string">'core/util/index'</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Runtime helper for rendering v-for lists.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">renderList</span> (<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  val: <span class="built_in">any</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">  render: (</span></span></span><br><span class="line"><span class="function"><span class="params">    val: <span class="built_in">any</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">    keyOrIndex: <span class="built_in">string</span> | <span class="built_in">number</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">    index?: <span class="built_in">number</span></span></span></span><br><span class="line"><span class="function"><span class="params">  ) =&gt; VNode</span></span></span><br><span class="line"><span class="function"><span class="params"></span>): ?<span class="title">Array</span>&lt;<span class="title">VNode</span>&gt; </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> ret: ?<span class="built_in">Array</span>&lt;VNode&gt;, i, l, keys, key</span><br><span class="line">  <span class="comment">// 如果传递的参数是数组或者是字符串，那么生成的新数组的元素为数组元素或是字符串中的每个字符</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">Array</span>.isArray(val) || <span class="keyword">typeof</span> val === <span class="string">'string'</span>) &#123;</span><br><span class="line">    ret = <span class="keyword">new</span> <span class="built_in">Array</span>(val.length)</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>, l = val.length; i &lt; l; i++) &#123;</span><br><span class="line">      ret[i] = render(val[i], i)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">typeof</span> val === <span class="string">'number'</span>) &#123;</span><br><span class="line">    <span class="comment">// 如果传递的参数是number，那么生成一个数组，数组元素为1到该number的值</span></span><br><span class="line">    ret = <span class="keyword">new</span> <span class="built_in">Array</span>(val)</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; val; i++) &#123;</span><br><span class="line">      ret[i] = render(i + <span class="number">1</span>, i)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (isObject(val)) &#123; <span class="comment">// 传递的参数为对象类型，需要进行进一步的判断</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果传递的对象可迭代，即具有Symbol.iterator生成器方法</span></span><br><span class="line">    <span class="keyword">if</span> (hasSymbol &amp;&amp; val[Symbol.iterator]) &#123;</span><br><span class="line">      ret = []</span><br><span class="line">      <span class="keyword">const</span> iterator: Iterator&lt;<span class="built_in">any</span>&gt; = val[Symbol.iterator]()</span><br><span class="line">      <span class="keyword">let</span> result = iterator.next()</span><br><span class="line">      <span class="keyword">while</span> (!result.done) &#123;</span><br><span class="line">        ret.push(render(result.value, ret.length))</span><br><span class="line">        result = iterator.next()</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// 该对象为不可迭代对象，一般为用户自定义对象，那么使用object.keys遍历它（因此，如果对象中有不可枚举属性，则该属性值无法得到）</span></span><br><span class="line">      keys = <span class="built_in">Object</span>.keys(val)</span><br><span class="line">      ret = <span class="keyword">new</span> <span class="built_in">Array</span>(keys.length)</span><br><span class="line">      <span class="keyword">for</span> (i = <span class="number">0</span>, l = keys.length; i &lt; l; i++) &#123;</span><br><span class="line">        key = keys[i]</span><br><span class="line">        ret[i] = render(val[key], key, i)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (!isDef(ret)) &#123;</span><br><span class="line">    ret = []</span><br><span class="line">  &#125;</span><br><span class="line">  (ret: <span class="built_in">any</span>)._isVList = <span class="literal">true</span></span><br><span class="line">  <span class="keyword">return</span> ret</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>读完上面这段源码后，可以做个总结：<br>无论我们传递什么类型的数据给v-if，vue层面会将该数据进行转化得到一个数组再进行列表渲染。</p><p>分类来说：</p><ol><li>如果为string，那么会得到一个字符数组</li><li>如果为number，那么数组将会是[1,2,3…,number];</li><li>如果为数组，那么以该数组建立新数组</li><li>如果为对象，又要分两类<ol><li>如果为可迭代对象（集合对象：数组，Map，Set，字符等其他有Symbol.iterator生成器方法的对象）那么将迭代的值存入新数组</li><li>如果为不可迭代对象，那么使用Object.keys()方法将得到的属性值存入新数组；因此，不会包括不可枚举属性的属性值</li></ol></li></ol><h2 id="数组和对象更新时需要注意的地方"><a href="#数组和对象更新时需要注意的地方" class="headerlink" title="数组和对象更新时需要注意的地方"></a>数组和对象更新时需要注意的地方</h2><p>我们知道，在进行数据双向绑定的时候。vue会将data中的每个属性和子属性使用Object.defineProperty变为访问器属性。当我们修改这些属性的属性值时，就会触发setter函数，从而引起视图变化。</p><p>但是，这个Object.defineProperty方法只能对具有属性的对象使用，那么vue是怎么做到对数组的监听呢？</p><p>这里只给出总体代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Observe a list of Array items.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">observeArray (items: <span class="built_in">Array</span>&lt;any&gt;) &#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>, l = items.length; i &lt; l; i++) &#123;</span><br><span class="line">    observe(items[i])  <span class="comment">// observe 功能为监测数据的变化</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>具体的，之后再深入的过程中会做出更加详细的解释s</p><p>然而，我们要注意，这个数据双向绑定的过程是发生在vue生命周期的挂载节点之后的。也就是说，当vue实例完全初始化完毕进入运行状态后，我们进行以下的操作将不会使数据进行响应：</p><p>对于数组：</p><ol><li>当你利用索引直接设置一个数组项时，例如：vm.items[indexOfItem] = newValue</li><li>当你修改数组的长度时，例如：vm.items.length = newLength</li></ol><p>对于对象：</p><ol><li>添加对象属性</li><li>删除对象属性</li></ol><p>对于以上的情况，我们都可以使用vm.$set来解决</p><h2 id="Vue为DOM元素设置和获取自定义属性"><a href="#Vue为DOM元素设置和获取自定义属性" class="headerlink" title="Vue为DOM元素设置和获取自定义属性"></a>Vue为DOM元素设置和获取自定义属性</h2><p>在html5中，我们使用 data-* 属性来嵌入自定义数据：</p><blockquote><p>data-* 属性赋予我们在所有 HTML 元素上嵌入自定义 data 属性的能力。</p></blockquote><p>需要注意的是：</p><blockquote><p>属性名不应该包含任何大写字母，并且在前缀 “data-“ 之后必须有至少一个字符</p></blockquote><p>例如：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">data-v</span>=<span class="string">'1'</span>&gt;</span>hello<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure><p>因此，为了遵循这一规范，我们在Vue中为一个DOM元素添加自定义属性时，也应当这样写：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">:data-v</span>=<span class="string">"value"</span>&gt;</span>&#123;&#123;value&#125;&#125;<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure><p>然后，我们可以通过element.getAttribute()来获取元素</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a = <span class="built_in">document</span>.getElementsByTagName(<span class="string">'a'</span>)[<span class="number">0</span>];</span><br><span class="line"><span class="built_in">console</span>.log(a.getAttribute(<span class="string">'data-v'</span>));</span><br></pre></td></tr></table></figure><p>但是，Vue并不推荐我们直接来操纵DOM，因此，我们可以使用Vue的ref属性来进行DOM元素的引用，引用的信息将会被注册在$refs对象上</p><p>因此，我们可以做出如下的修改：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">:data-v</span>=<span class="string">"value"</span> <span class="attr">ref</span>=<span class="string">"aLink"</span>&gt;</span>&#123;&#123;value&#125;&#125;<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure><p>此时，该a标签DOM元素将会作为aLink的键值在$refs对象中被注册</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 数据对象</span></span><br><span class="line">data: &#123;</span><br><span class="line">    value: <span class="number">123</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在Vue组件的某个方法中</span></span><br><span class="line">getDataV() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.$refs); <span class="comment">// &#123;aLink: a&#125;</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.$refs.aLink.getAttribute(<span class="string">'data-v'</span>)); <span class="comment">// 123</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="为指令设置动态参数"><a href="#为指令设置动态参数" class="headerlink" title="为指令设置动态参数"></a>为指令设置动态参数</h2><p>我们知道，Vue允许在指令后添加参数。例如，在v-bind指令后添加参数就可以将该参数作为DOM元素的属性</p><p>例如：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">:value</span>=<span class="string">"value"</span> <span class="attr">ref</span>=<span class="string">"aLink"</span>&gt;</span><span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure><p>我们通过控制台查看该DOM元素就可以得到如下结果：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">value</span>=<span class="string">"123346"</span>&gt;</span>value<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure><p>初次之外，Vue可以支持使用类似方括号的语法（但是方括号中只能填写Vue实例中data声明的变量）来为指令设置动态参数</p><p>例如：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">a</span> <span class="attr">:</span>[<span class="attr">attributeName</span>]=<span class="string">"url"</span>&gt;</span>&#123;&#123;value&#125;&#125;<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p>然后，我们在Vue实例中这样设置：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> Vue(&#123;</span><br><span class="line">    el: <span class="string">'#app'</span>,</span><br><span class="line">    data: &#123;</span><br><span class="line">        attributeName: <span class="string">'href'</span>,</span><br><span class="line">        url: <span class="string">'https://www.baidu.com'</span>,</span><br><span class="line">        value: <span class="string">'baidu'</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>然后，我们在控制台进行查看，就可以得到如下的结果：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span>&gt;</span>baidu<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure><p>令人意外的是，得到的结果并不是预料中的如下的结果：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"https://www.baidu.com"</span>&gt;</span>baidu<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure><p>然后我查看官方文档才发现了原因所在：</p><p>其实，Vue对于动态参数表达式是有限制的：</p><ol><li>空格和引号在表达式中是无效的</li><li>避免使用大写字符来命名键名，因为浏览器会把 attribute（属性） 名全部强制转为小写</li></ol><p>因此，我们需要将之前的模板和Vue实例进行修改：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">a</span> <span class="attr">:</span>[<span class="attr">attribute</span>]=<span class="string">"url"</span>&gt;</span>&#123;&#123;value&#125;&#125;<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> Vue(&#123;</span><br><span class="line">    el: <span class="string">'#app'</span>,</span><br><span class="line">    data: &#123;</span><br><span class="line">        attribute: <span class="string">'href'</span>,</span><br><span class="line">        url: <span class="string">'https://www.baidu.com'</span>,</span><br><span class="line">        value: <span class="string">'baidu'</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>此时，我们就可以查看到正确的DOM元素了</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"https://www.baidu.com"</span>&gt;</span>baidu<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="Vue的常用修饰符"><a href="#Vue的常用修饰符" class="headerlink" title="Vue的常用修饰符"></a>Vue的常用修饰符</h2><p>修饰符 (modifier) 是以半角句号 . 指明的特殊后缀，用于指出一个指令应该以特殊方式绑定。</p><p>在进行详细的事件处理修饰符的说明前，我们先来了解target.addEventListener方法的详细说明，因为，下面的修饰符大多数针对该方法进行简写而已</p><h3 id="addEventListener的详细说明"><a href="#addEventListener的详细说明" class="headerlink" title="addEventListener的详细说明"></a>addEventListener的详细说明</h3><p>完整的addEventListener的方法定义如下：</p><blockquote><p>target .addEventListener（type，listener [，options ]）;</p></blockquote><p>参数说明：</p><ul><li><p>type: 区分大小写的字符串，表示要侦听的事件类型。</p></li><li><p>listener: Event当指定类型的事件发生时，接收通知的对象（实现接口的对象）。这必须是实现EventListener接口的对象或JavaScript 函数</p></li><li><p>options: 可选，一个选项对象，可以包括以下几个选项：</p><ul><li>capture true表示在捕获阶段执行事件处理程序，false表示在冒泡阶段</li><li>once Boolean，listener应在添加后最多调用一次。如果为true，则listener在调用时会自动将其删除。</li><li>passive: Boolean 如果true表示表示所指定的函数listener将永远不会调用preventDefault()。如果被动侦听器确实进行了调用preventDefault()，则用户代理将不执行任何操作，只生成控制台警告。</li></ul></li></ul><h3 id="v-on事件处理的修饰符"><a href="#v-on事件处理的修饰符" class="headerlink" title="v-on事件处理的修饰符"></a>v-on事件处理的修饰符</h3><p>Vue的官方文档是这样叙述为什么要使用数件处理修饰符的：</p><blockquote><p>在事件处理程序中调用 event.preventDefault() 或 event.stopPropagation() 是非常常见的需求。尽管我们可以在方法中轻松实现这点，但更好的方式是：方法只有纯粹的数据逻辑，而不是去处理 DOM 事件细节。</p></blockquote><p>因此，Vue为v-on提供了事件处理修饰符</p><h4 id="stop修饰符-相当于调用event-stopPropagation"><a href="#stop修饰符-相当于调用event-stopPropagation" class="headerlink" title=".stop修饰符 相当于调用event.stopPropagation()"></a>.stop修饰符 相当于调用event.stopPropagation()</h4><p>该.stop修饰符可以阻止事件流进一步的传递（捕获或者冒泡）</p><p>以下以阻止事件进一步冒泡为例进行说明：</p><h5 id="没有使用-stop修饰符"><a href="#没有使用-stop修饰符" class="headerlink" title="没有使用.stop修饰符"></a>没有使用.stop修饰符</h5><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app"</span> <span class="attr">style</span>=<span class="string">"border: 1px solid black;width: 100px;height: 100px;"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span> <span class="attr">:</span>[<span class="attr">attribute</span>]=<span class="string">"url"</span> @<span class="attr">click</span>=<span class="string">"clickP"</span>&gt;</span>&#123;&#123;value&#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p>我们分别为div元素和p元素设置一个方法用来监听click事件:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> vm = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">    el: <span class="string">'#app'</span>,</span><br><span class="line">    data: &#123;</span><br><span class="line">        attribute: <span class="string">'href'</span>,</span><br><span class="line">        url: <span class="string">'https://www.baidu.com'</span>,</span><br><span class="line">        value: <span class="string">'baidu'</span></span><br><span class="line">    &#125;,</span><br><span class="line">    methods: &#123;</span><br><span class="line">        <span class="comment">// p元素的事件监听程序</span></span><br><span class="line">        clickP() &#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">'p is clicked'</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">// 在挂载节点完毕后的生命周期阶段添加div元素的事件监听程序</span></span><br><span class="line">    mounted() &#123;</span><br><span class="line">        <span class="keyword">this</span>.$el.addEventListener(<span class="string">'click'</span>,()=&gt;&#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">'app is clicked'</span>);</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>当我们单击p元素的时候可以得到以下的输出结果：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 输出结果</span></span><br><span class="line"><span class="comment">p is clicked</span></span><br><span class="line"><span class="comment">app is clicked</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>我们知道DOM事件流会经过以下三个阶段：</p><ol><li>捕获阶段</li><li>处于事件目标阶段</li><li>冒泡阶段</li></ol><p>在这里提一句，如果在v-on后没有添加.capture修饰符，那么该事件会在冒泡阶段发生（相当于addEventListener方法的第二个参数为false）</p><p>因此，当我们单击p元素时，会经过以下步骤：</p><ol><li>在捕获阶段，没有绑定若任何处理程序，因此没有任何响应</li><li>处于目标阶段，因为我们单击的是p元素，因此，响应p元素绑定的事件监听程序，输出’p is clicked’</li><li>处于冒泡阶段，此时div元素绑定的click事件监听程序被响应，因此，输出’app is clicked’</li></ol><p>那么，如果使用.stop修饰符呢？</p><h5 id="使用-stop修饰符"><a href="#使用-stop修饰符" class="headerlink" title="使用.stop修饰符"></a>使用.stop修饰符</h5><p>我们将html代码修改，js代码保持不变：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app"</span> <span class="attr">style</span>=<span class="string">"border: 1px solid black;width: 100px;height: 100px;"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span> <span class="attr">:</span>[<span class="attr">attribute</span>]=<span class="string">"url"</span> @<span class="attr">click.stop</span>=<span class="string">"clickP"</span>&gt;</span>&#123;&#123;value&#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p>此时，当我们单击p元素的时候，就会得到以下的输出结果：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 输出结果</span></span><br><span class="line"><span class="comment">p is clicked</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>我们看到’app is clicked’并没有输出，这是因为修饰符.stop起到了stopPropagation的作用，阻止了事件流的进一步传递</p><h4 id="prevent修饰符-相当于调用-event-preventDefault"><a href="#prevent修饰符-相当于调用-event-preventDefault" class="headerlink" title=".prevent修饰符 相当于调用 event.preventDefault()"></a>.prevent修饰符 相当于调用 event.preventDefault()</h4><p>我们知道preventDefault方法可以取消事件的默认行为。因此，.prevent修饰符也是起到同样的作用</p><p>例如：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span> =<span class="string">"https://www.baidu.com"</span> @<span class="attr">click.prevent</span>=<span class="string">"clickA"</span>&gt;</span>clickA<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure><p>本来，当我们点击a标签的时候，默认将会跳转到href给定的地址。但是，当我们使用.prevent修饰符后就可以取消跳转这一默认行为</p><h4 id="capture修饰符-添加事件监听器时使用捕获模式"><a href="#capture修饰符-添加事件监听器时使用捕获模式" class="headerlink" title=".capture修饰符 添加事件监听器时使用捕获模式"></a>.capture修饰符 添加事件监听器时使用捕获模式</h4><p>之前就提到过这一修饰符的作用，.capture修饰符可以让事件在捕获阶段被调用，而不是默认在冒泡阶段被调用</p><p>例如：</p><p>注意，此时我将带修饰符的事件处理程序绑定在了div元素，而p元素的事件处理程序没有带修饰符</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app"</span> @<span class="attr">click.capture</span>=<span class="string">"clickDiv"</span> <span class="attr">style</span>=<span class="string">"border: 1px solid black;width: 100px;height: 100px;"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span> @<span class="attr">click</span>=<span class="string">"clickP"</span>&gt;</span>&#123;&#123;value&#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> vm = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">    el: <span class="string">'#app'</span>,</span><br><span class="line">    data: &#123;</span><br><span class="line">        value: <span class="string">'click it'</span></span><br><span class="line">    &#125;,</span><br><span class="line">    methods: &#123;</span><br><span class="line">        clickP() &#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">'p is clicked'</span>);</span><br><span class="line">        &#125;,</span><br><span class="line">        clickDiv() &#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">'div is clicked'</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>现在，当我们点击p元素时可以得到如下输出结果：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 输出结果</span></span><br><span class="line"><span class="comment">div is clicked</span></span><br><span class="line"><span class="comment">p is clicked</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>的确，div元素绑定的事件处理程序在事件流的捕获阶段被触发了。</p><p>那么，如果我们不添加.capture修饰符，那么点击p元素得到的输出结果就会是：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 输出结果</span></span><br><span class="line"><span class="comment">p is clicked</span></span><br><span class="line"><span class="comment">div is clicked</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>这样，div事件处理程序就会默认在事件流的冒泡阶段被执行</p><h4 id="self修饰符-相当于事件自身触发的而不是从内部元素触发的"><a href="#self修饰符-相当于事件自身触发的而不是从内部元素触发的" class="headerlink" title=".self修饰符 相当于事件自身触发的而不是从内部元素触发的"></a>.self修饰符 相当于事件自身触发的而不是从内部元素触发的</h4><p>.self修饰符的作用是：只有当事件是自身元素触发的而不是该元素内部元素触发的才会被执行相应的事件处理程序</p><p>示例：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app"</span> @<span class="attr">click.self</span>=<span class="string">"clickDiv"</span> <span class="attr">style</span>=<span class="string">"border: 1px solid black;width: 100px;height: 100px;"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span> @<span class="attr">click</span>=<span class="string">"clickP"</span>&gt;</span>&#123;&#123;value&#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> vm = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">    el: <span class="string">'#app'</span>,</span><br><span class="line">    data: &#123;</span><br><span class="line">        value: <span class="string">'click it'</span></span><br><span class="line">    &#125;,</span><br><span class="line">    methods: &#123;</span><br><span class="line">        clickP() &#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">'p is clicked'</span>);</span><br><span class="line">        &#125;,</span><br><span class="line">        clickDiv() &#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">'div is clicked'</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>现在，当我们点击p元素时的输出结果会得到以下的输出结果：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 输出结果</span></span><br><span class="line"><span class="comment">p is cliked</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>我们看到div元素的事件处理程序没有被触发。因为,.self修饰符让该元素的事件处理程序只有在该元素自身触发事件才可以被执行</p><p>但是，如果我们将div元素的.self修饰符去掉</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app"</span> @<span class="attr">click</span>=<span class="string">"clickDiv"</span> <span class="attr">style</span>=<span class="string">"border: 1px solid black;width: 100px;height: 100px;"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span> @<span class="attr">click</span>=<span class="string">"clickP"</span>&gt;</span>&#123;&#123;value&#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p>那么，当我们点击p元素的输出结果就会是这样的:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 输出结果</span></span><br><span class="line"><span class="comment">p is clicked</span></span><br><span class="line"><span class="comment">div is clicked</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>此时，div的事件处理程序就会在事件流的冒泡阶段而被触发</p><h4 id="once修饰符-点击事件将只会被触发一次"><a href="#once修饰符-点击事件将只会被触发一次" class="headerlink" title=".once修饰符 点击事件将只会被触发一次"></a>.once修饰符 点击事件将只会被触发一次</h4><p>.once修饰符只允许事件监听程序只会被执行一次，无论你多少次触发该事件</p><p>例如：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app"</span> @<span class="attr">click</span>=<span class="string">"clickDiv"</span> <span class="attr">style</span>=<span class="string">"border: 1px solid black;width: 100px;height: 100px;"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span> @<span class="attr">click.once</span>=<span class="string">"clickP"</span>&gt;</span>&#123;&#123;value&#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p>事件处理程序的定义还是如下，不做任何改变</p><p>那么，当我们第一次点击p元素的时候会得到如下的输出结果：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 输出结果</span></span><br><span class="line"><span class="comment">p is clicked</span></span><br><span class="line"><span class="comment">div is clicked</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>那么，当我们第二次再点击该p元素，此时输出结果就变成这样了：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 输出结果</span></span><br><span class="line"><span class="comment">div is clicked</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>我们可以看到，p元素的事件处理程序没有再执行。这可以用来实现防抖的效果。</p><h4 id="passive修饰符"><a href="#passive修饰符" class="headerlink" title=".passive修饰符"></a>.passive修饰符</h4><p>该.passive修饰符对应addEventListener中的passive选项，当我们使用该.passive修饰符时，也就是默认将addEventListener的passive选项设置为true。</p><p>那么，这也意味着：</p><blockquote><p>所指定的函数listener将永远不会调用preventDefault()。</p></blockquote><p>简而言之，该.passive修饰符的作用是不要阻止事件的默认行为。那么，如果我们将.passive 和 .prevent 一起使用，那么.prevent 将会被忽略。</p><h5 id="passcive修饰符对于移动端性能的提升"><a href="#passcive修饰符对于移动端性能的提升" class="headerlink" title=".passcive修饰符对于移动端性能的提升"></a>.passcive修饰符对于移动端性能的提升</h5><p>在移动端，我们经常要使用触摸滚动的事件，那么使用passive修饰符将会大幅提升移动端的性能</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">v-on:scroll.passive</span>=<span class="string">"onScroll"</span>&gt;</span>...<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p>那么，这是为什么呢？</p><p>MDN文档是这样做出解释的：</p><blockquote><p>根据规范，passive 选项的默认值始终为false。但是，这引入了处理某些触摸事件（以及其他）的事件监听器在尝试处理滚动时阻止浏览器的主线程的可能性，从而导致滚动处理期间性能可能大大降低。</p></blockquote><h3 id="v-model表单输入绑定的修饰符"><a href="#v-model表单输入绑定的修饰符" class="headerlink" title="v-model表单输入绑定的修饰符"></a>v-model表单输入绑定的修饰符</h3><h4 id="lazy修饰符"><a href="#lazy修饰符" class="headerlink" title=".lazy修饰符"></a>.lazy修饰符</h4><p>我们知道在默认情况下，v-model使用监听oninput事件来使得数据保持同步。此时，只要我们在输入数据时该事件就会被触发</p><p>但是，当我们使用.lazy修饰符，v-model就会转而去监听onchange事件，而不是oninput事件。这意味着，只有当表单的value值发生了改变，并且该表单失去焦点时才会触发</p><p>例如：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">v-model.lazy</span>=<span class="string">"value"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>&#123;&#123;value&#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure><p>此时，当我们输入数据时，p元素中的value值不会立即更新。只有当input输入框失去焦点后，value值才会更新</p><h4 id="trim修饰符"><a href="#trim修饰符" class="headerlink" title=".trim修饰符"></a>.trim修饰符</h4><p>如果要自动过滤用户输入的首尾空白字符，可以给 v-model 添加 trim 修饰符</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">v-model.trim</span>=<span class="string">"msg"</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="计算属性和侦听器"><a href="#计算属性和侦听器" class="headerlink" title="计算属性和侦听器"></a>计算属性和侦听器</h2><h3 id="计算属性"><a href="#计算属性" class="headerlink" title="计算属性"></a>计算属性</h3><h4 id="什么是计算属性"><a href="#什么是计算属性" class="headerlink" title="什么是计算属性"></a>什么是计算属性</h4><p>我们知道，可以在模板语法中写入表达式：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span>&gt;</span>&#123;&#123;value.split('').reverse().join('')&#125;&#125;<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure><p>但是，为了模板的可读性，Vue提供了可计算属性来代替这种在模板中插入复杂的表达式计算</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">computed: &#123;</span><br><span class="line">    reverseValue: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.value.split(<span class="string">''</span>).reverse().join(<span class="string">''</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果，我们试着在某个阶段输出一下Vue实例，我们可以看到computed对象中的计算属性的值是直接被添加到vue实例的属性中的</p><p><img src="https://s2.ax1x.com/2019/11/12/M1cfld.png" alt></p><p>因此，它可以直接被作为模板语法直接进行插入</p><h4 id="计算属性的getter和setter"><a href="#计算属性的getter和setter" class="headerlink" title="计算属性的getter和setter"></a>计算属性的getter和setter</h4><p>其实，计算属性就是一个访问器属性。虽然，在computed对象中，我们声明的计算属性目前只是一个函数（此时计算属性默认只有getter），但其实，我们也可以为计算属性添加setter函数</p><p>例如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">computed: &#123;</span><br><span class="line">    reverseValue: &#123;</span><br><span class="line">        <span class="keyword">get</span>: function () &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>.value.split(<span class="string">''</span>).reverse().join(<span class="string">''</span>);</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="keyword">set</span>: function (value) &#123;</span><br><span class="line">            <span class="keyword">this</span>.value = value;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当我学习到这部分的时候，我就产生了疑问。明明这个计算属性应该是访问器属性才对，但是为什么计算属性使用了包含get和set属性的对象写法？还有，之前的默认是getter函数的为什么只需要采用函数写法？</p><p>这一切疑问我们可以从源码中找到答案</p><p>这是初始化计算属性的函数</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">initComputed</span> (<span class="params">vm: Component, computed: Object</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// $flow-disable-line</span></span><br><span class="line">  <span class="keyword">const</span> watchers = vm._computedWatchers = <span class="built_in">Object</span>.create(<span class="literal">null</span>)</span><br><span class="line">  <span class="comment">// computed properties are just getters during SSR</span></span><br><span class="line">  <span class="keyword">const</span> isSSR = isServerRendering()</span><br><span class="line"></span><br><span class="line"> <span class="comment">// 遍历所有computed对象中声明的计算属性</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">const</span> key <span class="keyword">in</span> computed) &#123;</span><br><span class="line">    <span class="keyword">const</span> userDef = computed[key]</span><br><span class="line">    <span class="comment">// 如果属性值为函数，那么将该函数赋值给getter；如果属性值为对象，那么将对象的get属性值赋值给getter</span></span><br><span class="line">    <span class="keyword">const</span> getter = <span class="keyword">typeof</span> userDef === <span class="string">'function'</span> ? userDef : userDef.get</span><br><span class="line">    <span class="keyword">if</span> (process.env.NODE_ENV !== <span class="string">'production'</span> &amp;&amp; getter == <span class="literal">null</span>) &#123;</span><br><span class="line">      warn(</span><br><span class="line">        <span class="string">`Getter is missing for computed property "<span class="subst">$&#123;key&#125;</span>".`</span>,</span><br><span class="line">        vm</span><br><span class="line">      )</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!isSSR) &#123;</span><br><span class="line">      <span class="comment">// create internal watcher for the computed property.</span></span><br><span class="line">      watchers[key] = <span class="keyword">new</span> Watcher(</span><br><span class="line">        vm,</span><br><span class="line">        getter || noop,</span><br><span class="line">        noop,</span><br><span class="line">        computedWatcherOptions</span><br><span class="line">      )</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// component-defined computed properties are already defined on the</span></span><br><span class="line">    <span class="comment">// component prototype. We only need to define computed properties defined</span></span><br><span class="line">    <span class="comment">// at instantiation here.</span></span><br><span class="line">    <span class="keyword">if</span> (!(key <span class="keyword">in</span> vm)) &#123;</span><br><span class="line">        <span class="comment">// 将该计算属性添加到vm实例上</span></span><br><span class="line">      defineComputed(vm, key, userDef)</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (process.env.NODE_ENV !== <span class="string">'production'</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (key <span class="keyword">in</span> vm.$data) &#123;</span><br><span class="line">        warn(<span class="string">`The computed property "<span class="subst">$&#123;key&#125;</span>" is already defined in data.`</span>, vm)</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (vm.$options.props &amp;&amp; key <span class="keyword">in</span> vm.$options.props) &#123;</span><br><span class="line">        warn(<span class="string">`The computed property "<span class="subst">$&#123;key&#125;</span>" is already defined as a prop.`</span>, vm)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们找到对应的defineComputed方法</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">defineComputed</span> (<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  target: any,</span></span></span><br><span class="line"><span class="function"><span class="params">  key: string,</span></span></span><br><span class="line"><span class="function"><span class="params">  userDef: Object | Function</span></span></span><br><span class="line"><span class="function"><span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> shouldCache = !isServerRendering()</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> userDef === <span class="string">'function'</span>) &#123;</span><br><span class="line">    sharedPropertyDefinition.get = shouldCache</span><br><span class="line">      ? createComputedGetter(key)</span><br><span class="line">      : createGetterInvoker(userDef)</span><br><span class="line">    sharedPropertyDefinition.set = noop</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    sharedPropertyDefinition.get = userDef.get</span><br><span class="line">      ? shouldCache &amp;&amp; userDef.cache !== <span class="literal">false</span></span><br><span class="line">        ? createComputedGetter(key)</span><br><span class="line">        : createGetterInvoker(userDef.get)</span><br><span class="line">      : noop</span><br><span class="line">    sharedPropertyDefinition.set = userDef.set || noop</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (process.env.NODE_ENV !== <span class="string">'production'</span> &amp;&amp;</span><br><span class="line">      sharedPropertyDefinition.set === noop) &#123;</span><br><span class="line">    sharedPropertyDefinition.set = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      warn(</span><br><span class="line">        <span class="string">`Computed property "<span class="subst">$&#123;key&#125;</span>" was assigned to but it has no setter.`</span>,</span><br><span class="line">        <span class="keyword">this</span></span><br><span class="line">      )</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 在这里将计算属性添加到vm实例上，并且该属性正式成为了访问器属性</span></span><br><span class="line">  <span class="built_in">Object</span>.defineProperty(target, key, sharedPropertyDefinition)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>看完了这两段源码，之前的困惑就应该消除了。</p><p>如果，我们将计算属性写成函数的形式，那么就将该函数作为该属性的getter方法；</p><p>如果，我们将计算属性写成对象的形式，那么就将对象中的get属性值和set属性值作为计算属性的getter方法和setter方法</p><h4 id="计算属性缓存和方法"><a href="#计算属性缓存和方法" class="headerlink" title="计算属性缓存和方法"></a>计算属性缓存和方法</h4><p>以下是源码中的初始化方法的函数</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">initMethods</span> (<span class="params">vm: Component, methods: Object</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> props = vm.$options.props</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">const</span> key <span class="keyword">in</span> methods) &#123;</span><br><span class="line">    <span class="keyword">if</span> (process.env.NODE_ENV !== <span class="string">'production'</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">typeof</span> methods[key] !== <span class="string">'function'</span>) &#123;</span><br><span class="line">        warn(</span><br><span class="line">          <span class="string">`Method "<span class="subst">$&#123;key&#125;</span>" has type "<span class="subst">$&#123;<span class="keyword">typeof</span> methods[key]&#125;</span>" in the component definition. `</span> +</span><br><span class="line">          <span class="string">`Did you reference the function correctly?`</span>,</span><br><span class="line">          vm</span><br><span class="line">        )</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (props &amp;&amp; hasOwn(props, key)) &#123;</span><br><span class="line">        warn(</span><br><span class="line">          <span class="string">`Method "<span class="subst">$&#123;key&#125;</span>" has already been defined as a prop.`</span>,</span><br><span class="line">          vm</span><br><span class="line">        )</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> ((key <span class="keyword">in</span> vm) &amp;&amp; isReserved(key)) &#123;</span><br><span class="line">        warn(</span><br><span class="line">          <span class="string">`Method "<span class="subst">$&#123;key&#125;</span>" conflicts with an existing Vue instance method. `</span> +</span><br><span class="line">          <span class="string">`Avoid defining component methods that start with _ or $.`</span></span><br><span class="line">        )</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    vm[key] = <span class="keyword">typeof</span> methods[key] !== <span class="string">'function'</span> ? noop : bind(methods[key], vm)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>粗略看一眼我们就可以看到，vm实例中的methods对象中的属性都是直接添加到vm实例的属性上的。</p><p>这也就意味着，我们在模板语法中也可以直接使用methods中的方法</p><p>例如：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">"change"</span>&gt;</span>&#123;&#123;getValue()&#125;&#125;<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br></pre></td></tr></table></figure><p>那么，对于之前的计算属性的写法，我们又可以直接将逻辑写在methods的方法中了</p><p>原来的复杂逻辑直接作为表达式插入模板中</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span>&gt;</span>&#123;&#123;value.split('').reverse().join('')&#125;&#125;<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure><p>使用计算属性</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span>&gt;</span>&#123;&#123;reverseValue&#125;&#125;<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure><p>现在，我们使用方法：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span>&gt;</span>&#123;&#123;reverseValue()&#125;&#125;<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">methods: &#123;</span><br><span class="line">    reverseValue() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.value.split(<span class="string">''</span>).reverse().join(<span class="string">''</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对了，计算属性的属性名不能与方法中的方法名同名，不然，计算属性就会无效。原因在于，计算属性和方法都会作为属性被添加到vm实例中去，那么总不能同名吧。具体，看上面的两个初始化函数。</p><p>来看个总体的例子：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>&#123;&#123;value&#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>&#123;&#123;reverseValue&#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>&#123;&#123;reverse()&#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> Vue(&#123;</span><br><span class="line">    el: <span class="string">'#app'</span>,</span><br><span class="line">    data: &#123;</span><br><span class="line">        value: <span class="string">'abc'</span></span><br><span class="line">    &#125;,</span><br><span class="line">    methods: &#123;</span><br><span class="line">        reverse() &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>.value.split(<span class="string">''</span>).reverse().join(<span class="string">''</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    computed: &#123;</span><br><span class="line">        reverseValue() &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>.value.split(<span class="string">''</span>).reverse().join(<span class="string">''</span>);     </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>渲染结果：</p><p><img src="https://s2.ax1x.com/2019/11/12/M1T2QK.png" alt></p><h5 id="计算属性与方法的区别"><a href="#计算属性与方法的区别" class="headerlink" title="计算属性与方法的区别"></a>计算属性与方法的区别</h5><p>那么，这两种写法有什么区别呢？</p><p>官方文档是这样解释的：</p><blockquote><p>计算属性是基于它们的响应式依赖进行缓存的。只在相关响应式依赖发生改变时它们才会重新求值</p></blockquote><p>也就是说，如果计算属性的getter函数中所依赖的值是响应式数据（上文中的value），那么只有当value值更新时，该计算属性才会更新。</p><p>但是，对于方法呢？只要DOM树重新渲染，这个方法就会被重新执行。我们知道，在vue的生命周期中，只要响应式数据发生了update，那么虚拟DOM就会被重建，挂载的那一部分就会被重新渲染</p><p>我们可以用一个例子来说明以上的结论</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>&#123;&#123;value&#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>&#123;&#123;dateNow&#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>&#123;&#123;getDateNow()&#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">"changeValue"</span>&gt;</span>change value<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> Vue(&#123;</span><br><span class="line">    el: <span class="string">'#app'</span>,</span><br><span class="line">    data: &#123;</span><br><span class="line">        value: <span class="number">123</span></span><br><span class="line">    &#125;,</span><br><span class="line">    methods: &#123;</span><br><span class="line">        getDateNow() &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">Date</span>.now();</span><br><span class="line">        &#125;,</span><br><span class="line">        changeValue() &#123;</span><br><span class="line">            <span class="keyword">this</span>.value = <span class="number">321</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    computed: &#123;</span><br><span class="line">        dateNow() &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">Date</span>.now();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>此时，渲染结果会如下gif<br><img src="https://i.imgur.com/r8wsMQ1.gif" alt></p><p>我们可以看到，当我们改变value值的时候，计算属性的值并没有改变，而方法所得到的的值发生了改变。</p><p>因为，计算属性的值依赖于响应式数据的变化，但是，上述代码中的计算属性的getter函数中并没有响应式数据，因此，就算该组件因为数据变化而重新渲染，计算属性的值也没有发生变化</p><p>但是，模板中的方法只要组件被重新渲染，就会被重新执行，因此，得到的值也就发生了变化</p><h3 id="侦听器"><a href="#侦听器" class="headerlink" title="侦听器"></a>侦听器</h3><p>Vue提供了侦听器用来响应数据的变化。</p><p>在vm实例中，我们可以用watch选项来侦听数据的变化，并作出响应</p><p>例如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> Vue(&#123;</span><br><span class="line">    el: <span class="string">'#app'</span>,</span><br><span class="line">    data: &#123;</span><br><span class="line">        value: <span class="number">123</span></span><br><span class="line">    &#125;,</span><br><span class="line">    watch: &#123;</span><br><span class="line">        value: <span class="function"><span class="keyword">function</span>(<span class="params">newVal,oldVal</span>) </span>&#123;</span><br><span class="line">            <span class="built_in">console</span>.log(newVal,oldVal);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h2 id="class与style绑定"><a href="#class与style绑定" class="headerlink" title="class与style绑定"></a>class与style绑定</h2><h3 id="class绑定"><a href="#class绑定" class="headerlink" title="class绑定"></a>class绑定</h3><p>因为，class属性属于元素上的一个特性，那么，我们可以使用v-bind语法进行绑定</p><h4 id="表达式结果为字符串的绑定"><a href="#表达式结果为字符串的绑定" class="headerlink" title="表达式结果为字符串的绑定"></a>表达式结果为字符串的绑定</h4><p>因为，v-bind中需要的是一个表达式，因此，我们只需要计算出表达式的字符串结果即可</p><h5 id="单变量绑定"><a href="#单变量绑定" class="headerlink" title="单变量绑定"></a>单变量绑定</h5><p>假如v-bind表达式中只有一个变量，那么，我们可以这样写：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line">.red &#123;</span><br><span class="line">    color: red</span><br><span class="line">&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span> <span class="attr">:class</span>=<span class="string">"className"</span>&gt;</span>&#123;&#123;value&#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> Vue(&#123;</span><br><span class="line">    el: <span class="string">"#app"</span>,</span><br><span class="line">    data: &#123;</span><br><span class="line">        value: &#123;</span><br><span class="line">            value: <span class="number">123</span>,</span><br><span class="line">            className: <span class="string">'red'</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h5 id="变量与字符串进行拼接"><a href="#变量与字符串进行拼接" class="headerlink" title="变量与字符串进行拼接"></a>变量与字符串进行拼接</h5><p>因为表达式的值必须为字符串，那么当拼接的时候就要求必须至少有一方为字符串类型</p><p>例如：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line">.red-item &#123;</span><br><span class="line">    color: red</span><br><span class="line">&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span> <span class="attr">:class</span>=<span class="string">"className+'-item'"</span>&gt;</span>&#123;&#123;value&#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> Vue(&#123;</span><br><span class="line">    el: <span class="string">"#app"</span>,</span><br><span class="line">    data: &#123;</span><br><span class="line">        value: &#123;</span><br><span class="line">            value: <span class="number">123</span>,</span><br><span class="line">            className: <span class="string">'red'</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h4 id="表达式结果为对象的绑定"><a href="#表达式结果为对象的绑定" class="headerlink" title="表达式结果为对象的绑定"></a>表达式结果为对象的绑定</h4><p>我们可以为v-bind传入一个对象来作为表达式的结果以动态切换class的值</p><p>例如：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">:class</span>=<span class="string">"&#123;['red-item']:true&#125;"</span>&gt;</span>&#123;&#123;value&#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure><p>另外，为了更加清晰的模板效果，我们可以将对象放在实例的data中</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">:class</span>=<span class="string">"classObj"</span>&gt;</span>&#123;&#123;value&#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> Vue(&#123;</span><br><span class="line">    el: <span class="string">'#app'</span>,</span><br><span class="line">    data: &#123;</span><br><span class="line">        value: <span class="number">123</span>,</span><br><span class="line">        classObj: &#123;</span><br><span class="line">            [<span class="string">'red-item'</span>]: <span class="literal">true</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>当然，作为计算属性也可：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> Vue(&#123;</span><br><span class="line">    el: <span class="string">'#app'</span>,</span><br><span class="line">    data: &#123;</span><br><span class="line">        value: <span class="number">123</span></span><br><span class="line">    &#125;,</span><br><span class="line">    computed: &#123;</span><br><span class="line">        classObj() &#123;</span><br><span class="line">            <span class="keyword">return</span> &#123;</span><br><span class="line">                [<span class="string">'red-item'</span>]: <span class="literal">true</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h4 id="表达式结果为数组的绑定"><a href="#表达式结果为数组的绑定" class="headerlink" title="表达式结果为数组的绑定"></a>表达式结果为数组的绑定</h4><p>Vue还允许我们使用数组来对class进行绑定，数组的结果就是class列表</p><p>例如：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">:class</span>=<span class="string">"['red-item']"</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure><p>当然，我们可以在数组项中加入对象</p><p>例如：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">:class</span>=<span class="string">"[classObj]"</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure><p>此时classObj对象作为vm实例的data属性和计算属性都可以</p><h3 id="style绑定"><a href="#style绑定" class="headerlink" title="style绑定"></a>style绑定</h3><p>当然，对于style我们也可以进行如上以数组和对象的表达式结果的绑定</p><h4 id="对象绑定"><a href="#对象绑定" class="headerlink" title="对象绑定"></a>对象绑定</h4><p>对于对象绑定，我们可以这样写</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">p</span> <span class="attr">:style</span>=<span class="string">"&#123;color: 'red',['font-size']: 15+'px'&#125;"</span>&gt;</span>&#123;&#123;value&#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br></pre></td></tr></table></figure><p>因为，在Js中变量不能包含’-‘连字符，因此，我们需要使用方括号语法进行转换[‘font-size’]</p><h4 id="数组绑定"><a href="#数组绑定" class="headerlink" title="数组绑定"></a>数组绑定</h4><p>v-bind:style 的数组语法可以将多个<strong>样式对象</strong>应用到同一个元素上</p><blockquote><p>如果对:style进行数组语法的绑定，那么数组元素必须为对象</p></blockquote><p>例如：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">:style="[&#123;color: 'red'&#125;,&#123;['font-size']: 20+'px',['font-weight']: 'bolder'&#125;]"</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;v-if与v-show的区别&quot;&gt;&lt;a href=&quot;#v-if与v-show的区别&quot; class=&quot;headerlink&quot; title=&quot;v-if与v-show的区别&quot;&gt;&lt;/a&gt;v-if与v-show的区别&lt;/h2&gt;&lt;p&gt;官方文档对于这两个指令的定义：&lt;/p&gt;
&lt;u
      
    
    </summary>
    
      <category term="Vue" scheme="http://yoursite.com/categories/Vue/"/>
    
    
  </entry>
  
  <entry>
    <title>Vue的生命周期理解</title>
    <link href="http://yoursite.com/2019/11/10/Vue%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E7%90%86%E8%A7%A3/"/>
    <id>http://yoursite.com/2019/11/10/Vue的生命周期理解/</id>
    <published>2019-11-10T04:50:15.000Z</published>
    <updated>2019-11-10T06:28:23.197Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Vue的生命周期"><a href="#Vue的生命周期" class="headerlink" title="Vue的生命周期"></a>Vue的生命周期</h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>每个Vue实例的生命周期大致如下：创建实例，初始化数据，模板编译，挂载DOM，，更新数据然后视图重新渲染，实例销毁等一系列过程</p><h3 id="各个生命周期的具体作用"><a href="#各个生命周期的具体作用" class="headerlink" title="各个生命周期的具体作用"></a>各个生命周期的具体作用</h3><p>在Vue实例的生命周期中，Vue提供了一系列相关的生命周期钩子的函数用来帮助开发者在Vue的不同生命周期阶段来添加适当的代码</p><p>以下是一张Vue官方文档中的生命周期示意图</p><p><img src="https://s2.ax1x.com/2019/11/10/MuEtdx.png" alt></p><p>我们来详细理解以下这张生命周期示意图</p><ol><li><p>new Vue()阶段 创建Vue实例，这一步也就是调用Vue构造函数</p> <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> vm = <span class="keyword">new</span> Vue(&#123;&#125;);</span><br></pre></td></tr></table></figure></li><li><p>初始化了一个空的Vue实例，此时该Vue实例对象上只有默认的一些生命周期函数和默认事件。</p></li><li><p>在这里有一个beforeCreate()生命周期钩子，但是在该钩子函数里我们还无法访问到data以及methods里的方法，当然更无法访问el</p> <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">beforeCreate() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.$data,<span class="keyword">this</span>.$el); <span class="comment">// undefined undefined</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>数据初始化完毕，此时data和methods可以被访问了</p></li><li><p>在该阶段有一个created()的钩子可以供我们调用，此时在该钩子函数中我们可以访问到data和methods内的属性了，但是此时仍然无法访问到el。因此，我们也可以看到该钩子函数是我们在所有钩子函数中最早能够访问到data和methods的阶段</p></li><li><p>Vue开始进行模板编译</p></li><li><p>当模板编译完毕后，Vue在这里提供了一个beforeMount()的生命周期钩子函数，此时render函数将开始被调用，在这个钩子里，我们已经可以访问到el属性了</p> <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">beforeMount() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.$el);</span><br><span class="line">&#125; <span class="comment">// &lt;div id="app"&gt;...&lt;/div&gt;</span></span><br></pre></td></tr></table></figure><p> 但是，在此阶段模板仅仅只是被编译好，而没有真正地替换到页面中去，我们点击上面的this.$el的输出结果可以发现：</p> <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id=<span class="string">"app"</span>&gt;</span><br><span class="line">    &lt;input v-model=<span class="string">"value"</span> /&gt;</span><br><span class="line">    &lt;p&gt;&#123;&#123;value&#125;&#125;&lt;<span class="regexp">/p&gt;</span></span><br><span class="line"><span class="regexp">&lt;/</span>div&gt;</span><br></pre></td></tr></table></figure><p> 我们可以看到此时的输出的要挂载的节点内容并没有被真实地替换掉，模板语法仍旧存在</p></li><li><p>将编译好的模板真实地替换到页面中去，此时我们在mounted()钩子中就可以看到真实被渲染完毕的el</p> <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">mounted() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.$el);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 输出结果</span></span><br><span class="line"><span class="comment">&lt;div&gt;</span></span><br><span class="line"><span class="comment">    &lt;input /&gt;</span></span><br><span class="line"><span class="comment">    &lt;p&gt;123&lt;/p&gt;</span></span><br><span class="line"><span class="comment">&lt;/div&gt;</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p> 此时，Vue实例已经被初始化完毕了，之后就是实例的运行阶段。</p></li><li><p>此时，在Vue组件运行阶段我们可能会要更新数据，当更新数据的时候，beforeUpdate钩子就会被调用，此时，data中的数据是最新的，但是还没有更新到视图中</p></li><li><p>虚拟DOM树重新渲染，然后更新到视图中</p></li><li><p>更行完毕后,updated钩子会被调用，此时数据与视图已经是同步的了</p></li><li><p>当vm.$destroy()实例销毁函数显式被调用时，便会触发触发 beforeDestroy 和 destroyed 的钩子。</p></li><li><p>在实例销毁之前我们可以调用beforeDestroy钩子，此时实例并没有被销毁，该组件所有的功能都还是可用的</p></li><li><p>destroyed()调用时，此时实例已经被销毁完毕了，该组件的所有功能都不再可用</p></li></ol><h2 id="各个生命周期适合开发者适合做的操作"><a href="#各个生命周期适合开发者适合做的操作" class="headerlink" title="各个生命周期适合开发者适合做的操作"></a>各个生命周期适合开发者适合做的操作</h2><h3 id="异步操作应该在哪个生命周期阶段进行"><a href="#异步操作应该在哪个生命周期阶段进行" class="headerlink" title="异步操作应该在哪个生命周期阶段进行"></a>异步操作应该在哪个生命周期阶段进行</h3><p>首先我们需要确认异步操作会不会阻塞Vue的整个生命周期的进行</p><p>我们可以使用宏任务setTimeout并且不设置过时时间来模拟异步操作的进行并修改data中的数据，具体实现如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 确定脚本开始运行的时间</span></span><br><span class="line"><span class="keyword">let</span> start = <span class="built_in">Date</span>.now();</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> vm = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">    el: <span class="string">'#app'</span>,</span><br><span class="line">    data: &#123;</span><br><span class="line">        value: <span class="number">123</span></span><br><span class="line">    &#125;,</span><br><span class="line">    created() &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">`created time <span class="subst">$&#123;<span class="built_in">Date</span>.now()-start&#125;</span>s`</span>);</span><br><span class="line">        <span class="comment">// 没有设置宏任务setTimeout的过时时间</span></span><br><span class="line">        setTimeout(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">`<span class="subst">$&#123;<span class="built_in">Date</span>.now()-start&#125;</span>s change the value to 321`</span>);</span><br><span class="line">            <span class="keyword">this</span>.value = <span class="number">321</span>;</span><br><span class="line">        &#125;)        </span><br><span class="line">    &#125;,</span><br><span class="line">    mounted() &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">`mounted time <span class="subst">$&#123;<span class="built_in">Date</span>.now()-start&#125;</span>s`</span>);        </span><br><span class="line">    &#125;,</span><br><span class="line">    updated() &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">`<span class="subst">$&#123;<span class="built_in">Date</span>.now()-start&#125;</span>s updated the value to <span class="subst">$&#123;<span class="keyword">this</span>.value&#125;</span>`</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 输出结果</span></span><br><span class="line"><span class="comment">created time 2s</span></span><br><span class="line"><span class="comment">mounted time 29s</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">140s change the value to 321</span></span><br><span class="line"><span class="comment">141s start updating the value to 321</span></span><br><span class="line"><span class="comment">143s updated the value to 321</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>我们可以看到宏任务setTimeout在Vue实例完全初始化后，也就是mounted阶段后才会开始运行。因此，对于异步请求数据操作也只会在Vue实例初始化完毕后（mounted阶段后）才会进行，之后的数据修改或赋值就会直接触发beforeUpdate以及后续进行的updated钩子</p><p>通过以上的输出结果，我们可以得出一个结论：</p><blockquote><p>异步操作并不会阻塞Vue初始化生命周期的进行。</p></blockquote><p>因此，我们将异步操作放在created，beforeMount，mounted这三个钩子里都是OK的。因为这三个阶段data数据都已经被初始化好了，我们可以在异步操作的回调中对data中的数据进行修改或赋值了</p><p>但是，为了减少用户的等待时间，我们最好在created阶段进行异步操作。因为异步任务都会被放入event table中进行，越早声明也就代表着被运行的时间越早，因此也就越有可能会在异步回调中的任务队列优先被执行回调</p><h3 id="DOM访问操作应该在哪个生命周期阶段进行"><a href="#DOM访问操作应该在哪个生命周期阶段进行" class="headerlink" title="DOM访问操作应该在哪个生命周期阶段进行"></a>DOM访问操作应该在哪个生命周期阶段进行</h3><p>只有在Vue实例挂在到DOM节点时，我们才可以去访问和操作DOM，因此，DOM访问操作应该在mounted阶段进行</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Vue的生命周期&quot;&gt;&lt;a href=&quot;#Vue的生命周期&quot; class=&quot;headerlink&quot; title=&quot;Vue的生命周期&quot;&gt;&lt;/a&gt;Vue的生命周期&lt;/h2&gt;&lt;h3 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; titl
      
    
    </summary>
    
      <category term="Vue" scheme="http://yoursite.com/categories/Vue/"/>
    
    
  </entry>
  
  <entry>
    <title>MVVM模式的理解以及双向数据绑定</title>
    <link href="http://yoursite.com/2019/11/09/MVVM%E6%A8%A1%E5%BC%8F%E7%9A%84%E7%90%86%E8%A7%A3%E4%BB%A5%E5%8F%8A%E5%8F%8C%E5%90%91%E6%95%B0%E6%8D%AE%E7%BB%91%E5%AE%9A/"/>
    <id>http://yoursite.com/2019/11/09/MVVM模式的理解以及双向数据绑定/</id>
    <published>2019-11-09T06:38:05.000Z</published>
    <updated>2019-11-09T11:19:20.682Z</updated>
    
    <content type="html"><![CDATA[<h2 id="MVVM"><a href="#MVVM" class="headerlink" title="MVVM"></a>MVVM</h2><h3 id="什么是MVVM"><a href="#什么是MVVM" class="headerlink" title="什么是MVVM"></a>什么是MVVM</h3><p>MVVM是一种软件架构设计模式，其由以下三个方面组成：</p><ul><li>Model: 对应MVVM中的第一个M，表示数据模型层，包括自定义数据以及后端给定的api接口数据</li><li>View: 对应MVVM中的第一个V，表示视图层，也就是我们常说的用户界面，这一层使用html+css来进行构建</li><li>ViewModel: 对应MVVM中的VM，表示视图数据层。这一层也是MVVM设计模式的核心。该层作为桥梁用来沟通View视图层和Model数据模型层。我们在该层对Model层给的数据进行数据上和业务上的处理，然后通过双向数据绑定，使得View视图层实时更新视图</li></ul><p><img src="https://s2.ax1x.com/2019/11/09/MmEkRJ.png" alt></p><h2 id="双向数据绑定"><a href="#双向数据绑定" class="headerlink" title="双向数据绑定"></a>双向数据绑定</h2><h3 id="什么数据双向绑定"><a href="#什么数据双向绑定" class="headerlink" title="什么数据双向绑定"></a>什么数据双向绑定</h3><p>对于MVVM设计模式来说，数据绑定是指当数据变化时试图会进行更新，当视图变化时数据会进行相应更新</p><p><img src="https://s2.ax1x.com/2019/11/09/MmmSl4.png" alt></p><h3 id="双向数据绑定的原理"><a href="#双向数据绑定的原理" class="headerlink" title="双向数据绑定的原理"></a>双向数据绑定的原理</h3><p>对于View视图层变化更新数据，一般可以通过事件监听的方式</p><p>例如：<br>vue中的指令v-model就可以监听表单的输入事件来更新相应的数据</p><p>先看下vue中实现的例子：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">v-model</span>=<span class="string">"value"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>&#123;&#123;value&#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var app = new Vue(&#123;</span><br><span class="line">    el: &apos;#app&apos;,</span><br><span class="line">    data: &#123;</span><br><span class="line">        value: &apos;&apos;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>当我们在input表单中输入数据的时候，value值也会进行相应的更新</p><p>实现效果如下：</p><p><img src="https://s2.ax1x.com/2019/11/09/Mmnd2D.png" alt></p><h4 id="利用事件监听机制来实现视图变动来更新数据"><a href="#利用事件监听机制来实现视图变动来更新数据" class="headerlink" title="利用事件监听机制来实现视图变动来更新数据"></a>利用事件监听机制来实现视图变动来更新数据</h4><p>对于v-model指令在表单中输入数据可以进行相应数据的更新，我们可以利用事件监听机制来进行实现</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app"</span>&gt;</span></span><br><span class="line">    /*绑定一个changeData事件，用于当进行表单输入操作时进行数据的更新*/</span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">value</span>=<span class="string">""</span> <span class="attr">id</span>=<span class="string">"input"</span> @<span class="attr">click</span>=<span class="string">"changeData"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>&#123;&#123;value&#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p>input输入框有一个oninput方法可以用来监听输入框中的value值是否有变化</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> app = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">    el: <span class="string">'#app'</span>,</span><br><span class="line">    data: &#123;</span><br><span class="line">        value: <span class="string">''</span></span><br><span class="line">    &#125;,</span><br><span class="line">    methods: &#123;</span><br><span class="line">        changeData() &#123;</span><br><span class="line">            <span class="keyword">let</span> input = <span class="built_in">document</span>.getElementById(<span class="string">'input'</span>);</span><br><span class="line">            <span class="comment">// 如果value值发生了变化，那么就将该value赋值给vue实例data中的value属性</span></span><br><span class="line">            input.addEventListener(<span class="string">'input'</span>,(e)=&gt;&#123;</span><br><span class="line">                <span class="comment">// e.target指向事件绑定的元素，也就是input元素，然后再获取到该元素的value值</span></span><br><span class="line">                <span class="keyword">this</span>.value = e.target.value;</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h4 id="发布订阅模式来解决数据的更新引起视图的更新"><a href="#发布订阅模式来解决数据的更新引起视图的更新" class="headerlink" title="发布订阅模式来解决数据的更新引起视图的更新"></a>发布订阅模式来解决数据的更新引起视图的更新</h4><p>以下是一张来自vue官方的数据双向绑定的原理图</p><p><img src="https://s2.ax1x.com/2019/11/09/MmM8bj.png" alt></p><p>对于Vue中的数据双向绑定的实现，主要通过以下四个步骤来实现</p><ul><li><p>实现一个监听器 Observer：对数据对象进行遍历，包括子属性对象的属性，利用 Object.defineProperty() 对属性都加上访问器属性 setter 和 getter。这样的话，监听器就可以对数据进行劫持，当我们给这个对象的某个值赋值，就会触发 setter，从而监听到数据的变化。</p></li><li><p>实现一个解析器 Compile：解析 Vue 模板指令，将模板中的变量都替换成数据，然后初始化渲染页面视图，并将每个指令对应的节点绑定更新函数，添加监听数据的订阅者，一旦数据有变动，收到通知，调用更新函数进行数据更新。</p></li><li><p>实现一个订阅者 Watcher：Watcher 订阅者是 Observer 和 Compile 之间通信的桥梁 ，主要的任务是订阅 Observer 中的属性值变化的消息，当收到属性值变化的消息时，触发解析器 Compile 中对应的更新函数。</p></li><li><p>实现一个订阅器 Dep：订阅器采用 发布-订阅 设计模式，用来收集订阅者 Watcher，对监听器 Observer 和 订阅者 Watcher 进行统一管理。</p></li></ul><p>大致流程图如下：</p><p><img src="https://s2.ax1x.com/2019/11/09/Mmlp6O.png" alt></p><p>接下来我们会一一实现这些步骤</p><h5 id="Observer监听器进行事件劫持"><a href="#Observer监听器进行事件劫持" class="headerlink" title="Observer监听器进行事件劫持"></a>Observer监听器进行事件劫持</h5><p>此过程主要是通过Object.defineProperty将data对象中的所有属性（包括属性是对象类型所有的子属性）具有访问器属性getter和setter</p><p>具体实现如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 要劫持的数据</span></span><br><span class="line"><span class="keyword">let</span> data = &#123;</span><br><span class="line">    item: <span class="number">1</span>,</span><br><span class="line">    k: &#123;</span><br><span class="line">        m: &#123;</span><br><span class="line">            g: <span class="number">2</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">observe(data)</span><br><span class="line"><span class="built_in">console</span>.log(data.item,data.k,data.k.m);</span><br><span class="line">data.item = &#123;<span class="attr">i</span>:<span class="number">1</span>&#125;;</span><br><span class="line">data.k = <span class="number">2</span>;</span><br><span class="line"><span class="built_in">console</span>.log(data.item,data.k,data.k.m);</span><br><span class="line"></span><br><span class="line"><span class="comment">// observer监听器函数，遍历data对象中的所有属性包括子属性然后调用自定义数据劫持函数setProperty进行数据劫持</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">observe</span>(<span class="params">obj</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> keys = <span class="built_in">Object</span>.keys(obj);</span><br><span class="line">    keys.forEach(<span class="function"><span class="params">v</span>=&gt;</span>&#123;</span><br><span class="line">        <span class="comment">// 如果该属性值是对象，那么进行递归</span></span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">typeof</span> obj[v] === <span class="string">'object'</span> &amp;&amp; v!==<span class="literal">null</span>) &#123;</span><br><span class="line">            observe(obj[v]);</span><br><span class="line">        &#125;</span><br><span class="line">        setProperty(data,v,obj[v]);</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 数据劫持函数，使用Object.defineProperty进行劫持</span></span><br><span class="line"><span class="comment">// 传入对象，键名，以及键值，并将它们作为对象的私有变量，之后对属性值修改与访问都是在操作该私有变量val</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">setProperty</span>(<span class="params">obj, key, val</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">Object</span>.defineProperty(obj, key, &#123;</span><br><span class="line">    enumerable: <span class="literal">true</span>,</span><br><span class="line">    configurable: <span class="literal">true</span>,</span><br><span class="line">    <span class="comment">// 访问器属性get，访问属性时将会调用该函数</span></span><br><span class="line">    <span class="keyword">get</span>: function() &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">'get value'</span>)</span><br><span class="line">      <span class="keyword">return</span> val</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">// 访问器属性set，设置属性值时将会调用该函数</span></span><br><span class="line">    <span class="keyword">set</span>: function(newVal) &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">'change value'</span>)</span><br><span class="line">      val = newVal</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在我们已经实现了，当数据变化后我们可以获得通知。接下来我们要去实现订阅器，来更加方便地管理这些变动</p><h5 id="Dep订阅器的实现"><a href="#Dep订阅器的实现" class="headerlink" title="Dep订阅器的实现"></a>Dep订阅器的实现</h5><p>订阅器的主要功能就是收集订阅者的订阅，然后当发布者发布事件后将订阅者的回调进行执行</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dep</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>() &#123;</span><br><span class="line">    <span class="keyword">this</span>.subs = []</span><br><span class="line">  &#125;</span><br><span class="line">  addSub(sub) &#123;</span><br><span class="line">    <span class="comment">// sub 是 Watcher 实例</span></span><br><span class="line">    <span class="keyword">this</span>.subs.push(sub)</span><br><span class="line">  &#125;</span><br><span class="line">  notify() &#123;</span><br><span class="line">    <span class="keyword">this</span>.subs.forEach(<span class="function"><span class="params">sub</span> =&gt;</span> &#123;</span><br><span class="line">      sub.update()</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 全局属性，通过该属性配置 Watcher</span></span><br><span class="line">Dep.target = <span class="literal">null</span></span><br></pre></td></tr></table></figure><h5 id="Watcher订阅者的实现"><a href="#Watcher订阅者的实现" class="headerlink" title="Watcher订阅者的实现"></a>Watcher订阅者的实现</h5><p>Watcher订阅者的功能就是等待发布者发布之后，订阅器就会统一执行所有订阅者的回调</p><p>事实上，data对象中并不是所有的数据都与视图层有关系，因此，当在模板解析的时候，解析到该值时模板语法，那么就会将该属性作为订阅者添加到订阅器中</p><p>具体实现如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Watcher</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(obj, key, cb) &#123;</span><br><span class="line">    <span class="comment">// 将 Dep.target 指向自己</span></span><br><span class="line">    <span class="comment">// 然后触发属性的 getter 添加监听</span></span><br><span class="line">    <span class="comment">// 最后将 Dep.target 置空</span></span><br><span class="line">    Dep.target = <span class="keyword">this</span></span><br><span class="line">    <span class="keyword">this</span>.cb = cb</span><br><span class="line">    <span class="keyword">this</span>.obj = obj</span><br><span class="line">    <span class="keyword">this</span>.key = key</span><br><span class="line">    <span class="keyword">this</span>.value = obj[key]</span><br><span class="line">    Dep.target = <span class="literal">null</span></span><br><span class="line">  &#125;</span><br><span class="line">  update() &#123;</span><br><span class="line">    <span class="comment">// 获得新值</span></span><br><span class="line">    <span class="keyword">this</span>.value = <span class="keyword">this</span>.obj[<span class="keyword">this</span>.key]</span><br><span class="line">    <span class="comment">// 调用 update 方法更新 Dom</span></span><br><span class="line">    <span class="keyword">this</span>.cb(<span class="keyword">this</span>.value)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">update</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">document</span>.querySelector(<span class="string">'div'</span>).innerText = value</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后，我们还需要修改之前的setProperty函数，在属性访问的时候将其作为订阅者添加到订阅器中，将属性值被修改时，将该事件发布，并执行订阅者相应的回调函数</p><p>具体实现如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">setProperty</span>(<span class="params">obj, key, val</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> dp = <span class="keyword">new</span> Dep()</span><br><span class="line">  <span class="built_in">Object</span>.defineProperty(obj, key, &#123;</span><br><span class="line">    enumerable: <span class="literal">true</span>,</span><br><span class="line">    configurable: <span class="literal">true</span>,</span><br><span class="line">    <span class="keyword">get</span>: function reactiveGetter() &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">'get value'</span>)</span><br><span class="line">      <span class="comment">// 将 Watcher 添加到订阅</span></span><br><span class="line">      <span class="keyword">if</span> (Dep.target) &#123;</span><br><span class="line">        dp.addSub(Dep.target)</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> val</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="keyword">set</span>: function reactiveSetter(newVal) &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">'change value'</span>)</span><br><span class="line">      val = newVal</span><br><span class="line">      <span class="comment">// 执行 watcher 的 update 方法</span></span><br><span class="line">      dp.notify()</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;MVVM&quot;&gt;&lt;a href=&quot;#MVVM&quot; class=&quot;headerlink&quot; title=&quot;MVVM&quot;&gt;&lt;/a&gt;MVVM&lt;/h2&gt;&lt;h3 id=&quot;什么是MVVM&quot;&gt;&lt;a href=&quot;#什么是MVVM&quot; class=&quot;headerlink&quot; title=&quot;什么是
      
    
    </summary>
    
      <category term="Vue" scheme="http://yoursite.com/categories/Vue/"/>
    
    
  </entry>
  
  <entry>
    <title>Buffer的理解以及文件上传的应用</title>
    <link href="http://yoursite.com/2019/11/05/Buffer%E7%9A%84%E7%90%86%E8%A7%A3%E4%BB%A5%E5%8F%8A%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E7%9A%84%E5%BA%94%E7%94%A8/"/>
    <id>http://yoursite.com/2019/11/05/Buffer的理解以及文件上传的应用/</id>
    <published>2019-11-05T07:16:53.000Z</published>
    <updated>2019-11-06T12:59:53.569Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Buffer（缓冲区）"><a href="#Buffer（缓冲区）" class="headerlink" title="Buffer（缓冲区）"></a>Buffer（缓冲区）</h2><p>在Node中，应用需要处理网络协议、操作数据库、处理图片、接收上传的文件等，在网络流和文件的操作中，还要处理大量的二进制数据，而Js自有的字符串远远无法满足这些需求，于是Buffer对象应运而生</p><p>Buffer类在全局作用域中，因此，我们无需使用require(‘buffer’).Buffer来进行使用</p><h3 id="什么是Buffer（缓冲区）"><a href="#什么是Buffer（缓冲区）" class="headerlink" title="什么是Buffer（缓冲区）"></a>什么是Buffer（缓冲区）</h3><p>我们知道数据的移动是以流的方式进行的。当我们从文件或网络读取数据的时候，就需要一个输入流来进行数据的读取；而当我们要写入一些数据的时候，就需要开启一个输出流来进行数据的移动。</p><p>但是，Node并无法控制数据流的速度以及数据到达目的地的时间。因此，如果数据到达的速度比进程消耗的速度快，那么少数早到达的数据会处于等待区等候被处理。反之，如果数据到达的速度比进程消耗的数据慢，那么早先到达的数据需要在等待区中等待一定量的数据到达之后才能被处理。</p><p>这个等待区也就是我们要提的Buffer（缓冲区）</p><h3 id="Buffer对象"><a href="#Buffer对象" class="headerlink" title="Buffer对象"></a>Buffer对象</h3><p>Buffer对象类似与一个数组，它的元素为16进制的两位数，即0到255的数值。</p><p>我们可以这样来创建Buffer对象</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> buf =  Buffer.from(<span class="string">'理解Buffer'</span>)</span><br><span class="line"><span class="built_in">console</span>.log(buf); <span class="comment">// &lt;Buffer e7 90 86 e8 a7 a3 42 75 66 66 65 72&gt;</span></span><br></pre></td></tr></table></figure><p>我们输出一下这个buf对象长度</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(buf.length); <span class="comment">// 12</span></span><br></pre></td></tr></table></figure><p>我们可以看到buf对象的长度与给定的字符串长度不一样。因此，我们可以得出不同编码的字符串占用的元素个数各不相同。上面的代码中的中文字在UTF-8的编码下占用3个元素，而字母和半角标点符号占用1个元素。</p><p>另外，以下是创建Buffer对象时常用的API：</p><ol><li><p>Buffer.from(array) 返回一个新的 Buffer，其中包含提供的八位字节数组的副本。</p></li><li><p>Buffer.from(arrayBuffer[, byteOffset [, length]]) 返回一个新的 Buffer，它与给定的 ArrayBuffer 共享相同的已分配内存。</p></li><li><p>Buffer.from(buffer) 返回一个新的 Buffer，其中包含给定 Buffer 的内容的副本。</p></li><li><p>Buffer.from(string[, encoding]) 返回一个新的 Buffer，其中包含提供的字符串的副本,encoding为给定的string的编码格式。</p></li><li><p>Buffer.alloc(size[, fill[, encoding]]) 返回一个指定大小的新建的的已初始化的 Buffer。 此方法比 Buffer.allocUnsafe(size) 慢，但能确保新创建的 Buffer 实例永远不会包含可能敏感的旧数据。 如果 size 不是数字，则将会抛出 TypeError。</p></li><li><p>Buffer.allocUnsafe(size) 和 Buffer.allocUnsafeSlow(size) 分别返回一个指定大小的新建的未初始化的 Buffer。 由于 Buffer 是未初始化的，因此分配的内存片段可能包含敏感的旧数据。</p></li></ol><p>如果 size 小于或等于 Buffer.poolSize 的一半，则 Buffer.allocUnsafe() 返回的 Buffer 实例可能是从共享的内部内存池中分配。 Buffer.allocUnsafeSlow() 返回的实例则从不使用共享的内部内存池。</p><p>示例：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建一个给定Array的Buffer，其中Array的元素为10进制整数，它会被转化为16进制的二进制数</span></span><br><span class="line"><span class="keyword">let</span> buffer = Buffer.from([<span class="number">53</span>,<span class="number">198</span>,<span class="number">255</span>]);</span><br><span class="line"><span class="built_in">console</span>.log(buffer); <span class="comment">// &lt;Buffer 35 c6 ff&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 分配一个指定大小的新建的的已初始化的 Buffer，该Buffer永远不会包含旧数据</span></span><br><span class="line">buffer = Buffer.alloc(<span class="number">10</span>);</span><br><span class="line"><span class="built_in">console</span>.log(buffer); <span class="comment">// &lt;Buffer 00 00 00 00 00 00 00 00 00 00&gt;</span></span><br></pre></td></tr></table></figure><h3 id="Buffer的内存分配"><a href="#Buffer的内存分配" class="headerlink" title="Buffer的内存分配"></a>Buffer的内存分配</h3><p>我们在V8的垃圾回收机制中了解到，一般的基本类型变量会存储在栈中，而复杂引用类型会存储在v8的堆内存中。</p><p>然而，Buffer对象的内存分配不是在v8的堆内存中进行的，而是在Node的C++层面进行内存分配的。</p><p>因为处理大量的字节数据不能采用需要一点内存就向系统申请内存的方式（v8的内存管理就采用这种方式，如果堆内存不够就继续申请堆内存直到超过系统限制），这样的话会造成操作系统层面的压力</p><p>Node采用slab分配机制来进行Buffer对象的内存分配。</p><p>slab是一块申请号的固定大小的内存区域，它的大小为8kb。Node通常也以8Kb为分界来区分小Buffe对象和大Buffer对象</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Buffer.poolSize = <span class="number">8</span>*<span class="number">1024</span>;</span><br></pre></td></tr></table></figure><p>之前提过，我们可以使用Buffer.alloc(size)来分配指定大小的Buffer对象</p><p>当size&lt;8*1024时，该Buffer对象为小对象，否则，则是大对象</p><p>当在进行slab内存分配的时候，其符合以下的规则：</p><ol><li>如果要分配的Buffer内存大小小于slab内存大小，那么在slab中分配内存给Buffer</li><li>如果slab剩余空闲内存小于需要分配的Buffer内存大小，那么重新会新建一个slab来分配该Buffer对象的内存</li><li>如果Buffer对象为大对象，即需要分配的内存大于8kb，那么，系统将会直接分配一个SlowBuffer对象作为slab单元，这个slab单元将会被该Buffer对象独占</li></ol><h3 id="Buffer与字符串的相互转换"><a href="#Buffer与字符串的相互转换" class="headerlink" title="Buffer与字符串的相互转换"></a>Buffer与字符串的相互转换</h3><p>当字符串存储入一个Buffer实例或者从Buffer实例中提取时，我们可以指定一个字符编码</p><p>例如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 以utf-8编码将字符串存储入Buffer中</span></span><br><span class="line"><span class="keyword">let</span> buf = Buffer.from(<span class="string">'理解Buffer'</span>,<span class="string">'utf-8'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(buf); <span class="comment">// &lt;Buffer e7 90 86 e8 a7 a3 42 75 66 66 65 72&gt;</span></span><br><span class="line"><span class="comment">// 以base64编码取出该字符串</span></span><br><span class="line"><span class="built_in">console</span>.log(buf.toString(<span class="string">'base64'</span>)); <span class="comment">// 55CG6KejQnVmZmVy</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 以ascii编码将字符串存入Buffer中</span></span><br><span class="line">buf = Buffer.from(<span class="string">'理解Buffer'</span>,<span class="string">'ascii'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(buf);</span><br></pre></td></tr></table></figure><h3 id="Buffer的拼接"><a href="#Buffer的拼接" class="headerlink" title="Buffer的拼接"></a>Buffer的拼接</h3><h4 id="直接拼接Buffer时遇到的问题"><a href="#直接拼接Buffer时遇到的问题" class="headerlink" title="直接拼接Buffer时遇到的问题"></a>直接拼接Buffer时遇到的问题</h4><p>我们知道数据的移动是以流的方式进行的。那么，使用了Buffer作为缓冲区后，我们得到一个流数据就是一段一段的进行获取</p><p>现在我们来试着使用读取流来读取一个文件内容：</p><p>例如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 该fs.createReadStream()方法会返回一个新的fs.ReadStream对象，该对象也就是读取流</span></span><br><span class="line"><span class="keyword">let</span> rs = fs.createReadStream(<span class="string">'./a.ja'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> data = <span class="string">''</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 当流将数据块传送给消费者后触发data事件</span></span><br><span class="line">rs.on(<span class="string">'data'</span>,(chunk)=&gt;&#123;</span><br><span class="line">    data+=chunk;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 'end' 事件只有在数据被完全消费掉后才会触发</span></span><br><span class="line">rs.on(<span class="string">'end'</span>,()=&gt;&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(data);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>此时a.js文件内容如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="string">'hello'</span>);</span><br></pre></td></tr></table></figure><p>那么，输出结果如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">console.log(&apos;hello&apos;);</span><br></pre></td></tr></table></figure><p>我们发现读取似乎没有什么问题。但其实，这是有问题的。上述程序中有一行语句是</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">data+=chunk;</span><br></pre></td></tr></table></figure><p>我们知道流的读取时，传递的应该是Buffer对象，我们试着输出一下这个chunk</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">rs.on(<span class="string">'data'</span>,(chunk)=&gt;&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(chunk); <span class="comment">// &lt;Buffer 63 6f 6e 73 6f 6c 65 2e 6c 6f 67 28 27 68 65 6c 6c 6f 27 29 3b&gt;</span></span><br><span class="line">    data+=chunk;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>的确，这个chunk确实是Buffer对象，那么为什么最后输出的是正确的字符串呢？</p><p>我们知道在字符串拼接的时候，如果有一方不是字符串，那么就会将其转化为字符串之后再进行拼接。因此，那行代码又可以等价为</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">data+=chunk.toString();</span><br></pre></td></tr></table></figure><p>这样似乎都可以说的通了，但是如果我们读取的内容不全是英文，而是包括有宽字节的中文呢?</p><p>我们将a.js文件内容改为如下</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="string">'你好呀，我很好'</span>);</span><br></pre></td></tr></table></figure><p>同时，我们利用highWaterMark属性将缓冲区的大小限制为5。</p><p>此时，完整的程序如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将每次读取的Buffer长度限制为5</span></span><br><span class="line"><span class="keyword">let</span> rs = fs.createReadStream(<span class="string">'./a.js'</span>,&#123;<span class="attr">highWaterMark</span>:<span class="number">5</span>&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> data = <span class="string">''</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">rs.on(<span class="string">'data'</span>,(chunk)=&gt;&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(chunk);</span><br><span class="line">    data+=chunk;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">rs.on(<span class="string">'end'</span>,()=&gt;&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(data);</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 输出结果</span></span><br><span class="line"><span class="comment">&lt;Buffer 63 6f 6e 73 6f&gt;</span></span><br><span class="line"><span class="comment">&lt;Buffer 6c 65 2e 6c 6f&gt;</span></span><br><span class="line"><span class="comment">&lt;Buffer 67 28 27 e4 bd&gt;</span></span><br><span class="line"><span class="comment">&lt;Buffer a0 e5 a5 bd e5&gt;</span></span><br><span class="line"><span class="comment">&lt;Buffer 91 80 ef bc 8c&gt;</span></span><br><span class="line"><span class="comment">&lt;Buffer e6 88 91 e5 be&gt;</span></span><br><span class="line"><span class="comment">&lt;Buffer 88 e5 a5 bd 27&gt;</span></span><br><span class="line"><span class="comment">&lt;Buffer 29 3b&gt;</span></span><br><span class="line"><span class="comment">console.log('��好���，我��好');</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>我们可以看到，每次的读取Buffer长度的确为5。此时，我们惊奇的发现，文件内容出现了乱码。</p><p>这是为什么呢？我们知道，中文字符为宽字节字符，在utf-8模式下，其占3个字节。因此，我们用每次5个字节进行读取时，就会遇到，有些中文字符会被拆分到两次读取中，因此，就会显示出乱码</p><h4 id="利用setEncoding来解决"><a href="#利用setEncoding来解决" class="headerlink" title="利用setEncoding来解决"></a>利用setEncoding来解决</h4><p>readable.setEncoding() 方法为从可读流读取的数据设置字符编码。</p><p>默认情况下没有设置字符编码，流数据返回的是 Buffer 对象。 如果设置了字符编码，则流数据返回指定编码的字符串。 例如，调用 readable.setEncoding(‘utf-8’) 会将数据解析为 UTF-8 数据，并返回字符串，调用 readable.setEncoding(‘hex’) 则会将数据编码成十六进制字符串。</p><p>因此，我们可以这样修改上述的程序：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> rs = fs.createReadStream(<span class="string">'./a.js'</span>,&#123;<span class="attr">highWaterMark</span>:<span class="number">5</span>&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置字符编码，将流Buffer对象转化为字符串</span></span><br><span class="line">rs.setEncoding(<span class="string">'utf-8'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> data = <span class="string">''</span>;</span><br><span class="line">rs.on(<span class="string">'data'</span>,(chunk)=&gt;&#123;</span><br><span class="line">    <span class="comment">// 此时chunk为字符串形式</span></span><br><span class="line">    <span class="built_in">console</span>.log(chunk);</span><br><span class="line">    data+=chunk;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">rs.on(<span class="string">'end'</span>,()=&gt;&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(data);</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 输出结果</span></span><br><span class="line"><span class="comment">conso</span></span><br><span class="line"><span class="comment">le.lo</span></span><br><span class="line"><span class="comment">g('</span></span><br><span class="line"><span class="comment">你好</span></span><br><span class="line"><span class="comment">呀，</span></span><br><span class="line"><span class="comment">我</span></span><br><span class="line"><span class="comment">很好'</span></span><br><span class="line"><span class="comment">);</span></span><br><span class="line"><span class="comment">console.log('你好呀，我很好');</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>虽然使用setEncoding可以解决目前的问题，但是它目前只能处理utf-8、Base64等部分编码，因此，它并不是完美的。</p><h4 id="使用Buffer-concat-来解决"><a href="#使用Buffer-concat-来解决" class="headerlink" title="使用Buffer.concat()来解决"></a>使用Buffer.concat()来解决</h4><p>相较setEncoding方法在接收时并将buffer对象进行编码转换的不同，Buffer.concat()方法的思想是先接收到所有的小Buffer对象，然后将所有的小Buffer对象进行合并成一个大对象然后再进行字符串输出</p><p>Buffer.concat(list[,totalLength])方法接受一个要合并的Buffer数组和合并后list中的Buffer实例的总长度，然后返回一个合并了list中所有Buffer实例的新Buffer</p><p>如果没有提供 totalLength，则计算 list 中的 Buffer 实例的总长度。 但是这会导致执行额外的循环用于计算 totalLength，因此如果已知长度，则明确提供长度会更快</p><p>因此，最完美的解决方案应该如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> rs = fs.createReadStream(<span class="string">'./a.js'</span>,&#123;<span class="attr">highWaterMark</span>:<span class="number">5</span>&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> list = [];</span><br><span class="line"><span class="keyword">let</span> length = <span class="number">0</span>;</span><br><span class="line">rs.on(<span class="string">'data'</span>,(chunk)=&gt;&#123;</span><br><span class="line">    list.push(chunk);</span><br><span class="line">    length+=chunk.length;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">rs.on(<span class="string">'end'</span>,()=&gt;&#123;</span><br><span class="line">    <span class="keyword">let</span> newBuf = Buffer.concat(list,length);</span><br><span class="line">    <span class="built_in">console</span>.log(newBuf);</span><br><span class="line">    <span class="built_in">console</span>.log(newBuf.toString(<span class="string">'utf-8'</span>));</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 输出结果</span></span><br><span class="line"><span class="comment">&lt;Buffer 63 6f 6e 73 6f 6c 65 2e 6c 6f 67 28 27 e4 bd a0 e5 a5 bd e5 91 80 ef bc 8c e6 88 91 e5 be 88 e5 a5 bd 27 29 3b&gt;</span></span><br><span class="line"><span class="comment">console.log('你好呀，我很好');</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>我们可以看到，结果是可以正确输出的。</p><h3 id="BUffer与网络传输"><a href="#BUffer与网络传输" class="headerlink" title="BUffer与网络传输"></a>BUffer与网络传输</h3><p>网络传输一般使用字节流来进行传输，因此，无论我们在传输之前什么类型的值，在传输的过程中都会转化为Buffer对象来进行网络传输</p><p>例如：当客户端想要通过post方式传递一些数据的时候，这些数据就会被转化为Buffer对象，一点一点地传递到服务器端</p><p>注意：</p><blockquote><p>网络传输中，请求与响应都是流对象，req为可读流，res为可写流</p></blockquote><p>因此，我们可以利用以下的方式来获取post请求的携带的数据</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> http = <span class="built_in">require</span>(<span class="string">'http'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> list = [];</span><br><span class="line"><span class="keyword">let</span> length = <span class="number">0</span>;</span><br><span class="line">http.createServer(<span class="function">(<span class="params">req,res</span>)=&gt;</span>&#123;</span><br><span class="line">    req.on(<span class="string">'data'</span>,(chunk)=&gt;&#123;</span><br><span class="line">        <span class="comment">// console.log(chunk);</span></span><br><span class="line">        list.push(chunk);</span><br><span class="line">        length+=chunk.length;</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    req.on(<span class="string">'end'</span>,()=&gt;&#123;</span><br><span class="line">        <span class="keyword">let</span> buf = Buffer.concat(list,length);</span><br><span class="line">        <span class="comment">// console.log(buf);</span></span><br><span class="line">        <span class="built_in">console</span>.log(buf.toString(<span class="string">'utf-8'</span>));</span><br><span class="line"></span><br><span class="line">        res.setHeader(<span class="string">'Content-Type'</span>,<span class="string">'application/JSON'</span>);</span><br><span class="line">        res.end(buf.toString(<span class="string">'utf-8'</span>))</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>因此，如果我们直接返回Buffer类型，cpu就不需要进行类型转换工作，可以有效地减少cpu的重复使用，节省服务器资源</p><h2 id="文件上传"><a href="#文件上传" class="headerlink" title="文件上传"></a>文件上传</h2><p>首先我们要在前端选取文件，并得到文件的base64编码</p><p>前端部分代码，通过FileReader对象来将获取的文件进行base64编码，通过axios来进行文件上传</p><p>前端部分</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> axios = <span class="built_in">require</span>(<span class="string">'axios'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> fileSelect = <span class="built_in">document</span>.getElementsByTagName(<span class="string">'input'</span>)[<span class="number">0</span>];</span><br><span class="line"><span class="keyword">let</span> submit = <span class="built_in">document</span>.getElementsByTagName(<span class="string">'input'</span>)[<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">submit.addEventListener(<span class="string">'click'</span>,()=&gt;&#123;</span><br><span class="line">    <span class="keyword">let</span> file = fileSelect.files[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">let</span> fr = <span class="keyword">new</span> FileReader(file);</span><br><span class="line">    <span class="comment">// 处理load事件。该事件在读取操作完成时触发。</span></span><br><span class="line">    fr.addEventListener(<span class="string">'load'</span>,()=&gt;&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(fr.result);</span><br><span class="line">        axios.post(<span class="string">'/api/hello'</span>,&#123;</span><br><span class="line">            params: &#123;</span><br><span class="line">                value: fr.result</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).then(<span class="function"><span class="params">v</span>=&gt;</span>&#123;</span><br><span class="line">            <span class="built_in">console</span>.log(v);</span><br><span class="line">        &#125;).catch(<span class="function"><span class="params">err</span>=&gt;</span>&#123;</span><br><span class="line">            <span class="built_in">console</span>.log(err);</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="comment">// 开始读取指定的Blob中的内容。一旦完成，result属性中将包含一个data: URL格式的Base64字符串以表示所读取文件的内容。</span></span><br><span class="line">    fr.readAsDataURL(file);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="Node端处理文件上传"><a href="#Node端处理文件上传" class="headerlink" title="Node端处理文件上传"></a>Node端处理文件上传</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> http = <span class="built_in">require</span>(<span class="string">'http'</span>);</span><br><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>);</span><br><span class="line"><span class="keyword">const</span> queryString = <span class="built_in">require</span>(<span class="string">'queryString'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> list = [];</span><br><span class="line"><span class="keyword">let</span> length = <span class="number">0</span>;</span><br><span class="line">http.createServer(<span class="function">(<span class="params">req,res</span>)=&gt;</span>&#123;</span><br><span class="line">    req.on(<span class="string">'data'</span>,(chunk)=&gt;&#123;</span><br><span class="line">        list.push(chunk);</span><br><span class="line">        length+=chunk.length;</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    req.on(<span class="string">'end'</span>,()=&gt;&#123;</span><br><span class="line">        <span class="comment">// 获取得到的是utf-8编码的Buffer对象</span></span><br><span class="line">        <span class="keyword">let</span> buf = Buffer.concat(list,length);</span><br><span class="line">        <span class="comment">// 将该Buffer对象转化为utf-8编码的字符串，并且取出包含在该字符串中的base64编码的文件内容</span></span><br><span class="line">        <span class="keyword">let</span> data = <span class="built_in">JSON</span>.parse(buf.toString(<span class="string">'utf-8'</span>)).params.value.replace(<span class="regexp">/^data:text\/javascript;base64,/</span>,<span class="string">''</span>);</span><br><span class="line">        <span class="comment">// 接下来就需要将base64编码转化为utf-8编码，我们可以间接地通过Buffer对象来转换</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建以base64编码的Buffer对象</span></span><br><span class="line">        <span class="keyword">let</span> newBuf = Buffer.from(data,<span class="string">'base64'</span>);</span><br><span class="line">        <span class="comment">// 将该Buffer对象转化为base64编码的字符串</span></span><br><span class="line">        <span class="keyword">let</span> fileContent = newBuf.toString(<span class="string">'utf-8'</span>);</span><br><span class="line">        <span class="comment">// 将文件内容写进get.js文件</span></span><br><span class="line">        fs.writeFile(<span class="string">'get.js'</span>,fileContent,()=&gt;&#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">'文件已保存'</span>);</span><br><span class="line">        &#125;)</span><br><span class="line">        res.setHeader(<span class="string">'Content-Type'</span>,<span class="string">'application/JSON'</span>);</span><br><span class="line">        res.end(<span class="built_in">JSON</span>.stringify(&#123;<span class="attr">value</span>:<span class="string">'收到'</span>&#125;));</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;).listen(<span class="number">3000</span>,()=&gt;&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'Port 3000 is listenging'</span>);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>此时，我们就可以实现一个js文件的上传。</p><p>当然，为了能够上传更多格式的文件，我们修改以上的正则表达式就OK了</p><h3 id="Node端处理图片上传"><a href="#Node端处理图片上传" class="headerlink" title="Node端处理图片上传"></a>Node端处理图片上传</h3><p>因为图片的编码貌似都是base64编码，因此，我们在获得图片的base64编码后不需要像文件一样转化为utf-8编码，只需直接存储即可</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> http = <span class="built_in">require</span>(<span class="string">'http'</span>);</span><br><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>);</span><br><span class="line"><span class="keyword">const</span> queryString = <span class="built_in">require</span>(<span class="string">'queryString'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> list = [];</span><br><span class="line"><span class="keyword">let</span> length = <span class="number">0</span>;</span><br><span class="line">http.createServer(<span class="function">(<span class="params">req,res</span>)=&gt;</span>&#123;</span><br><span class="line">    req.on(<span class="string">'data'</span>,(chunk)=&gt;&#123;</span><br><span class="line">        list.push(chunk);</span><br><span class="line">        length+=chunk.length;</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    req.on(<span class="string">'end'</span>,()=&gt;&#123;</span><br><span class="line">        <span class="comment">// 获取得到的是utf-8编码的Buffer对象</span></span><br><span class="line">        <span class="keyword">let</span> buf = Buffer.concat(list,length);</span><br><span class="line">        <span class="comment">// 将该Buffer对象转化为utf-8编码的字符串，并且取出包含在该字符串中的base64编码的文件内容</span></span><br><span class="line">        <span class="keyword">let</span> data = <span class="built_in">JSON</span>.parse(buf.toString(<span class="string">'utf-8'</span>)).params.value.replace(<span class="regexp">/^data:((text\/(javascript|plain))|(image\/(png|jpg|jpeg|gif)));base64,/</span>,<span class="string">''</span>);</span><br><span class="line">        <span class="comment">// 接下来就需要将base64编码转化为utf-8编码，我们可以间接地通过Buffer对象来转换</span></span><br><span class="line">        <span class="built_in">console</span>.log(data);</span><br><span class="line">        <span class="comment">// 创建以base64编码的Buffer对象</span></span><br><span class="line">        <span class="keyword">let</span> newBuf = Buffer.from(data,<span class="string">'base64'</span>);</span><br><span class="line">        <span class="comment">// 不需要将该Buffer对象转化为base64编码的字符串</span></span><br><span class="line">        <span class="comment">//let fileContent = newBuf.toString('utf-8');</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 生成a.jpeg</span></span><br><span class="line">        fs.writeFile(<span class="string">'a.jpeg'</span>,newBuf,()=&gt;&#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">'文件已保存'</span>);</span><br><span class="line">        &#125;)</span><br><span class="line">        res.setHeader(<span class="string">'Content-Type'</span>,<span class="string">'application/JSON'</span>);</span><br><span class="line">        res.end(<span class="built_in">JSON</span>.stringify(&#123;<span class="attr">value</span>:<span class="string">'收到'</span>&#125;));</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;).listen(<span class="number">3000</span>,()=&gt;&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'Port 3000 is listenging'</span>);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Buffer（缓冲区）&quot;&gt;&lt;a href=&quot;#Buffer（缓冲区）&quot; class=&quot;headerlink&quot; title=&quot;Buffer（缓冲区）&quot;&gt;&lt;/a&gt;Buffer（缓冲区）&lt;/h2&gt;&lt;p&gt;在Node中，应用需要处理网络协议、操作数据库、处理图片、接收上传的
      
    
    </summary>
    
      <category term="Node" scheme="http://yoursite.com/categories/Node/"/>
    
    
  </entry>
  
  <entry>
    <title>V8的垃圾回收机制与内存管理</title>
    <link href="http://yoursite.com/2019/11/04/V8%E7%9A%84%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6/"/>
    <id>http://yoursite.com/2019/11/04/V8的垃圾回收机制/</id>
    <published>2019-11-04T12:11:14.000Z</published>
    <updated>2019-11-04T14:04:11.479Z</updated>
    
    <content type="html"><![CDATA[<h2 id="内存管理简介"><a href="#内存管理简介" class="headerlink" title="内存管理简介"></a>内存管理简介</h2><p>来自于MDN的简介：</p><blockquote><p>像C语言这样的底层语言一般都有底层的内存管理接口，比如 malloc()和free()。相反，JavaScript是在创建变量（对象，字符串等）时自动进行了分配内存，并且在不使用它们时“自动”释放。 释放的过程称为垃圾回收。这个“自动”是混乱的根源，并让JavaScript（和其他高级语言）开发者错误的感觉他们可以不关心内存管理。 </p></blockquote><h2 id="内存的生命周期"><a href="#内存的生命周期" class="headerlink" title="内存的生命周期"></a>内存的生命周期</h2><p>内存的生命周期基本如下：</p><ol><li>分配需要的内存</li><li>时候用分配到的内存进行读写操作</li><li>不需要是将该内存归还或释放</li></ol><h2 id="v8的内存模型"><a href="#v8的内存模型" class="headerlink" title="v8的内存模型"></a>v8的内存模型</h2><p>一个运行中的程序总是与内存中的一部分空间相对应，这部分空间被称为Resident Set（驻留集）。</p><p>其内存模型如下：</p><p><img src="https://s2.ax1x.com/2019/11/04/KxzhXF.png" alt></p><p>图中各名词的解释：</p><ul><li>Resident Segment 驻留集（当前程序所占用的全部空间）</li><li>Code Segment 存放正在执行的代码</li><li>Stack 栈 存放基本类型变量以及对象的指针（因为栈中的内存较小，栈中的每一块内存大小固定）</li><li>Heap 堆 存放复杂引用类型</li><li>Used Heap 堆中已经使用的内存量</li></ul><h2 id="Node中的内存查看方式"><a href="#Node中的内存查看方式" class="headerlink" title="Node中的内存查看方式"></a>Node中的内存查看方式</h2><p>Node中可以使用process.memoryUsage()方法来查看当前进程的内存使用情况</p><p>因为该方法输出的内存单位为字节，我们在下面的方法中将其封装从而输出以M为单位</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">format</span>(<span class="params">bytes</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (bytes/<span class="number">1024</span>/<span class="number">1024</span>).toFixed(<span class="number">2</span>)+<span class="string">'MB'</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> memoryUsage = process.memoryUsage();</span><br><span class="line"></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'rss'</span>,format(memoryUsage.rss));</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'heapTotal'</span>,format(memoryUsage.heapTotal));</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'heapUsed'</span>,format(memoryUsage.heapUsed));</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'external'</span>,format(memoryUsage.external));</span><br><span class="line">&#125;)()</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 输出结果</span></span><br><span class="line"><span class="comment">rss 17.60MB</span></span><br><span class="line"><span class="comment">heapTotal 4.05MB</span></span><br><span class="line"><span class="comment">heapUsed 2.01MB</span></span><br><span class="line"><span class="comment">external 0.61MB</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>其中，process.memoryUsage方法返回的对象中的所有属性说明如下：</p><ol><li>rss(resident set size): 当前进程占用的内存部分，包括之前提到过的代码本身、存储基本类型变量和对象指针的栈、存储复杂引用类型的堆</li><li>heapTotal: 堆中总共申请到的内存量</li><li>heapUsed: 堆中目前已经使用的内存量</li><li>external: v8引擎内部的C++对象占用的内存</li></ol><p>我们知道，Js中的所有复杂引用类型都是存储在堆中的。因此，当我们创建一个对象时，该对象所占用的内存就会被存放在堆中。如果，当前堆的空闲内存大小已经不够再分配一个新的对象，那么将会继续申请堆内存，直到堆的大小超过V8的限制为止。</p><p>在这里提一句，在默认情况下，v8堆内存的最大值在64位系统下大约为1.4G，在32位系统下大约为0.7G</p><h2 id="v8的垃圾回收机制"><a href="#v8的垃圾回收机制" class="headerlink" title="v8的垃圾回收机制"></a>v8的垃圾回收机制</h2><blockquote><p>垃圾回收是指回收那些在应用程序中不再被引用的对象</p></blockquote><p>例如，我们将一个对象指向null后该对象就会垃圾回收机制自动回收掉</p><p>v8的垃圾回收机制主要基于分代式垃圾回收机制</p><h3 id="新生代与老生代"><a href="#新生代与老生代" class="headerlink" title="新生代与老生代"></a>新生代与老生代</h3><p>在V8中，主要将内存分为新生代和老生代两代。新生代中的对象为存活时间较短的对象，老生代中的对象为存活时间较长或常驻内存中的对象</p><p><img src="https://s2.ax1x.com/2019/11/04/KzZCSH.png" alt></p><p>由此，我们可以看到v8申请到堆的大小就是新生代所用内存空间加上老生代所用内存空间</p><h4 id="新生代内存空间所使用的的垃圾回收算法（Scavenge算法）"><a href="#新生代内存空间所使用的的垃圾回收算法（Scavenge算法）" class="headerlink" title="新生代内存空间所使用的的垃圾回收算法（Scavenge算法）"></a>新生代内存空间所使用的的垃圾回收算法（Scavenge算法）</h4><p>在新生代内存空间中，v8主要使用Scavenge算法来进行垃圾回收。</p><p>该算法是一种采用复制的方式来实现的垃圾回收算法。</p><p>它会将新生代内存一份为二，其中一个空间称为From空间，该空间是当前正在使用的空间；另一个空间成为To空间，该空间是当前正在被闲置的空间（该空间中的内存没有被任何对象使用）</p><p><img src="https://s2.ax1x.com/2019/11/04/KzZpfe.png" alt></p><p>当开始进行垃圾回收时，v8会检查From空间是否还有存活的对象，如果有，那么将这些对象复制到当前空闲的To空间；而，其余非存活的对象则会被回收，它们所占用的空间也会被释放。完成复制后，From空间和To空间的角色将会被互换，也就是刚刚的From空间在复制后就会变为空闲的To空间；而刚刚空闲的To空间在复制后则变成From空间</p><p><img src="https://s2.ax1x.com/2019/11/04/KzZPld.png" alt></p><p>该算法的缺点是，将新生代内存空间一分为二后，新生代中的内存使用变为原来的一半。</p><p>但是，其有一个显著的优点。该算法只复制存活的对象，并且存活时间短的存活对象只占所有新生代中对象的极少一部分，因此，复制效率就会极其高</p><p>这便是典型的以空间换时间策略的算法。</p><p>另外，如果一个新生代中的对象经过多次SC垃圾回收算法的复制仍然存在，那么v8将会认为该对象已经是存活时间较长的对象了，它已经不适合再呆在新生代内存空间中了，更加确切的说，该对象已经不再适合用SC算法来进行管理了。那么,v8就会将该对象移动到老生代内存空间中，采用新的垃圾回收算法进行管理</p><h4 id="老生代内存空间所使用的垃圾回收算法"><a href="#老生代内存空间所使用的垃圾回收算法" class="headerlink" title="老生代内存空间所使用的垃圾回收算法"></a>老生代内存空间所使用的垃圾回收算法</h4><p>由于老生代内存空间中的对象生存事件较长。因此，如果仍旧采用SC算法就会有明显的两个缺点：</p><ol><li>因为对象存活时间长，因此当该算法运行时，存活对象所占的比例极高，那么复制对象的效率就会明显很低</li><li>另外，就是要有一半的内存空间是空闲出来的，这样就会造成浪费</li></ol><p>因此，v8中采用Mark-Sweep（标记清除）&amp;Mark-Compact（标记整理）</p><h5 id="标记清除"><a href="#标记清除" class="headerlink" title="标记清除"></a>标记清除</h5><p>标记清除算法分为标记和清除两个阶段。</p><ol><li>标记阶段 遍历堆中的所有对象，将存活的对象进行标记</li><li>清除阶段 清除没有进行标记的对象</li></ol><p>可以看出，该算法只清理已经不再存活的对象。由于，在老生代内存空间中，死对象所占的比例较少，因此，清除死对象的方式会极其高效</p><p><img src="https://s2.ax1x.com/2019/11/04/KzKHSO.png" alt></p><p>我们可以看到，该算法将死对象清除后会造成内存空间的不连续，这也将会对后续的内存分配造成问题，因为，很可能后续会有一个需要较大的内存空间的对象要被分配，但是所有的碎片空间都无法满足此次分配，因此，就会提前触发垃圾回收机制并将该大内存空间的对象回收</p><p>为了解决这个问题，标记整理的算法就被提了出来</p><h5 id="标记整理"><a href="#标记整理" class="headerlink" title="标记整理"></a>标记整理</h5><p>标记整理算法是标记清除算法的改进版。</p><p>标记的过程还是一样的，区别在于清除过程，标记清除算法只是直接回收死对象的内存空间；</p><p>而标记整理算法是在整理过程中，将活着的对象往一端移动，那么当移动完成后，另一端就都是死的对象，因此，此时只要直接清除掉那一整块死掉的对象内存空间即可</p><p><img src="https://s2.ax1x.com/2019/11/04/Kz18BQ.jpg" alt></p><p><img src="https://s2.ax1x.com/2019/11/04/KzKblD.png" alt></p><h5 id="v8对于标记清除和标记整理算法的考虑"><a href="#v8对于标记清除和标记整理算法的考虑" class="headerlink" title="v8对于标记清除和标记整理算法的考虑"></a>v8对于标记清除和标记整理算法的考虑</h5><p>由于在标记整理中，v8需要将对象移动，因此它的执行速度就会相对比标记清除算法要慢。</p><p>因此，v8对于这两个算法是结合使用的。v8主要使用标记清除算法，只有当老生代内存空间不足以应对即将要分配的占用大内存空间对象的时候才会使用标记整理算法</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;内存管理简介&quot;&gt;&lt;a href=&quot;#内存管理简介&quot; class=&quot;headerlink&quot; title=&quot;内存管理简介&quot;&gt;&lt;/a&gt;内存管理简介&lt;/h2&gt;&lt;p&gt;来自于MDN的简介：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;像C语言这样的底层语言一般都有底层的内存管理接
      
    
    </summary>
    
      <category term="浏览器" scheme="http://yoursite.com/categories/%E6%B5%8F%E8%A7%88%E5%99%A8/"/>
    
    
  </entry>
  
  <entry>
    <title>node.js的事件循环机制</title>
    <link href="http://yoursite.com/2019/11/03/node-js%E7%9A%84%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF%E6%9C%BA%E5%88%B6/"/>
    <id>http://yoursite.com/2019/11/03/node-js的事件循环机制/</id>
    <published>2019-11-03T07:20:19.000Z</published>
    <updated>2019-11-04T07:05:17.830Z</updated>
    
    <content type="html"><![CDATA[<h2 id="什么是事件循环"><a href="#什么是事件循环" class="headerlink" title="什么是事件循环"></a>什么是事件循环</h2><p>之前，我们了解了浏览器中的事件循环机制。现在，我们来看一下Node中的事件循环机制。</p><p>来自于Node官网的解释：</p><blockquote><p>The event loop is what allows Node.js to perform non-blocking I/O operations — despite the fact that JavaScript is single-threaded — by offloading operations to the system kernel whenever possible.</p></blockquote><p>大致意思是，事件循环可以使Node.js通过将操作转移到系统内核中来执行非阻塞I / O操作（尽管JavaScript是单线程的）。</p><p>另外，我们需要知道，Node事件循环的概念与浏览器事件循环的概念类似，都是用来处理异步任务的。虽然异步任务必须要等到主线程执行堆栈中的任务执行完毕后才能被执行，但是，事件循环在进程启动的时候就会被创建。</p><h2 id="事件循环的流程"><a href="#事件循环的流程" class="headerlink" title="事件循环的流程"></a>事件循环的流程</h2><p>在进程启动时，Node便会创建一个类似于While(true)的循环，每执行一次循环体的过程我们称之为Tick。在每个Tick中，我们查看是否还有事件待处理，如果有，那么就取出该事件及其相关回调函数。如果存在关联的回调函数就执行它们。然后再进入下一个循环，如果不再有事件处理，那么就退出该循环。</p><p>流程图如下：</p><p><img src="https://s2.ax1x.com/2019/11/03/KXUgYR.png" alt></p><h2 id="事件循环的详细步骤"><a href="#事件循环的详细步骤" class="headerlink" title="事件循环的详细步骤"></a>事件循环的详细步骤</h2><p>每一个事件循环都会包含以下6个阶段</p><p><img src="https://s2.ax1x.com/2019/11/03/KXduKf.png" alt></p><p>每个阶段都有一个当前阶段要执行的回调FIFO（先进先出）队列。虽然每个阶段都有其自己的特殊方式，但是通常，当事件循环进入给定阶段时，它将执行该阶段特定的任何操作，然后在该阶段的队列中执行回调，直到队列用尽或回调的最大数量为止。当队列已用完或达到回调限制时，事件循环将移至下一个阶段，依此类推。</p><h3 id="阶段概述"><a href="#阶段概述" class="headerlink" title="阶段概述"></a>阶段概述</h3><ol><li><p>timers阶段：该阶段执行setTimeout和setInterval设定的回调函数</p></li><li><p>pending callbacks阶段： 此阶段执行某些系统操作的回调，例如TCP错误的类型。例如，如果ECONNREFUSED尝试连接时收到TCP套接字，则某些* nix系统希望等待报告错误。这将排队等待在挂起的回调阶段执行。</p></li><li><p>idle,prepare阶段：该阶段仅在内部使用，我们不用关心</p></li><li><p>poll阶段：</p><ol><li>检索新的I / O事件；</li><li>执行与I / O相关的回调（除了close回调，计时器安排的回调和setImmediate()的回调）；</li><li>适当时，Node将在此处阻塞。</li></ol></li><li><p>check阶段：执行setImmediate()设置的回调</p></li><li><p>close callbacks阶段： 一些监听事件结束的回调，例如socket.destroy()和socket.on(‘close’, callback)等等</p></li></ol><h3 id="需要详细说明的几个阶段"><a href="#需要详细说明的几个阶段" class="headerlink" title="需要详细说明的几个阶段"></a>需要详细说明的几个阶段</h3><h4 id="timers阶段"><a href="#timers阶段" class="headerlink" title="timers阶段"></a>timers阶段</h4><p>我们在阶段概述的时候就提到过，该阶段用来执行setTimeout和setInterval设定的回调函数。</p><p>我们也知道，Node无法保证在定时器设定的时间正好响应该回调函数。那个时间更准确地说来，应该是当Node监听到当前时间已经过了预期设定的事件，那么就将该回调函数放到主线程执行队列去等待执行。</p><p>另外，我们需要知道的是，从技术上来说，计时器的执行时间是由poll阶段来控制的（具体内容我们在poll阶段来详细说明）。</p><h4 id="poll阶段"><a href="#poll阶段" class="headerlink" title="poll阶段"></a>poll阶段</h4><p>poll阶段主要有2个功能：</p><ol><li>处理poll队列的事件的回调</li><li>当有已超时的timer（定时器），那么就转去timers阶段执行定时器设定的回调函数（这一个功能是有条件的，条件是此时的poll阶段必须为空闲状态，事件循环才会去查看当前是否有已超时的定时器。否则，事件循环会同步执行poll队列里的回调函数）</li></ol><p>以下为详细说明：</p><p>如果事件循环进入了poll阶段，并且当前代码中没有设定定时器，那么就会发生以下两种情况：</p><ul><li><p>如果poll队列不为空，那么事件循环将会同步执行poll队列里的回调函数直到清空队列或者执行的回调数量到达规定的上限</p></li><li><p>如果poll队列为空，那么事件循环就会去检查是否有设定setImmediate()</p><ol><li>如果设定了setImmediate()，那么事件循环将立刻结束当前的poll阶段，并转入下一个check阶段执行check阶段的队列中的回调（check阶段中的队列包含的是setImmediate()的回调）</li><li>如果没有设定setImmediate()，那么事件循环则会阻塞在该阶段等待回调加入队列中（其中阻塞是有超时时间的，当阻塞的时间超过超时时间，那么还未执行的回调只能在下一轮或更后面的事件循环中被执行）</li></ol></li></ul><p>一旦poll任务队列为空，那么事件循环将会检查timers，如果有一个或多个定时器准备就绪，那么事件循环将会离开当前阶段并进入下一轮事件循环，在timers阶段去执行timers任务队列中的回调</p><h4 id="check阶段"><a href="#check阶段" class="headerlink" title="check阶段"></a>check阶段</h4><p>setImmediate()的回调会被加入check队列中，然后当事件循环进入check阶段时同步执行队列中的回调</p><h5 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h5><p>事件循环的每个阶段都有对应的任务队列。当异步任务完成后，它们所对应的回调函数将会根据异步任务的类型进入相应的任务队列。例如：</p><ul><li>定时器任务的回调进入timers阶段的任务<br>队列</li><li>异步I/O的回调进入poll阶段的任务队列</li><li>setImmediate的回调进入chck阶段的任务队列</li></ul><p>另外，对于上述复杂的poll阶段的规则。</p><p>我们可以总结得到：</p><ul><li>如果事件循环进入poll阶段时有任务，那么同步执行完所有的回调；</li><li>如果没有，那么查看是否有setImmediate，<ol><li>如果有，那么离开poll阶段进入下一个check阶段；</li><li>如果没有，那么Node进入阻塞状态，同时不断检查Timers阶段任务队列是否有任务，<ul><li>如果有那么离开当前阶段去到Timers阶段执行回调；</li><li>如果没有，那么一直保持阻塞状态直到有异步I/O的回调加入任务队列或者设置的限制阻塞的超时时间已到</li></ul></li></ol></li></ul><p>简单来说: 能够退出poll阶段阻塞态的只有以下几种方式</p><ol><li>阻塞时间超过了设定的超时时间</li><li>在阻塞状态时检查到timers队列中有任务</li><li>设定了setImmediate</li></ol><p>说了那么多，我们来看一下一个例子，就应该较好地理解Node中的事件循环机制</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 程序开始时间</span></span><br><span class="line"><span class="keyword">let</span> startTime = <span class="built_in">Date</span>.now();</span><br><span class="line"></span><br><span class="line"><span class="comment">// Node中读取文件的异步API</span></span><br><span class="line">fs.readFile(<span class="string">'./a.js'</span>,<span class="string">'utf-8'</span>,(err,data)=&gt;&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'readFileTime'</span>,<span class="built_in">Date</span>.now()-startTime);</span><br><span class="line">    <span class="keyword">if</span>(err) <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'error'</span>);</span><br><span class="line">    <span class="keyword">return</span> data;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定时器</span></span><br><span class="line">setTimeout(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'timeout'</span>,<span class="built_in">Date</span>.now()-startTime);</span><br><span class="line">&#125;,<span class="number">50</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// setImmediate()</span></span><br><span class="line">setImmediate(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'immediate'</span>,<span class="built_in">Date</span>.now()-startTime);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>来看下输出结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">immediate 2</span><br><span class="line">readFileTime 10</span><br><span class="line">timeout 54</span><br></pre></td></tr></table></figure><h2 id="setTimeout与setImmediate"><a href="#setTimeout与setImmediate" class="headerlink" title="setTimeout与setImmediate"></a>setTimeout与setImmediate</h2><p>在上面我们已经知道了setTimeout设定的回调会在timers阶段被执行，而setImmediate设定的回调会在check阶段被执行。</p><p>那么，接下来我们来看一段程序：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">setTimeout(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'timeout'</span>);</span><br><span class="line">&#125;,<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">setImmediate(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'immediate'</span>);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>事实上，这段代码的运行结果不是唯一的。主要是两个输出语句的输出顺序是不一定的。</p><p>有可能是：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">timeout</span><br><span class="line">immediate</span><br></pre></td></tr></table></figure><p>但也有可能是</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">immediate</span><br><span class="line">timeout</span><br></pre></td></tr></table></figure><p>但是，如果我们在一次I/O中在运行调用setTimeout和setImmediate，我们会发现setImmediate的回调永远比setTimeout的回调先执行</p><p>例如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>);</span><br><span class="line"></span><br><span class="line">fs.readFile(<span class="string">'./a.js'</span>,<span class="string">'utf-8'</span>,()=&gt;&#123;</span><br><span class="line">    setTimeout(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'timeout'</span>);</span><br><span class="line">    &#125;,<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">    setImmediate(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'immediate'</span>);</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 输出结果</span></span><br><span class="line"><span class="comment">immediate</span></span><br><span class="line"><span class="comment">timeout</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>那么，这是为什么呢?</p><p>搬用cnode社区里的一个大神的回答</p><pre><code>在node中，setTimeout(cb, 0) === setTimeout(cb, 1);而setImmediately属于uv_run_check的部分确实每次loop进来，都是先检查uv_run_timer的，但是由于cpu工作耗费时间，比如第一次获取的hrtime为0那么setTimeout(cb, 1)，超时时间就是loop-&gt;time = 1(ms，node定时器精确到1ms，但是hrtime是精确到纳秒级别的)所以第一次loop进来的时候就有两种情况：1.由于第一次loop前的准备耗时超过1ms，当前的loop-&gt;time &gt;=1 ，则uv_run_timer生效，timeout先执行2.由于第一次loop前的准备耗时小于1ms，当前的loop-&gt;time = 0，则本次loop中的第一次uv_run_timer不生效，那么io_poll后先执行uv_run_check，即immediate先执行，然后等close cb执行完后，继续执行uv_run_timer那么你说的为什么在回调中，一定是先immediate执行呢，其实也很容易理解你可以思考一下你写的场景由于你的timeout和immediate的事件注册是在readFile的回调执行时，触发是必然的，在readFile的回调执行前的每一次event loop进来的uv_run_timer都不会有超时事件触发那么当readFile执行完毕，kevent收到监听的fd事件完成后，执行了该回调，此时1.timeout事件注册2.immediate事件注册3.由于readFile的回调执行完毕，那么就会从uv_io_poll中出来，此时立即执行uv_run_check，所以immediate事件被执行掉4.最后的uv_run_timer检查timeout事件，执行timeout事件所以你会发现，在I/O回调中注册的两者，永远都是immediately先执行</code></pre><p><a href="https://cnodejs.org/topic/57d68794cb6f605d360105bf" target="_blank" rel="noopener">这里是大神文章的链接：</a></p><h2 id="process-nextTick"><a href="#process-nextTick" class="headerlink" title="process.nextTick()"></a>process.nextTick()</h2><p>Node官方文档是这样解释process.nextTick()的：</p><blockquote><p>process.nextTick() 方法将 callback 添加到下一个时间点的队列。 在 JavaScript 堆栈上的当前操作运行完成之后以及允许事件循环继续之前，此队列会被完全耗尽。 如果要递归地调用 process.nextTick()，则可以创建无限的循环。</p></blockquote><p>这就意味着：</p><ol><li><p>如果，process.nextTick定义在事件循环机制开始前，而非事件循环机制中，那么，process.nextTick定义的回调函数将在主线程执行队列中的所有任务执行完毕后被调用</p><p> 例如：</p> <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">setTimeout(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'timeout'</span>);</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">process.nextTick(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'tick'</span>);</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">setImmediate(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'immediate'</span>);</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 输出结果</span></span><br><span class="line"><span class="comment">1</span></span><br><span class="line"><span class="comment">2</span></span><br><span class="line"><span class="comment">tick</span></span><br><span class="line"><span class="comment">// 注意：timeout和Immediate的输出顺序是不一定的，原因在前文已经提过</span></span><br><span class="line"><span class="comment">timeout</span></span><br><span class="line"><span class="comment">immediate</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure></li><li><p>如果process.nextTick()在事件循环中被定义，那么process.nextTick定义的回调函数将会在下一个事件循环的阶段开始前被执行，也就是两个阶段切换时的中间过程</p><p> 来看一个例子：</p> <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>);</span><br><span class="line"></span><br><span class="line">fs.readFile(<span class="string">'./a.js'</span>,<span class="string">'utf-8'</span>,()=&gt;&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">1</span>);</span><br><span class="line">    setTimeout(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'timeout'</span>);</span><br><span class="line">    &#125;,<span class="number">0</span>)</span><br><span class="line">    setImmediate(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'immediate'</span>);</span><br><span class="line">    &#125;)</span><br><span class="line">    process.nextTick(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'tick1'</span>);</span><br><span class="line">    &#125;)</span><br><span class="line">    process.nextTick(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'tick2'</span>);</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 输出结果</span></span><br><span class="line"><span class="comment">1</span></span><br><span class="line"><span class="comment">tick1</span></span><br><span class="line"><span class="comment">tick2</span></span><br><span class="line"><span class="comment">immediate</span></span><br><span class="line"><span class="comment">timeout</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p> 当异步读取完文件后，此时位于poll阶段，执行回调函数，该回调函数设定了一个setTimeout，一个setImmediate，两个process.nextTick。加下来事件循环开始离开poll阶段，在从poll阶段切换到check阶段的中间，两个process.nextTick设定的回调函数将会被执行。接着，转换到check阶段执行setImmediate设定的回调函数。最后，在下一轮事件循环中执行setTimeout设定的回调函数。</p></li><li><p>如果process.nextTick()定义在某个阶段中要同步的执行当前队列的所有回调函数内部时，根据，官方文档的说明，在 JavaScript 执行堆栈上的当前操作运行完成之后以及允许事件循环继续之前，process.nextTick将会被执行</p></li></ol><p>例如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">setImmediate(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'immediate1'</span>);</span><br><span class="line">    process.nextTick(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'tick强势插入'</span>);</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">setImmediate(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'immediate2'</span>);</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 输出结果</span></span><br><span class="line"><span class="comment">immediate1</span></span><br><span class="line"><span class="comment">tick强势插入</span></span><br><span class="line"><span class="comment">immediate2</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>在事件循环机制中，此时位于check阶段，事件循环机制将按照同步的方式依次将setImmediate的回调函数放入主线程的执行堆栈中进行运行。但是第一个setImmediate的回调函数执行时又注册了process.nextTick()。因此，在事件循环机制继续运行（将下一个setImmediate回调放入主线程执行堆栈中进行执行）前，process.nextTick就优先被执行</p><p>另外，需要尤其注意的是，process.nextTick的回调一旦执行，必须要直到nextTick队列被清空，才会进入到下一个事件阶段，所以如果递归调用 process.nextTick()，会导致出现I/O starving（饥饿）的问题</p><p>例如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> index = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">let</span> startTime = <span class="built_in">Date</span>.now();</span><br><span class="line"></span><br><span class="line">fs.readFile(<span class="string">'./a.js'</span>,<span class="string">'utf-8'</span>,()=&gt;&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'File is readed'</span>);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`Time wasted <span class="subst">$&#123;<span class="built_in">Date</span>.now()-startTime&#125;</span>`</span>);</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">handle</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(index &gt; <span class="number">1000</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`tick <span class="subst">$&#123;index&#125;</span>`</span>);</span><br><span class="line">    index++;</span><br><span class="line">    process.nextTick(handle);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">handle();</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 输出结果</span></span><br><span class="line"><span class="comment">tick 0</span></span><br><span class="line"><span class="comment">tick 1</span></span><br><span class="line"><span class="comment">tick 2</span></span><br><span class="line"><span class="comment">...</span></span><br><span class="line"><span class="comment">...</span></span><br><span class="line"><span class="comment">tick 1000</span></span><br><span class="line"><span class="comment">File is readed</span></span><br><span class="line"><span class="comment">Time wasted 495</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>我们发现，在上述程序中，只有当process.nextTick()全部执行完毕后，fs。readFile()注册的回调函数才会被执行</p><h3 id="process-nextTick-与setImmediate"><a href="#process-nextTick-与setImmediate" class="headerlink" title="process.nextTick()与setImmediate()"></a>process.nextTick()与setImmediate()</h3><p>我们在前面已经分别介绍过了process.nextTick()与setImmediate()注册的回调函数的执行时机。</p><p>因此，如果，process.nextTick()与setImmediate()同时被注册，那么process.nextTick的优先级要高于setImmediate</p><p>例如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">setImmediate(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'immediate'</span>);</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">process.nextTick(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'tick'</span>);</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 输出结果</span></span><br><span class="line"><span class="comment">tick</span></span><br><span class="line"><span class="comment">immediate</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>其实，这段代码在上面的叙述中已经提过。那么，为什么还要将它们俩放在一起比较呢？</p><p>其实，是因为我们提到，process.nextTick()一旦执行就会将当前所有的nextTick()注册的回调执行完后才会进入下一个事件阶段，因此，很容易造成I/O饥饿现象</p><p>而setImmediate则会改变这种现象。因为，在事件循环中，每次在check阶段每个setImmedaite任务只会执行一次setImmediate的回调，如果回调里还有setImmediate任务，那么它将会在下一轮事件循环中执行</p><p>例如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>);</span><br><span class="line"></span><br><span class="line">fs.readFile(<span class="string">'./a.js'</span>,<span class="string">'utf-8'</span>,()=&gt;&#123;</span><br><span class="line">    setImmediate(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'immediate1'</span>);</span><br><span class="line">        setImmediate(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">'immediate2'</span>);</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">    setTimeout(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'timeout2'</span>);</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 输出结果</span></span><br><span class="line"><span class="comment">immediate1</span></span><br><span class="line"><span class="comment">timeout2</span></span><br><span class="line"><span class="comment">immediate2</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>我们可以看到,setImmediate第一个回调执行完毕后并没有立刻执行第二个setImmediate回调，而是进入了下一轮事件循环，先在timers阶段执行了setTimeout的回调，然后再在check阶段执行第二个setImmediate的回调。</p><p>因此，在解决多次调用process.nextTick所具有的的I/O饥饿问题，我们可以使用setImmediate来解决</p><p>下面的程序只是将上面的程序中的process.nextTick替换成setImmediate</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> index = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">let</span> startTime = <span class="built_in">Date</span>.now();</span><br><span class="line"></span><br><span class="line">fs.readFile(<span class="string">'./a.js'</span>,<span class="string">'utf-8'</span>,()=&gt;&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'File is readed'</span>);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`Time wasted <span class="subst">$&#123;<span class="built_in">Date</span>.now()-startTime&#125;</span>`</span>);</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">handle</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(index &gt; <span class="number">100</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`tick <span class="subst">$&#123;index&#125;</span>`</span>);</span><br><span class="line">    index++;</span><br><span class="line">    setImmediate(handle);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">handle();</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 输出结果</span></span><br><span class="line"><span class="comment">tick 0</span></span><br><span class="line"><span class="comment">tick 1</span></span><br><span class="line"><span class="comment">...</span></span><br><span class="line"><span class="comment">tick 7</span></span><br><span class="line"><span class="comment">File is readed</span></span><br><span class="line"><span class="comment">Time wasted 12</span></span><br><span class="line"><span class="comment">tick 8</span></span><br><span class="line"><span class="comment">tick 9</span></span><br><span class="line"><span class="comment">...</span></span><br><span class="line"><span class="comment">...</span></span><br><span class="line"><span class="comment">tick 100</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>我们可以看到,fs.readFile()的回调再setImmediate的递归中进行了输出，而不是等所有递归结束后再被执行。</p><p>我们来解释一下其中的原因：</p><ol><li>执行fs.readFile异步任务和handle()函数，同时输出tick 0</li><li>第一次事件循环，此时在poll阶段并没有得等到readFile的回调加入任务队列，而此时setImmediate函数被注册，那么立即离开poll阶段</li><li>进入check阶段，执行setImmediate注册的回调函数，在该程序中也就是再执行一遍，此时输出tick 1，但是，在该回调函数中又注册了一个setTimeout，但是该setTimeout并不会立即执行，而是等到下一轮事件循环中执行</li><li>…中途经过了几轮的事件循环，在这几轮中，pool阶段始终没有等到readFile的回调，因此，在check阶段一直输出到了tick 7</li><li>在这轮事件循环中，在poll阶段的任务队列中终于有了readFile()的回调，那么立即执行该回调，输出<blockquote><p>File is readed<br> Time wasted 12</p></blockquote></li><li>继续多轮事件循环，一直到退出handle()递归</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;什么是事件循环&quot;&gt;&lt;a href=&quot;#什么是事件循环&quot; class=&quot;headerlink&quot; title=&quot;什么是事件循环&quot;&gt;&lt;/a&gt;什么是事件循环&lt;/h2&gt;&lt;p&gt;之前，我们了解了浏览器中的事件循环机制。现在，我们来看一下Node中的事件循环机制。&lt;/p&gt;
&lt;p&gt;
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>深入了解Node的异步I/O</title>
    <link href="http://yoursite.com/2019/11/01/%E6%B7%B1%E5%85%A5%E4%BA%86%E8%A7%A3Node%E7%9A%84%E5%BC%82%E6%AD%A5I-O/"/>
    <id>http://yoursite.com/2019/11/01/深入了解Node的异步I-O/</id>
    <published>2019-11-01T06:35:42.000Z</published>
    <updated>2019-11-04T07:05:17.830Z</updated>
    
    <content type="html"><![CDATA[<h2 id="I-O"><a href="#I-O" class="headerlink" title="I/O"></a>I/O</h2><h3 id="什么是I-O"><a href="#什么是I-O" class="headerlink" title="什么是I/O"></a>什么是I/O</h3><blockquote><p>I/O（英语：Input/Output），即输入/输出，通常指数据在内部存储器和外部存储器或其他周边设备之间的输入和输出。</p></blockquote><p>另外，I/O又可以具体分为磁盘I/O和网络I/O。</p><p>它们一般具有以下两个步骤：</p><ol><li>等待数据准备 </li><li>将数据从内核拷贝到进程中</li></ol><p>对于一般的I/O读操作，我们可以进行以下的抽象：</p><ol><li>应用发起read系统调用</li><li>操作系统层面接受应用的请求，如果内核缓冲区中有该数据，那么将该数据拷贝到用户缓存区</li><li>如果内核缓存区中没有数据，那么内核会向io模块发送请求，让其从磁盘中读取数据。读取完毕后，将其存入内核缓存区，并拷贝到用户缓存区</li></ol><p><img src="https://s2.ax1x.com/2019/11/03/KOXjrq.jpg" alt></p><p>总结：</p><ol><li><p>当应用程序调用read接口时，操作系统检查在内核的高速缓存有没有需要的数据，如果已经缓存了，那么就直接从缓存中返回，如果没有，则从磁盘中读取，然后缓存在操作系统的缓存中。</p></li><li><p>应用程序调用write接口时，将数据从用户地址空间复制到内核地址空间的缓存中，这时对用户程序来说，写操作已经完成，至于什么时候再写到磁盘中，由操作系统决定，除非显示调用了sync同步命令</p></li></ol><h3 id="PIO与DMA"><a href="#PIO与DMA" class="headerlink" title="PIO与DMA"></a>PIO与DMA</h3><p>有必要提一下PIO与DMA两种I/O方式</p><ol><li><p>PIO<br>我们拿磁盘来说，很早以前，磁盘和内存之间的数据传输是需要CPU控制的，也就是说如果我们读取磁盘文件到内存中，数据要经过CPU存储转发，这种方式称为PIO。显然这种方式非常不合理，需要占用大量的CPU时间来读取文件，造成文件访问时系统几乎停止响应。</p></li><li><p>DMA<br>后来，DMA（直接内存访问，Direct Memory Access）取代了PIO，它可以不经过CPU而直接进行磁盘和内存的数据交换。在DMA模式下，CPU只需要向DMA控制器下达指令，让DMA控制器来处理数据的传送即可，DMA控制器通过系统总线来传输数据，传送完毕再通知CPU，这样就在很大程度上降低了CPU占有率，大大节省了系统资源，而它的传输速度与PIO的差异其实并不十分明显，因为这主要取决于慢速设备的速度。</p></li></ol><p>因此，在这里我们树立一个概念，现在的I/O操作在读写的过程中是不需要经过CPU进行处理的。</p><h2 id="异步与非阻塞，同步与阻塞是同一个概念吗"><a href="#异步与非阻塞，同步与阻塞是同一个概念吗" class="headerlink" title="异步与非阻塞，同步与阻塞是同一个概念吗"></a>异步与非阻塞，同步与阻塞是同一个概念吗</h2><p>在Node的文章中，我们经常可以看到异步，非阻塞；同步，阻塞这些概念。听起来，异步与非阻塞像是同一个概念，而且他们实现的效果好像是一样的。但是，实际上它们是两回事。</p><p>对于阻塞与非阻塞我们可以这样理解：</p><blockquote><p>阻塞和非阻塞关注的是程序在等待调用结果（消息，返回值）时的状态.阻塞调用是指调用结果返回之前，当前线程会被挂起。调用线程只有在得到结果之后才会返回。非阻塞调用指在不能立刻得到结果之前，该调用不会阻塞当前线程。</p></blockquote><p>而对于异步与同步：</p><blockquote><p>同步和异步关注的是消息通信机制。所谓同步，就是在发出一个调用时，在没有得到结果之前，该调用就不返回。但是一旦调用返回，就得到返回值了。换句话说，就是由调用者*动等待这个调用的结果。而异步则是相反，调用在发出之后，这个调用就直接返回了，当然不会有返回结果。换句话说，当一个异步过程调用发出后，调用者不会立刻得到结果。而是在调用发出后，被调用者通过状态、通知来通知调用者，或通过回调函数处理这个调用。</p></blockquote><p>总结来说：</p><ol><li>阻塞与非阻塞更多的考虑是对于自身的线程。阻塞即线程挂起等待结果返回；而非阻塞就是该线程继续往下执行，但是不会立即得到等待结果。我们只有通过轮询机制才能得到结果</li><li>同步与异步更多的是考虑双方的状态。例如，应用层向服务端发起一个请求，如果是同步请求，那么只有服务端得到结果之后才可以返回；而如果是异步请求，那么调用就直接返回，经过一定时间后，服务端的数据已经处理完毕，然后通过回调机制来通知应用层结果已经返回</li></ol><h2 id="Node的异步I-O"><a href="#Node的异步I-O" class="headerlink" title="Node的异步I/O"></a>Node的异步I/O</h2><h3 id="事件循环"><a href="#事件循环" class="headerlink" title="事件循环"></a>事件循环</h3><p>在这里可以去查看另一篇文章</p><h3 id="观察者"><a href="#观察者" class="headerlink" title="观察者"></a>观察者</h3><p>在每次事件循环中，Node如何判断是否有新的事件需要处理呢？</p><p>Node引入观察者来实现是否有事件需要处理的判断。每个事件循环中都会有1个或多个观察者，而判断是否有事件需要处理的过程就是向这些观察者询问是否有要处理的事件。</p><p>在Node中，事件主要来源于网络请求、文件I/O等，这些事件的对应观察者即网络I/O观察者，文件I/O观察者。</p><p>另外，事件循环是典型的生产者/消费者模型。异步I/O、网络请求等则是生产者，源源不断为Node提供不同类型的事件，这些事件会被传递到对应的观察者那里，然后事件循环则会从观察者那里取出事件并进行处理</p><h3 id="异步I-O的整体流程"><a href="#异步I-O的整体流程" class="headerlink" title="异步I/O的整体流程"></a>异步I/O的整体流程</h3><p>我们以fs.open()方法为例来探究以下异步I/O的整体流程。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>);</span><br><span class="line"></span><br><span class="line">fs.open(path,flags,mode,callback);</span><br></pre></td></tr></table></figure><p>fs.open()的作用是根据指定的路径和参数去打开一个文件，从而得到一个文件描述符。</p><h4 id="异步调用的第一个阶段"><a href="#异步调用的第一个阶段" class="headerlink" title="异步调用的第一个阶段"></a>异步调用的第一个阶段</h4><p>当Node调用fs.open()核心模块后，该核心模块将会去调用C++内建模块。然后通过libuv这一层为不同的平台（windows和*nix）调用分别系统级底层函数。</p><p><img src="https://s2.ax1x.com/2019/11/04/KvItQx.png" alt></p><p>在系统级底层函数uv_fs_open()的调用过程中，会创建一个FSReqWrap的请求对象，所有传递给js核心模块fs.open()的参数和回调方法都被作为该对象的属性被其封装。例如，回调函数会被设置在这个对象的oncomplete_sym上：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">req_wrap-&gt;object_-&gt;Set(oncomplete_sym,callback);</span><br></pre></td></tr></table></figure><p>请求对象包装完毕后，则会将该请求对象推入线程池中去等待执行。</p><p>至此，Js调用立即返回，有Js层面发起的异步调用的第一阶段到这里就结束了。Js主线程可以继续去执行其余任务，当前的I/O操作则会在线程池中等待执行，不管线程池中的该I/O线程是否阻塞，都不会影响Js主线程的后续执行，因此，异步就这样实现了。</p><h4 id="异步调用的第二个阶段"><a href="#异步调用的第二个阶段" class="headerlink" title="异步调用的第二个阶段"></a>异步调用的第二个阶段</h4><blockquote><p>回调通知则是异步调用的第二个阶段。</p></blockquote><p>当线程池中的I/O线程完成工作后，会将获取的结果储存在第一阶段定义的请求对象的req-&gt;result属性上，然后会通知IOCP（windows实现的异步I/O方案），告知当前对象操作已经完成，然后将线程归还线程池。</p><p>到这里，整个异步I/O的流程并没有结束。</p><p>事件循环中的I/O观察者将会在每次事件循环中去检查请求是否执行完成，如果执行完毕，那么就会取出请求对象的rq-&gt;result属性作为参数，取出oncomplete_sym属性作为方法，然后进行调用执行，以此来达到调用Js中传入的回调函数的目的。</p><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>至此，整个异步I/O的流程完全结束，流程图如下：</p><p><img src="https://s2.ax1x.com/2019/11/04/KvINy6.png" alt></p><p>简单来说，Node的异步I/O流程可以分为以下几步：</p><p>异步调用</p><ol><li>应用层发起异步调用，Node会从调用核心模块到内建模块一直到调用到底层系统级函数</li><li>将应用层传入的参数和回调封装给一个请求对象</li><li>将请求对象放入线程池等待执行</li><li>应用层发起的异步调用结束，立即返回</li></ol><p>线程池</p><ol><li>分配空闲线程来执行请求对象中的I/O操作</li><li>I/O线程执行完毕，将执行完毕的结果储存在请求对象中</li><li>在windows下通知IOCP已经执行完毕，然后归还该I/O线程</li></ol><p>事件循环</p><ol><li>事件循环中的I/O观察者观察到事件已完成，将该事件的回调推入任务队列中</li><li>取出回调函数和请求对象中的结果进行调用执行</li></ol><h2 id="事件驱动"><a href="#事件驱动" class="headerlink" title="事件驱动"></a>事件驱动</h2><p>Node中的事件驱动就是通过不断地进行事件循环然后当事件来临时进行触发的机制。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;I-O&quot;&gt;&lt;a href=&quot;#I-O&quot; class=&quot;headerlink&quot; title=&quot;I/O&quot;&gt;&lt;/a&gt;I/O&lt;/h2&gt;&lt;h3 id=&quot;什么是I-O&quot;&gt;&lt;a href=&quot;#什么是I-O&quot; class=&quot;headerlink&quot; title=&quot;什么是I/O&quot;&gt;&lt;
      
    
    </summary>
    
      <category term="Node" scheme="http://yoursite.com/categories/Node/"/>
    
    
  </entry>
  
  <entry>
    <title>浏览器渲染机制</title>
    <link href="http://yoursite.com/2019/10/29/%E6%B5%8F%E8%A7%88%E5%99%A8%E6%B8%B2%E6%9F%93%E6%9C%BA%E5%88%B6/"/>
    <id>http://yoursite.com/2019/10/29/浏览器渲染机制/</id>
    <published>2019-10-29T06:58:30.000Z</published>
    <updated>2019-10-29T12:58:26.581Z</updated>
    
    <content type="html"><![CDATA[<h2 id="浏览器渲染步骤"><a href="#浏览器渲染步骤" class="headerlink" title="浏览器渲染步骤"></a>浏览器渲染步骤</h2><p>浏览器的渲染机制一般分为以下几步：</p><ol><li>处理HTML并构建DOM树</li><li>处理CSS构建CSSOM树</li><li>将DOM和CSSOM合并生成Render Tree（渲染树）</li><li>根据渲染树计算节点的位置进行布局</li><li>通过显卡将画面绘制到屏幕上</li></ol><p>一个整体的流程图<br><img src="https://s2.ax1x.com/2019/10/29/KfV1eS.jpg" alt></p><h2 id="DOM树与CSSOM树的生成过程"><a href="#DOM树与CSSOM树的生成过程" class="headerlink" title="DOM树与CSSOM树的生成过程"></a>DOM树与CSSOM树的生成过程</h2><p>DOM树的生成过程（CSSOM树与之类似）：</p><ol><li>转换：浏览器从磁盘或网络上读取HTML的原始字节，并根据文件的指定编码（例如UTF-8）将它们转换为单个字符。</li><li>标记化：浏览器将字符串转换为W3C HTML5标准指定的不同标记；例如“ <html>”，“ <body>”以及尖括号内的其他字符串。每个令牌都有特殊的含义和自己的规则集。</body></html></li><li>节点生成：发出的令牌被转换为“对象”，以定义其属性和规则。</li><li>DOM构造：最后，由于HTML标记定义了不同标记之间的关系（某些标记包含在其他标记中），因此创建的对象以树形数据结构链接，该树数据结构还捕获了原始标记中定义的父子关系：HTML 对象是body对象的父对象，body是段落对象的父 对象，依此类推。</li></ol><p>DOM树示例</p><p><img src="https://s2.ax1x.com/2019/10/29/KRQVC4.png" alt></p><p>CSSOM树示例</p><p><img src="https://s2.ax1x.com/2019/10/29/KRQZ8J.png" alt></p><h2 id="Render-Tree（渲染树）"><a href="#Render-Tree（渲染树）" class="headerlink" title="Render Tree（渲染树）"></a>Render Tree（渲染树）</h2><p>在上面，我们得到了描述页面内容的DOM树和描述页面样式的CSSOM。接下来，我们就得需要将两者进行结合生成Render Tree</p><h3 id="渲染树的生成和渲染步骤"><a href="#渲染树的生成和渲染步骤" class="headerlink" title="渲染树的生成和渲染步骤"></a>渲染树的生成和渲染步骤</h3><ol><li><p>将DOM和CSSOM树合并以形成渲染树</p><pre><code>渲染树的生成步骤：1. 从DOM树的根节点开始，采取深度优先遍历的方式（也就是说当前节点的所有子节点都构建好后才会去构建当前节点的下一个兄弟节点）来遍历每一个可见节点&gt; 什么是不可见节点：     1. 一些节点不可见（例如，脚本标记，元标记等），由于它们未反映在渲染的输出中，因此将其省略。    2. 一些节点通过CSS隐藏，并且在渲染树中也被省略；例如，将一个节点设置了“ display：none”属性。（但是设置visibility: hidden就会将该CSSOM节点和属性添加到渲染树中）2. 对于每个可见节点，找到匹配CSSOM规则并应用它们。3. 生成具有内容及其计算样式的可见节点。</code></pre></li><li><p>布局：在生成的渲染树中，我们已经可以得知了那些节点是可见的，并且该节点的样式也是已知的。接下来我们需要计算它们在设备视口中的确切位置和大小，这就是“布局”阶段，也称为“重排”。 </p></li><li><p>将各个节点绘制到屏幕上</p></li></ol><p><img src="https://s2.ax1x.com/2019/10/29/KRwEmF.png" alt></p><p>需要注意的是：</p><blockquote><p>Render Tree与DOM树不一定是相同的。虽然，Renter Tree是按照DOM树的节点进行遍历生成的。但是，我们要记住，Render Tree中的所有节点都是可见节点（我们在前面已经提到过什么是不可见节点）。</p></blockquote><h2 id="阻塞渲染"><a href="#阻塞渲染" class="headerlink" title="阻塞渲染"></a>阻塞渲染</h2><p>我们知道HTML会阻塞渲染树的渲染，因为要是没有DOM，渲染树就无法渲染任何内容。那么对于css和JS呢？它们阻塞渲染吗？</p><p>掘金站点的html文档耗时情况<br><img src="https://s2.ax1x.com/2019/10/29/KfZ5j0.png" alt></p><p>我们可以看到阻塞了150ms</p><h3 id="css阻塞渲染"><a href="#css阻塞渲染" class="headerlink" title="css阻塞渲染"></a>css阻塞渲染</h3><p>在默认的情况下，css是阻塞渲染的。</p><p>我们在html文档里引入一个css文件，然后查看一下渲染过程，我们可以看到该css文件是阻塞的</p><p>在构建 CSSOM 树时，会阻塞渲染，直至 CSSOM 树构建完成。并且构建 CSSOM 树是一个十分消耗性能的过程，所以应该尽量保证层级扁平，减少过度层叠，越是具体的 CSS 选择器，执行速度越慢。</p><p><img src="https://s2.ax1x.com/2019/10/29/KRwkOU.png" alt></p><h3 id="js文件阻塞渲染"><a href="#js文件阻塞渲染" class="headerlink" title="js文件阻塞渲染"></a>js文件阻塞渲染</h3><blockquote><p>除非明确声明为异步，否则JavaScript会阻止DOM构建</p></blockquote><h4 id="非异步脚本"><a href="#非异步脚本" class="headerlink" title="非异步脚本"></a>非异步脚本</h4><p>无论我们使用的是&lt;script&gt;内联形式的代码块还是引入外部文件，浏览器都会暂停并执行js脚本，然后才能处理文档的其余部分。</p><p>另外，在使用外部JavaScript文件的情况下，浏览器必须暂停以等待从磁盘，缓存或远程服务器中获取脚本，这可能会增加关键渲染路径的数十到数千毫秒的延迟。</p><p>我们来试验一下：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">head</span>&gt;</span><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span> <span class="attr">src</span>=<span class="string">"./a.js"</span>&gt;</span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span></span><br></pre></td></tr></table></figure><p>结果</p><p><img src="https://s2.ax1x.com/2019/10/29/KRwVw4.png" alt></p><h4 id="异步脚本"><a href="#异步脚本" class="headerlink" title="异步脚本"></a>异步脚本</h4><p>HTML5为script元素定义了async属性。该属性可以让js文件异步加载。</p><blockquote><p>async只适用于外部脚本文件</p></blockquote><p>指定async属性的目的是不让页面等待脚本下载和执行，从而异步加载页面其他内容。因此，异步脚本不要在加载期间修改DOM</p><p>另外，异步脚本一定会在页面的load事件前执行。</p><p>来看一下加上async属性，该js脚本是否回阻塞后面的执行：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">head</span>&gt;</span><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">script</span> <span class="attr">async</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span> <span class="attr">src</span>=<span class="string">"./a.js"</span>&gt;</span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span></span><br></pre></td></tr></table></figure><p>结果</p><p><img src="https://s2.ax1x.com/2019/10/29/KRwZTJ.png" alt></p><h2 id="重绘与回流"><a href="#重绘与回流" class="headerlink" title="重绘与回流"></a>重绘与回流</h2><p>重绘与回流的基本概念</p><ol><li><p>当Render Tree中部分或全部元素的尺寸、结构、或某些属性发生改变时，浏览器重新渲染部分或全部文档的过程称为回流。</p></li><li><p>当页面中元素样式的改变并不影响它在文档流中的位置时（例如：color、background-color、visibility等），浏览器会将新样式赋予给元素并重新绘制它，这个过程称为重绘。</p></li></ol><p>由此我们可以得出一个结论：</p><blockquote><p>回流必定会发生重绘，重绘不一定会引发回流。</p></blockquote><p>我们来看一下回流具体发生的场景：</p><ol><li><p>添加或者删除可见的DOM元素；</p></li><li><p>元素位置改变；</p></li><li><p>元素尺寸改变——边距、填充、边框、宽度和高度</p></li><li><p>内容改变——比如文本改变或者图片大小改变而引起的计算值宽度和高度改变；</p></li><li><p>页面渲染初始化；</p></li><li><p>浏览器窗口尺寸改变——resize事件发生时；</p></li><li><p>查询或调用一些会引起回流的属性</p><pre><code>clientWidth、clientHeight、clientTop、clientLeftoffsetWidth、offsetHeight、offsetTop、offsetLeftscrollWidth、scrollHeight、scrollTop、scrollLeftscrollIntoView()、scrollIntoViewIfNeeded()getComputedStyle()getBoundingClientRect()scrollTo()</code></pre></li></ol><h3 id="重绘与回流的开销"><a href="#重绘与回流的开销" class="headerlink" title="重绘与回流的开销"></a>重绘与回流的开销</h3><blockquote><p>回流比重绘的开销要更大。</p></blockquote><p>另外，回流的开销也会因为操作的不同而有可能相差很大</p><p>假如，我们直接操纵body，并且在body前插入一个元素，那么整个Render Tree都会被重新构建</p><p>而如果只是在Render Tree的叶子节点后插入一个节点，那么前面的所有节点都不会影响。因此，开销会比上一个回流的开销小得多。</p><h3 id="减少重绘与回流（性能提高）"><a href="#减少重绘与回流（性能提高）" class="headerlink" title="减少重绘与回流（性能提高）"></a>减少重绘与回流（性能提高）</h3><h4 id="对于css"><a href="#对于css" class="headerlink" title="对于css"></a>对于css</h4><ol><li><p>避免使用table布局。 由于浏览器使用流式布局，对Render Tree的计算通常只需要遍历一次就可以完成，但table及其内部元素除外，他们可能需要多次计算，通常要花3倍于同等元素的时间。</p></li><li><p>使用 visibility：0 替换 display: none ，因为前者只会引起重绘，后者会引发回流（改变了布局–渲染树不会生成该节点）</p></li><li><p>CSS 选择符从右往左匹配查找，避免 DOM 深度过深</p></li><li><p>避免使用CSS表达式（例如：calc()）</p></li></ol><h4 id="对于js"><a href="#对于js" class="headerlink" title="对于js"></a>对于js</h4><ol><li><p>避免频繁操作样式，最好一次性重写style属性，或者将样式列表定义为class并一次性更改class属性。</p></li><li><p>避免频繁操作DOM，创建一个documentFragment，在它上面应用所有DOM操作，最后再把它添加到文档中。</p></li><li><p>避免频繁读取会引发回流/重绘的属性，如果确实需要多次使用，就用一个变量缓存起来。</p></li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++) &#123;</span><br><span class="line">    <span class="comment">// 获取 offsetTop 会导致回流，因为需要去获取正确的值</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">document</span>.querySelector(<span class="string">'.test'</span>).style.offsetTop)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="4"><li>也可以先为元素设置display: none，操作结束后再把它显示出来。因为在display属性为none的元素上进行的DOM操作不会引发回流和重绘（因为将display属性设置为none的节点为不可见节点，不可见节点不会被添加到渲染树中）。</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;浏览器渲染步骤&quot;&gt;&lt;a href=&quot;#浏览器渲染步骤&quot; class=&quot;headerlink&quot; title=&quot;浏览器渲染步骤&quot;&gt;&lt;/a&gt;浏览器渲染步骤&lt;/h2&gt;&lt;p&gt;浏览器的渲染机制一般分为以下几步：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;处理HTML并构建DOM树&lt;/li&gt;

      
    
    </summary>
    
      <category term="浏览器" scheme="http://yoursite.com/categories/%E6%B5%8F%E8%A7%88%E5%99%A8/"/>
    
    
  </entry>
  
  <entry>
    <title>循环中的async与await处理</title>
    <link href="http://yoursite.com/2019/10/28/%E5%BE%AA%E7%8E%AF%E4%B8%AD%E7%9A%84async%E4%B8%8Eawait%E5%A4%84%E7%90%86/"/>
    <id>http://yoursite.com/2019/10/28/循环中的async与await处理/</id>
    <published>2019-10-28T10:18:25.000Z</published>
    <updated>2019-10-28T14:30:38.717Z</updated>
    
    <content type="html"><![CDATA[<h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p>之前在做项目的时候，遇到一个场景：</p><p>给定了一个数组类似于这样：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">    &#123;</span><br><span class="line">        hallId: <span class="number">1</span></span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">        hallId: <span class="number">2</span></span><br><span class="line">    &#125;,</span><br><span class="line">    ...</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>需求是这样的，我们需要遍历整个数组，获得每个对象中的hallId值，再通过该ID值请求某接口得到hallName，再将该hallName存入对象</p><p>结果类似于这样</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">    &#123;</span><br><span class="line">        hallId: <span class="number">1</span>,</span><br><span class="line">        hallName: <span class="string">'1号'</span></span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">        hallId: <span class="number">2</span>,</span><br><span class="line">        hallName: <span class="string">'2号'</span></span><br><span class="line">    &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>然后就遇到了循环中使用async和await遇到的一些问题，以下就是探究的过程</p><h2 id="前期准备"><a href="#前期准备" class="headerlink" title="前期准备"></a>前期准备</h2><p>我们首先准备要获取的数据</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> ha = [</span><br><span class="line">    &#123;</span><br><span class="line">        hallId: <span class="number">1</span></span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">        hallId: <span class="number">2</span></span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">        hallId: <span class="number">3</span></span><br><span class="line">    &#125;</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> hall = [</span><br><span class="line">    &#123;</span><br><span class="line">        hallId: <span class="number">1</span>,</span><br><span class="line">        hallName: <span class="string">'1号'</span></span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">        hallId: <span class="number">2</span>,</span><br><span class="line">        hallName: <span class="string">'2号'</span></span><br><span class="line">    &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">        hallId: <span class="number">3</span>,</span><br><span class="line">        hallName: <span class="string">'3号'</span></span><br><span class="line">    &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>以及使用setTimeout来模拟异步请求</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getHallName</span>(<span class="params">id</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve,reject</span>)=&gt;</span>&#123;</span><br><span class="line">        setTimeout(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">let</span> v of hall) &#123;</span><br><span class="line">                <span class="keyword">if</span>(v.hallId===id) &#123;</span><br><span class="line">                    resolve(v.hallName);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,<span class="number">1000</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="for循环中使用await"><a href="#for循环中使用await" class="headerlink" title="for循环中使用await"></a>for循环中使用await</h2><p>我们首先来看下在for循环中使用await</p><p>我们可以很自然地写出以下异步函数：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> v of ha) &#123;</span><br><span class="line">        <span class="keyword">let</span> value = <span class="keyword">await</span> getHallName(v.hallId);</span><br><span class="line">        <span class="built_in">console</span>.log(value);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">test();</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 执行结果</span></span><br><span class="line"><span class="comment">// 等待1000ms</span></span><br><span class="line"><span class="comment">1号</span></span><br><span class="line"><span class="comment">// 等待1000ms</span></span><br><span class="line"><span class="comment">2号</span></span><br><span class="line"><span class="comment">// 等待1000ms</span></span><br><span class="line"><span class="comment">3号</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h2 id="在forEach中使用await"><a href="#在forEach中使用await" class="headerlink" title="在forEach中使用await"></a>在forEach中使用await</h2><p>一开始的写的异步函数如下</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    ha.forEach(<span class="function"><span class="params">v</span>=&gt;</span>&#123;</span><br><span class="line">        <span class="keyword">let</span> value = <span class="keyword">await</span> getHallName(v.hallId);</span><br><span class="line">        <span class="built_in">console</span>.log(value);</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">test();</span><br></pre></td></tr></table></figure><p>但是当我们兴致冲冲去查看运行结果的时候却傻了眼，得到的输出结果却是如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SyntaxError: await is only valid in async function</span><br></pre></td></tr></table></figure><p>这时候，我们一拍脑袋，回想起来forEach() 方法是对数组的每个元素执行一次提供的函数。</p><p>现在，我又将函数修改为以下的形式</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    ha.forEach(<span class="keyword">async</span> v =&gt; &#123;</span><br><span class="line">        <span class="keyword">let</span> value = <span class="keyword">await</span> getHallName(v.hallId);</span><br><span class="line">        <span class="built_in">console</span>.log(value);</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">test();</span><br></pre></td></tr></table></figure><p>现在结果总该是正确的吧，但是，令人失望的是，结果还是错的</p><p>输出结果如下：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 输出结果</span></span><br><span class="line"><span class="comment">// 等待1000ms,然后直接输出下面的三项，而不是每一项之间间隔1000ms</span></span><br><span class="line"><span class="comment">1号</span></span><br><span class="line"><span class="comment">2号</span></span><br><span class="line"><span class="comment">3号</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>查阅资料后，才得到了一个结论</p><blockquote><p>JavaScript 中的 forEach不支持 promise 感知，也不支持 async 和await，所以不能在 forEach 使用 await 。</p></blockquote><h2 id="在map中使用await"><a href="#在map中使用await" class="headerlink" title="在map中使用await"></a>在map中使用await</h2><p>既然在forEach中无法使用await，那么map()方法呢？</p><p>这次我们有了forEach()的教训，</p><blockquote><p>map() 方法创建一个新数组，其结果是该数组中的每个元素都调用一个提供的函数后返回的结果。</p></blockquote><p>我们就记住了要让提供给map()方法的函数为异步函数</p><p>我们写出来以下的方法来进行试验：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    ha.map(<span class="keyword">async</span> v=&gt; &#123;</span><br><span class="line">        <span class="keyword">let</span> value = <span class="keyword">await</span> getHallName(v.hallId);</span><br><span class="line">        <span class="built_in">console</span>.log(value);</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">test();</span><br></pre></td></tr></table></figure><p>输出结果如下：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 输出结果</span></span><br><span class="line"><span class="comment">// 等待1000ms，然后直接一次性输出下列三个值</span></span><br><span class="line"><span class="comment">1号</span></span><br><span class="line"><span class="comment">2号</span></span><br><span class="line"><span class="comment">3号</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>我们查看一下mdn文档对于map()方法的说明：</p><blockquote><p>map 方法会给原数组中的每个元素都按顺序调用一次  callback 函数。callback 每次执行后的返回值（包括 undefined）组合起来形成一个新数组。</p></blockquote><p>也就是说，在不考虑返回数组的情况下，map()方法就可以表示为以下的形式</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">map1</span>(<span class="params">v</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> value = <span class="keyword">await</span> getHallName(v.hallId);</span><br><span class="line">    <span class="built_in">console</span>.log(value);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">map2</span>(<span class="params">v</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> value = <span class="keyword">await</span> getHallName(v.hallId);</span><br><span class="line">    <span class="built_in">console</span>.log(value);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">map3</span>(<span class="params">v</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> value = <span class="keyword">await</span> getHallName(v.hallId);</span><br><span class="line">    <span class="built_in">console</span>.log(value);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">map1(ha[<span class="number">0</span>]);</span><br><span class="line">map2(ha[<span class="number">1</span>]);</span><br><span class="line">map3(ha[<span class="number">2</span>]);</span><br></pre></td></tr></table></figure><p>我们首先注册了三个异步函数，然后并行调用了它们。因此，输出结果也就是如上述所述，等待一段时间后，然后按照任务队列中的顺序依次输出</p><p>那么，如果再考虑map()方法的特性，其可以将每次函数执行后的返回值组合起来形成一个新的数组。另外，我们又知道</p><blockquote><p>异步函数返回一个promise对象</p></blockquote><p>因此，使用map()方法就可以返回一个包含promise对象的数组</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[ <span class="built_in">Promise</span> &#123; &lt;pending&gt; &#125;, <span class="built_in">Promise</span> &#123; &lt;pending&gt; &#125;, <span class="built_in">Promise</span> &#123; &lt;pending&gt; &#125; ]</span><br></pre></td></tr></table></figure><p>因此，我们可以利用Promise.all()方法来进行后续的处理</p><p>现在，我们来重写之前的方法</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> promiseArr = ha.map(<span class="keyword">async</span> v =&gt; &#123;</span><br><span class="line">        <span class="keyword">let</span> value = <span class="keyword">await</span> getHallName(v.hallId);</span><br><span class="line">        <span class="keyword">return</span> value;</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    <span class="built_in">Promise</span>.all(promiseArr).then( <span class="function"><span class="params">v</span>=&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(v);</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">test();</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 输出结果</span></span><br><span class="line"><span class="comment">// 等待1000ms</span></span><br><span class="line"><span class="comment">[ '1号', '2号', '3号' ]</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>根据以上的分析，我们可以看到：<br>对于async和await来控制异步流程</p><ol><li>如果想要在循环中让异步任务串行（继发运行），那么使用for循环(包括for的一些列循环: for…of , for…in)</li><li>如果想要在循环中让异步任务并行，那么我们除了Promise.all()方法外，还可以使用map()方法来使异步任务并行</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;引言&quot;&gt;&lt;a href=&quot;#引言&quot; class=&quot;headerlink&quot; title=&quot;引言&quot;&gt;&lt;/a&gt;引言&lt;/h2&gt;&lt;p&gt;之前在做项目的时候，遇到一个场景：&lt;/p&gt;
&lt;p&gt;给定了一个数组类似于这样：&lt;/p&gt;
&lt;figure class=&quot;highlight ty
      
    
    </summary>
    
      <category term="ES6" scheme="http://yoursite.com/categories/ES6/"/>
    
    
  </entry>
  
  <entry>
    <title>TypeScript与koa搭建web项目的总结</title>
    <link href="http://yoursite.com/2019/10/28/TypeScript%E4%B8%8Ekoa%E6%90%AD%E5%BB%BAweb%E9%A1%B9%E7%9B%AE%E7%9A%84%E6%80%BB%E7%BB%93/"/>
    <id>http://yoursite.com/2019/10/28/TypeScript与koa搭建web项目的总结/</id>
    <published>2019-10-28T06:50:21.000Z</published>
    <updated>2019-10-28T09:48:44.585Z</updated>
    
    <content type="html"><![CDATA[<h2 id="项目准备"><a href="#项目准备" class="headerlink" title="项目准备"></a>项目准备</h2><h3 id="项目的创建以及必需的包的安装"><a href="#项目的创建以及必需的包的安装" class="headerlink" title="项目的创建以及必需的包的安装"></a>项目的创建以及必需的包的安装</h3><ol><li><p>创建npm项目</p><blockquote><p>npm init</p></blockquote><p> 默认即可，如果考虑后期npm包的发布，那么可以自定义</p></li><li><p>安装koa项目必要的npm包模块    </p><ol><li><p>安装TypeScript</p><blockquote><p>cnpm i -g typescript</p></blockquote></li><li><p>安装koa,koa-router</p><blockquote><p>cnpm i koa koa-router -D</p></blockquote></li><li><p>安装@types/koa,@types/koa-router</p><p> 这两个模块可以允许我们使用TypeScript语法来编写koa应用</p><blockquote><p>cnpm i @types/koa @types/koa-router -D</p></blockquote></li><li><p>安装ts-node,nodemon</p><ol><li>ts-node可以直接编译.ts文件，而不需要等待tsc将ts文件编译成js文件再进行编译的方式</li><li>nodemon可以监听文件的变动并进行重新编译（热加载）<blockquote><p>cnpm i ts-node nodemon -D</p></blockquote></li></ol></li></ol></li><li><p>安装数据库相关的npm包模块</p><ol><li>安装node.js ORM框架 sequelize<blockquote><p>cnpm i sequelize -D</p></blockquote></li><li>为所选数据库安装驱动程序<blockquote><p>One of the following:<br> $ npm install –save pg pg-hstore # Postgres<br> $ npm install –save mysql2<br> $ npm install –save mariadb<br> $ npm install –save sqlite3<br> $ npm install –save tedious # Microsoft SQL Server</p></blockquote></li></ol></li></ol><h3 id="项目结构的确定"><a href="#项目结构的确定" class="headerlink" title="项目结构的确定"></a>项目结构的确定</h3><p>采用面向对象（OOP）的思想，我们可以确定如下的项目结构</p><figure class="highlight md"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">|-- program</span><br><span class="line"><span class="code">    |-- package.json</span></span><br><span class="line"><span class="code">    |-- tsconfig.json</span></span><br><span class="line"><span class="code">    |-- .vscode</span></span><br><span class="line"><span class="code">    |-- dist</span></span><br><span class="line"><span class="code">    |-- src</span></span><br><span class="line"><span class="code">        |-- app.ts</span></span><br><span class="line"><span class="code">        |-- Config</span></span><br><span class="line"><span class="code">        |   |-- config.ts</span></span><br><span class="line"><span class="code">        |-- Controllers</span></span><br><span class="line"><span class="code">        |   |-- movieController.ts</span></span><br><span class="line"><span class="code">        |   |-- swiperController.ts</span></span><br><span class="line"><span class="code">        |   |-- timeController.ts</span></span><br><span class="line"><span class="code">        |-- Entity</span></span><br><span class="line"><span class="code">        |   |-- entities.ts</span></span><br><span class="line"><span class="code">        |-- Models</span></span><br><span class="line"><span class="code">        |   |-- movieHall.ts</span></span><br><span class="line"><span class="code">        |   |-- movieModel.ts</span></span><br><span class="line"><span class="code">        |   |-- swiperModel.ts</span></span><br><span class="line"><span class="code">        |   |-- timeModel.ts</span></span><br><span class="line"><span class="code">        |-- Sequelize</span></span><br><span class="line"><span class="code">        |   |-- Sequelize.ts</span></span><br><span class="line"><span class="code">        |-- Services</span></span><br><span class="line"><span class="code">            |-- movieService.ts</span></span><br><span class="line"><span class="code">            |-- swiperService.ts</span></span><br><span class="line"><span class="code">            |-- timeServiece.ts</span></span><br></pre></td></tr></table></figure><h4 id="package-json"><a href="#package-json" class="headerlink" title="package.json"></a>package.json</h4><p>接下来我们会提一下package.josn该配置文件的关键配置</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">"scripts": &#123;</span><br><span class="line">  "build": "tsc",</span><br><span class="line">  "start": "tsc &amp;&amp; nodemon dist/app.js",</span><br><span class="line">  "watch-server": "nodemon --watch src -e ts,tsx --exec ts-node ./src/app.ts"</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>npm 允许在package.json文件里面，使用scripts字段定义脚本命令。</p></blockquote><p>我们需要在scripts脚本命令中进行配置，以简化启动命令的编写</p><h5 id="脚本配置命令的说明"><a href="#脚本配置命令的说明" class="headerlink" title="脚本配置命令的说明"></a>脚本配置命令的说明</h5><ol><li><p>start 命令</p><p> 我们执行npm run start就相当于创建了一个新的shell来执行tsc &amp;&amp; node dist/app.js。</p><p> 对于tsc命令，是typescript命令行自带的，在不带任何输入文件下调用tsc命令，编译器就会从当前目录向上查找tsconfig.json配置文件。按照tsconfig.json配置文件的说明来进行ts的文件编译</p><p> 对于nodemon dist/app.js,监听使用tsc命令编译成的app.js文件的变化，并进行热加载编译</p></li><li><p>watch-server 命令</p><p> nodemon –watch src用来监视src目录下所有文件的变动</p><p> nodemon -e ts/tsx 默认情况下，nodemon查找与文件.js，.mjs，.coffee，.litcoffee，和.json扩展。使用该命令可以扩展其监视的文件类型（当前是ts/tsx）</p><p> nodemon –exec ts-node ./src/app.ts nodemon还可以用于执行和监视其他外部非nodemon程序。此处用来执行ts-node ./src/app.ts。用来执行该ts文件</p></li></ol><h4 id="tsconfig-json"><a href="#tsconfig-json" class="headerlink" title="tsconfig.json"></a>tsconfig.json</h4><p>tsconfig.json文件中指定了用来编译这个项目的根文件和编译选项。</p><p>我们通过tsc命令来进行ts文件的编译。</p><p>以下是tsconfig.json的配置</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"compilerOptions"</span>: &#123;</span><br><span class="line">      "target": "ES2017",  /* 指定 ECMAScript 目标版本: 'ES3' (default), 'ES5', 'ES2015', 'ES2016', 'ES2017', or 'ESNEXT' */</span><br><span class="line">      "module": "es2015", /* 指定使用模块: 'commonjs', 'amd', 'system', 'umd' or 'es2015' */</span><br><span class="line">      "sourceMap": true, /* 生成相应的 '.map' 文件 */</span><br><span class="line">      "strict": true, /* 启用所有严格类型检查选项 */</span><br><span class="line">      "outDir": "./dist", /* 指定输出目录 */</span><br><span class="line">      "rootDir": "./src", /* 用来控制输出目录结构 --outDir. (输出目录的解构会与给定的rootDir目录解构一致) */</span><br><span class="line">      "strictNullChecks": false, /* 是否启用严格的 null 检查 （这里为否） */</span><br><span class="line">      "noImplicitAny": false, /* 在表达式和声明上有隐含的 any类型时是否报错 （这里为否）*/</span><br><span class="line">      "alwaysStrict": false, /* 是否以严格模式检查每个模块，并在每个文件里加入 'use strict' （这里为否）*/</span><br><span class="line">      "esModuleInterop": true</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="dist"><a href="#dist" class="headerlink" title="dist"></a>dist</h4><p>指定编译生成的输出目录，目录结构与src源代码目录一致</p><h4 id="src"><a href="#src" class="headerlink" title="src"></a>src</h4><p>源代码目录</p><h5 id="app-ts"><a href="#app-ts" class="headerlink" title="app.ts"></a>app.ts</h5><p>项目入口文件，引入控制器模块并指定端口生成应用</p><p>例如：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> Koa <span class="keyword">from</span> <span class="string">'koa'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> swiperController <span class="keyword">from</span> <span class="string">'./Controllers/swiperController'</span>;</span><br><span class="line"><span class="keyword">import</span> movieController <span class="keyword">from</span> <span class="string">'./Controllers/movieController'</span>;</span><br><span class="line"><span class="keyword">import</span> timeController <span class="keyword">from</span> <span class="string">'./Controllers/timeController'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> app = <span class="keyword">new</span> Koa();</span><br><span class="line"></span><br><span class="line">app.use(swiperController.routes()).use(swiperController.allowedMethods());</span><br><span class="line">app.use(movieController.routes()).use(movieController.allowedMethods());</span><br><span class="line">app.use(timeController.routes()).use(timeController.allowedMethods());</span><br><span class="line"></span><br><span class="line">app.listen(<span class="number">3000</span>,(): <span class="function"><span class="params">void</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'Port 3000 is listening'</span>);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h5 id="Controllers-控制层"><a href="#Controllers-控制层" class="headerlink" title="Controllers 控制层"></a>Controllers 控制层</h5><p>控制层用来分发路由，处理传入的HTTP请求。</p><p>例如：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> Router <span class="keyword">from</span> <span class="string">'koa-router'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123;MovieService&#125; <span class="keyword">from</span> <span class="string">'../Services/movieService'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> movieController = <span class="keyword">new</span> Router();</span><br><span class="line"><span class="keyword">let</span> movieService = <span class="keyword">new</span> MovieService();</span><br><span class="line"></span><br><span class="line">movieController.get(<span class="string">'/movies'</span>,<span class="function">(<span class="params">ctx</span>) =&gt;</span> movieService.getMovieById(ctx));</span><br><span class="line">movieController.get(<span class="string">'/movies/showing'</span>,<span class="function">(<span class="params">ctx</span>) =&gt;</span> movieService.getShowingMovies(ctx));</span><br><span class="line">movieController.get(<span class="string">'/movies/coming'</span>,<span class="function">(<span class="params">ctx</span>) =&gt;</span> movieService.getComingMovies(ctx))</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> movieController;</span><br></pre></td></tr></table></figure><h5 id="services-业务层"><a href="#services-业务层" class="headerlink" title="services 业务层"></a>services 业务层</h5><p>业务层用来编写业务代码，对控制层得到的http请求作出响应</p><p>例如：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> Movie <span class="keyword">from</span> <span class="string">'../Models/movieModel'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> MovieService &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 通过电影ID获取电影信息</span></span><br><span class="line">    <span class="keyword">async</span> getMovieById(ctx) &#123;</span><br><span class="line">        <span class="keyword">let</span> movieId = ctx.request.query[<span class="string">'movieId'</span>];</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">let</span> value = <span class="keyword">await</span> Movie.findOne(&#123;</span><br><span class="line">                where: &#123;</span><br><span class="line">                    movieId: movieId</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">            <span class="keyword">let</span> movieMes = value.dataValues;</span><br><span class="line">            ctx.body = &#123;</span><br><span class="line">                error_code: <span class="number">0</span>,</span><br><span class="line">                data: &#123;</span><br><span class="line">                    movie: movieMes</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;;</span><br><span class="line">        &#125;<span class="keyword">catch</span>(e) &#123;</span><br><span class="line">            <span class="built_in">console</span>.log(e);</span><br><span class="line">            ctx.body = &#123;</span><br><span class="line">                error_code: <span class="number">-100</span>,</span><br><span class="line">                data: &#123;</span><br><span class="line">                    mes: <span class="string">'指定参数movieId不存在'</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> &#123;MovieService&#125;</span><br></pre></td></tr></table></figure><h5 id="Models-模型"><a href="#Models-模型" class="headerlink" title="Models 模型"></a>Models 模型</h5><p>模型代表一个存取数据的对象。用来对应数据库中的一个表实体。通过sequelize ORM框架来进行模型对象与数据库表之间的映射。之后，我们在业务层就可以直接通过操作该模型对象来操作数据库。</p><p>例如：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;sequelize&#125; <span class="keyword">from</span> <span class="string">'../Sequelize/Sequelize'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123;Sequelize,Movie&#125; <span class="keyword">from</span> <span class="string">'../Entity/entities'</span>;</span><br><span class="line"></span><br><span class="line">Movie.init(&#123;</span><br><span class="line">    MovieId: &#123;</span><br><span class="line">        <span class="keyword">type</span>: Sequelize.STRING,</span><br><span class="line">        allowNull: <span class="literal">false</span>,</span><br><span class="line">        primaryKey: <span class="literal">true</span></span><br><span class="line">    &#125;,</span><br><span class="line">    MovieName: &#123;</span><br><span class="line">        <span class="keyword">type</span>: Sequelize.STRING,</span><br><span class="line">        allowNull: <span class="literal">false</span></span><br><span class="line">    &#125;,</span><br><span class="line">    MovieImgUrl: &#123;</span><br><span class="line">        <span class="keyword">type</span>: Sequelize.STRING,</span><br><span class="line">        allowNull: <span class="literal">false</span></span><br><span class="line">    &#125;,</span><br><span class="line">    MovieType: &#123;</span><br><span class="line">        <span class="keyword">type</span>: Sequelize.STRING,</span><br><span class="line">        allowNull: <span class="literal">false</span></span><br><span class="line">    &#125;,</span><br><span class="line">    Duration: &#123;</span><br><span class="line">        <span class="keyword">type</span>: Sequelize.INTEGER,</span><br><span class="line">        allowNull: <span class="literal">false</span></span><br><span class="line">    &#125;,</span><br><span class="line">    PlayType: &#123;</span><br><span class="line">        <span class="keyword">type</span>: Sequelize.STRING,</span><br><span class="line">        allowNull: <span class="literal">false</span></span><br><span class="line">    &#125;,</span><br><span class="line">    stage: &#123;</span><br><span class="line">        <span class="keyword">type</span>: Sequelize.STRING,</span><br><span class="line">        allowNull: <span class="literal">false</span></span><br><span class="line">    &#125;,</span><br><span class="line">    Score: &#123;</span><br><span class="line">        <span class="keyword">type</span>: Sequelize.FLOAT,</span><br><span class="line">        allowNull: <span class="literal">true</span></span><br><span class="line">    &#125;,</span><br><span class="line">    SourceArea: &#123;</span><br><span class="line">        <span class="keyword">type</span>: Sequelize.STRING,</span><br><span class="line">        allowNull: <span class="literal">false</span></span><br><span class="line">    &#125;,</span><br><span class="line">    ReleaseArea: &#123;</span><br><span class="line">        <span class="keyword">type</span>: Sequelize.STRING,</span><br><span class="line">        allowNull: <span class="literal">false</span></span><br><span class="line">    &#125;,</span><br><span class="line">    ReleaseDate: &#123;</span><br><span class="line">        <span class="keyword">type</span>: Sequelize.DATE,</span><br><span class="line">        allowNull: <span class="literal">false</span></span><br><span class="line">    &#125;,</span><br><span class="line">    Stars: &#123;</span><br><span class="line">        <span class="keyword">type</span>: Sequelize.STRING,</span><br><span class="line">        allowNull: <span class="literal">false</span></span><br><span class="line">    &#125;,</span><br><span class="line">    Details: &#123;</span><br><span class="line">        <span class="keyword">type</span>: Sequelize.STRING,</span><br><span class="line">        allowNull: <span class="literal">false</span></span><br><span class="line">    &#125;,</span><br><span class="line">&#125;,&#123;</span><br><span class="line">    sequelize,</span><br><span class="line">    tableName: <span class="string">'movie'</span>,</span><br><span class="line">    createdAt: <span class="literal">false</span>,</span><br><span class="line">    updatedAt: <span class="literal">false</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> Movie;</span><br></pre></td></tr></table></figure><h5 id="Entity-实体"><a href="#Entity-实体" class="headerlink" title="Entity 实体"></a>Entity 实体</h5><p>存放所有model对应的实体</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> Sequelize = <span class="built_in">require</span>(<span class="string">'sequelize'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> Model = Sequelize.Model;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> Swiper <span class="keyword">extends</span> Model &#123;&#125;;</span><br><span class="line"><span class="keyword">class</span> Movie <span class="keyword">extends</span> Model &#123;&#125;;</span><br><span class="line"><span class="keyword">class</span> Time <span class="keyword">extends</span> Model &#123;&#125;;</span><br><span class="line"><span class="keyword">class</span> MovieHall <span class="keyword">extends</span> Model &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> &#123;Sequelize,Swiper,Movie,Time,MovieHall&#125;;</span><br></pre></td></tr></table></figure><h5 id="Sequelize-数据库连接"><a href="#Sequelize-数据库连接" class="headerlink" title="Sequelize 数据库连接"></a>Sequelize 数据库连接</h5><p>sequelize.ts 来进行数据库连接</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;Sequelize&#125; <span class="keyword">from</span> <span class="string">'sequelize'</span>;</span><br><span class="line"><span class="keyword">import</span> config <span class="keyword">from</span> <span class="string">'../Config/config'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> sequelize = <span class="keyword">new</span> Sequelize(config.dataBase,config.userName,config.password,(config.options <span class="keyword">as</span> object));</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> &#123;sequelize,config&#125;;</span><br></pre></td></tr></table></figure><h5 id="config"><a href="#config" class="headerlink" title="config"></a>config</h5><p>存放一些配置文件，例如数据库配置</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这是sequelize用来进行数据库连接的一些配置信息</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> Options&#123;</span><br><span class="line">    host: <span class="built_in">string</span>;</span><br><span class="line">    port?: <span class="built_in">number</span>;</span><br><span class="line">    dialect: <span class="built_in">string</span>;</span><br><span class="line">    pool?: &#123;</span><br><span class="line">        max?: <span class="built_in">number</span>;</span><br><span class="line">        min?: <span class="built_in">number</span>;</span><br><span class="line">        idle?: <span class="built_in">number</span>;</span><br><span class="line">        acquire: <span class="built_in">number</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> Config &#123;</span><br><span class="line">    dataBase: <span class="built_in">string</span>;</span><br><span class="line">    userName: <span class="built_in">string</span>;</span><br><span class="line">    password: <span class="built_in">string</span>;</span><br><span class="line">    options: Options;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> config: Config = &#123;</span><br><span class="line">    dataBase: <span class="string">'moviedb'</span>,</span><br><span class="line">    userName: <span class="string">'root'</span>,</span><br><span class="line">    password: <span class="string">'zjb13777838499'</span>,</span><br><span class="line">    options: &#123;</span><br><span class="line">        host: <span class="string">'localhost'</span>,</span><br><span class="line">        port: <span class="literal">undefined</span>,</span><br><span class="line">        dialect: <span class="string">'mysql'</span>,</span><br><span class="line">        pool: &#123;</span><br><span class="line">            max: <span class="number">5</span>,</span><br><span class="line">            min: <span class="number">0</span>,</span><br><span class="line">            idle: <span class="number">10000</span>,</span><br><span class="line">            acquire: <span class="number">30000</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> config;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;项目准备&quot;&gt;&lt;a href=&quot;#项目准备&quot; class=&quot;headerlink&quot; title=&quot;项目准备&quot;&gt;&lt;/a&gt;项目准备&lt;/h2&gt;&lt;h3 id=&quot;项目的创建以及必需的包的安装&quot;&gt;&lt;a href=&quot;#项目的创建以及必需的包的安装&quot; class=&quot;headerli
      
    
    </summary>
    
      <category term="TypeScript" scheme="http://yoursite.com/categories/TypeScript/"/>
    
    
  </entry>
  
  <entry>
    <title>TypeScript的常用类型探秘</title>
    <link href="http://yoursite.com/2019/10/23/TypeScript%E7%9A%84%E5%B8%B8%E7%94%A8%E7%B1%BB%E5%9E%8B%E6%8E%A2%E7%A7%98/"/>
    <id>http://yoursite.com/2019/10/23/TypeScript的常用类型探秘/</id>
    <published>2019-10-23T12:12:03.000Z</published>
    <updated>2019-10-24T14:24:52.119Z</updated>
    
    <content type="html"><![CDATA[<h2 id="基本注解"><a href="#基本注解" class="headerlink" title="基本注解"></a>基本注解</h2><p>类型注解使用 :TypeAnnotation 语法。类型声明空间中可用的任何内容都可以用作类型注解。</p><p>例如，在下面这个例子中，使用了变量、函数参数以及函数返回值的类型注解：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> num: <span class="built_in">number</span> = <span class="number">123</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">identity</span>(<span class="params">num: <span class="built_in">number</span></span>): <span class="title">number</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> num;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="类型系统"><a href="#类型系统" class="headerlink" title="类型系统"></a>类型系统</h2><h3 id="JS原有的基本数据类型"><a href="#JS原有的基本数据类型" class="headerlink" title="JS原有的基本数据类型"></a>JS原有的基本数据类型</h3><p>TypeScript支持JS具有的六种基本数据类型</p><ol><li>null</li><li>undefined</li><li>boolean</li><li>number</li><li>string</li><li>symbol</li></ol><p>我们在声明变量的时候可以预先定义该变量的类型，使得之后定义的变量类型必须符合该类型</p><p>例如：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> num: <span class="built_in">number</span> = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">let</span> str: <span class="built_in">string</span> = <span class="string">'123'</span>;</span><br><span class="line"><span class="keyword">let</span> bool: <span class="built_in">boolean</span> = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">let</span> u: <span class="literal">undefined</span> = <span class="literal">undefined</span>;</span><br><span class="line"><span class="keyword">let</span> n: <span class="literal">null</span> = <span class="literal">null</span>;</span><br></pre></td></tr></table></figure><p>值得注意的是：</p><blockquote><p>默认情况下null和undefined（后面还会介绍到Never类型，它也是所有类型的子类型）是所有类型的子类型。也就是说我们可以把null和undefined赋值给任意类型的变量</p></blockquote><p>例如：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> num: <span class="built_in">number</span> = <span class="literal">undefined</span>;</span><br><span class="line"><span class="keyword">let</span> str: <span class="built_in">string</span> = <span class="literal">null</span>;</span><br></pre></td></tr></table></figure><h3 id="JS原有的复杂引用类型"><a href="#JS原有的复杂引用类型" class="headerlink" title="JS原有的复杂引用类型"></a>JS原有的复杂引用类型</h3><h4 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h4><p>TypeScript像JavaScript一样可以操作数组元素。 有两种方式可以定义数组。 </p><ol><li><p>可以在元素类型后面接上 []，表示由此类型元素组成的一个数组：</p> <figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr: <span class="built_in">number</span>[] = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>];</span><br></pre></td></tr></table></figure><p> 那么，该数组不允许出现其他类型的项</p> <figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Error</span></span><br><span class="line"><span class="keyword">let</span> arr: <span class="built_in">number</span>[] = [<span class="number">1</span>,<span class="string">'nice'</span>,<span class="number">3</span>]</span><br></pre></td></tr></table></figure><p> 当然，如果我们想要像js一样可以包含各种类型的数组，我们可以使用Any类型再在后面接上 []：</p> <figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr: <span class="built_in">any</span>[] = [<span class="number">1</span>,<span class="string">'nice'</span>,<span class="literal">true</span>];</span><br></pre></td></tr></table></figure></li><li><p>使用数组泛型</p> <figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> list: <span class="built_in">Array</span>&lt;<span class="built_in">number</span>&gt; = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>];</span><br></pre></td></tr></table></figure></li></ol><h4 id="Object"><a href="#Object" class="headerlink" title="Object"></a>Object</h4><p>object表示非原始类型，也就是复杂引用类型。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> obj: object = &#123;</span><br><span class="line">    m: <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(obj); <span class="comment">// &#123;m:1&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> date: object = <span class="keyword">new</span> <span class="built_in">Date</span>();</span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> date); <span class="comment">// object</span></span><br></pre></td></tr></table></figure><h4 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h4><p>与JS一直，ts也可以使用函数声明和函数表达式来声明函数</p><p>例如：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 函数声明</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params">v: <span class="built_in">string</span></span>): <span class="title">void</span> </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(v);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数表达式（注意：这种写法其实经过了类型推断；因为，我们只是给匿名函数添加类型）</span></span><br><span class="line"><span class="keyword">let</span> test = <span class="function"><span class="keyword">function</span>(<span class="params">v: <span class="built_in">string</span></span>): <span class="title">void</span> </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(v);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数表达式完整写法（手动给返回的函数添加类型）</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> test: <span class="function">(<span class="params">v: <span class="built_in">string</span></span>) =&gt;</span> <span class="built_in">void</span> = <span class="function"><span class="keyword">function</span>(<span class="params">v: <span class="built_in">string</span></span>): <span class="title">void</span> </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(v);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意：在 TypeScript 的类型定义中，=&gt; 用来表示函数的定义，左边是输入类型，需要用括号括起来，右边是输出类型。</p><p>值得注意的是,与js不同，js可以不用去管形参的个数和类型而向函数传递任意实参。但是</p><blockquote><p>ts规定输入多余的（或者少于要求的）参数，是不被允许的</p></blockquote><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params">v: <span class="built_in">string</span>|<span class="built_in">number</span></span>): <span class="title">void</span> </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(v);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// OK</span></span><br><span class="line">test(<span class="string">'nice'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Error (应有 1 个参数，但获得 2 个。)</span></span><br><span class="line">test(<span class="string">'nice'</span>,<span class="number">1</span>);</span><br></pre></td></tr></table></figure><h5 id="可选参数"><a href="#可选参数" class="headerlink" title="可选参数"></a>可选参数</h5><p>我们在接口中可以使用可选属性，那么，类似的，在函数中，我们也可以使用可选参数</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params">k: <span class="built_in">string</span>,v?: <span class="built_in">number</span></span>): <span class="title">void</span></span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(k,v); <span class="comment">// 'hello' 'undefined'</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">test(<span class="string">'hello'</span>);</span><br></pre></td></tr></table></figure><blockquote><p>值得注意的是，可选参数必须在确定参数的后面</p></blockquote><p>这点很容易想清楚，如果可选参数在确定参数的前面，因此，我们无法知道可选参数是不是一定传入了实参，因此，会造成实参与形参匹配的混乱</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Error</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params">v?: <span class="built_in">number</span>,k: <span class="built_in">string</span></span>): <span class="title">void</span></span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(k,v); <span class="comment">// 'hello' 'undefined'</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">test(<span class="string">'hello'</span>);</span><br></pre></td></tr></table></figure><h5 id="参数默认值"><a href="#参数默认值" class="headerlink" title="参数默认值"></a>参数默认值</h5><p>在ES6中，我们允许为参数添加默认值，就像这样</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params">k,v=<span class="number">1</span></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(k,v); <span class="comment">// 'k' 1</span></span><br><span class="line">&#125;</span><br><span class="line">test(<span class="string">'k'</span>);</span><br></pre></td></tr></table></figure><p>如果我们没有为相应的形参传入实参，那么形参就会默认使用默认值</p><p>类似的，ts也具有默认参数值。另外，我们在之前提到的可选参数必须放在确定参数后面的限制在默认参数这里也就没有了（但是我们依旧需要传入undefined来匹配这个可选参数）。</p><p>例如：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params">k: <span class="built_in">string</span> = 'k',v: <span class="built_in">number</span></span>): <span class="title">void</span> </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(k,v);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// OK</span></span><br><span class="line">test(<span class="literal">undefined</span>,<span class="number">1</span>); <span class="comment">// 'k' 1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Error</span></span><br><span class="line">test(<span class="number">1</span>);</span><br></pre></td></tr></table></figure><h5 id="不定参数"><a href="#不定参数" class="headerlink" title="不定参数"></a>不定参数</h5><p>类似ES6不定参数的概念，在ts中，我们也可以使用不定参数</p><blockquote><p>记住，不定参数必须在函数所有命名参数的末尾</p></blockquote><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params">k: <span class="built_in">string</span>, ...arr: <span class="built_in">any</span>[]</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(k,arr); <span class="comment">// 'k' [ 1, 2, 3, 4 ]</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">test(<span class="string">'k'</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>);</span><br></pre></td></tr></table></figure><h4 id="其他复杂引用类型"><a href="#其他复杂引用类型" class="headerlink" title="其他复杂引用类型"></a>其他复杂引用类型</h4><p>包括基本包装类型、Error、Date、RegExp等</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> s: <span class="built_in">String</span> = <span class="keyword">new</span> <span class="built_in">String</span>(<span class="number">1</span>); <span class="comment">// [String: '1']</span></span><br><span class="line"><span class="keyword">let</span> b: <span class="built_in">Boolean</span> = <span class="keyword">new</span> <span class="built_in">Boolean</span>(<span class="number">1</span>); <span class="comment">// [Boolean: true]</span></span><br><span class="line"><span class="keyword">let</span> e: <span class="built_in">Error</span> = <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'Error occurred'</span>); <span class="comment">// Error: Error occurred</span></span><br><span class="line"><span class="keyword">let</span> d: <span class="built_in">Date</span> = <span class="keyword">new</span> <span class="built_in">Date</span>(); <span class="comment">// 2019-10-24T14:24:24.745Z </span></span><br><span class="line"><span class="keyword">let</span> r: <span class="built_in">RegExp</span> = <span class="regexp">/[a-z]/</span>; <span class="comment">// /[a-z]/</span></span><br></pre></td></tr></table></figure><h3 id="TypeScript提供的一些类型"><a href="#TypeScript提供的一些类型" class="headerlink" title="TypeScript提供的一些类型"></a>TypeScript提供的一些类型</h3><h4 id="任意值-Any"><a href="#任意值-Any" class="headerlink" title="任意值 Any"></a>任意值 Any</h4><p>有时候我们在定义的时候可能不知道该变量会在之后是什么类型。又或者，我们想要在定义变量之后可以修改该变量的类型。那么，我们就可以使用Any类型。</p><p>任意值（Any）用来表示允许赋值为任意类型。</p><p>例如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a: any;</span><br><span class="line">a = <span class="number">1</span>;</span><br><span class="line">a = <span class="string">'hello'</span>;</span><br></pre></td></tr></table></figure><p>可能会有点匪夷所思，但是事实上：</p><blockquote><p>在任意值上访问和操作任何属性和方法都是允许的，哪怕该属性和方法从未定义过。</p></blockquote><p>例如：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a: <span class="built_in">any</span> = <span class="number">1</span>;</span><br><span class="line"><span class="built_in">console</span>.log(a.num); <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure><p>如果照着js的思维，那么引擎在执行a.num时，会执行如下操作：</p><ol><li>创建a的基本包装类型对象，也就是new Number(1);</li><li>访问a.num（a的基本包装类型对象中的num属性，当然没有该属性，那么返回undefined）</li><li>销毁该实例（生命周期只会存在一行）</li></ol><p>这样来看，似乎说的通，但是对于undefined和null呢？</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a: <span class="built_in">any</span> = <span class="literal">undefined</span>;</span><br><span class="line"><span class="built_in">console</span>.log(a.num);</span><br></pre></td></tr></table></figure><p>我们利用ts-node来运行该段代码，我们会得到如下输出结果</p><blockquote><p>Cannot read property ‘num’ of undefined</p></blockquote><p>但是，他并没有报任何错。</p><p>而将其编译成js代码之后再运行，我们就发现控制台报出了错误：</p><blockquote><p>TypeError: Cannot read property ‘num’ of undefined</p></blockquote><p>因此，我个人认为（因为网上找寻资料未果），我们尽量避免在任意值上操作其本来就不具有的属性和方法。因为，尽管其在TypeScript语法中不会报错，但是当其编译成js代码后可能就会出现错误。</p><p>另外，我们知道TypeScript是JS语法的超集。在ts文件里写js语法是没有任何问题的。</p><p>在js中，我们定义的变量可以是任何类型。因此，在ts中，如果我们在变量定义时没有指定其类型，那么它就会被视为Any（任意值）类型</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> str;</span><br><span class="line">str = <span class="number">1</span>;</span><br><span class="line">str = <span class="string">'str'</span>;</span><br></pre></td></tr></table></figure><p>等同于</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> str: <span class="built_in">any</span>;</span><br><span class="line">str = <span class="number">1</span>;</span><br><span class="line">str = <span class="string">'str'</span>;</span><br></pre></td></tr></table></figure><h4 id="空值-Void"><a href="#空值-Void" class="headerlink" title="空值 Void"></a>空值 Void</h4><p>我们可以用void来表示空值。在某种程度上,Void类型就像是与Any类型相反，它表示没有任何类型</p><p>在c和java中，我们就经常使用void来表示一个函数没有返回值。同样，TypeScript也是如此：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params">v: <span class="built_in">number</span></span>): <span class="title">void</span></span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(v);</span><br><span class="line">    <span class="comment">// 没有任何返回值</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">test(<span class="number">1</span>); <span class="comment">// 1</span></span><br></pre></td></tr></table></figure><p>声明一个类型为void类型的变量并没有什么实际的意义。因为，我们只能为其赋予undefined和null（undefined和null是所有类型的子类型），仅此而已。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> v: <span class="built_in">void</span> = <span class="literal">undefined</span>;</span><br></pre></td></tr></table></figure><p>因此，我们只需要在函数没有任何返回值的时候使用void的类型即可</p><h4 id="Never类型"><a href="#Never类型" class="headerlink" title="Never类型"></a>Never类型</h4><p>Never类型表示那些永远不会存在的值。与void类型表示空值不同（void表示一个函数没有返回值），never类型用来表示一个函数根本不可能会有返回值</p><p>例如：</p><ol><li><p>函数一直无限运行下去，不会有返回值</p> <figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>): <span class="title">never</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>) &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>函数抛出错误，不会有返回值</p> <figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>): <span class="title">never</span></span>&#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'error'</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p>另外,never类型与null和undefined类型是任何类型的子类型，因此也能赋值给任何类型。但是，没有类型是它的子类型，也就是说只有never类型只能被另一个never类型所赋予。</p><h4 id="元组-Tuple"><a href="#元组-Tuple" class="headerlink" title="元组 Tuple"></a>元组 Tuple</h4><p>元组类型用来表示给定已知元素类型和数量的数组，各元素类型不必相同。</p><blockquote><p>使用 :[typeofmember1, typeofmember2] 能够为元组添加类型注解</p></blockquote><p>例如:</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> t: [<span class="built_in">string</span>,<span class="built_in">number</span>];</span><br><span class="line">t = [<span class="string">'123'</span>,<span class="number">123</span>];</span><br><span class="line"><span class="built_in">console</span>.log(t); <span class="comment">// ['123',123]</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> t[<span class="number">0</span>],<span class="keyword">typeof</span> t[<span class="number">1</span>]); <span class="comment">// string number</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Error</span></span><br><span class="line">t = [<span class="number">123</span>,<span class="string">'123'</span>];</span><br></pre></td></tr></table></figure><p>我们可以使用解构来配合元组进行使用</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> t: [<span class="built_in">string</span>,<span class="built_in">number</span>];</span><br><span class="line">t = [<span class="string">'123'</span>,<span class="number">123</span>];</span><br><span class="line"><span class="keyword">let</span> [m,n] = t;</span><br><span class="line"><span class="built_in">console</span>.log(m,n); <span class="comment">// '123' 123</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> m,<span class="keyword">typeof</span> n); <span class="comment">// string number</span></span><br></pre></td></tr></table></figure><p>值得注意的是：</p><blockquote><p>当在一个元组中访问一个越界的元素时，该元素的类型会被限制为元组中每个类型的联合类型</p></blockquote><p>也就是说，在上述t这个元组中，当我们访问一个越界元素时，该元素的类型只能是string或者是number</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> t: [<span class="built_in">string</span>,<span class="built_in">number</span>];</span><br><span class="line">t = [<span class="string">'123'</span>,<span class="number">123</span>];</span><br><span class="line">t.push(<span class="string">'nice'</span>);</span><br><span class="line">t.push(<span class="number">5</span>);</span><br><span class="line"><span class="built_in">console</span>.log(t); <span class="comment">// ['123',123,'nice',5]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Error（类型“true”的参数不能赋给类型“string | number”的参数）</span></span><br><span class="line">t.push(<span class="literal">true</span>);</span><br></pre></td></tr></table></figure><h4 id="枚举-Enum"><a href="#枚举-Enum" class="headerlink" title="枚举 Enum"></a>枚举 Enum</h4><p>枚举（Enum）类型用于取值被限定在一定范围内的场景，比如一周只能有七天，颜色限定为红绿蓝等。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> Week &#123;Sun,Mon,Tue,Wed,Thu,Fri,Sat&#125;</span><br><span class="line"><span class="keyword">enum</span> Colors &#123;red,green,blue&#125;</span><br></pre></td></tr></table></figure><p>现在，让我们试着输出一下这些枚举变量</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(Colors); <span class="comment">// &#123; '0': 'red', '1': 'green', '2': 'blue', red: 0, green: 1, blue: 2 &#125;</span></span><br></pre></td></tr></table></figure><p>我们可以发现，枚举类型变量实际上是一个对象。</p><p>枚举成员会被赋值为从 0 开始递增的数字，同时也会对枚举值到枚举名进行反向映射</p><p>我们查看一下被编译的js文件，我们可以看到枚举类型被编译为：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> Colors;</span><br><span class="line">(<span class="function"><span class="keyword">function</span> (<span class="params">Colors</span>) </span>&#123;</span><br><span class="line">    Colors[Colors[<span class="string">"red"</span>] = <span class="number">0</span>] = <span class="string">"red"</span>;</span><br><span class="line">    Colors[Colors[<span class="string">"green"</span>] = <span class="number">1</span>] = <span class="string">"green"</span>;</span><br><span class="line">    Colors[Colors[<span class="string">"blue"</span>] = <span class="number">2</span>] = <span class="string">"blue"</span>;</span><br><span class="line">&#125;)(Colors || (Colors = &#123;&#125;));</span><br></pre></td></tr></table></figure><p>我们来看下这段代码</p><blockquote><p>Colors[Colors[“red”] = 0] = “red”;</p></blockquote><p>很巧妙的写法，在[Colors[“red”] = 0]这里，首先将Colors对象的”red”属性赋值0。又因为赋值表达式的值为等式右边的值，因此，后面的赋值又会变为Colors[0]=”red”。这样，一个赋值表达式就可以达到两个表达式的效果。</p><p>当然，除了默认从0开始为元素编号，我们也可以手动为成员指定自己的编号</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 部分指定枚举成员(未手动赋值的枚举项会接着上一个枚举项递增。)</span></span><br><span class="line"><span class="keyword">enum</span> Colors &#123;red = <span class="number">1</span>, green, blue&#125;;</span><br><span class="line"><span class="built_in">console</span>.log(Colors); <span class="comment">// &#123; '1': 'red', '2': 'green', '3': 'blue', red: 1, green: 2, blue: 3 &#125;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">enum</span> Colors &#123;red, green = <span class="number">2</span>, blue&#125;;</span><br><span class="line"><span class="built_in">console</span>.log(Colors); <span class="comment">// &#123; '0': 'red', '2': 'green', '3': 'blue', red: 0, green: 2, blue: 3 &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">enum</span> Colors &#123;red , green = <span class="number">2</span> , blue , black = <span class="number">7</span>&#125;</span><br><span class="line"><span class="built_in">console</span>.log(Colors); <span class="comment">// &#123; '0': 'red', '2': 'green', '3': 'blue', '7': 'black', red: 0, green: 2, blue: 3 , black: 7&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 全部指定</span></span><br><span class="line"><span class="keyword">enum</span> Colors &#123;red = <span class="number">1</span>, green = <span class="number">3</span>, blue = <span class="number">5</span>&#125;</span><br><span class="line"><span class="built_in">console</span>.log(Colors); <span class="comment">// &#123; '1': 'red', '3': 'green', '5': 'blue', red: 1, green: 3, blue: 5 &#125;</span></span><br></pre></td></tr></table></figure><h4 id="接口-interface"><a href="#接口-interface" class="headerlink" title="接口 interface"></a>接口 interface</h4><h5 id="什么是接口"><a href="#什么是接口" class="headerlink" title="什么是接口"></a>什么是接口</h5><p>在面向对象的语言中，例如java。在java中，接口中的所有方法都是抽象的，这些方法都需要使用接口的类来实现</p><p>在ts中，接口是一个非常灵活的概念，除了可用于对类的一部分行为进行抽象，也常用于对对象的形状进行描述</p><h5 id="接口的最基础使用"><a href="#接口的最基础使用" class="headerlink" title="接口的最基础使用"></a>接口的最基础使用</h5><p>我们使用interface来声明一个接口，被声明的接口一般首字母大写。</p><p>注意:</p><blockquote><p>接口中的每一个属性的类型声明语句最好以分号（;）结尾</p></blockquote><p>例如，我们声明一个Person接口</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> Person&#123;</span><br><span class="line">    name: <span class="built_in">string</span>;</span><br><span class="line">    age: <span class="built_in">number</span>;</span><br><span class="line">    area: <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> ming: Person = &#123;</span><br><span class="line">    name: <span class="string">'ming'</span>,</span><br><span class="line">    age: <span class="number">18</span>,</span><br><span class="line">    area: <span class="string">'zh'</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(ming); <span class="comment">// &#123; name: 'ming', age: 18, area: 'zh' &#125;</span></span><br></pre></td></tr></table></figure><p>另外，类型检查器不会去检查属性的顺序，只要相应的属性存在并且类型也是对的就可以。</p><p>因此，以下使用Person接口来描述的对象也是允许的。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> lee: Person = &#123;</span><br><span class="line">    age: <span class="number">19</span>;</span><br><span class="line">    name: <span class="string">'lee'</span>;</span><br><span class="line">    area: <span class="string">'zh'</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是，我们需要记住，使用接口作为类型定义的变量形状与接口的形状必须保持一致（属性顺序可以调换，但是属性不能多也不能少）</p><p>例如：以下使用Person接口定义的变量是不被允许的</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Error</span></span><br><span class="line"><span class="keyword">let</span> ming: Person = &#123;</span><br><span class="line">    name: <span class="string">'ming'</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Error</span></span><br><span class="line"><span class="keyword">let</span> lee: Person = &#123;</span><br><span class="line">    name: <span class="string">'lee'</span>,</span><br><span class="line">    age: <span class="number">19</span>,</span><br><span class="line">    area: <span class="string">'zh'</span>,</span><br><span class="line">    city: <span class="string">'hz'</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="可选属性"><a href="#可选属性" class="headerlink" title="可选属性"></a>可选属性</h5><p>有时候，接口里的属性不全是必需的，例如Person接口中的area属性</p><p>那么，我们可以在接口中的属性名后面加上?来表示这是一个可选属性</p><p>例如：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> Person&#123;</span><br><span class="line">    name: <span class="built_in">string</span>;</span><br><span class="line">    age: <span class="built_in">number</span>;</span><br><span class="line">    area?: <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// area属性现在是可选属性了</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// OK</span></span><br><span class="line"><span class="keyword">let</span> ming: Person = &#123;</span><br><span class="line">    name: <span class="string">'ming'</span>,</span><br><span class="line">    age: <span class="number">18</span>,</span><br><span class="line">    area: <span class="string">'zh'</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// OK</span></span><br><span class="line"><span class="keyword">let</span> lee: Person = &#123;</span><br><span class="line">    name: <span class="string">'lee'</span>,</span><br><span class="line">    age: <span class="number">18</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="只读属性"><a href="#只读属性" class="headerlink" title="只读属性"></a>只读属性</h5><p>我们希望有些属性在创建的时候被赋值之后就无法再被修改，那么我们就可以使用readonly将该属性定义为只读属性</p><blockquote><p> 我们可以在属性名前用 readonly来指定只读属性</p></blockquote><p>例如：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> Person &#123;</span><br><span class="line">    readonly name: <span class="built_in">string</span>;</span><br><span class="line">    age: <span class="built_in">number</span>;</span><br><span class="line">    area: <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> ming: Person = &#123;</span><br><span class="line">    name: <span class="string">'ming'</span>,</span><br><span class="line">    age: <span class="number">18</span>,</span><br><span class="line">    area: <span class="string">'zh'</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// name属性现在无法被修改了</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// OK</span></span><br><span class="line">ming.age = <span class="number">19</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Error</span></span><br><span class="line">ming.name = <span class="string">'wang'</span>;</span><br></pre></td></tr></table></figure><h5 id="任意属性"><a href="#任意属性" class="headerlink" title="任意属性"></a>任意属性</h5><p>利用接口的属性可索引的特性，我们可以创建一个拥有任意属性的接口</p><p>例如：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> Person &#123;</span><br><span class="line">    readonly name: <span class="built_in">string</span>;</span><br><span class="line">    age: <span class="built_in">number</span>;</span><br><span class="line">    area?: <span class="built_in">string</span>;</span><br><span class="line">    [propName: <span class="built_in">string</span>]: <span class="built_in">any</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> ming: Person = &#123;</span><br><span class="line">    name: <span class="string">'ming'</span>,</span><br><span class="line">    age: <span class="number">18</span>,</span><br><span class="line">    city: <span class="string">'hz'</span> <span class="comment">// 接口中预先未定义的属性</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>需要注意的是：</p><blockquote><p>虽然定义了任意属性，但是接口中已有的确定的属性必须在声明的对象中表示</p></blockquote><p>比如这样声明的变量是不被允许的</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Error</span></span><br><span class="line"><span class="keyword">let</span> lee: Person = &#123;</span><br><span class="line">    age: <span class="number">19</span>,</span><br><span class="line">    city: <span class="string">'hz'</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>另外，一旦定义了任意属性，那么该接口中的其他确定属性和可选属性的类型必须是该任意属性定义的属性类型的子集</p><p>也就是说，像下面这样的情况是不被允许的</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Error</span></span><br><span class="line"><span class="keyword">interface</span> Person &#123;</span><br><span class="line">    readonly name: <span class="built_in">string</span>;</span><br><span class="line">    age: <span class="built_in">number</span>;</span><br><span class="line">    area?: <span class="built_in">string</span>;</span><br><span class="line">    <span class="comment">// 因为定义的任意属性的类型为string，但是age属性的number类型并不在string类型的子集中（string类型的子集包括string,undefined,number,never类型）</span></span><br><span class="line">    [propName: <span class="built_in">string</span>]: <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因此，如果要定义任意属性，那么任意属性的类型最好为任意值（Any）类型</p><h2 id="联合类型"><a href="#联合类型" class="headerlink" title="联合类型"></a>联合类型</h2><h3 id="联合类型的简单介绍"><a href="#联合类型的简单介绍" class="headerlink" title="联合类型的简单介绍"></a>联合类型的简单介绍</h3><p>有时候，我们希望一个变量可以在字符串类型和number类型之间相互转换；又或者，我们不确定某个变量的具体类型，只能知道其是string类型或者是是number类型。那么，我们就可以使用联合类型来声明一个变量</p><p>我们使用’|’来联合两个类型</p><p>例如：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> v: <span class="built_in">string</span>|<span class="built_in">number</span>;</span><br><span class="line">v = <span class="string">'123'</span>;</span><br><span class="line">v = <span class="built_in">parseInt</span>(v);</span><br><span class="line"><span class="built_in">console</span>.log(v,<span class="keyword">typeof</span> v); <span class="comment">// 123 number</span></span><br></pre></td></tr></table></figure><h3 id="联合类型的属性和方法访问"><a href="#联合类型的属性和方法访问" class="headerlink" title="联合类型的属性和方法访问"></a>联合类型的属性和方法访问</h3><p>我们要始终记住一点：</p><blockquote><p>当 TypeScript 不确定一个联合类型的变量到底是哪个类型的时候，我们只能访问此联合类型的所有类型里共有的属性或方法</p></blockquote><p>这段话是什么意思呢？</p><p>如果，ts可以确定一个联合类型的变量是什么类型，那么也就无关上述的限制了。这个被推断得到的类型只能访问和操作其所具有的属性和方法</p><p>例如：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> v: <span class="built_in">string</span>|<span class="built_in">number</span>;</span><br><span class="line">v = <span class="string">'123'</span>;</span><br><span class="line"><span class="comment">// OK (变量v被推断为string类型，它具有length属性) </span></span><br><span class="line"><span class="built_in">console</span>.log(v.length); <span class="comment">// 3</span></span><br><span class="line"></span><br><span class="line">v = <span class="number">123</span>;</span><br><span class="line"><span class="comment">// Error （这时候变量v被推断为number类型，它不具有length属性）</span></span><br><span class="line"><span class="built_in">console</span>.log(v.length);</span><br></pre></td></tr></table></figure><p>上述的规则，其实是适用于下述的场景（也就是ts无法确定这个联合类型的变量究竟是什么类型）</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params">v: <span class="built_in">string</span>|<span class="built_in">number</span></span>): <span class="title">void</span></span>&#123;</span><br><span class="line">    <span class="comment">// 在函数声明的时候，ts无法推断出v究竟是联合类型中的哪一个类型。因此，v只能访问和操作其所有具有的属性和方法</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// OK</span></span><br><span class="line">    <span class="built_in">console</span>.log(v.toString());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Error</span></span><br><span class="line">    <span class="built_in">console</span>.log(v.length);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="最基础的类型推论"><a href="#最基础的类型推论" class="headerlink" title="最基础的类型推论"></a>最基础的类型推论</h2><p>TypeScript里，在有些没有明确指出类型的地方，类型推论会帮助提供类型。</p><p>来看一些例子</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> u = <span class="literal">undefined</span>; <span class="comment">// undefined类型</span></span><br><span class="line"><span class="keyword">let</span> n = <span class="literal">null</span>; <span class="comment">// null类型</span></span><br><span class="line"><span class="keyword">let</span> str = <span class="string">'123'</span>; <span class="comment">// string类型</span></span><br><span class="line"><span class="keyword">let</span> num = <span class="number">123</span>; <span class="comment">// number类型</span></span><br><span class="line"><span class="keyword">let</span> bool = <span class="literal">true</span>; <span class="comment">// boolean类型</span></span><br><span class="line"><span class="keyword">let</span> obj = &#123;v:<span class="number">1</span>&#125;; <span class="comment">// object类型</span></span><br><span class="line"><span class="keyword">let</span> func = <span class="function"><span class="keyword">function</span> <span class="title">k</span>(<span class="params"></span>) </span>&#123;&#125;; <span class="comment">// object类型</span></span><br></pre></td></tr></table></figure><p>我们可以看到，如果在ts中没有为变量指定类型，那么ts的类型推断将会按照js中的类型进行类型指定。</p><p>注意是指定，这也意味着，在后续，ts不允许我们将变量修改为其他类型</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> str = <span class="string">'123'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 类型推论变量str为字符串类型，那么之后该变量的类型不允许被修改</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Error</span></span><br><span class="line">str = <span class="number">123</span>;</span><br></pre></td></tr></table></figure><p>另外，如果一个变量只是被声明（没有指定类型），而没有被定义。那么，该变量则会被推断为任意值（Any）类型</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// OK</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> str;</span><br><span class="line">str = <span class="string">'123'</span>;</span><br><span class="line">str = <span class="number">123</span>;</span><br></pre></td></tr></table></figure><p>相当于</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> str: <span class="built_in">any</span>;</span><br><span class="line">str = <span class="string">'123'</span>;</span><br><span class="line">str = <span class="number">123</span>;</span><br></pre></td></tr></table></figure><h2 id="类型断言"><a href="#类型断言" class="headerlink" title="类型断言"></a>类型断言</h2><p>类型断言有如下两种语法：</p><ol><li><p>尖括号语法</p> <figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a: <span class="built_in">any</span> = <span class="number">123</span>;</span><br><span class="line">(&lt;<span class="built_in">string</span>&gt;a) = <span class="string">'123'</span>;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> a); <span class="comment">// string</span></span><br></pre></td></tr></table></figure></li><li><p>as语法</p> <figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a: <span class="built_in">any</span> = <span class="number">123</span>;</span><br><span class="line">(a <span class="keyword">as</span> <span class="built_in">string</span>) = <span class="string">'123'</span>;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> a); <span class="comment">// string</span></span><br></pre></td></tr></table></figure></li></ol><p>ts允许我们为类型进行断言从而覆盖编译器的类型推断结果。</p><p>也就是说，</p><blockquote><p>通过类型断言，我们可以为一个变量指定一个类型。</p></blockquote><p>是不是很奇怪？我们不是在定义的时候就可以指定它的类型了吗？没错，是的。那是一开始就知道了它的具体类型，但是，如果一开始设定的不是基本类型和一些object,数组之类的类型，而是any类型。</p><p>那么，我们可能不知道他会在后面变化为了什么类型，但是ts的类型推论可以推论出这是什么类型。</p><p>而类型断言，则是允许我们来断定这个类型是什么类型。某种程度上，在这一刻我们超越了编译器。</p><blockquote><p>类型断言通常会发生在你清楚地知道一个实体具有比它现有类型更确切的类型。</p></blockquote><p>例如：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> m: <span class="built_in">any</span>;</span><br><span class="line">m = <span class="number">123</span>; <span class="comment">// 类型推论会推论该类型为number类型</span></span><br><span class="line">(&lt;<span class="built_in">string</span>&gt;m) = <span class="string">'123'</span>; <span class="comment">// 现在我们断言m是string类型</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> m); <span class="comment">// string</span></span><br></pre></td></tr></table></figure><p>是不是觉得好像没什么用，那么再来一个更为实际的应用（我们之前在联合类型写过的一个函数）,</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params">v: <span class="built_in">string</span>|<span class="built_in">number</span></span>): <span class="title">void</span></span>&#123;</span><br><span class="line">    <span class="comment">// 在函数声明的时候，ts无法推断出v究竟是联合类型中的哪一个类型。因此，v只能访问和操作其所有具有的属性和方法</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// OK</span></span><br><span class="line">    <span class="built_in">console</span>.log(v.toString());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Error</span></span><br><span class="line">    <span class="built_in">console</span>.log(v.length);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们无法在被声明联合类型的变量访问联合类型不公有的属性和方法。但是，利用类型断言就可以将一个联合类型的变量指定更为具体的类型</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params">v: <span class="built_in">string</span>|<span class="built_in">number</span></span>): <span class="title">void</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">typeof</span> v === <span class="string">'string'</span>) &#123;</span><br><span class="line">        <span class="comment">// 如果我们传入的实参为string类型，那么我们断言该类型为string类型，那么此时v就是string类型，因此也就可以调用length属性了</span></span><br><span class="line">        <span class="built_in">console</span>.log((&lt;<span class="built_in">string</span>&gt;v).length);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(v);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">test(<span class="string">'str'</span>); <span class="comment">// 3</span></span><br><span class="line">test(<span class="number">1</span>); <span class="comment">// 1</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;基本注解&quot;&gt;&lt;a href=&quot;#基本注解&quot; class=&quot;headerlink&quot; title=&quot;基本注解&quot;&gt;&lt;/a&gt;基本注解&lt;/h2&gt;&lt;p&gt;类型注解使用 :TypeAnnotation 语法。类型声明空间中可用的任何内容都可以用作类型注解。&lt;/p&gt;
&lt;p&gt;例如，在
      
    
    </summary>
    
      <category term="TypeScript" scheme="http://yoursite.com/categories/TypeScript/"/>
    
    
  </entry>
  
  <entry>
    <title>ts新手的vscode环境配置</title>
    <link href="http://yoursite.com/2019/10/22/ts%E6%96%B0%E6%89%8B%E7%9A%84vscode%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/"/>
    <id>http://yoursite.com/2019/10/22/ts新手的vscode环境配置/</id>
    <published>2019-10-22T12:25:15.000Z</published>
    <updated>2019-10-25T09:11:05.741Z</updated>
    
    <content type="html"><![CDATA[<h2 id="安装TypeScript"><a href="#安装TypeScript" class="headerlink" title="安装TypeScript"></a>安装TypeScript</h2><p>通过npm/cnpm来安装TypeScript的命令行工具</p><blockquote><p>cnpm i -g typescript</p></blockquote><h2 id="创建TypeSscript项目配置文件"><a href="#创建TypeSscript项目配置文件" class="headerlink" title="创建TypeSscript项目配置文件"></a>创建TypeSscript项目配置文件</h2><h3 id="tsconfig-json概述"><a href="#tsconfig-json概述" class="headerlink" title="tsconfig.json概述"></a>tsconfig.json概述</h3><p>如果一个目录下存在一个tsconfig.json文件，那么它意味着这个目录是TypeScript项目的根目录。 tsconfig.json文件中指定了用来编译这个项目的根文件和编译选项。 </p><p>一个项目可以通过以下方式之一来编译：</p><ol><li><p>使用tsconfig.json<br>不带任何输入文件的情况下调用tsc，编译器会从当前目录开始去查找tsconfig.json文件，逐级向上搜索父目录。</p></li><li><p>不带任何输入文件的情况下调用tsc，且使用命令行参数–project（或-p）指定一个包含tsconfig.json文件的目录。<br>当命令行上指定了输入文件时，tsconfig.json文件会被忽略。</p></li></ol><h3 id="创建与配置"><a href="#创建与配置" class="headerlink" title="创建与配置"></a>创建与配置</h3><ol><li><p>创建tsconfig.json文件</p><blockquote><p>tsc –init</p></blockquote></li><li><p>修改配置项</p><p> 因为ts文件会被编译生成一个js文件。因此，为了文件结构的清晰。我们可以创建ts源文件夹和js输出文件夹。并在tsconfig.json文件修改配置项</p><p> 以下为我的配置项</p> <figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"compilerOptions"</span>: &#123;</span><br><span class="line">        <span class="attr">"target"</span>: <span class="string">"es5"</span>,         </span><br><span class="line">        <span class="attr">"module"</span>: <span class="string">"commonjs"</span>,</span><br><span class="line">        <span class="attr">"sourceMap"</span>: <span class="literal">true</span>,</span><br><span class="line">        <span class="attr">"strict"</span>: <span class="literal">true</span>,</span><br><span class="line">        <span class="attr">"outDir"</span>: <span class="string">"./js"</span>, </span><br><span class="line">        <span class="attr">"rootDir"</span>: <span class="string">"./ts"</span>,</span><br><span class="line">        <span class="attr">"noImplicitAny"</span>: <span class="literal">false</span>,</span><br><span class="line">        <span class="attr">"strictNullChecks"</span>: <span class="literal">false</span>,</span><br><span class="line">        <span class="attr">"alwaysStrict"</span>: <span class="literal">false</span>,</span><br><span class="line">        <span class="attr">"esModuleInterop"</span>: <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p>更多配置项信息请查看<a href="https://www.tslang.cn/docs/handbook/tsconfig-json.html" target="_blank" rel="noopener">TypeScript官方文档</a></p><h2 id="创建ts文件，并编写ts程序"><a href="#创建ts文件，并编写ts程序" class="headerlink" title="创建ts文件，并编写ts程序"></a>创建ts文件，并编写ts程序</h2><p>我们在ts文件夹中新建一个hello.ts，并键入如下ts程序</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> str: <span class="built_in">string</span> = <span class="string">'123'</span>;</span><br><span class="line"><span class="built_in">console</span>.log(str);</span><br></pre></td></tr></table></figure><h2 id="自动编译"><a href="#自动编译" class="headerlink" title="自动编译"></a>自动编译</h2><p>我们可以采取两种方式来进行自动编译</p><ol><li><p>命令行</p><blockquote><p>tsc –watch  /  tsc -w</p></blockquote><p> 在监视模式下运行编译器。会监视输出文件，在它们改变时重新编译。</p></li><li><p>菜单栏</p><p> 我们可以在vscode菜单栏中点击</p><blockquote><p>终端 -&gt; 运行任务</p></blockquote><p> 可以看到两个可选项</p><ol><li>tsc:build （进行一次编译）</li><li>tsc:watch （监测ts文件的改动进行实时编译）</li></ol></li></ol><p>这样，我们既可以在js文件夹中找到同名的编译好的js文件</p><h2 id="执行ts文件"><a href="#执行ts文件" class="headerlink" title="执行ts文件"></a>执行ts文件</h2><p>我们可以利用ts-node这个npm包来帮助我们执行ts文件，而不用预先编译ts文件为js文件</p><p>我们可以这样来执行</p><blockquote><p>npx ts-node ./ts/hello.ts</p></blockquote><h2 id="热加载ts文件执行"><a href="#热加载ts文件执行" class="headerlink" title="热加载ts文件执行"></a>热加载ts文件执行</h2><h3 id="nodemon监听生成的Js文件"><a href="#nodemon监听生成的Js文件" class="headerlink" title="nodemon监听生成的Js文件"></a>nodemon监听生成的Js文件</h3><p>我们不希望每次在修改ts文件之后都要重新进行ts-node来执行。因此，我想到了利用tsc -w来监视ts文件的变动，然后用nodemon来监视ts生成的js文件的变动。</p><p>因此，我们可以借助concurrently这个npm包来帮助我们同时运行多个命令</p><p>安装nodemon</p><blockquote><p>cnpm i nodemon -D</p></blockquote><p>在package.json添加启动命令</p><blockquote><p>“start”: “concurrently &quot; tsc -w&quot; &quot;nodemon js/hello.js&quot; “</p></blockquote><p>因为我们要在双引号中还要使用双引号，所以要使用转义符</p><p>之后我们在执行npm start的时候，修改ts文件的时候就可以看到执行结果的热更新了</p><h3 id="监听ts源文件"><a href="#监听ts源文件" class="headerlink" title="监听ts源文件"></a>监听ts源文件</h3><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;<span class="attr">"watch-server"</span>:<span class="string">"nodemon --watch ./ts/app.ts -e ts,tsx --exec ts-node ./ts/app.ts"</span>&#125;</span><br></pre></td></tr></table></figure><h2 id="编写node程序"><a href="#编写node程序" class="headerlink" title="编写node程序"></a>编写node程序</h2><p>Node.js 不是内置对象的一部分，如果想用 TypeScript 写 Node.js，则需要引入第三方声明文件：</p><blockquote><p>cnpm i @types/node -D</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;安装TypeScript&quot;&gt;&lt;a href=&quot;#安装TypeScript&quot; class=&quot;headerlink&quot; title=&quot;安装TypeScript&quot;&gt;&lt;/a&gt;安装TypeScript&lt;/h2&gt;&lt;p&gt;通过npm/cnpm来安装TypeScript的命令行工具&lt;
      
    
    </summary>
    
      <category term="TypeScript" scheme="http://yoursite.com/categories/TypeScript/"/>
    
    
  </entry>
  
  <entry>
    <title>浏览器的几种存储方式</title>
    <link href="http://yoursite.com/2019/10/21/%E6%B5%8F%E8%A7%88%E5%99%A8%E7%9A%84%E5%87%A0%E7%A7%8D%E5%AD%98%E5%82%A8%E6%96%B9%E5%BC%8F/"/>
    <id>http://yoursite.com/2019/10/21/浏览器的几种存储方式/</id>
    <published>2019-10-21T08:05:06.000Z</published>
    <updated>2019-10-22T07:48:28.648Z</updated>
    
    <content type="html"><![CDATA[<h2 id="cookie"><a href="#cookie" class="headerlink" title="cookie"></a>cookie</h2><p>cookie的介绍移步另一篇blog  <a href="http://angellikefairy.coding.me/2019/10/20/cookie%E4%B8%8Esession/" target="_blank" rel="noopener">cookie与session</a></p><h2 id="webStorage"><a href="#webStorage" class="headerlink" title="webStorage"></a>webStorage</h2><p>由于cookie的存储的存储数据不能超过4k，并且每次请求都会携带在请求头中，对于请求性能会产生影响。因此，为了更大数据的存储，降低对请求性能的影响以及安全方面的考虑，html5引入了webStorage来进行客户端的存储</p><p>与cookie不同，webStorage的存储限制更大（至少5M）</p><p>Web存储按来源进行。所有页面，如果是同源的话，都可以存储和访问相同的数据。（因此,webStorage也存在跨域问题）</p><h3 id="localStorage"><a href="#localStorage" class="headerlink" title="localStorage"></a>localStorage</h3><p>localStorage保存的数据会长期存在，只要你不删除，那么他就会一直存在。</p><h4 id="localStorage的使用"><a href="#localStorage的使用" class="headerlink" title="localStorage的使用"></a>localStorage的使用</h4><p>localStorage保存的数据，以“键值对”的形式存在。也就是说，每一项数据都有一个键名和对应的值。所有的数据都是以文本格式保存。</p><p>localStorage对象提供4个API来进行存储的相关操作</p><ol><li>localStorage.setItem(key,value) 存储数据</li><li>localStorage.getItem(key) 读取某一项</li><li>localStorage.removeItem(key) 删除某一项</li><li>localStorage.clear() 清空所有数据</li></ol><h5 id="localStorage存储对象"><a href="#localStorage存储对象" class="headerlink" title="localStorage存储对象"></a>localStorage存储对象</h5><p>需要注意的是，在webStorage中，名称/值对始终存储为字符串。</p><p>因此，我们会发现，当你存储其他类型的值时，键值对都会被强制转型为字符串</p><p>例如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">localStorage.setItem(<span class="string">'a'</span>,<span class="number">1</span>);</span><br><span class="line">localStorage.setItem(<span class="string">'b'</span>,<span class="literal">undefined</span>);</span><br><span class="line">localStorage.setItem(<span class="string">'c'</span>,&#123;<span class="attr">c</span>:<span class="number">1</span>&#125;);</span><br></pre></td></tr></table></figure><p>当我们使用存储api进行存储后，打开浏览器的webStorage选项，我们可以看到如下：</p><p><img src="https://s2.ax1x.com/2019/10/22/K3YR0S.png" alt></p><p>我们可以来查看一下这三个键值的类型</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> localStorage.getItem(<span class="string">'a'</span>)); <span class="comment">// string</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> localStorage.getItem(<span class="string">'b'</span>)); <span class="comment">// string</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> localStorage.getItem(<span class="string">'c'</span>)); <span class="comment">// string</span></span><br></pre></td></tr></table></figure><p>我们会发现，无论哪种类型的值确实是都被存为了String类型，而且是通过String()转型函数的。因为,toString()方法不能转型undefiend和null（这里插一句，因为toString()方法只有对象才能够具有和使用，而Number,Boolean在读取的时候会作为基本包装类型（只存在一行中）所以具有toString()方法）。</p><p>我们可以看到，基本类型值转换为字符串我们还可以通过转型函数来将他们转换回来。那么对于对象呢？其实，我们可以通过JSON序列化来存入JSON字符串，之后再通过JSON解析的方式来进行存储和读取</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123;<span class="attr">m</span>:<span class="number">1</span>&#125;;</span><br><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>];</span><br><span class="line"></span><br><span class="line">localStorage.setItem(<span class="string">'obj'</span>,<span class="built_in">JSON</span>.stringify(obj));</span><br><span class="line">localStorage.setItem(<span class="string">'arr'</span>,<span class="built_in">JSON</span>.stringify([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]));</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">JSON</span>.parse(localStorage.getItem(<span class="string">'obj'</span>))); <span class="comment">// &#123;m:1&#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">JSON</span>.parse(localStorage.getItem(<span class="string">'arr'</span>))); <span class="comment">// [1,2,3]</span></span><br></pre></td></tr></table></figure><p>这时我们可以看到浏览器的webStorage存储的键值是JSON字符串，因此，我们也可以通过JSON解析成功得到对象</p><p><img src="https://s2.ax1x.com/2019/10/22/K3Y2m8.png" alt></p><p>但是，这种方法无法处理函数对象。因为JSON不支持函数。</p><h4 id="localStorage的使用场景"><a href="#localStorage的使用场景" class="headerlink" title="localStorage的使用场景"></a>localStorage的使用场景</h4><p>我们可以使用localStorage来作为本地缓存。比如说在网页在首屏渲染的时候，我们可以将一些更新不频繁的文件或静态资源储存在localStorage来加快首屏渲染速度</p><h3 id="sessionStorage"><a href="#sessionStorage" class="headerlink" title="sessionStorage"></a>sessionStorage</h3><p>sessionStorage 与 localStorage 相似，不同之处在于 localStorage 里面存储的数据没有过期时间设置，而存储在 sessionStorage 里面的数据在页面会话结束时会被清除。</p><p>页面会话在浏览器打开期间一直保持，并且重新加载或恢复页面仍会保持原来的页面会话。而在新标签或窗口打开一个页面时会在顶级浏览上下文中初始化一个新的会话，这点和 session cookies 的运行方式不同。</p><p>sesseionStorage的api与localStorage一致</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 保存数据到 sessionStorage</span></span><br><span class="line">sessionStorage.setItem(<span class="string">'key'</span>, <span class="string">'value'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 从 sessionStorage 获取数据</span></span><br><span class="line"><span class="keyword">let</span> data = sessionStorage.getItem(<span class="string">'key'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 从 sessionStorage 删除保存的数据</span></span><br><span class="line">sessionStorage.removeItem(<span class="string">'key'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 从 sessionStorage 删除所有保存的数据</span></span><br><span class="line">sessionStorage.clear();</span><br></pre></td></tr></table></figure><h3 id="IndexedDB简单介绍"><a href="#IndexedDB简单介绍" class="headerlink" title="IndexedDB简单介绍"></a>IndexedDB简单介绍</h3><p>由于webStorage仍然具有一些缺点：</p><ol><li>随着web应用程序的不断发展,5M的存储大小对于一些大型的web应用程序来说有些不够</li><li>web Storage只能存储string类型的数据.对于Object类型的数据只能先用JSON.stringify()转换一下在存储.</li></ol><p>因此，就又有了浏览器数据库存储这个概念，也就是IndexedDB</p><blockquote><p>IndexedDB 是一种在用户浏览器中持久存储数据的方法。它允许您不考虑网络可用性，创建具有丰富查询能力的可离线 Web 应用程序。IndexedDB 对于存储大量数据的应用程序（例如借阅库中的 DVD 目录）和不需要持久 Internet 连接的应用程序（例如邮件客户端、待办事项列表或记事本）很有用。</p></blockquote><h4 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h4><ol><li><p>IndexedDB 数据库使用 key-value 键值对储存数据. </p><p> values 数据可以是结构非常复杂的对象，key可以是对象自身的属性。你可以对对象的任何属性创建索引（index）以实现快速查询和列举排序。key可以是二进制对象。</p></li><li><p>IndexedDB 是事务模式的数据库. </p><p> 任何操作都发生在事务(transaction)中。  IndexedDB API提供了索引(indexes)、表(tables)、指针(cursors)等等，但是所有这些必须是依赖于某种事务的。因此，你不能在事务外执行命令或者打开指针。事务(transaction)有生存周期，在生存周期以后使用它会报错。并且，事务(transaction)是自动提交的，不可以手动提交。</p><p> 当用户在不同的标签页同时打开Web应用的两个实例时，这个事务模型就会非常有用。如果没有事务操作的支持，这两个实例就会互相影响对方的修改。</p></li><li><p>The IndexedDB API 基本上是异步的。 </p><p> IndexedDB的API不通过return语句返回数据，而是需要你提供一个回调函数来接受数据。执行API时，你不以同步（synchronous）方式对数据库进行“存储”和“读取”操作，而是向数据库发送一个操作“请求”。当操作完成时，数据库会以DOM事件的方式通知你，同时事件的类型会告诉你这个操作是否成功完成。这个过程听起来会有些复杂，但是里面是有明智的原因的。这个和XMLHttpRequest请求是类似的</p></li><li><p>IndexedDB在结果准备好之后通过DOM事件通知用户。 </p><p> DOM事件总是有一个类型（type）属性（在IndexedDB中，该属性通常设置为success或error）。DOM事件还有一个目标（target）属性，用来告诉事件是被谁触发的。通常情况下，目标（target）属性是数据库操作生成的IDBRequest。成功（success）事件不弹出提示并且不能撤销，错误（error）事件会弹出提示且可以撤销。这一点是非常重要的，因为除非错误事件被撤销，否则他们会终止所在的任何事务。</p></li><li><p>IndexedDB是面向对象的。</p><p> 传统的关系型数据库，你需要用到二维表来存储数据集合（每一行代表一个数据，每一列代表一个属性），indexedDB有所不同，它要求你为一种数据创建一个对象仓库(object Store)，只要这种数据是一个JavaScript对象即可。每个对象仓库都有一个索引(index)集合以方便查询和迭代遍历。</p></li><li><p>IndexedDB遵循同源（same-origin）策略 </p><p> “源”指脚本所在文档URL的域名、应用层协议和端口。每一个“源”都有与其相关联的数据库。在同一个“源”内的所有数据库都有唯一、可区别的名称。</p></li></ol><h4 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h4><h5 id="打开数据库"><a href="#打开数据库" class="headerlink" title="打开数据库"></a>打开数据库</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> req = indexedDB.open(<span class="string">'firstDB'</span>);</span><br><span class="line"></span><br><span class="line">req.addEventListener(<span class="string">'success'</span>,()=&gt;&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'数据库连接成功'</span>);</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">req.addEventListener(<span class="string">'error'</span>,()=&gt;&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'数据库连接失败'</span>);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>open 请求不会立即打开数据库或者开始一个事务。 对 open() 函数的调用会返回一个我们可以作为事件来处理的包含 result（成功的话）或者错误值的 IDBOpenDBRequest 对象。在 IndexedDB 中的大部分异步方法做的都是同样的事情 - 返回一个包含 result 或错误的 IDBRequest 对象。open 函数的结果是一个 IDBDatabase 对象的实例。</p><p>在通过对indexedDB.open()方法拿到一个数据库对象IDBOpenDBRequest我们可以通过监听这个对象的success事件和error事件来执行相应的操作.</p><p>该 open 方法接受第二个参数，就是数据库的版本号。数据库的版本决定了数据库架构，即数据库的对象仓库（object store）和他的结构。如果数据库不存在，open 操作会创建该数据库，然后 onupgradeneeded 事件被触发，你需要在该事件的处理函数中创建数据库模式。如果数据库已经存在，但你指定了一个更高的数据库版本，会直接触发 onupgradeneeded 事件，允许你在处理函数中更新数据库模式。</p><h5 id="创建对象仓库"><a href="#创建对象仓库" class="headerlink" title="创建对象仓库"></a>创建对象仓库</h5><p>连接到数据库之后，我们就可以创建对象仓库来存储数据。对象仓库的概念类似于Mysql中的表的概念</p><blockquote><p>要创建一个对象仓库必须在upgradeneeded事件中,而upgradeneeded事件只会在版本号更新的时候触发.这是因为indexedDB API中不允许数据库中的数据仓库在同一版本中发生变化</p></blockquote><p>另外，我们使用createObjectStore()方法来创建对象仓库。</p><blockquote><p>createObjectStore()方法接受两个参数,第一个是对象仓库的名字,在同一数据库中,仓库名不能重复.第二个是可选参数.用于指定数据的主键,以及是否自增主键.</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> req = indexedDB.open(<span class="string">'firstDB'</span>,<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">req.addEventListener(<span class="string">'error'</span>,()=&gt;&#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'数据库连接失败'</span>);</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">req.addEventListener(<span class="string">'upgradeneeded'</span>,<span class="function"><span class="keyword">function</span>(<span class="params">e</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> db = e.target.result;</span><br><span class="line">    db.createObjectStore(<span class="string">'Users'</span>,&#123;<span class="attr">keyPath</span>:<span class="string">'userId'</span>,<span class="attr">autoIncrement</span>:<span class="literal">false</span>&#125;);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'创建对象仓库成功'</span>);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h5 id="创建事务"><a href="#创建事务" class="headerlink" title="创建事务"></a>创建事务</h5><p>我们需要创建事务来确保一个数据库操作要么全部成功要么全部失败。比如，我们在一个操作中，要修改多条数据。如果前面几条成功了，最后一条失败了。那么事务的存在就会使得前面所有的成功修改的操作失效，放弃数据修改</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> tx = db.transaction(<span class="string">'Users'</span>,<span class="string">'readwrite'</span>);</span><br></pre></td></tr></table></figure><p>我们使用transaction()来创建一个事务.transaction()接受两个参数,第一个是你要操作的对象仓库名称,第二个是你创建的事务模式.传入 readonly时只能对对象仓库进行读操作,无法写操作.可以传入readwrite进行读写操作.</p><h5 id="操作数据"><a href="#操作数据" class="headerlink" title="操作数据"></a>操作数据</h5><p>我们可以使用以下四种api来进行数据的操作</p><ol><li>add() : 增加数据。接收一个参数，为需要保存到对象仓库中的对象。</li><li>put() : 增加或修改数据。接收一个参数，为需要保存到对象仓库中的对象。</li><li>get() : 获取数据。接收一个参数，为需要获取数据的主键值。</li><li>delete() : 删除数据。接收一个参数，为需要获取数据的主键值</li></ol><h5 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h5><p>到这里，我们就可以创建一个数据库以及对象仓库来进行数据的存储操作了。</p><p>以下是完整代码及解释</p><p>创建数据库和对象仓库</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 连接数据库，如果没有该数据库则创建</span></span><br><span class="line"><span class="keyword">const</span> req = indexedDB.open(<span class="string">'firstDB'</span>,<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 监听数据库连接失败处理程序</span></span><br><span class="line">req.addEventListener(<span class="string">'error'</span>,()=&gt;&#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'数据库连接失败'</span>);</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在版本更新阶段阶段对象仓库（类似于mysql中的表）</span></span><br><span class="line">req.addEventListener(<span class="string">'upgradeneeded'</span>,<span class="function"><span class="keyword">function</span>(<span class="params">e</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 得到数据库对象</span></span><br><span class="line">    <span class="keyword">let</span> db = e.target.result;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建对象仓库</span></span><br><span class="line">    db.createObjectStore(<span class="string">'Users'</span>,&#123;<span class="attr">keyPath</span>:<span class="string">'userId'</span>,<span class="attr">autoIncreament</span>:<span class="literal">false</span>&#125;);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>添加数据</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> req = indexedDB.open(<span class="string">'firstDB'</span>);</span><br><span class="line"></span><br><span class="line">req.addEventListener(<span class="string">'success'</span>,<span class="function"><span class="keyword">function</span>(<span class="params">e</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 获得数据库对象</span></span><br><span class="line">    <span class="keyword">let</span> db = e.target.result;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建事务，transaction() 方法接受两个参数（一个是可选的）并返回一个事务对象。第一个参数是事务希望跨越的对象存储空间的列表。如果你希望事务能够跨越所有的对象存储空间你可以传入一个空数组。如果你没有为第二个参数指定任何内容，你得到的是只读事务。如果你想写入数据，你需要传入 "readwrite" 标识。</span></span><br><span class="line">    <span class="keyword">const</span> tx = db.transaction([<span class="string">'Users'</span>],<span class="string">'readwrite'</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 取出对象仓库</span></span><br><span class="line">    <span class="keyword">const</span> store = tx.objectStore(<span class="string">'Users'</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 添加数据</span></span><br><span class="line">    <span class="keyword">let</span> addReq = store.add(&#123;</span><br><span class="line">        userId: <span class="number">1</span>,</span><br><span class="line">        name: <span class="string">'xiaoMing'</span>,</span><br><span class="line">        age: <span class="number">18</span>,</span><br><span class="line">        area: <span class="string">'zhejiang'</span></span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 监听数据是否添加成功</span></span><br><span class="line">    addReq.addEventListener(<span class="string">'success'</span>,()=&gt;&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'数据保存成功'</span>);</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;cookie&quot;&gt;&lt;a href=&quot;#cookie&quot; class=&quot;headerlink&quot; title=&quot;cookie&quot;&gt;&lt;/a&gt;cookie&lt;/h2&gt;&lt;p&gt;cookie的介绍移步另一篇blog  &lt;a href=&quot;http://angellikefairy.cod
      
    
    </summary>
    
      <category term="浏览器" scheme="http://yoursite.com/categories/%E6%B5%8F%E8%A7%88%E5%99%A8/"/>
    
    
  </entry>
  
  <entry>
    <title>cookie与session</title>
    <link href="http://yoursite.com/2019/10/20/cookie%E4%B8%8Esession/"/>
    <id>http://yoursite.com/2019/10/20/cookie与session/</id>
    <published>2019-10-20T05:43:09.000Z</published>
    <updated>2019-10-21T07:41:18.868Z</updated>
    
    <content type="html"><![CDATA[<h2 id="cookie"><a href="#cookie" class="headerlink" title="cookie"></a>cookie</h2><h3 id="什么是cookie"><a href="#什么是cookie" class="headerlink" title="什么是cookie"></a>什么是cookie</h3><p>cookie 是服务器发送到用户浏览器并保存在本地的一小块数据，它会在浏览器下次向同一服务器再发起请求时被携带并发送到服务器上。通常，它用于告知服务端两个请求是否来自同一浏览器，如保持用户的登录状态。</p><p><img src="https://s2.ax1x.com/2019/10/20/KKCqeA.png" alt></p><p>我们知道http协议是无状态协议，也就是说服务器不知道是哪个浏览器在访问它。但是，利用cookie我们就可以使得http协议记录稳定的状态信息</p><p>cookie主要用于以下三个方面：</p><ol><li>会话状态管理（如用户登录状态、购物车、游戏分数或其他需要记录的信息）</li><li>个性化设置（如用户自定义设置、主题等）</li><li>浏览器行为跟踪（如跟踪分析用户行为等）</li></ol><p>Cookie曾一度用于客户端数据的存储，因当时并没有其它合适的存储办法而作为唯一的存储手段，但现在随着现代浏览器开始支持各种各样的存储方式，Cookie渐渐被淘汰。由于服务器指定Cookie后，浏览器的每次请求都会携带Cookie数据，会带来额外的性能开销（尤其是在移动环境下）。新的浏览器API已经允许开发者直接将数据存储到本地，如使用 Web storage API （本地存储和会话存储）或 IndexedDB 。</p><h3 id="cookie的创建"><a href="#cookie的创建" class="headerlink" title="cookie的创建"></a>cookie的创建</h3><p>当服务器收到HTTP请求时，服务器可以在响应头里面添加一个Set-Cookie选项。浏览器收到响应后通常会保存下Cookie，之后对该服务器每一次请求中都通过Cookie请求头部将Cookie信息发送给服务器。另外，Cookie的过期时间、域、路径、有效期、适用站点都可以根据需要来指定。</p><p>服务器使用<strong>Set-Cookie响应头部</strong>向用户代理（一般是浏览器）发送Cookie信息。</p><p>使用node.js来为请求创建cookie</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> http = <span class="built_in">require</span>(<span class="string">'http'</span>);</span><br><span class="line"></span><br><span class="line">http.createServer(<span class="function">(<span class="params">req,res</span>)=&gt;</span>&#123;</span><br><span class="line">    res.setHeader(<span class="string">'Content-Type'</span>,<span class="string">'text/html'</span>);</span><br><span class="line">    res.setHeader(<span class="string">'Set-Cookie'</span>,[<span class="string">'name=zhangsan'</span>, <span class="string">'userId=123456'</span>]);</span><br><span class="line">    res.end(<span class="string">'set-cookie'</span>);</span><br><span class="line">&#125;).listen(<span class="number">3000</span>,()=&gt;&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'Port 3000 is listening'</span>);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>上述程序为<a href="http://localhost:3000请求设置了Set-Cookie响应头。所有的cookie键值对被存放在一个数组中。" target="_blank" rel="noopener">http://localhost:3000请求设置了Set-Cookie响应头。所有的cookie键值对被存放在一个数组中。</a></p><p>响应头部分信息如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Response Headers</span><br><span class="line"></span><br><span class="line">Connection: keep-alive</span><br><span class="line">Content-Length: 10</span><br><span class="line">Content-Type: text/html</span><br><span class="line">Date: Sun, 20 Oct 2019 06:11:45 GMT</span><br><span class="line">Set-Cookie: name=zhangsan</span><br><span class="line">Set-Cookie: userId=123456</span><br></pre></td></tr></table></figure><p>设置完毕之后，该浏览器再对该服务器发送的每一次新请求都会携带保存的cookie信息通过Cookie请求头部发送给服务器</p><p>请求头部分信息如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Accept: text/html,application/xhtml+xml,</span><br><span class="line">Cache-Control: no-cache</span><br><span class="line">Connection: keep-alive</span><br><span class="line">Cookie: _ga=GA1.1.608774072.1562924708; type=ninja; language=javascript; name=zhangsan; userId=123456</span><br></pre></td></tr></table></figure><h3 id="cookie的有效期"><a href="#cookie的有效期" class="headerlink" title="cookie的有效期"></a>cookie的有效期</h3><h4 id="会话期cookie"><a href="#会话期cookie" class="headerlink" title="会话期cookie"></a>会话期cookie</h4><p>会话期Cookie是最简单的Cookie：浏览器关闭之后它会被自动删除，也就是说它仅在会话期内有效。会话期Cookie不需要指定过期时间（Expires）或者有效期（Max-Age）。需要注意的是，有些浏览器提供了会话恢复功能，这种情况下即使关闭了浏览器，会话期Cookie也会被保留下来，就好像浏览器从来没有关闭一样。</p><p>我们可以注意到，当cookie是会话期cookie的时候（也就是只存在于一次会话期），其Expires字段就会被设置为session(会话存储)。</p><p><img src="https://s2.ax1x.com/2019/10/20/KKARCq.png" alt></p><p>现在，我们来验证下会话期cookie是否在浏览器关闭后就会被自动删除，同时我们需要重新修改一下之前的程序，使得这次可以判断浏览器是否携带了cookie</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> http = <span class="built_in">require</span>(<span class="string">'http'</span>);</span><br><span class="line"></span><br><span class="line">http.createServer(<span class="function">(<span class="params">req,res</span>)=&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(req.headers.cookie)&#123;</span><br><span class="line">        res.setHeader(<span class="string">'Content-Type'</span>,<span class="string">'text/html;charset=utf-8;'</span>);</span><br><span class="line">        res.end(<span class="string">'浏览器携带了cookie'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'浏览器没有携带cookie信息，那么我们为其设置cookie信息'</span>);</span><br><span class="line">        res.setHeader(<span class="string">'Set-Cookie'</span>,[<span class="string">'name=zhangsan'</span>,<span class="string">'userId=123456'</span>]);</span><br><span class="line">        res.setHeader(<span class="string">'Content-Type'</span>,<span class="string">'text/html;charset=utf-8;'</span>);</span><br><span class="line">        res.end(<span class="string">'服务器设置了cookie'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;).listen(<span class="number">3000</span>,()=&gt;&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'Port 3000 is listening'</span>);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>现在，我们关闭浏览器之后重新打开并访问http:localhost:3000我们可以发现服务器端控制台输出：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 浏览器没有携带cookie信息，那么我们为其设置cookie信息</span></span><br><span class="line"><span class="comment">// 浏览器携带了cookie</span></span><br></pre></td></tr></table></figure><p>为什么会输出这样呢？而不是仅仅只输出第一句呢？其实是因为浏览器会默认请求两次，一次是请求该url也就是<a href="http://localhost:3000;而另一次，则是请求该网站的logo(favicon.ico)" target="_blank" rel="noopener">http://localhost:3000;而另一次，则是请求该网站的logo(favicon.ico)</a></p><p>我们可以查看chrome中的network，我们就可以发现请求<a href="http://localhost:3000时的请求头没有携带cookie，因此服务端为其设置了cookie；然后在请求favicon.ico的时候就携带上了刚刚设置的cookie" target="_blank" rel="noopener">http://localhost:3000时的请求头没有携带cookie，因此服务端为其设置了cookie；然后在请求favicon.ico的时候就携带上了刚刚设置的cookie</a></p><blockquote><p>Cookie: name=zhangsan; userId=123456</p></blockquote><p>请求<a href="http://localhost:3000（没有Cookie请求头）" target="_blank" rel="noopener">http://localhost:3000（没有Cookie请求头）</a></p><p><img src="https://s2.ax1x.com/2019/10/20/KK3OTx.png" alt></p><p>请求favion.ico（有Cookie请求头）</p><p><img src="https://s2.ax1x.com/2019/10/20/KK3jk6.png" alt></p><p>因此，我们验证了会话期cookie在浏览器被关闭后就会被自动删除</p><h4 id="持久性cookie"><a href="#持久性cookie" class="headerlink" title="持久性cookie"></a>持久性cookie</h4><p>和关闭浏览器便失效的会话期Cookie不同，持久性Cookie可以指定一个特定的过期时间（Expires）或有效期（Max-Age）。</p><p>例如：</p><blockquote><p>Set-Cookie: id=a3fWa; Expires=Wed, 21 Oct 2015 07:28:00 GMT;</p></blockquote><p>我们可以修改之前的设置cookie程序，来设置cookie的同时并设置有效期（单位为毫秒）</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> http = <span class="built_in">require</span>(<span class="string">'http'</span>);</span><br><span class="line"></span><br><span class="line">http.createServer(<span class="function">(<span class="params">req,res</span>)=&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(req.headers.cookie)&#123;</span><br><span class="line">        res.setHeader(<span class="string">'Content-Type'</span>,<span class="string">'text/html;charset=utf-8;'</span>);</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'浏览器携带了cookie'</span>);</span><br><span class="line">        res.end(<span class="string">'浏览器携带了cookie'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'浏览器没有携带cookie信息，那么我们为其设置cookie信息'</span>);</span><br><span class="line">        res.setHeader(<span class="string">'Set-Cookie'</span>,[<span class="string">'name=zhangsan;max-age=100000;'</span>,<span class="string">'userId=123456;max-age=200000;'</span>]);</span><br><span class="line">        res.setHeader(<span class="string">'Content-Type'</span>,<span class="string">'text/html;charset=utf-8;'</span>);</span><br><span class="line">        res.end(<span class="string">'服务器设置了cookie'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;).listen(<span class="number">3000</span>,()=&gt;&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'Port 3000 is listening'</span>);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>这时候，我们可以看到响应头的Set-cookie字段会添加上每一个设置的cookie的有效期</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Set-Cookie: name=zhangsan;max-age=100000</span><br><span class="line">Set-Cookie: userId=123456;max-age=200000</span><br></pre></td></tr></table></figure><p>这时候，我们关闭浏览器，再重新打开并访问<a href="http://localhost:3000，我们可以发现服务器端控制台会输出：" target="_blank" rel="noopener">http://localhost:3000，我们可以发现服务器端控制台会输出：</a></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 浏览器携带了cookie</span></span><br><span class="line"><span class="comment">// 浏览器携带了cookie</span></span><br></pre></td></tr></table></figure><p>备注：输出两次的原因在上文提到过，之后的所有程序就当浏览器只请求了url一次</p><h3 id="cookie的Secure和HttpOnly标记"><a href="#cookie的Secure和HttpOnly标记" class="headerlink" title="cookie的Secure和HttpOnly标记"></a>cookie的Secure和HttpOnly标记</h3><p>标记为 Secure 的Cookie只应通过被HTTPS协议加密过的请求发送给服务端。但即便设置了 Secure 标记，敏感信息也不应该通过Cookie传输，因为Cookie有其固有的不安全性，Secure 标记也无法提供确实的安全保障。</p><p>为避免<strong>跨域脚本 (XSS) 攻击</strong>，通过JavaScript的 Document.cookie API无法访问带有 HttpOnly 标记的Cookie，它们只应该发送给服务端。如果包含服务端 Session 信息的 Cookie 不想被客户端 JavaScript 脚本调用，那么就应该为其设置 HttpOnly 标记。</p><blockquote><p>Set-Cookie: id=a3fWa; Expires=Wed, 21 Oct 2015 07:28:00 GMT; Secure; HttpOnly</p></blockquote><h3 id="cookie的键值对"><a href="#cookie的键值对" class="headerlink" title="cookie的键值对"></a>cookie的键值对</h3><p>cookie的键名（也就是name属性），我们需要注意的是一个域名下绑定的cookie的name不应该相同，如果相同的话，那么后面的键值对会覆盖之前同名的键值对</p><p>cookie的值（cookie的value属性）。</p><p>我们需要注意一点：</p><blockquote><p>由于cookie规定是名称/值是不允许包含分号，逗号，空格的，所以为了不给用户带来麻烦，以及考虑服务器的兼容性，任何存储cookie的数据都应该被编码。</p></blockquote><h3 id="cookie的作用域"><a href="#cookie的作用域" class="headerlink" title="cookie的作用域"></a>cookie的作用域</h3><p>Domain 和 Path 标识定义了Cookie的作用域：即Cookie应该发送给哪些URL。</p><p>Domain 标识指定了哪些主机可以接受Cookie。如果不指定，默认为当前文档的主机（不包含子域名）。如果指定了Domain，则一般包含子域名。</p><p>例如，如果设置 Domain=mozilla.org，则Cookie也包含在子域名中（如developer.mozilla.org）。</p><p>Path 标识指定了主机下的哪些路径可以接受Cookie（该URL路径必须存在于请求URL中）。以字符 %x2F (“/“) 作为路径分隔符，子路径也会被匹配。</p><p>例如，设置 Path=/docs，则以下地址都会匹配：</p><pre><code>/docs/docs/Web//docs/Web/HTTP</code></pre><h3 id="Js操作cookie"><a href="#Js操作cookie" class="headerlink" title="Js操作cookie"></a>Js操作cookie</h3><p>通过Document.cookie属性可创建新的Cookie，也可通过该属性访问非HttpOnly标记的Cookie。</p><p>例如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">document</span>.cookie = <span class="string">'name=lisi'</span>;</span><br><span class="line"><span class="built_in">document</span>.cookie = <span class="string">'age=18'</span>;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">document</span>.cookie); <span class="comment">// "name=lisi; age=18"</span></span><br></pre></td></tr></table></figure><p>通过js创建的cookie，在请求的时候同样也会被放在请求头中。但需要注意的是，js创建的cookie是会话期cookie，当浏览器被关闭后就会被自动删除。</p><h2 id="session"><a href="#session" class="headerlink" title="session"></a>session</h2><h3 id="什么是session"><a href="#什么是session" class="headerlink" title="什么是session"></a>什么是session</h3><p>Session 对象存储特定用户会话所需的属性及配置信息。这样，当用户在应用程序的 Web 页之间跳转时，存储在 Session 对象中的变量将不会丢失，而是在整个用户会话中一直存在下去。当用户请求来自应用程序的 Web 页时，如果该用户还没有会话，则 Web 服务器将自动创建一个 Session 对象。当会话过期或被放弃后，服务器将终止该会话。Session 对象最常见的一个用法就是存储用户的首选项。例如，如果用户指明不喜欢查看图形，就可以将该信息存储在 Session 对象中。</p><h3 id="session机制"><a href="#session机制" class="headerlink" title="session机制"></a>session机制</h3><p>session机制是一种服务器端的机制，服务器使用一种类似于散列表的结构（也可能就是使用散列表）来保存信息。</p><p>当程序需要为某个客户端的请求创建一个session时，服务器首先检查这个客户端的请求里是否已包含了一个session标识（称为session id）</p><ol><li>如果已包含则说明以前已经为此客户端创建过session，服务器就按照session id把这个session检索出来使用（检索不到，会新建一个）</li><li>如果客户端请求不包含session id，则为此客户端创建一个session并且生成一个与此session相关联的session id</li></ol><p>session id的值应该是一个既不会重复，又不容易被找到规律以仿造的字符串，这个session id将被在本次响应中返回给客户端保存。</p><p><img src="https://s2.ax1x.com/2019/10/21/Kl8cQO.png" alt></p><h3 id="创建session"><a href="#创建session" class="headerlink" title="创建session"></a>创建session</h3><h4 id="通过cookie来实现session"><a href="#通过cookie来实现session" class="headerlink" title="通过cookie来实现session"></a>通过cookie来实现session</h4><p>我们已经知道session是保存于服务端的。有别于cookie可能将用户信息直接明文存储于浏览器端，session只是将sessionId通过cookie存储在浏览器端，然后同一个应用程序的所有页面访问服务端都会携带上该sessionId</p><h4 id="通过url重写"><a href="#通过url重写" class="headerlink" title="通过url重写"></a>通过url重写</h4><p>我们在每次请求中都携带一个 SessionID 的参数，也可以 Post 的方式提交，也可以在请求的地址后面拼接 xxx?SessionID=123456…</p><h4 id="隐藏表单域"><a href="#隐藏表单域" class="headerlink" title="隐藏表单域"></a>隐藏表单域</h4><p>当然我们也可以使用隐藏表单域来进行sessionId的提交</p><h2 id="cookie与session的区别"><a href="#cookie与session的区别" class="headerlink" title="cookie与session的区别"></a>cookie与session的区别</h2><ol><li>作用范围不同，cookie保存在客户端（浏览器），而session保存在服务端</li><li>存取方式的不同，cookie只能保存ASCII，而session可以存储任何数据类型。因为，我们只是将sessionId存放到cookie返回给客户端。sessionde的信息需要服务端从数据库或文件或redis进行获取。</li><li>有效期不同，cookie可以设置为长时间保存，比如常用于自动登录；而session一般失效时间较短，客户端关闭或者session超市都会失效</li><li>隐私策略不同，Cookie 存储在客户端，比较容易遭到不法获取，早期有人将用户的登录名和密码存储在 Cookie 中导致信息被窃取；Session 存储在服务端，安全性相对 Cookie 要好一些。</li><li>存储大小不同， 单个 Cookie 保存的数据不能超过 4K，Session 可存储数据远高于 Cookie</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;cookie&quot;&gt;&lt;a href=&quot;#cookie&quot; class=&quot;headerlink&quot; title=&quot;cookie&quot;&gt;&lt;/a&gt;cookie&lt;/h2&gt;&lt;h3 id=&quot;什么是cookie&quot;&gt;&lt;a href=&quot;#什么是cookie&quot; class=&quot;headerlink
      
    
    </summary>
    
      <category term="后端基础" scheme="http://yoursite.com/categories/%E5%90%8E%E7%AB%AF%E5%9F%BA%E7%A1%80/"/>
    
    
  </entry>
  
  <entry>
    <title>Generator与async+await</title>
    <link href="http://yoursite.com/2019/10/16/%E5%BC%82%E6%AD%A5%E7%9A%84%E7%BB%88%E6%9E%81%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88async-await/"/>
    <id>http://yoursite.com/2019/10/16/异步的终极解决方案async-await/</id>
    <published>2019-10-16T07:19:34.000Z</published>
    <updated>2019-10-17T14:34:19.629Z</updated>
    
    <content type="html"><![CDATA[<h2 id="异步操作的发展"><a href="#异步操作的发展" class="headerlink" title="异步操作的发展"></a>异步操作的发展</h2><p>有一个场景，要先读取a文件，当a文件成功读取完毕后再去读取b文件，我们看一下各种异步操作是如何进行的？</p><h3 id="回调函数"><a href="#回调函数" class="headerlink" title="回调函数"></a>回调函数</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 采用回调函数方式，很容易造成回调地狱</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">readFile</span>(<span class="params">err,data</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(err) <span class="keyword">throw</span> err;</span><br><span class="line">    <span class="built_in">console</span>.log(data);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fs.readFile(<span class="string">'./a.js'</span>,<span class="string">'utf-8'</span>,(err,data)=&gt;&#123;</span><br><span class="line">    <span class="keyword">if</span>(err) <span class="keyword">throw</span> err;</span><br><span class="line">    <span class="built_in">console</span>.log(data);</span><br><span class="line">    fs.readFile(<span class="string">'./b.js'</span>,<span class="string">'utf-8'</span>,(err,data)=&gt;&#123;</span><br><span class="line">        <span class="keyword">if</span>(err) <span class="keyword">throw</span> err;</span><br><span class="line">        <span class="built_in">console</span>.log(data);</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h3 id="Promise"><a href="#Promise" class="headerlink" title="Promise"></a>Promise</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 采用promise方式，但问题是容易造成代码冗余，并且一堆then导致代码不够清晰</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getPromise</span>(<span class="params">file</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve,reject</span>)=&gt;</span>&#123;</span><br><span class="line">        fs.readFile(file,<span class="string">'utf-8'</span>,(err,data)=&gt;&#123;</span><br><span class="line">            <span class="keyword">if</span>(err) reject(err);</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                resolve(data);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">getPromise(<span class="string">'./a.js'</span>).then(<span class="function"><span class="params">v</span>=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(v);</span><br><span class="line">    <span class="keyword">return</span> getPromise(<span class="string">'./b.js'</span>);</span><br><span class="line">&#125;).then(<span class="function"><span class="params">v</span>=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(v);</span><br><span class="line">&#125;).catch(<span class="function"><span class="params">err</span>=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(err);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="Generator"><a href="#Generator" class="headerlink" title="Generator"></a>Generator</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Generator生成器模式，利用每当执行完一条yield语句后函数会自动停止执行的特性，从而通过调用next()方法来使异步操作看起来同步化</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">read</span>(<span class="params">file</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve,reject</span>)=&gt;</span>&#123;</span><br><span class="line">        fs.readFile(file,<span class="string">'utf-8'</span>,(err,data)=&gt;&#123;</span><br><span class="line">            <span class="keyword">if</span>(err) reject(err);</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                resolve(data);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> *<span class="title">readFile</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">yield</span> read(<span class="string">'./a.js'</span>);</span><br><span class="line">    <span class="keyword">yield</span> read(<span class="string">'./b.js'</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> file = readFile();</span><br><span class="line"><span class="keyword">let</span> value,done;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>((&#123;value,done&#125; = file.next())&amp;&amp;!done) &#123;</span><br><span class="line">    value.then(<span class="function"><span class="params">v</span>=&gt;</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(v);</span><br><span class="line">    &#125;).catch(<span class="function"><span class="params">err</span>=&gt;</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(err);</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="async-await"><a href="#async-await" class="headerlink" title="async+await"></a>async+await</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// async+await</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">read</span>(<span class="params">fileName</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve,reject</span>)=&gt;</span>&#123;</span><br><span class="line">        fs.readFile(fileName,<span class="string">'utf-8'</span>,(err,data)=&gt;&#123;</span><br><span class="line">            <span class="keyword">if</span>(err) &#123;</span><br><span class="line">                reject(err);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                resolve(data);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">readFile</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> fileA = <span class="keyword">await</span> read(<span class="string">'./a.js'</span>);</span><br><span class="line">    <span class="keyword">let</span> fileB = <span class="keyword">await</span> read(<span class="string">'./b.js'</span>);</span><br><span class="line">    <span class="built_in">console</span>.log(fileA);</span><br><span class="line">    <span class="built_in">console</span>.log(fileB); </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">readFile();</span><br></pre></td></tr></table></figure><h2 id="Generator函数"><a href="#Generator函数" class="headerlink" title="Generator函数"></a>Generator函数</h2><h3 id="简单任务执行器"><a href="#简单任务执行器" class="headerlink" title="简单任务执行器"></a>简单任务执行器</h3><p>由于执行yield语句会暂停当前函数的执行过程并等待下一次调用next()方法，那么我们能否做到设置一个简单任务执行器自动执行所有的任务呢？</p><p>例如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 设置三个简单任务</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> *<span class="title">tasks</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">yield</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">yield</span> <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">yield</span> <span class="number">3</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 简单任务执行器函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">run</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> task = tasks();</span><br><span class="line">    <span class="keyword">let</span> result = task.next();</span><br><span class="line">  </span><br><span class="line">    <span class="comment">// 通过递归的方式，不断检测迭代器的done属性判断迭代器是否迭代完全</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">step</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!result.done) &#123;</span><br><span class="line">            <span class="built_in">console</span>.log(result.value);</span><br><span class="line">            result = task.next();</span><br><span class="line">            step();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    step();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">run();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出结果</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">3</span></span><br></pre></td></tr></table></figure><h3 id="向任务执行器传递函数"><a href="#向任务执行器传递函数" class="headerlink" title="向任务执行器传递函数"></a>向任务执行器传递函数</h3><p>我们再深入一点：如果，那些任务之间是有关联的呢？比如说后执行的任务需要先执行的任务的返回值</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> *<span class="title">tasks</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> value = <span class="keyword">yield</span> <span class="number">1</span>;</span><br><span class="line">    value = <span class="keyword">yield</span> value + <span class="number">1</span>;</span><br><span class="line">    value = <span class="keyword">yield</span> value + <span class="number">2</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那么，我们就可以利用可以向next()方法传递参数的特性。因为这个参数的值就会代替生成器内部上一条yield语句的返回值。</p><p>对于上述生成器函数tasks，如果，没有向next()方法中传入参数，那么yield就不会有返回值（或者默认返回undefined）</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">run</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> task = tasks();</span><br><span class="line">    <span class="keyword">let</span> result = task.next();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">step</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!result.done) &#123;</span><br><span class="line">            <span class="built_in">console</span>.log(result.value);</span><br><span class="line">            result = task.next(result.value);</span><br><span class="line">            step();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    step();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">run();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出结果</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">4</span></span><br></pre></td></tr></table></figure><h3 id="异步任务执行器"><a href="#异步任务执行器" class="headerlink" title="异步任务执行器"></a>异步任务执行器</h3><h4 id="Thunk函数"><a href="#Thunk函数" class="headerlink" title="Thunk函数"></a>Thunk函数</h4><p>任何函数，只要参数有回调函数，就能写成 Thunk 函数的形式</p><p>thunk函数的作用就是将一个函数的执行参数（除回调函数外，一般是回调函数之前定义的参数）和回调函数分成两个函数。</p><p>比如:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fn(args,callback) = &gt; thunk(fn)(args)(callback)</span><br></pre></td></tr></table></figure><p>thunk函数转化器</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> Thunk = <span class="function"><span class="keyword">function</span>(<span class="params">fn</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params">...args</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params">callback</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> fn.call(<span class="keyword">this</span>, ...args, callback);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="Thunk函数与Generator"><a href="#Thunk函数与Generator" class="headerlink" title="Thunk函数与Generator"></a>Thunk函数与Generator</h4><p>因为thunk函数可以将回调函数与执行函数分开，因此，我们就可以在一个地方执行执行函数，而在另一个地方来执行回调函数。</p><p>我们再去思考一些常用的异步操作，例如文件读取、例如Ajax。我们都是从回调函数中获取数据</p><p>因此，我们就可以得到下列的异步处理流程：</p><blockquote><p>执行函数执行 –&gt;等待回调函数传回数据 –&gt; 操作获取的数据</p></blockquote><p>这样，我们就可以将异步代码变得同步化。就像这样</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">let v = fs.readFile(&apos;./a.js&apos;); // 异步操作读取文件</span><br><span class="line">console.log(v); // 操作数据</span><br><span class="line"></span><br><span class="line">readFileThunk(callback); // 在另一个地方执行回调，得到数据并传回数据</span><br></pre></td></tr></table></figure><p>那么，怎么传回数据呢？在前文提到过，我们可以在迭代器中的next()方法中传入参数，来使得该参数成为Generator函数中上一条yield语句的返回值</p><h4 id="以fs-readFile-为例"><a href="#以fs-readFile-为例" class="headerlink" title="以fs.readFile()为例"></a>以fs.readFile()为例</h4><p>假如我们要读取a文件和b文件，那么结合Generator和Thunk函数，我们可以这样写：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Thunk函数转化器</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">thunkify</span>(<span class="params">fn</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">...args</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">callback</span>) </span>&#123;</span><br><span class="line">            fn.call(<span class="keyword">this</span>,...args,callback);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> readFile = thunkify(fs.readFile);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> *<span class="title">read</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 执行函数以及操作数据</span></span><br><span class="line">    <span class="keyword">let</span> value = <span class="keyword">yield</span> readFile(<span class="string">'./a.js'</span>,<span class="string">'utf-8'</span>);</span><br><span class="line">    <span class="built_in">console</span>.log(value);</span><br><span class="line">    value = <span class="keyword">yield</span> readFile(<span class="string">'./b.js'</span>,<span class="string">'utf-8'</span>);</span><br><span class="line">    <span class="built_in">console</span>.log(value);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">run</span>(<span class="params">generator</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> iterator = generator();</span><br><span class="line">    <span class="keyword">let</span> file = iterator.next();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 回调函数执行，以及将获取的数据回传</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">step</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!file.done) &#123;</span><br><span class="line">            file.value(<span class="function">(<span class="params">err,data</span>)=&gt;</span>&#123;</span><br><span class="line">                <span class="keyword">if</span>(err) <span class="keyword">return</span> err;</span><br><span class="line">                file = iterator.next(data);</span><br><span class="line">                step();</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    step();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">run(read);</span><br></pre></td></tr></table></figure><h2 id="async函数"><a href="#async函数" class="headerlink" title="async函数"></a>async函数</h2><p>async的引入可以说是异步操作的终极解决方案。</p><p>那么,async函数是什么呢？</p><blockquote><p>async function 用来定义一个返回 AsyncFunction 对象的异步函数。异步函数是指通过事件循环异步执行的函数，它会通过一个隐式的 Promise 返回其结果。如果你在代码中使用了异步函数，就会发现它的语法和结构会更像是标准的同步函数。</p></blockquote><p>事实上,async函数其实就是Generator函数的语法糖。使用async来表示这是一个异步函数，函数内部使用await来表示一个异步操作</p><p>例如，读取两个文件</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">readFile</span>(<span class="params">fileName,encode</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve,reject</span>)=&gt;</span>&#123;</span><br><span class="line">        fs.readFile(fileName,encode,(err,data)=&gt;&#123;</span><br><span class="line">            <span class="keyword">if</span>(err) &#123;</span><br><span class="line">                reject(err);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> resolve(data);</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">read</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> value = <span class="keyword">await</span> readFile(<span class="string">'./a.js'</span>,<span class="string">'utf-8'</span>);</span><br><span class="line">    <span class="built_in">console</span>.log(value);</span><br><span class="line">    value = <span class="keyword">await</span> readFile(<span class="string">'./b.js'</span>,<span class="string">'utf-8'</span>);</span><br><span class="line">    <span class="built_in">console</span>.log(value);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">read();</span><br></pre></td></tr></table></figure><p>但是，相比于Generator函数，async函数主要有以下的改进</p><ol><li><p>内置执行器</p><p> 在前文提到过，Generator函数会返回一个迭代器。但若想要迭代器自动执行，我们就需要设置一个执行器函数来帮助操作。但是，async函数只需要直接调用就可以自动执行</p></li><li><p>更好的语义化</p><p> async和await，比起星号和yield，语义更清楚了。async表示函数里有异步操作，await表示紧跟在后面的表达式需要等待结果。</p></li><li><p>更广的实用性</p><p> co模块约定，yield命令后面只能是 Thunk 函数或 Promise 对象，而async函数的await命令后面，可以是 Promise 对象和原始类型的值（数值、字符串和布尔值，但这时会自动转成立即 resolved 的 Promise 对象）。</p></li><li><p>返回值是Promise</p><p> async函数的返回值是 Promise 对象，这比 Generator 函数的返回值是 Iterator 对象方便多了。你可以用then方法指定下一步的操作。</p></li></ol><h3 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h3><p>因为async是用来定义一个异步函数的。因此，函数的所有写法都可以在前面加上async定义</p><p>例如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 函数声明</span></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数表达式</span></span><br><span class="line"><span class="keyword">let</span> test = <span class="keyword">async</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 作为对象的方法</span></span><br><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">    <span class="keyword">async</span> test() &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//  作为类的方法</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">T</span></span>&#123;</span><br><span class="line">    <span class="keyword">async</span> test() &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 箭头函数</span></span><br><span class="line"><span class="keyword">let</span> test = <span class="keyword">async</span> ()=&gt;&#123;&#125;</span><br></pre></td></tr></table></figure><h3 id="async函数的返回值"><a href="#async函数的返回值" class="headerlink" title="async函数的返回值"></a>async函数的返回值</h3><p>async会返回一个Promise对象，其会运行执行(resolve)异步函数的返回结果，或者运行拒绝(reject)——如果异步函数抛出异常的话。</p><p>async函数内部的返回值会成为返回的promise对象的回调函数的参数</p><p>例如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">test().then(<span class="function"><span class="params">v</span>=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(v); <span class="comment">// 1</span></span><br><span class="line">&#125;).catch(<span class="function"><span class="params">err</span>=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(err);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>当然，如果async函数内部抛出了错误，就会导致返回的Promsie对象变为reject状态。并且出错的原因会作为promise对象的拒绝处理程序的参数</p><p>例如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'err'</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">test().then(<span class="function"><span class="params">v</span>=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(v);</span><br><span class="line">&#125;).catch(<span class="function"><span class="params">err</span>=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(err); <span class="comment">// Error: 'err'</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="async函数对于多个异步操作的简化"><a href="#async函数对于多个异步操作的简化" class="headerlink" title="async函数对于多个异步操作的简化"></a>async函数对于多个异步操作的简化</h3><p>async/await的目的是简化使用多个 promise 时的同步行为，并对一组 Promises执行某些操作。</p><p>async函数返回的Promise对象必须要等到内部所有的await命令后面的Promise全部执行完，才会将自身的状态从pending（运行态）转化为resolved（fulfilled已完成）或rejected（已拒绝）</p><p>例如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> v1 = <span class="keyword">await</span> <span class="built_in">Promise</span>.resolve(<span class="number">1</span>);</span><br><span class="line">    <span class="built_in">console</span>.log(v1); <span class="comment">// 1</span></span><br><span class="line">    <span class="keyword">let</span> v2 = <span class="keyword">await</span> <span class="built_in">Promise</span>.resolve(<span class="number">2</span>);</span><br><span class="line">    <span class="built_in">console</span>.log(v2); <span class="comment">// 2</span></span><br><span class="line">    <span class="keyword">return</span> v1+v2;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">test().then(<span class="function"><span class="params">v</span>=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(v); <span class="comment">// 3</span></span><br><span class="line">&#125;).catch(<span class="function"><span class="params">err</span>=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(err);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>值得注意的是，如果await命令后面的Promise对象如果变为reject状态，那么整个async函数就会中断运行，并且，async函数返回的promise就会变为拒绝态，并且出错的原因会作为promise对象的拒绝处理程序的参数</p><p>例如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> v1 = <span class="keyword">await</span> <span class="built_in">Promise</span>.resolve(<span class="number">1</span>);</span><br><span class="line">    <span class="built_in">console</span>.log(v1); <span class="comment">// 1</span></span><br><span class="line">    <span class="keyword">let</span> v2 = <span class="keyword">await</span> <span class="built_in">Promise</span>.reject(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// async在这里停止运行</span></span><br><span class="line">    <span class="built_in">console</span>.log(v2);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">test().then(<span class="function"><span class="params">v</span>=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(v);</span><br><span class="line">&#125;).catch(<span class="function"><span class="params">err</span>=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(err); <span class="comment">// 2</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="错误处理"><a href="#错误处理" class="headerlink" title="错误处理"></a>错误处理</h3><p>我们在前面提到过，只要await命令后的一个promise是rejected态的，那么整个async函数就会停止运行。那么，为了防止某个promise错误影响后面的promise执行，我们需要有错误处理机制。</p><p>我们可以使用try…catch…来处理</p><p>例如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> v1 = <span class="keyword">await</span> <span class="built_in">Promise</span>.reject(<span class="string">'err'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span>(e)&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(e); <span class="comment">// 'err'</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">let</span> v2 = <span class="keyword">await</span> <span class="built_in">Promise</span>.resolve(<span class="number">1</span>);</span><br><span class="line">    <span class="built_in">console</span>.log(v2); <span class="comment">// 1</span></span><br><span class="line">    <span class="keyword">return</span> v2;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">test().then(<span class="function"><span class="params">v</span>=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(v); <span class="comment">// 1</span></span><br><span class="line">&#125;).catch(<span class="function"><span class="params">err</span>=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(err);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>如果有多个await命令，我们可以统一放在try…catch结构里</p><p>例如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> v1 = <span class="keyword">await</span> <span class="built_in">Promise</span>.resolve(<span class="number">1</span>);</span><br><span class="line">        <span class="built_in">console</span>.log(v1); <span class="comment">// 1</span></span><br><span class="line">        <span class="keyword">let</span> v2 = <span class="keyword">await</span> <span class="built_in">Promise</span>.reject(<span class="string">'err'</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 抛出错误，try后续部分不再执行</span></span><br><span class="line">        <span class="built_in">console</span>.log(v2);</span><br><span class="line">        <span class="keyword">let</span> v3 = <span class="built_in">Promise</span>.resolve(<span class="number">3</span>);</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="number">3</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span>(e) &#123;</span><br><span class="line">        <span class="comment">// 捕获错误</span></span><br><span class="line">        <span class="built_in">console</span>.log(e); <span class="comment">// 'err'</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">test();</span><br></pre></td></tr></table></figure><h3 id="继发与并发"><a href="#继发与并发" class="headerlink" title="继发与并发"></a>继发与并发</h3><p>继发是执行完一个异步操作之后才会去执行下一个异步操作</p><p>例如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">await</span> <span class="built_in">Promise</span>.resolve(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">await</span> <span class="built_in">Promise</span>.reject(<span class="string">'err'</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">test();</span><br></pre></td></tr></table></figure><p>如果，函数内部的异步操作没有继发关系。也就是每个异步操作是相互独立的，那么让所有的异步操作同时触发会节省程序的执行时间</p><p>我们可以通过Promsie.all()来实现</p><p>例如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> [v1,v2] = <span class="keyword">await</span> <span class="built_in">Promise</span>.all([<span class="built_in">Promise</span>.resolve(<span class="number">1</span>),<span class="built_in">Promise</span>.resolve(<span class="number">2</span>)]);</span><br><span class="line">    <span class="keyword">return</span> [v1,v2];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">test().then(<span class="function"><span class="params">v</span>=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(v); <span class="comment">// [1,2]</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>是的，我们很容易可以想到。如果并发的多个异步操作中有些抛出错误了怎么办？</p><p>我们可以使用try…catch来处理。因此，在使用async函数时请尽量要确保有错误处理机制。</p><p>例如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">try</span>&#123;</span><br><span class="line">        <span class="keyword">let</span> [v1,v2] = <span class="keyword">await</span> <span class="built_in">Promise</span>.all([<span class="built_in">Promise</span>.resolve(<span class="number">1</span>),<span class="built_in">Promise</span>.reject(<span class="number">2</span>)]);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 停止运行</span></span><br><span class="line">        <span class="keyword">return</span> [v1,v2];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span>(e) &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'err'</span>,e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="async函数可以保留运行堆栈"><a href="#async函数可以保留运行堆栈" class="headerlink" title="async函数可以保留运行堆栈"></a>async函数可以保留运行堆栈</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> a() &#123;</span><br><span class="line">    b().then(<span class="function"><span class="params">()</span>=&gt;</span>c())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述代码中，函数a内部运行了一个异步任务b()。当b运行的时候，函数a()不会中断，而是会继续执行，也就是说，当异步操作b()结束后，可能a()早已经结束了。那么，b()所在的上下文环境就会消失</p><p>但是，对于async异步函数</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">await</span> b();</span><br><span class="line">    c();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>b()异步操作在运行的时候,a函数是暂停运行的。因此，对于b()函数，其上下文环境都仍旧保存着。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;异步操作的发展&quot;&gt;&lt;a href=&quot;#异步操作的发展&quot; class=&quot;headerlink&quot; title=&quot;异步操作的发展&quot;&gt;&lt;/a&gt;异步操作的发展&lt;/h2&gt;&lt;p&gt;有一个场景，要先读取a文件，当a文件成功读取完毕后再去读取b文件，我们看一下各种异步操作是如何进行的
      
    
    </summary>
    
      <category term="ES6" scheme="http://yoursite.com/categories/ES6/"/>
    
    
  </entry>
  
  <entry>
    <title>事件机制</title>
    <link href="http://yoursite.com/2019/10/11/%E4%BA%8B%E4%BB%B6%E6%9C%BA%E5%88%B6/"/>
    <id>http://yoursite.com/2019/10/11/事件机制/</id>
    <published>2019-10-11T07:15:04.000Z</published>
    <updated>2019-11-11T10:18:55.741Z</updated>
    
    <content type="html"><![CDATA[<h2 id="事件流"><a href="#事件流" class="headerlink" title="事件流"></a>事件流</h2><p>事件流描述的是从页面中接收事件的顺序。IE提出的事件流是事件冒泡流，而网景提出的事件流是事件捕获流</p><h3 id="事件冒泡"><a href="#事件冒泡" class="headerlink" title="事件冒泡"></a>事件冒泡</h3><p>事件冒泡指代的是，事件开始时是由最具体的元素接收，然后逐级向上传播到较为不具体的节点</p><p>例如：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">head</span>&gt;</span><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">p</span>&gt;</span>hello<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>当你单击了P元素，那么这个事件就会按照如下顺序传播：</p><ol><li>&lt;p&gt;</li><li>&lt;div&gt;</li><li>&lt;body&gt;</li><li>&lt;html&gt;</li><li>document</li></ol><h3 id="事件捕获"><a href="#事件捕获" class="headerlink" title="事件捕获"></a>事件捕获</h3><p>事件捕获的思想是不大具体的节点应该更早接收到事件，而最具体的节点应该最后接收到事件。事件捕获的用意在于在事件到达预定目标之前捕获它</p><p>那么上述例子如果采用事件捕获的话，那么传播顺序就会是这样的：</p><ol><li>document</li><li>&lt;html&gt;</li><li>&lt;body&gt;</li><li>&lt;div&gt;</li><li>&lt;p&gt;</li></ol><h3 id="DOM事件流"><a href="#DOM事件流" class="headerlink" title="DOM事件流"></a>DOM事件流</h3><p>“DOM2级事件”规定的事件流包括三个阶段：</p><ol><li>事件捕获阶段</li><li>处于目标阶段</li><li>事件冒泡阶段</li></ol><p>首先发生的是事件捕获，为截获事件提供了机会。然后是实际的目标接收到事件。最后一个阶段是冒泡阶段，可以在这个阶段对事件做出响应</p><p>值得注意的是：</p><blockquote><p>捕获阶段是不包括实际的目标元素的。这也意味着对于上述的例子，在捕获阶段，事件从document -&gt; &lt;div&gt;后就停止了。然后，处于目标阶段就会响应该目标注册的事件。并在事件处理中被看做事件冒泡阶段的一部分进入事件冒泡阶段</p></blockquote><p>这有一个例子：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">&lt;html&gt;</span><br><span class="line">    &lt;head&gt;<span class="xml"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span></span><br><span class="line">    &lt;body&gt;</span><br><span class="line">        &lt;div style=<span class="string">"width: 100px;height: 100px;border: 1px solid black;"</span>&gt;</span><br><span class="line">            &lt;p style=<span class="string">"width: 50px;height: 20px;border: 1px solid red;margin: 10px 20px"</span>&gt;</span><br><span class="line">                hello</span><br><span class="line">            &lt;<span class="regexp">/p&gt;</span></span><br><span class="line"><span class="regexp">        &lt;/</span>div&gt;</span><br><span class="line">        </span><br><span class="line">        &lt;script&gt;</span><br><span class="line">            <span class="keyword">let</span> div = <span class="built_in">document</span>.getElementsByTagName(<span class="string">'div'</span>)[<span class="number">0</span>];</span><br><span class="line">            div.addEventListener(<span class="string">"click"</span>,(e)=&gt;&#123;</span><br><span class="line">                <span class="built_in">console</span>.log(<span class="string">'冒泡'</span>);</span><br><span class="line">            &#125;,<span class="literal">false</span>);</span><br><span class="line">            div.addEventListener(<span class="string">"click"</span>,(e)=&gt;&#123;</span><br><span class="line">                <span class="built_in">console</span>.log(<span class="string">'捕获'</span>);</span><br><span class="line">            &#125;,<span class="literal">true</span>);</span><br><span class="line">        &lt;<span class="regexp">/script&gt;</span></span><br><span class="line"><span class="regexp">    &lt;/</span>body&gt;</span><br><span class="line">&lt;<span class="regexp">/html&gt;</span></span><br></pre></td></tr></table></figure><p>我们为div元素注册了两个事件，一个要求在冒泡阶段被调用，一个是要求在捕获阶段被调用</p><p>根据DOM事件流的三个阶段，当我们点击&lt;p&gt;元素时，会看到先输”冒泡”再输出”捕获”。因为，我们点击的目标元素是&lt;p&gt;元素，会经历以下三个阶段。</p><ol><li>在捕获阶段（document-&gt; &lt;html&gt; -&gt; &lt;body&gt; -&gt; &lt;div&gt;），我们捕获到了div注册的要在捕获阶段调用的事件，那么触发它。</li><li>处于目标阶段，没有目标注册的事件</li><li>冒泡阶段（&lt;div&gt; -&gt; &lt;body&gt; -&gt; &lt;html&gt; -&gt; document）响应了div注册的要在冒泡阶段调用的事件</li></ol><p>但是，当我们点击的&lt;div&gt;元素的时候，会看到先输出”捕获”再输出”冒泡”，根据DOM事件流的三个阶段</p><ol><li>在捕获阶段（document-&gt; &lt;html&gt; -&gt; &lt;body&gt;），我们没有捕获到div注册的任何事件。</li><li>处于目标阶段，那么触发目标注册的事件，因为目标注册了两个事件，那么按照顺序依次触发它们，依次输出”冒泡”、”捕获”</li><li>冒泡阶段（ 发生的事件 -&gt; &lt;body&gt; -&gt; &lt;html&gt; -&gt; document）没有捕获到div注册的任何事件</li></ol><h2 id="事件注册"><a href="#事件注册" class="headerlink" title="事件注册"></a>事件注册</h2><h3 id="DOM0级事件处理程序"><a href="#DOM0级事件处理程序" class="headerlink" title="DOM0级事件处理程序"></a>DOM0级事件处理程序</h3><p>每个元素都有自己的事件处理程序属性，这些属性通常全部<strong>小写</strong>，将这种属性的值设置为一个函数，就可以指定事件处理程序</p><p>因为，使用该方法指定的事件处理程序被认为是元素的方法。因此，这时候的事件处理程序是在当前元素的作用域内运行的。也就是说，处理函数中的this指向当前元素</p><p>例如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> element = <span class="built_in">document</span>.getElementById(<span class="string">'ele'</span>);</span><br><span class="line">element.onclick = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.id); <span class="comment">// 'ele'</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们可以将事件处理程序属性的值设为null来删除指定的事件处理程序</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">element.onclick = <span class="literal">null</span>;</span><br></pre></td></tr></table></figure><blockquote><p>注意：DOM0级处理程序默认在冒泡阶段被调用</p></blockquote><h3 id="DOM2级事件处理程序"><a href="#DOM2级事件处理程序" class="headerlink" title="DOM2级事件处理程序"></a>DOM2级事件处理程序</h3><p>DOM2级提供了两个方法来添加和删除事件处理程序</p><ol><li>addEventListener()</li><li>removeEventListener()</li></ol><p>这两个方法都接受三个参数：</p><ol><li>要处理的事件名</li><li>作为事件处理程序的函数</li><li>布尔值（true表示在捕获阶段调用函数；false表示在冒泡阶段调用函数）</li></ol><p>例如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> element = <span class="built_in">document</span>.getElementById(<span class="string">'ele'</span>);</span><br><span class="line"></span><br><span class="line">element.addEventListener(<span class="string">'click'</span>,(e)=&gt;&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'捕获'</span>)</span><br><span class="line">&#125;,<span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">element.addEventListener(<span class="string">'click'</span>,(e)=&gt;&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'冒泡'</span>)</span><br><span class="line">&#125;,<span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">element.removeEventListener(<span class="string">'click'</span>,(e)=&gt;&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'捕获'</span>)</span><br><span class="line">&#125;,<span class="literal">true</span>);</span><br></pre></td></tr></table></figure><p>我们可以看到，使用DOM2级注册方式的主要好处是可以添加多个事件处理程序</p><p>值得注意的是：</p><blockquote><p>通过addEventListener()方法注册的事件处理程序只能通过removeEventListener()方法来移除。并且，移除时传入的三个参数必须与添加时的三个参数一致。因此，通过addEventListener()添加的匿名函数无法被移除（参数必须完全一致，也就是说第二个参数函数也要是同一个函数）</p></blockquote><p>例如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> element = <span class="built_in">document</span>.getElementById(<span class="string">'ele'</span>);</span><br><span class="line"></span><br><span class="line">element.addEventListener(<span class="string">'click'</span>,(e)=&gt;&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'捕获'</span>)</span><br><span class="line">&#125;,<span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">element.addEventListener(<span class="string">'click'</span>,(e)=&gt;&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'冒泡'</span>)</span><br><span class="line">&#125;,<span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">element.removeEventListener(<span class="string">'click'</span>,(e)=&gt;&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'捕获'</span>)</span><br><span class="line">&#125;,<span class="literal">true</span>);</span><br></pre></td></tr></table></figure><p>点击<div>后的输出结果会是’捕获’与’冒泡’，也就是说事件移除方法没有生效。原因就在于事件移除方法中的第二个参数与添加时的那个函数不是同一个函数</div></p><p>我们可以将函数单独提出来赋予给一个变量，从而可以达到目标</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> element = <span class="built_in">document</span>.getElementById(<span class="string">'ele'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> handle = <span class="function">(<span class="params">e</span>)=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'捕获'</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">element.addEventListener(<span class="string">'click'</span>,handle,<span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">element.addEventListener(<span class="string">'click'</span>,(e)=&gt;&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'冒泡'</span>)</span><br><span class="line">&#125;,<span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">element.removeEventListener(<span class="string">'click'</span>,handle,<span class="literal">true</span>);</span><br></pre></td></tr></table></figure><p>此时的输出结果就会是’冒泡’，也就是说事件移除程序生效了</p><p>另外，类似DOM0级方法，使用addEventListener()方法添加的事件处理程序内部的this值也指向当前绑定的元素，但要注意箭头函数的情况。因为箭头函数内部的this是由其外层代码作用域决定的</p><p>例如：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"ele"</span>&gt;</span>hello<span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> div = <span class="built_in">document</span>.getElementsByTagName(<span class="string">'div'</span>)[<span class="number">0</span>];</span><br><span class="line">div.addEventListener(<span class="string">'click'</span>,<span class="function"><span class="keyword">function</span>(<span class="params">e</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.id); <span class="comment">// ele</span></span><br><span class="line">&#125;)</span><br><span class="line">div.addEventListener(<span class="string">'click'</span>,(e)=&gt;&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.id,<span class="keyword">this</span>); <span class="comment">// undefined,window &#123;&#125;</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>可以看到，在非箭头函数中this指向当前事件绑定的对象；而在箭头函数中this指向了window全局对象（因为该箭头函数外层代码作用域为window全局作用域，因此this也指向了window全局对象）</p><h2 id="事件对象"><a href="#事件对象" class="headerlink" title="事件对象"></a>事件对象</h2><p>在触发DOM上的某个事件时，会产生一个事件对象event。这个对象包含着所有与事件有关的信息。</p><h3 id="事件对象的常用属性："><a href="#事件对象的常用属性：" class="headerlink" title="事件对象的常用属性："></a>事件对象的常用属性：</h3><table><thead><tr><th>属性</th><th>类型</th><th>说明</th></tr></thead><tbody><tr><td>target</td><td>Element</td><td>事件的目标，也就是当前事件发生的目标。比如说点击的那个元素</td></tr><tr><td>currentTarget</td><td>Element</td><td>当前事件绑定的那个元素</td></tr><tr><td>type</td><td>String</td><td>被触发的事件类型</td></tr><tr><td>eventPhase</td><td>Integer</td><td>调用时间处理程序的阶段：1表示捕获阶段，2表示处于目标阶段，3表示冒泡阶段</td></tr></tbody></table><p>值得注意的是，在事件处理程序内部（非匿名函数），对象中this的值始终等于event.currentTarget的值，而不一定等于event.target</p><p>例如：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">"height:100px;width:100px;border:1px solid red;"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span> <span class="attr">style</span>=<span class="string">"height:50px;width:50px;border:1px solid black;"</span>&gt;</span>hello<span class="tag">&lt;/<span class="name">p</span>&gt;</span>    </span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> div = <span class="built_in">document</span>.getElementsByTagName(<span class="string">'div'</span>)[<span class="number">0</span>];</span><br><span class="line">div.addEventListener(<span class="string">'click'</span>,(event)=&gt;&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(event.target);</span><br><span class="line">    <span class="built_in">console</span>.log(event.currentTarget);</span><br><span class="line">    <span class="built_in">console</span>.log(event.type);</span><br><span class="line">    <span class="built_in">console</span>.log(event.eventPhase);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>当我们点击div元素时，输出结果如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;div&gt;...&lt;/div&gt;</span><br><span class="line">&lt;div&gt;...&lt;/div&gt;</span><br><span class="line">click</span><br><span class="line">2</span><br></pre></td></tr></table></figure><p>当我们点击p元素时，输出结果如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;p&gt;...&lt;/p&gt;</span><br><span class="line">&lt;div&gt;...&lt;/div&gt;</span><br><span class="line">click</span><br><span class="line">3</span><br></pre></td></tr></table></figure><p>很明显可以发现，event.target指向你点击的那个元素；而event.currentTarget指向该事件绑定的那个元素</p><h3 id="事件对象的常用方法"><a href="#事件对象的常用方法" class="headerlink" title="事件对象的常用方法"></a>事件对象的常用方法</h3><table><thead><tr><th>方法</th><th>类型</th><th>说明</th></tr></thead><tbody><tr><td>preventDefault()</td><td>Function</td><td>取消事件的默认行为。如果camcelable是true，则可以使用该方法</td></tr><tr><td>stopPropagation()</td><td>Function</td><td>取消事件的进一步捕获或冒泡</td></tr><tr><td>stopImmediatePropagation()</td><td>Function</td><td>取消事件的进一步捕获或冒泡，同时阻止相同事件的其他侦听器被调用</td></tr></tbody></table><h4 id="preventDefault"><a href="#preventDefault" class="headerlink" title="preventDefault()"></a>preventDefault()</h4><p>要阻止特定事件的默认行为，我们就可以使用preventDefault()方法。比如，链接的默认行为就是在被单击时会导航到其href特性指定的URL。如果想要阻止该默认行为，我们可以这样做</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a = <span class="built_in">document</span>.getElementsByTagName(<span class="string">'a'</span>);</span><br><span class="line">a.addEventListener(<span class="string">'click'</span>,<span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line">    event.preventDefault();</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>这样的话，我们点击链接后就不会进行跳转</p><h4 id="stopPropagation"><a href="#stopPropagation" class="headerlink" title="stopPropagation()"></a>stopPropagation()</h4><p>stopPropagation()方法可以立即停止事件在DOM层次中的传播，即取消进一步的事件捕获或冒泡</p><p>例如，我们在一个元素上的绑定两个事件处理程序，一个在捕获阶段执行，一个在冒泡阶段执行；并且我们在要在捕获阶段调用的函数添加event.stopPropagation()方法</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span>hello<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> div = <span class="built_in">document</span>.getElementsByTagName(<span class="string">'div'</span>)[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">div.addEventListener(<span class="string">'click'</span>,<span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'捕获'</span>,event.eventPhase);</span><br><span class="line">    <span class="comment">// 添加event.stopPropagation()方法来阻止事件的进一步传播</span></span><br><span class="line">    event.stopPropagation();</span><br><span class="line">&#125;,<span class="literal">true</span>)</span><br><span class="line"></span><br><span class="line">div.addEventListener(<span class="string">'click'</span>,<span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'冒泡'</span>,event.eventPhase);</span><br><span class="line">&#125;,<span class="literal">false</span>)</span><br></pre></td></tr></table></figure><p>此时我们会看到输出结果是：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&apos;捕获&apos; 2</span><br><span class="line">&apos;冒泡&apos; 2</span><br></pre></td></tr></table></figure><p>为什么event.stopPropagation()没有阻止事件的进一步传播？</p><p>我们可以看到，两个事件处理程序输出的eventPhase值都是2，也就是这两个函数在处于目标阶段被调用。回忆，前文提到的，DOM事件流的三个阶段，捕获阶段和冒泡阶段是不会包括目标元素的。</p><p>因此，我们可以将事件绑定到document上</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">document</span>.addEventListener(<span class="string">'click'</span>,<span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'捕获'</span>,event.eventPhase);</span><br><span class="line">    <span class="comment">// 添加event.stopPropagation()方法来阻止事件的进一步传播</span></span><br><span class="line">    event.stopPropagation();</span><br><span class="line">&#125;,<span class="literal">true</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">document</span>.addEventListener(<span class="string">'click'</span>,<span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'冒泡'</span>,event.eventPhase);</span><br><span class="line">&#125;,<span class="literal">false</span>)</span><br></pre></td></tr></table></figure><p>这样输出结果就符合预期，输出如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&apos;捕获&apos; 1</span><br></pre></td></tr></table></figure><h2 id="事件委托（事件代理）"><a href="#事件委托（事件代理）" class="headerlink" title="事件委托（事件代理）"></a>事件委托（事件代理）</h2><p>事件委托是将一个或多个元素响应事件的函数委托给它们的外层元素来解决事件处理程序过多的问题。</p><p>例如，有一个列表</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span> <span class="attr">id</span>=<span class="string">"li-1"</span>&gt;</span>1<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span> <span class="attr">id</span>=<span class="string">"li-2"</span>&gt;</span>2<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span> <span class="attr">id</span>=<span class="string">"li-3"</span>&gt;</span>3<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br></pre></td></tr></table></figure><p>如果我们想要在点击每一个列表项时可以输出列表项的内容</p><p>传统做法会为每个li绑定事件处理程序：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">handle</span>(<span class="params">e</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.innerHTML);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">document</span>.getElementById(<span class="string">'li-1'</span>).addEventListener(<span class="string">'click'</span>,handle);</span><br><span class="line"></span><br><span class="line"><span class="built_in">document</span>.getElementById(<span class="string">'li-2'</span>).addEventListener(<span class="string">'click'</span>,handle);</span><br><span class="line"></span><br><span class="line"><span class="built_in">document</span>.getElementById(<span class="string">'li-3'</span>).addEventListener(<span class="string">'click'</span>,handle);</span><br></pre></td></tr></table></figure><p>使用事件委托（事件代理）,我们可以将事件处理程序绑定到li的外层元素ul上</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> ul = <span class="built_in">document</span>.getElementsByTagName(<span class="string">'ul'</span>)[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">ul.addEventListener(<span class="string">'click'</span>,<span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(event.target.innerHTML);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>此时，当我们点击列表项时，DOM事件流会在第三个阶段（冒泡阶段）触发事件处理程序。我们通过event.target来获得实际点击的元素来输出列表项内容。</p><p>因此，与传统方法相比，如果每一个列表项需要绑定的是不同的事件处理程序。那么，我们可以想象，如果，列表足够长，那么我们需要定义的函数对象就会非常多，因此，也会非常占用内存造成性能变差。而事件委托机制则可以很好的解决这个问题</p><h3 id="事件委托（事件代理）的优点"><a href="#事件委托（事件代理）的优点" class="headerlink" title="事件委托（事件代理）的优点"></a>事件委托（事件代理）的优点</h3><ol><li><p>减少内存消耗，提升效率</p></li><li><p>可以动态地绑定事件</p><p> 例如：使用传统方法，当我们动态地添加一个节点时，我们就另外需要为该节点绑定一个事件。但是，如果采用事件委托，我们就可以避免这种情况。因为事件是绑定在父层的，和目标元素的增减是没有关系的，执行到目标元素是在真正响应执行事件函数的过程中去匹配的；</p></li></ol><p>例如：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span> <span class="attr">id</span>=<span class="string">"li-1"</span>&gt;</span>1<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span> <span class="attr">id</span>=<span class="string">"li-2"</span>&gt;</span>2<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span> <span class="attr">id</span>=<span class="string">"li-3"</span>&gt;</span>3<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br></pre></td></tr></table></figure><p>当我们需要动态添加一个节点比如说li-4，采用传统方式的话，创建完之后我们还需要额外绑定事件</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> li_4 = <span class="built_in">document</span>.createElment(<span class="string">'li'</span>);</span><br><span class="line"></span><br><span class="line">li_4.addEventListener(<span class="string">'click'</span>,<span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.innerHTML);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>如果，我们采用事件委托（事件代理）的话，就可以避免这个问题</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ul.addEventListener(<span class="string">'click'</span>,<span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(event.target.innerHTML);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>这样的话，无论添加多少个节点或是删除多少个节点，只要在父节点内的节点都可以有相应的事件</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;事件流&quot;&gt;&lt;a href=&quot;#事件流&quot; class=&quot;headerlink&quot; title=&quot;事件流&quot;&gt;&lt;/a&gt;事件流&lt;/h2&gt;&lt;p&gt;事件流描述的是从页面中接收事件的顺序。IE提出的事件流是事件冒泡流，而网景提出的事件流是事件捕获流&lt;/p&gt;
&lt;h3 id=&quot;事件冒泡
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>跨域与解决方案</title>
    <link href="http://yoursite.com/2019/10/07/%E8%B7%A8%E5%9F%9F%E4%B8%8E%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/"/>
    <id>http://yoursite.com/2019/10/07/跨域与解决方案/</id>
    <published>2019-10-07T08:11:53.000Z</published>
    <updated>2019-10-11T07:16:44.071Z</updated>
    
    <content type="html"><![CDATA[<h2 id="什么是跨域"><a href="#什么是跨域" class="headerlink" title="什么是跨域"></a>什么是跨域</h2><p>通过XHR对象来实现Ajax通信的一个主要限制，来源于跨域安全策略。在默认的情况下，XHR对象只能访问与包含它的页面位于同一个域中的资源。</p><p>那么，什么样的情况算是同一个域，什么样的情况算是不同的域呢？</p><h3 id="同源"><a href="#同源" class="headerlink" title="同源"></a>同源</h3><p>所谓同源（即指在同一个域）就是两个页面具有相同的协议（包括HTTP和HTTPS），主机（host）和端口号（port）</p><h3 id="跨域"><a href="#跨域" class="headerlink" title="跨域"></a>跨域</h3><p>当一个请求url的协议、域名、端口三者之间任意一个与当前页面url不同即为跨域</p><h3 id="域名层次"><a href="#域名层次" class="headerlink" title="域名层次"></a>域名层次</h3><h4 id="域名语法"><a href="#域名语法" class="headerlink" title="域名语法"></a>域名语法</h4><p>域名由一或多个部分组成，这些部分通常连接在一起，并由点分隔，例如zh.wikipedia.org。最右边的一个标签是顶级域名，例如zh.wikipedia.org的顶级域名是org。一个域名的层次结构，从右侧到左侧隔一个点依次下降一层。</p><h4 id="顶级域名"><a href="#顶级域名" class="headerlink" title="顶级域名"></a>顶级域名</h4><p>顶级域名是域名中最高的一级，每个域名都以顶级域名结尾。</p><h4 id="子域名"><a href="#子域名" class="headerlink" title="子域名"></a>子域名</h4><p>子域名将顶级域名进一步细分。域名层次结构中，顶级域名下面是二级域名，它位于顶级域名的左侧。例如，在zh.wikipedia.org中，wikipedia是二级域名。w3.org中，w3也是二级域名，与前例中的wikipedia属于一个层面。</p><p>二级域名下面是三级域名，它位于二级域名的左侧。例如，在zh.wikipedia.org中，zh是三级域名；zh-classical.wikipedia.org（文言文维基大典的域名）中，zh-classical也是三级域名，与前例中的zh属于一个层面。从右侧到左侧，隔一个点依次下降一层。</p><h3 id="常见跨域场景"><a href="#常见跨域场景" class="headerlink" title="常见跨域场景"></a>常见跨域场景</h3><table><thead><tr><th>当前页面URL</th><th>请求页面URL</th><th>是否跨域</th><th>原因</th></tr></thead><tbody><tr><td><a href="http://www.example.com/a.js" target="_blank" rel="noopener">http://www.example.com/a.js</a></td><td><a href="http://www.example.com/b.js" target="_blank" rel="noopener">http://www.example.com/b.js</a></td><td>否</td><td>协议、域名、端口号均相同</td></tr><tr><td><a href="http://www.example.com/a.js" target="_blank" rel="noopener">http://www.example.com/a.js</a></td><td><a href="https://www.example.com/b.js" target="_blank" rel="noopener">https://www.example.com/b.js</a></td><td>是</td><td>协议不同（http与https）</td></tr><tr><td><a href="http://www.example.com/a.js" target="_blank" rel="noopener">http://www.example.com/a.js</a></td><td><a href="http://www.test.com/b.js" target="_blank" rel="noopener">http://www.test.com/b.js</a></td><td>是</td><td>域名不同</td></tr><tr><td><a href="http://www.example.com/a.js" target="_blank" rel="noopener">http://www.example.com/a.js</a></td><td><a href="http://www.blog.example.com/b.js" target="_blank" rel="noopener">http://www.blog.example.com/b.js</a></td><td>是</td><td>主域名相同，但子域名不同</td></tr><tr><td><a href="http://www.example.com/a.js" target="_blank" rel="noopener">http://www.example.com/a.js</a></td><td><a href="http://192.168.56.1/b.js" target="_blank" rel="noopener">http://192.168.56.1/b.js</a></td><td>是</td><td>域名与其对应ip地址之间的请求也算跨域</td></tr><tr><td><a href="http://www.example.com" target="_blank" rel="noopener">http://www.example.com</a></td><td><a href="http://www.example.com:8888/b.js" target="_blank" rel="noopener">http://www.example.com:8888/b.js</a></td><td>是</td><td>端口不同</td></tr></tbody></table><h2 id="跨域解决方案"><a href="#跨域解决方案" class="headerlink" title="跨域解决方案"></a>跨域解决方案</h2><h3 id="JSONP"><a href="#JSONP" class="headerlink" title="JSONP"></a>JSONP</h3><h4 id="什么是JSONP"><a href="#什么是JSONP" class="headerlink" title="什么是JSONP"></a>什么是JSONP</h4><p>JSONP是JSON with padding（填充式JSON或参数是JSON）的简写，是应用JSON的一种新方法。JSONP看起来与JSON差不多，只不过是被包含在函数调用中的JSON，例如</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">callback(&#123;<span class="string">"name"</span>:<span class="string">"Ming"</span>&#125;)</span><br></pre></td></tr></table></figure><p>JSONP由两部分组成：回调函数以及传递给回调函数的参数JSON字符串</p><h4 id="JSONP的原理及具体实现过程"><a href="#JSONP的原理及具体实现过程" class="headerlink" title="JSONP的原理及具体实现过程"></a>JSONP的原理及具体实现过程</h4><ol><li><p>因为&lt;script&gt;元素可以不受限制地从其他域加载资源。因此<br>我们可以在web端通过动态&lt;script&gt;来实现一个JSONP请求，例如</p> <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> script = <span class="built_in">document</span>.createElement(<span class="string">'script'</span>);</span><br><span class="line">script.src = <span class="string">'http://localhost:8888/getTestData?callback=handle'</span></span><br></pre></td></tr></table></figure></li><li><p>通过上一步，我们就可以引入<a href="http://localhost:8888/getTestData?callback=handle该文件，同时将参数callback发送给服务器" target="_blank" rel="noopener">http://localhost:8888/getTestData?callback=handle该文件，同时将参数callback发送给服务器</a></p></li><li><p>因为script标签内需要可执行的javascript代码，因此我们可以知道使用JSONP是需要后端配合的，后端需要返回一个javascript类型数据才可以。我们通过express来模拟返回一下数据</p> <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> express = <span class="built_in">require</span>(<span class="string">'express'</span>);</span><br><span class="line"><span class="keyword">let</span> app = express();</span><br><span class="line"></span><br><span class="line">app.listen(<span class="number">8888</span>);</span><br><span class="line"></span><br><span class="line">app.get(<span class="string">'/getTestData'</span>,<span class="function"><span class="keyword">function</span>(<span class="params">req,res,next</span>) </span>&#123;</span><br><span class="line"><span class="keyword">let</span> _callback = req.query.callback;</span><br><span class="line"><span class="keyword">let</span> _data = &#123;</span><br><span class="line">    <span class="string">"code"</span>: <span class="number">0</span>,</span><br><span class="line">    <span class="string">"msg"</span>: <span class="string">'hello world'</span></span><br><span class="line">&#125;;</span><br><span class="line">res.type(<span class="string">'text/javascript'</span>);</span><br><span class="line">res.send(_callback+<span class="string">'('</span>+<span class="built_in">JSON</span>.stringify(_data)+<span class="string">')'</span>);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p> 我们可以看到，服务器会接收到我们请求的参数，也就是回调函数名callback；接着，服务器生成_data数据，将其序列化后作为参数传入callback函数并返回给前端（注意的是，返回的内容类型是javascript代码）</p></li><li><p>收到服务器返回的javascript代码，也就是一个准备执行的已传入参数的函数。（需要注意的是，script标签内的代码会成为全局代码，也就是该函数会成为全局函数）</p></li><li><p>因此，如果我们在使用模块化开发的时候，模块内的代码都是局部代码，因此，我们需要注册一个全局的callback函数让服务器返回的Javascript代码可以执行。同时，我们的业务逻辑也就可以写在这个callback函数中。例如：</p> <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">window</span>.handle = <span class="function"><span class="keyword">function</span>(<span class="params">res</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(res);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>捕获错误：我们可以使用onerror事件处理程序来确定JSONP请求是否成功</p> <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">script.onerror = <span class="function"><span class="keyword">function</span> (<span class="params">err</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'error'</span>,err);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h4 id="JSONP的前后端代码示例"><a href="#JSONP的前后端代码示例" class="headerlink" title="JSONP的前后端代码示例"></a>JSONP的前后端代码示例</h4><h5 id="前端代码"><a href="#前端代码" class="headerlink" title="前端代码"></a>前端代码</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> script = <span class="built_in">document</span>.createElement(<span class="string">'script'</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">window</span>.handle = <span class="function"><span class="keyword">function</span> (<span class="params">res</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.console.log(res.code);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">script.src = <span class="string">'http://localhost:8888/getTestData?callback=handle'</span>;</span><br><span class="line">script.onerror = <span class="function"><span class="keyword">function</span> (<span class="params">err</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'error'</span>,err);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">document</span>.body.appendChild(script);</span><br></pre></td></tr></table></figure><h5 id="Node-js代码"><a href="#Node-js代码" class="headerlink" title="Node.js代码"></a>Node.js代码</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> express = <span class="built_in">require</span>(<span class="string">'express'</span>);</span><br><span class="line"><span class="keyword">let</span> app = express();</span><br><span class="line"></span><br><span class="line">app.listen(<span class="number">8888</span>);</span><br><span class="line"></span><br><span class="line">app.get(<span class="string">'/getTestData'</span>,<span class="function"><span class="keyword">function</span>(<span class="params">req,res,next</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> _callback = req.query.callback;</span><br><span class="line">  <span class="keyword">let</span> _data = &#123;</span><br><span class="line">    code: <span class="number">0</span>,</span><br><span class="line">    msg: <span class="string">'hello world'</span></span><br><span class="line">  &#125;;</span><br><span class="line">  res.type(<span class="string">'text/javascript'</span>);</span><br><span class="line">  res.send(_callback+<span class="string">'('</span>+<span class="built_in">JSON</span>.stringify(_data)+<span class="string">')'</span>);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h4 id="JSONP的一些个人思考"><a href="#JSONP的一些个人思考" class="headerlink" title="JSONP的一些个人思考"></a>JSONP的一些个人思考</h4><ol><li>为什么后端返回的javascript代码中传给函数的参数是JSON而不是javascript对象？<br>关于这个，我们要记住，JSON数据是我们的要获取的东西（json易于人阅读和编写，也易于机器解析和生成，相对网络传输速率较高，因此，进行数据交换我们一般使用JSON），而JSONP是我们获取JSON数据的手段。</li><li>JSONP能够直接访问响应文本，并且支持在浏览器与服务器之间双向通信</li><li>可以看到，JSONP只支持GET请求</li></ol><h3 id="CORS"><a href="#CORS" class="headerlink" title="CORS"></a>CORS</h3><p>CORS （Cross-Origin Resource Sharing，跨域资源共享）是一个系统，它由一系列传输的HTTP头组成，这些HTTP头决定浏览器是否阻止前端 JavaScript 代码获取跨域请求的响应。</p><p>同源安全策略 默认阻止“跨域”获取资源。但是 CORS 给了web服务器这样的权限，即服务器可以选择，允许跨域请求访问到它们的资源。</p><h4 id="简单请求"><a href="#简单请求" class="headerlink" title="简单请求"></a>简单请求</h4><p>某些请求不会触发CORS预检请求，这样的请求被视为简单请求。</p><p>满足以下条件之一就被视为简单请求</p><ol><li><p>使用下列方法之一：</p><p> GET<br> HEAD<br> POST</p></li><li><p>Content-Type 的值仅限于下列三者之一：</p><p> text/plain<br> multipart/form-data<br> application/x-www-form-urlencoded</p></li></ol><p>目前浏览器基本都实现了XHR对象对CORS的原生支持。因此，对于简单请求，浏览器就会直接发出CORS请求，具体来说，就是会在请求的头信息中，增加一个Origin字段来表示请求源</p><p>我们查看一下请求报文就可以发现，在请求报文中会多出一个字段origin来说明请求的源；在响应报文中会多出一个字段Access-Control-Allow-Origin:*来允许所有的源进行跨域；当然也可以设置这个字段只允许一个或几个域才可以跨域</p><p><strong>请求报文与响应报文</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">GET /resources/public-data/ HTTP/1.1</span><br><span class="line">Host: bar.other</span><br><span class="line">User-Agent: Mozilla/5.0 (Macintosh; U; Intel Mac OS X 10.5; en-US; rv:1.9.1b3pre) Gecko/20081130 Minefield/3.1b3pre</span><br><span class="line">Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8</span><br><span class="line">Accept-Language: en-us,en;q=0.5</span><br><span class="line">Accept-Encoding: gzip,deflate</span><br><span class="line">Accept-Charset: ISO-8859-1,utf-8;q=0.7,*;q=0.7</span><br><span class="line">Connection: keep-alive</span><br><span class="line">Referer: http://foo.example/examples/access-control/simpleXSInvocation.html</span><br><span class="line"></span><br><span class="line">// origin</span><br><span class="line">Origin: http://foo.example</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">HTTP/1.1 200 OK</span><br><span class="line">Date: Mon, 01 Dec 2008 00:23:53 GMT</span><br><span class="line">Server: Apache/2.0.61</span><br><span class="line"></span><br><span class="line">// Access-Control-Allow-Origin</span><br><span class="line">Access-Control-Allow-Origin: *</span><br><span class="line">Keep-Alive: timeout=2, max=100</span><br><span class="line">Connection: Keep-Alive</span><br><span class="line">Transfer-Encoding: chunked</span><br><span class="line">Content-Type: application/xml</span><br><span class="line"></span><br><span class="line">[XML Data]</span><br></pre></td></tr></table></figure><h4 id="非简单请求（预检请求）"><a href="#非简单请求（预检请求）" class="headerlink" title="非简单请求（预检请求）"></a>非简单请求（预检请求）</h4><p>与简单请求不同，非简单请求（预检请求）会要求使用OPTIONS方法预先发送一个预检请求给服务器，以货值服务器是否允许该实际请求。预检请求的使用，可以一定程度上来避免跨域请求对服务器的用户数据产生未预期的影响</p><p>当请求满足以下任一条件时，就会发送预检请求</p><ol><li><p>使用了下面任一HTTP方法</p><ol><li>PUT</li><li>DELETE</li><li>CONNECT</li><li>OPTIONS</li><li>TRACE</li><li>PATCH</li></ol></li><li><p>人为设置了对 CORS 安全的首部字段集合之外的其他首部字段。该集合为：</p><p> Accept<br> Accept-Language<br> Content-Language<br> Content-Type (需要注意额外的限制)<br> DPR<br> Downlink<br> Save-Data<br> Viewport-Width<br> Width</p></li><li><p>Content-Type 的值不属于下列之一:</p><ol><li>application/ x-www-form-urlencoded</li><li>multipart/form-data</li><li>text/plain</li></ol></li></ol><p>非简单请求（预检请求）的示意图如下：</p><p><img src="https://mdn.mozillademos.org/files/16753/preflight_correct.png" alt></p><h3 id="node中间件代理"><a href="#node中间件代理" class="headerlink" title="node中间件代理"></a>node中间件代理</h3><p>node中间件实现跨域代理，是通过启一个代理服务器，实现数据的转发</p><p>前端所在的域与node代理服务器处在同一个域上，所有发送给代理服务器的请求都会被该服务器代理并转发给预先设定的服务器地址</p><h4 id="前端请求"><a href="#前端请求" class="headerlink" title="前端请求"></a>前端请求</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> xhr = <span class="keyword">new</span> XMLHttpRequest();</span><br><span class="line">xhr.onreadystatechange = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(xhr.readyState===<span class="number">4</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span>(xhr.status&gt;=<span class="number">200</span>&amp;&amp;xhr.status&lt;<span class="number">300</span>) &#123;</span><br><span class="line">            <span class="built_in">console</span>.log(xhr.responseText);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">'error'</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">xhr.open(<span class="string">'get'</span>,<span class="string">'http://localhost:3000'</span>,<span class="literal">true</span>);</span><br><span class="line">xhr.send(<span class="literal">null</span>);</span><br></pre></td></tr></table></figure><h4 id="node代理服务器"><a href="#node代理服务器" class="headerlink" title="node代理服务器"></a>node代理服务器</h4><p>利用http-proxy-middleware该中间件实现代理服务器</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> express = <span class="built_in">require</span>(<span class="string">'express'</span>);</span><br><span class="line"><span class="keyword">const</span> proxy = <span class="built_in">require</span>(<span class="string">'http-proxy-middleware'</span>)</span><br><span class="line"><span class="keyword">let</span> app = express();</span><br><span class="line"></span><br><span class="line">app.use(<span class="string">'/'</span>,proxy(&#123;</span><br><span class="line">  target: <span class="string">'http://localhost:3000'</span>,</span><br><span class="line">  changeOrigin: <span class="literal">true</span></span><br><span class="line">&#125;))</span><br><span class="line"></span><br><span class="line">app.listen(<span class="number">8080</span>,<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'8080端口已打开'</span>);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h4 id="node-js后端"><a href="#node-js后端" class="headerlink" title="node.js后端"></a>node.js后端</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> express = <span class="built_in">require</span>(<span class="string">'express'</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> app = express();</span><br><span class="line"></span><br><span class="line">app.get(<span class="string">'/'</span>,(req,res)=&gt;&#123;</span><br><span class="line">    res.send(<span class="string">'hello'</span>);</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">app.listen(<span class="number">3000</span>,<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'3000端口已打开'</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>这样我们就可以通过代理服务器进行跨域请求</p><h3 id="webpack配置跨域"><a href="#webpack配置跨域" class="headerlink" title="webpack配置跨域"></a>webpack配置跨域</h3><p>类似Vue这些框架都会用webpack进行打包。webpack中可以引入webpack-dev-server来进行服务器相关的配置。</p><p>与上述node中间件使用http-proxy-middleware 包一样，该dev-server也使用了该包，因此语法也是一样的</p><p>我们可以在webpack.config.js进行跨域相关的配置</p><p>webpack.config.js的跨域配置</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">devServer : &#123;</span><br><span class="line">    proxy: &#123;</span><br><span class="line">        <span class="string">"/api"</span>: &#123;</span><br><span class="line">            target: <span class="string">"http://localhost:3000"</span>,</span><br><span class="line">            pathRewrite: &#123;<span class="string">"^/api"</span>: <span class="string">""</span>&#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>前端请求</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> xhr = <span class="keyword">new</span> XMLHttpRequest();</span><br><span class="line">xhr.onreadystatechange = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(xhr.readyState===<span class="number">4</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span>(xhr.status&gt;=<span class="number">200</span>&amp;&amp;xhr.status&lt;<span class="number">300</span>) &#123;</span><br><span class="line">            <span class="built_in">console</span>.log(xhr.responseText);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">'error'</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">xhr.open(<span class="string">'get'</span>,<span class="string">'/api/hello'</span>,<span class="literal">true</span>);</span><br><span class="line">xhr.send(<span class="literal">null</span>);</span><br></pre></td></tr></table></figure><p>后端node接口</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> express = <span class="built_in">require</span>(<span class="string">'express'</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> app = express();</span><br><span class="line"></span><br><span class="line">app.get(<span class="string">'/hello'</span>,(req,res)=&gt;&#123;</span><br><span class="line">    res.setHeader(<span class="string">'Content-type'</span>,<span class="string">'application/json'</span>);</span><br><span class="line">    res.send(<span class="string">'hello'</span>);</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">app.listen(<span class="number">3000</span>,<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'3000端口已打开'</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>此时，请求”/api/hello”就会被代理到”<a href="http://localhost:3000/hello&quot;" target="_blank" rel="noopener">http://localhost:3000/hello&quot;</a></p><h4 id="配置中的主要参数说明"><a href="#配置中的主要参数说明" class="headerlink" title="配置中的主要参数说明"></a>配置中的主要参数说明</h4><ol><li><p>‘/api’</p><p> 如果请求中有该字符串’/api’，那么就会开始匹配代理。比如，api请求’/api/hello’，就会被代理到请求’<a href="http://localhost:3000/api/hello&#39;" target="_blank" rel="noopener">http://localhost:3000/api/hello&#39;</a></p></li><li><p>target</p><p> 代理的API地址。地址可以是域名也可以是IP地址，如果是域名就需要额外添加一个参数changeOrigin: true</p></li><li><p>pathRewrite</p><p> 路径重写，也就是说会修改最终请求的API路径。设置pathRewrite:{‘^/api’:’’}后，最终代理访问的路径就会是’<a href="http://localhost:3000/hello&#39;" target="_blank" rel="noopener">http://localhost:3000/hello&#39;</a></p></li><li><p>changeOrigin</p><p> 该参数可以让target参数是域名</p></li><li><p>secure</p><p> secure: false，不检查安全问题；设置后，可以接受运行在https上，可以使用无效证书的后端服务器</p></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;什么是跨域&quot;&gt;&lt;a href=&quot;#什么是跨域&quot; class=&quot;headerlink&quot; title=&quot;什么是跨域&quot;&gt;&lt;/a&gt;什么是跨域&lt;/h2&gt;&lt;p&gt;通过XHR对象来实现Ajax通信的一个主要限制，来源于跨域安全策略。在默认的情况下，XHR对象只能访问与包含它的页面
      
    
    </summary>
    
      <category term="浏览器" scheme="http://yoursite.com/categories/%E6%B5%8F%E8%A7%88%E5%99%A8/"/>
    
    
  </entry>
  
  <entry>
    <title>Ajax</title>
    <link href="http://yoursite.com/2019/09/30/Ajax/"/>
    <id>http://yoursite.com/2019/09/30/Ajax/</id>
    <published>2019-09-30T10:39:26.000Z</published>
    <updated>2019-10-01T11:28:00.474Z</updated>
    
    <content type="html"><![CDATA[<h2 id="什么是Ajax"><a href="#什么是Ajax" class="headerlink" title="什么是Ajax"></a>什么是Ajax</h2><p>AJAX即“Asynchronous JavaScript and XML”（异步的JavaScript与XML技术）。使用Ajax可以无需刷新页面就可以从服务器取得数据</p><h2 id="Ajax的核心–XMLHttpRequest对象"><a href="#Ajax的核心–XMLHttpRequest对象" class="headerlink" title="Ajax的核心–XMLHttpRequest对象"></a>Ajax的核心–XMLHttpRequest对象</h2><p>如果不考虑IE7以前的版本，那么对于所有的标准浏览器我们都可以使用如下来创建一个XHR对象</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> xhr = <span class="keyword">new</span> XMLHttpRequest();</span><br></pre></td></tr></table></figure><h3 id="XHR对象的一些属性"><a href="#XHR对象的一些属性" class="headerlink" title="XHR对象的一些属性"></a>XHR对象的一些属性</h3><table><thead><tr><th>属性名</th><th>作用</th></tr></thead><tbody><tr><td>status</td><td>响应的HTTP状态码</td></tr><tr><td>statusText</td><td>HTTP状态码的说明</td></tr><tr><td>responseText</td><td>作为响应主体被返回的文本</td></tr><tr><td>responseXml</td><td>对请求的响应，解析为 XML 并作为 Document 对象返回</td></tr><tr><td>readyState</td><td>请求/响应过程的当前活动状态</td></tr><tr><td>onreadystatechange()</td><td>readyState属性值改变触发的readystatechange事件的绑定函数</td></tr></tbody></table><p>readyState属性的说明：<br>属性可取值|名称|说明<br>–|–|–<br>0|未初始化|尚未调用open()方法<br>1|启动|已经调用open()方法，但尚未调用send()方法<br>2|发送|已经调用send()方法，但尚未接收到响应<br>3|接收|已经接收到部分响应数据<br>4|完成|已经接收到全部响应数据</p><p>status（HTTP常见状态码）<br>状态码|名称|说明<br>–|–|–<br>200|OK|请求成功，信息在返回的响应报文中<br>301|Moved Permanently|请求的对象已经被永久转移了，新的URL定义在响应报文的Location: 首部行中。客户软件将自动获取新的URL<br>304|Not Modified|未修改。所请求的资源未修改，服务器返回此状态码时，不会返回任何资源。客户端通常会缓存访问过的资源，通过提供一个头信息指出客户端希望只返回在指定日期之后修改的资源<br>400|Bad Request|一个通用差错代码，指示该请求不能被服务器理解<br>404|Not Found|请求的资源不存在<br>500|Internal Server Error|内部服务器错误<br>505|HTTP Version Not Supported|服务器不支持请求报文使用的HTTP协议版本</p><p>HTTP状态码分类</p><table><thead><tr><th>状态码</th><th>名称</th><th>说明</th></tr></thead><tbody><tr><td>1**</td><td>信息</td><td>服务器收到请求，需要请求者继续执行操作</td></tr><tr><td>2**</td><td>成功</td><td>操作被成功接收并处理</td></tr><tr><td>3**</td><td>重定向</td><td>需要进一步的操作以完成请求</td></tr><tr><td>4**</td><td>客户端错误</td><td>请求包含语法错误或无法完成请求</td></tr><tr><td>5**</td><td>服务器错误</td><td>服务器在处理请求的过程中发生了错误</td></tr></tbody></table><h3 id="XHR对象的一些方法"><a href="#XHR对象的一些方法" class="headerlink" title="XHR对象的一些方法"></a>XHR对象的一些方法</h3><h4 id="open"><a href="#open" class="headerlink" title="open()"></a>open()</h4><p>参数：</p><p>method<br>    要使用的HTTP方法，比如「GET」、「POST」、「PUT」、「DELETE」、等。对于非HTTP(S) URL被忽略。</p><p>url<br>    一个DOMString表示要向其发送请求的URL。</p><p>async 可选<br>    一个可选的布尔参数，默认为true，表示要不要异步执行操作。如果值为false（表示同步执行），send()方法直到收到答复前不会返回。如果true（表示异步执行），已完成事务的通知可供事件监听器使用。</p><pre><code>注意：主线程上的同步请求很容易破坏用户体验，应该避免；实际上，许多浏览器已完全弃用主线程上的同步XHR支持。在 Worker中允许同步请求</code></pre><p>user 可选<br>    可选的用户名用于认证用途；默认为null。</p><p>password 可选<br>    可选的密码用于认证用途，默认为null。 </p><h4 id="send"><a href="#send" class="headerlink" title="send()"></a>send()</h4><p>XMLHttpRequest.send() 方法接受一个可选的参数，其作为请求主体；如果请求方法是 GET 或者 HEAD，则应将请求主体设置为 null。（注：在HTTP请求报文中，使用GET方法时，请求实体为空，而是用POST方法时传输的内容保存在该请求实体中）</p><h4 id="setRequestHeader"><a href="#setRequestHeader" class="headerlink" title="setRequestHeader"></a>setRequestHeader</h4><p>XMLHttpRequest.setRequestHeader() 是设置HTTP请求头部的方法。此方法必须在  open() 方法和 send()   之间调用。如果多次对同一个请求头赋值，只会生成一个合并了多个值的请求头。</p><h4 id="abort"><a href="#abort" class="headerlink" title="abort()"></a>abort()</h4><p>如果该请求已被发出，XMLHttpRequest.abort() 方法将终止该请求。当一个请求被终止，它的 readyState 属性将被置为0（ UNSENT )。</p><h3 id="使用XHR对象进行同步请求"><a href="#使用XHR对象进行同步请求" class="headerlink" title="使用XHR对象进行同步请求"></a>使用XHR对象进行同步请求</h3><p>对于同步请求，也就是意味着该次请求是阻塞的。因此，之后的代码会等到服务器响应之后才会执行。</p><p>在收到响应后，响应的数据会自动填充到XHR对象的属性</p><p>例如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> xhr = <span class="keyword">new</span> XMLHttpRequest();</span><br><span class="line"><span class="comment">// 使用同步请求时，open()方法的第三个参数设置为false</span></span><br><span class="line">xhr.open(<span class="string">"get"</span>,<span class="string">"https://www.baidu.com"</span>,<span class="literal">false</span>);</span><br><span class="line">xhr.send(<span class="literal">null</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>((xhr.status&gt;=<span class="number">200</span>&amp;&amp;xhr.status&lt;<span class="number">300</span>)||xhr.status===<span class="number">304</span>) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(xhr.responseText);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"Request was failed"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="使用XHR对象进行异步请求"><a href="#使用XHR对象进行异步请求" class="headerlink" title="使用XHR对象进行异步请求"></a>使用XHR对象进行异步请求</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> xhr = <span class="keyword">new</span> XMLHttpRequest();</span><br><span class="line">xhr.onreadystatechange=<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(xhr.readyState===<span class="number">4</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span>((xhr.status&gt;=<span class="number">200</span>&amp;&amp;xhr.status&lt;<span class="number">300</span>)||xhr.status===<span class="number">304</span>) &#123;</span><br><span class="line">            <span class="built_in">console</span>.log(xhr.responseText);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">"Request was failed"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 使用异步请求时，open()方法的第三个参数设置为true</span></span><br><span class="line">xhr.open(<span class="string">"get"</span>,<span class="string">"https://www.baidu.com"</span>,<span class="literal">true</span>);</span><br><span class="line">xhr.send(<span class="literal">null</span>);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'异步请求'</span>);</span><br></pre></td></tr></table></figure><blockquote><p>注意：我们必须在调用open()方法之前指定onreadystatechange事件处理程序才能确保跨浏览器兼容性</p></blockquote><h3 id="GET请求"><a href="#GET请求" class="headerlink" title="GET请求"></a>GET请求</h3><p>对于GET请求，我们经常将查询字符串参数追加到URL的末尾，以便将信息发送给服务器</p><p>但是，我们经常会遇到URL的编码问题（查询字符串的格式有问题，例如在传递中文字符的时候）。因此，我们需要将每个参数的名称和值使用encodeURIComponent()进行编码，然后才能放到URL的末尾</p><p>encodeURIComponent()是对统一资源标识符（URI）的组成部分进行编码的方法。它使用一到四个转义序列来表示字符串中的每个字符的UTF-8编码。它会转义除了字母、数字、(、)、.、!、~、*、’、-和_之外的所有字符。</p><p>decodeURIComponent() 方法用于解码由 encodeURIComponent 方法或者其它类似方法编码的部分统一资源标识符（URI）。</p><p>因此，我们利用一个函数，将每个参数的键与值进行编码后加入到URL的末尾</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">addURLParam</span>(<span class="params">url,key,value</span>) </span>&#123;</span><br><span class="line">    url+=url.indexOf(<span class="string">'?'</span>)&lt;<span class="number">0</span>?<span class="string">'?'</span>:<span class="string">'&amp;'</span>;</span><br><span class="line">    <span class="comment">// 编码参数</span></span><br><span class="line">    url+=<span class="built_in">encodeURIComponent</span>(key)+<span class="string">'='</span>+<span class="built_in">encodeURIComponent</span>(value);</span><br><span class="line">    <span class="keyword">return</span> url;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> url = addURLParam(<span class="string">'https://www.baidu.com'</span>,<span class="string">'a'</span>,<span class="string">'天'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(url);</span><br><span class="line"><span class="keyword">let</span> url1 = addURLParam(url,<span class="string">'b'</span>,<span class="string">'才'</span>);</span><br><span class="line"><span class="comment">// 解码URL</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">decodeURIComponent</span>(url1));</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">https://www.baidu.com?a=%E5%A4%A9</span></span><br><span class="line"><span class="comment">https://www.baidu.com?a=天&amp;b=才</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h3 id="POST请求"><a href="#POST请求" class="headerlink" title="POST请求"></a>POST请求</h3><p>POST请求的内容不会明文出现在URL上，它会存放在请求的实体部分进行传递。值得注意的是，POST请求的主体可包含非常多的数据，而且格式不限</p><p>注意，在使用POST请求提交数据的时候，我们需要将请求头设置一下</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">xhr.setRequestHeader(<span class="string">"Content-Type"</span>,<span class="string">"application/x-www-form-urlencoded"</span>);</span><br></pre></td></tr></table></figure><p>POST完整请求示例</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> xhr = <span class="keyword">new</span> XMLHttpRequest();</span><br><span class="line">xhr.onreadystatechange=<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(xhr.readyState===<span class="number">4</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span>(xhr.status&gt;=<span class="number">200</span>&amp;&amp;xhr.status&lt;<span class="number">300</span>) &#123;</span><br><span class="line">            <span class="built_in">console</span>.log(xhr.responseText);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">'error'</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">xhr.open(<span class="string">"post"</span>,<span class="string">"https://www.baidu.com"</span>,<span class="string">"true"</span>);</span><br><span class="line">xhr.setRequestHeader(<span class="string">"Content-Type"</span>,<span class="string">"x-www-from-urlencoded"</span>);</span><br><span class="line">xhr.send(<span class="string">'123'</span>);</span><br></pre></td></tr></table></figure><h3 id="XMLHttpRequest-2级"><a href="#XMLHttpRequest-2级" class="headerlink" title="XMLHttpRequest 2级"></a>XMLHttpRequest 2级</h3><h4 id="FormData"><a href="#FormData" class="headerlink" title="FormData"></a>FormData</h4><p>在上面提到过，使用POST请求进行传输时，我们需要明确地设置请求头</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">xhr.setRequestHeader(<span class="string">"Content-Type"</span>,<span class="string">"x-www-from-urlencoded"</span>);</span><br></pre></td></tr></table></figure><p>但是，如果使用FormData的话，我们就不要进行设置。因为，XHR对象能够识别传入的数据类型是FormData的实例，并配置适当的头部信息</p><p>例如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建FormData实例</span></span><br><span class="line"><span class="keyword">let</span> data = <span class="keyword">new</span> FormData();</span><br><span class="line"><span class="comment">// 向对象添加数据，append()方法接受两个参数：键和值</span></span><br><span class="line">data.append(<span class="string">"name"</span>,<span class="string">"Ming"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 我们可以看到没有设置POST请求头</span></span><br><span class="line"><span class="keyword">let</span> xhr = <span class="keyword">new</span> XMLHttpRequest();</span><br><span class="line">xhr.onreadystatechange=<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(xhr.readyState===<span class="number">4</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span>(xhr.status&gt;=<span class="number">200</span>&amp;&amp;xhr.status&lt;<span class="number">300</span>) &#123;</span><br><span class="line">            <span class="built_in">console</span>.log(xhr.responseText);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">'error'</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">xhr.open(<span class="string">"post"</span>,<span class="string">"https://www.baidu.com"</span>,<span class="literal">true</span>);</span><br><span class="line">xhr.send(data);</span><br></pre></td></tr></table></figure><h4 id="进度事件"><a href="#进度事件" class="headerlink" title="进度事件"></a>进度事件</h4><p>我们可以利用进度事件来实现一个进度指示器</p><p>progress事件会在浏览器接收新数据期间周期性地触发。而onprogress事件处理程序就会接收到一个events对象，其有三个关于进度的属性：lengthComputable(表示进度信息是否可用),position(表示已经接受的字节数),totalSize(表示总字节数)</p><p>例如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> xhr = <span class="keyword">new</span> XMLHttpRequest();</span><br><span class="line">xhr.onprogress=<span class="function"><span class="keyword">function</span>(<span class="params">events</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(events.lengthComputable)&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(events.position+<span class="string">"/"</span>+events.totalSize);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">xhr.open(<span class="string">"get"</span>,<span class="string">"https://www.baidu.com"</span>,<span class="literal">true</span>);</span><br><span class="line">xhr.send(<span class="literal">null</span>);</span><br></pre></td></tr></table></figure><h3 id="Ajax的一些知识点总结"><a href="#Ajax的一些知识点总结" class="headerlink" title="Ajax的一些知识点总结"></a>Ajax的一些知识点总结</h3><h4 id="原生Js-Ajax请求有几个步骤"><a href="#原生Js-Ajax请求有几个步骤" class="headerlink" title="原生Js Ajax请求有几个步骤"></a>原生Js Ajax请求有几个步骤</h4><p>我们以步骤最多的POST请求为例</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1. 创建XHR对象</span></span><br><span class="line"><span class="keyword">let</span> xhr = <span class="keyword">new</span> XMLHttpRequest();</span><br><span class="line"><span class="comment">// 响应服务器返回的数据</span></span><br><span class="line">xhr.onreadystatechange=<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(xhr.readyState===<span class="number">4</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span>(xhr.status&gt;=<span class="number">200</span>&amp;&amp;xhr.status&lt;<span class="number">300</span>) &#123;</span><br><span class="line">            <span class="built_in">console</span>.log(xhr.responseText);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">'error'</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 2. 准备一个请求，规定请求的类型、URL 以及是否异步处理请求</span></span><br><span class="line">xhr.open(<span class="string">"post"</span>,<span class="string">"https://www.baidu.com"</span>,<span class="string">"true"</span>);</span><br><span class="line"><span class="comment">// 3. 设置请求头中的Content-type</span></span><br><span class="line">xhr.setRequestHeader(<span class="string">"Content-Type"</span>,<span class="string">"x-www-from-urlencoded"</span>);</span><br><span class="line"><span class="comment">// 发送请求</span></span><br><span class="line">xhr.send(<span class="string">'123'</span>);</span><br></pre></td></tr></table></figure><h4 id="Ajax有哪几种请求方式"><a href="#Ajax有哪几种请求方式" class="headerlink" title="Ajax有哪几种请求方式"></a>Ajax有哪几种请求方式</h4><p>常用的有GET,POST,DELETE,PUT。</p><h4 id="POST请求与GET请求的区别"><a href="#POST请求与GET请求的区别" class="headerlink" title="POST请求与GET请求的区别"></a>POST请求与GET请求的区别</h4><ol><li>POST请求更加安全，因为POST请求将参数存放在请求实体中，而GET请求参数在URL上</li><li>GET请求传输速度更快。因为post通过请求体传参，后台通过数据流接收。速度稍微慢一些。而get通过url传参可以直接获取</li><li>POST请求没有数据量的限制</li><li>POST请求的参数内容没有格式限制</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;什么是Ajax&quot;&gt;&lt;a href=&quot;#什么是Ajax&quot; class=&quot;headerlink&quot; title=&quot;什么是Ajax&quot;&gt;&lt;/a&gt;什么是Ajax&lt;/h2&gt;&lt;p&gt;AJAX即“Asynchronous JavaScript and XML”（异步的JavaScri
      
    
    </summary>
    
      <category term="javaScript基础" scheme="http://yoursite.com/categories/javaScript%E5%9F%BA%E7%A1%80/"/>
    
    
  </entry>
  
</feed>
